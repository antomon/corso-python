---
reference-location: margin
citation-location: margin

format:
  html:
    code-fold: true
    code-summary: "Mostra il codice"
    code-link: true
---

# Esercizi

## Fondamenti

### ➀ Python come calcolatrice

Primi esperimenti con Python.

#### Numeri interi e in virgola mobile

::: {.panel-tabset}

Provare le operazioni su booleani, numeri interi, in virgola mobile e stringhe, nel REPL.

## Problema

Usare gli operatori matematici su costanti numeriche e osservare i risultati e gli errori nel REPL, perché è più immediato rispetto all'esecuzione completa del programma e permette di prendere dimistichezza velocemente con dei costrutti di base del linguaggio.

## Soluzione

Il codice seguente può essere eseguito sia nel REPL, riga per riga, sia come programma. 

::: {.callout-tip}
## Suggerimento

Usando il REPL, basterà digitare l'espressione senza assegnamento per ottenere il risultato.
::: 

```python
# Moltiplicazione
x = 5 * 2
print(x)

x = 5 * 2.
print(x) # Cosa notiamo?

# Divisione in virgola mobile
x = 5 / 2
print(x)

x = 4 / 2
print(x) # Cosa notiamo?

x = 4 / 2.
print(x)

# Confronto
x = 5 > 2
print(x)

x = 5 > 2.
print(x) # Cosa notiamo?

# Diversità
x = 4 != 4.
print(x) # Cosa notiamo?

x = 0 != (1 - 1)
print(x) # Cosa notiamo?
```
:::

#### Stringhe

::: {.panel-tabset}

## Problema

Usare gli operatori su stringhe, sempre nel REPL.

## Soluzione

```python
s = "Hello" + ' ' + 'World!'
print(s)

ss = s

ss *= 2
print(ss)
print(s) # Cosa notiamo per s e ss?

# Appartenenza
b = 'el' in s
print(b) 

b = 'oo' not in s
print(b)

# Confronto
b = "Ciao Mondo!" < s 
print(b) # È rispettato l'ordine lessicografico?

l_s= len(s)
print(l_s)

# Slicing della stringa come contenitore di caratteri
s_ = ss[:l_s] 
print(s_) 

l_ss = len(ss) 
print(l_ss)

# Modo alternativo di ottenere la stringa originale solo usando ss
s_ = ss[:int(l_ss / 2)] 
print(s_) 

# Metodo per rendere la stringa in maiuscolo
su = s.upper()
print(su)

# Uguaglianza
b = s == su
print(b) # Cosa notiamo?
```

:::

#### Espressioni

::: {.panel-tabset}

## Problema

Costruire delle espressioni per comprendere come mischiare numeri e stringhe, la precedenza degli operatori e le conversioni di tipo, sempre nel REPL.

## Soluzione

```python
n = 42
s = "42"

# Congiunzione
b = n and s
print(b) # Cosa notiamo?

# Disgiunzione
b = n or s
print(b) 

# Negazione e congiunzione
b = n and not s
print(b) # Cosa notiamo?

# Conversione di tipo in stringa e appartenenza
b = str(2) in s
print(b)

# Conversione di tipo in intero e divisione
b = int(s) / 2
print(b)

# Espressione con precedenza data dall'ordine degli operatori 
e = 2 + n * 3
print(e)

# Espressione con precedenza modificata colle parentesi 
e = (2 + n) * 3
print(e) # Cosa notiamo?
```

:::

## Funzioni e istruzioni composte

### ➁ Numeri pari o dispari 

Definire una funzione che prende in input un numero intero e restituisce una stringa di `Pari` o `Dispari`.

#### Riscaldamento

::: {.panel-tabset}

## Problema

Sperimentiamo l'operatore modulo `%`, che restituisce il resto della divisione di due interi, con diversi input sia pari che dispari usando un test condizionale.

## Soluzione

```python
n = 42

if n % 2 == 0:
  print("Pari")

else:
  print("Dispari")
```

:::

#### Svolgimento

::: {.panel-tabset}

## Problema 

Inserire le istruzioni in una funzione che prende in input un parametro, il numero intero, e restituisce una stringa, `Pari` o `Dispari`. Sperimentare soluzioni diverse.

## Soluzione 1

Usiamo l'operatore modulo `%` che restituisce il resto della divisione di due interi all'interno di una funzione. Questa prende in input un numero intero e restituisce la stringa richiesta.

```python
def pari_o_dispari(n):
  if n % 2 == 0:
    return "Pari"

  else:
    return "Dispari"

risultato = pari_o_dispari(42)

print(risultato)

risultato = pari_o_dispari(73)

print(risultato)
```

## Soluzione 2

Usiamo l'operatore modulo `%` per il test di parità sul numero intero e la funzione `isinstance` per verificare il tipo in input.

```python
def pari_o_dispari(n):
  if not isinstance(n, int):
    return "Errore: l'input deve essere un numero intero!"
    
  if n % 2 == 0:
    return "Pari"

  else:
    return "Dispari"

risultato = pari_o_dispari(42)

print(risultato)

risultato = pari_o_dispari(73)

print(risultato)
```

## Soluzione 3

Usiamo l'operatore modulo `%`, la funzione `isinstance` per verificare il tipo in input e `assert` in caso di input non corretto.

```python
def pari_o_dispari(n):
  assert isinstance(n, int), \
    "Errore: l'input deve essere un numero intero!"
    
  if n % 2 == 0:
    return "Pari"

  else:
    return "Dispari"

risultato = pari_o_dispari(42)

print(risultato)

risultato = pari_o_dispari(73)

print(risultato)

'''
risultato = pari_o_dispari("42")

print(risultato)

risultato = pari_o_dispari(73.)

print(risultato)
'''
```

## Soluzione 4

Usiamo la funzione `divmod` che restituisce il quoziente e il resto della divisione di due interi.

```python
def pari_o_dispari(n):
  _, remainder = divmod(n, 2)

  return "Pari" if remainder == 0 else "Dispari"

risultato = pari_o_dispari(42)

print(risultato)

risultato = pari_o_dispari(73)

print(risultato)
```
:::

## Sequenze

### ➂ Rimozione di duplicati da una lista

::: {.panel-tabset}

## Problema

Scrivere una funzione che prende in input una lista e ne rimuove i duplicati, preservando l'ordinamento.

## Soluzione 1

Usiamo una seconda lista per travasare elementi non già presenti.

```python
def rimuovi_duplicati(lista):
    nuova_lista = []

    for elemento in lista:
        if elemento not in nuova_lista:
            nuova_lista.append(elemento)

    return nuova_lista

# Esempio di utilizzo
lista = [1, 2, 2, 3, 4, 4, 5]

print(rimuovi_duplicati(lista))  # Output: [1, 2, 3, 4, 5]
```

## Soluzione 2

Usiamo la proprietà dei dizionari di preservare l'ordine di inserimento.

```python
def rimuovi_duplicati(lista):
    return list(dict.fromkeys(lista))

# Esempio di utilizzo
lista = [1, 2, 2, 3, 4, 4, 5]

print(rimuovi_duplicati(lista))  # Output: [1, 2, 3, 4, 5]
```

:::

