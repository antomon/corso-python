% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
  letterpaper,
]{scrbook}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[left=1.5cm,right=1.5cm,top=2cm,bottom=2cm]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
  \begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
 % allow citations to break across lines
 \let\@cite@ofmt\@firstofone
 % avoid brackets around text for \cite:
 \def\@biblabel#1{}
 \def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
 {\begin{list}{}{%
  \setlength{\itemindent}{0pt}
  \setlength{\leftmargin}{0pt}
  \setlength{\parsep}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
   \setlength{\leftmargin}{\cslhangindent}
   \setlength{\itemindent}{-1\cslhangindent}
  \fi
  % set entry spacing
  \setlength{\itemsep}{#2\baselineskip}}}
 {\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Indice}
\else
  \newcommand\contentsname{Indice}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{Elenco delle Figure}
\else
  \newcommand\listfigurename{Elenco delle Figure}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{Elenco delle Tabelle}
\else
  \newcommand\listtablename{Elenco delle Tabelle}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figura}
\else
  \newcommand\figurename{Figura}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Tabella}
\else
  \newcommand\tablename{Tabella}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Lista}
\newcommand*\listoflistings{\listof{codelisting}{Elenco degli Elenchi}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tikz}{}{\usepackage{tikz}}
\makeatother
        \newcommand*\circled[1]{\tikz[baseline=(char.base)]{
          \node[shape=circle,draw,inner sep=1pt] (char) {{\scriptsize#1}};}}  
                  
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{italian}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Da neofita di Python a campione},
  pdfauthor={Antonio Montano},
  pdflang={it},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Da neofita di Python a campione}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Corso di Python per tutti}
\author{Antonio Montano}
\date{2024-05-24}

\begin{document}
\frontmatter
\maketitle

\renewcommand*\contentsname{Indice}
{
\setcounter{tocdepth}{2}
\tableofcontents
}
\mainmatter
\bookmarksetup{startatroot}

\chapter*{Prefazione}\label{prefazione}
\addcontentsline{toc}{chapter}{Prefazione}

\markboth{Prefazione}{Prefazione}

\includegraphics{red-python.png}

\part{Prima parte: I fondamenti della programmazione}

\chapter{I linguaggi di programmazione, i programmi e i
programmatori}\label{i-linguaggi-di-programmazione-i-programmi-e-i-programmatori}

Partiamo da alcuni concetti basilari che ci permettono di
contestualizzare più facilmente quelli che introdurremo via via nel
corso.

\section{Definizioni}\label{definizioni}

La \textbf{programmazione} è il processo di progettazione e scrittura di
\textbf{istruzioni}, nella forma statica, ad esempio un file di testo,
identificate come \textbf{codice sorgente}, che un computer può ricevere
per eseguire compiti predefiniti. Queste istruzioni sono codificate in
un \textbf{linguaggio di programmazione}, che traduce le idee e gli
algoritmi del programmatore, in un formato comprensibile ed eseguibile
dal computer.

Un \textbf{programma} informatico è una sequenza di istruzioni scritte
per eseguire una specifica operazione o un insieme di operazioni su un
computer. Queste istruzioni sono codificate in un linguaggio che il
computer può comprendere e utilizzare per eseguire attività come
calcoli, manipolazione di dati, controllo di dispositivi e interazione
con l'utente. Pensate a un programma come a una ricetta di cucina. La
ricetta elenca gli ingredienti necessari (dati) e fornisce istruzioni
passo-passo (algoritmo) per preparare un piatto. Allo stesso modo, un
programma informatico specifica i dati da usare e le istruzioni da
seguire per ottenere un risultato desiderato.

Un linguaggio di programmazione è un linguaggio formale che fornisce un
insieme di regole e sintassi per scrivere programmi informatici. Questi
linguaggi permettono ai programmatori di comunicare con i computer e di
creare software. Alcuni esempi di linguaggi di programmazione includono
Python, Java, C++, SQL, Rust, Haskell, Prolog, C, Assembly, Fortran,
JavaScript e altre centinaia (o forse migliaia).

\section{Linguaggi naturali e di
programmazione}\label{linguaggi-naturali-e-di-programmazione}

I linguaggi di programmazione hanno dei punti in comune e delle
differenze coi linguaggi naturali (come l'italiano o l'inglese).
Quest'ultime sono principalmente:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Precisione e rigidità: I linguaggi di programmazione sono estremamente
  precisi e rigidi. Ogni istruzione deve essere scritta in un modo
  specifico affinché il computer possa comprenderla ed eseguirla
  correttamente. Anche un piccolo errore di sintassi può impedire il
  funzionamento di un programma.
\item
  Ambiguità: I linguaggi naturali sono spesso ambigui e aperti a
  interpretazioni. Le stesse parole possono avere significati diversi a
  seconda del contesto. I linguaggi di programmazione, invece, sono
  progettati per essere privi di ambiguità; ogni istruzione ha un
  significato preciso e univoco.
\item
  Vocabolario limitato: I linguaggi naturali hanno un vocabolario
  vastissimo e in continua espansione. I linguaggi di programmazione, al
  contrario, hanno un vocabolario limitato costituito da parole chiave e
  comandi definiti dal linguaggio stesso.
\item
  Forma di mediazione: I linguaggi naturali sono direttamente utilizzati
  per comunicare, quelli di programmazione non sono comprensibili
  immediatamente dai computer, ma devono essere tradotti in una forma
  opportuna per mezzo di programmi ad hoc.
\end{enumerate}

\section{Algoritmi}\label{algoritmi}

Un \textbf{algoritmo} è ``un insieme di regole che definiscono con
precisione una sequenza di operazioni'' (Harold Stone,
\emph{Introduction to Computer Organization and Data Structures}, 1971
(Stone 1971)). Tale definizione, per quanto generica, coglie i due
aspetti fondanti, cioè regole, intese come prescrizioni sintattiche o
semantiche, che si traducono in operazioni richieste ad un agente, umano
o informatico.

In altre parole, un algoritmo è una sequenza ben definita di passi o
operazioni ben codificata, che, a partire da un input, produce un output
in un tempo finito e, quindi, presenta la seguente serie di
caratteristiche:

\begin{itemize}
\item
  Finitudine: L'algoritmo deve terminare dopo un numero finito di passi.
\item
  Determinismo: Ogni passo dell'algoritmo deve essere definito in modo
  preciso e non ambiguo.
\item
  Input: L'algoritmo riceve zero o più dati in ingresso.
\item
  Output: L'algoritmo produce uno o più risultati.
\item
  Effettività: Ogni operazione dell'algoritmo deve essere fattibile ed
  eseguibile in un tempo finito.
\end{itemize}

Gli algoritmi sono tradotti in codice sorgente attraverso un linguaggio
di programmazione per creare programmi. In altre parole, un programma è
la realizzazione pratica e funzionante degli algoritmi ideati dal
programmatore.

\section{Dal codice sorgente
all'esecuzione}\label{dal-codice-sorgente-allesecuzione}

Per comprendere come un programma scritto in un linguaggio di
programmazione passi dal file di testo contenente il codice sorgente
all'esecuzione delle istruzioni da parte della CPU, è fondamentale
capire che questo processo richiede un programma che interpreti il
codice sorgente. Tale programma può essere un \textbf{compilatore} o un
\textbf{interprete}, le due macrocategorie che definiscono come il
codice sorgente viene tradotto ed eseguito.

Un \textbf{compilatore} è un programma che traduce l'intero codice
sorgente di un programma scritto in un linguaggio di alto livello (come
C o C++) in codice macchina, che è il linguaggio comprensibile
direttamente dalla CPU. Questa traduzione avviene una sola volta,
generando un file eseguibile che può essere eseguito direttamente dalla
CPU.

Un \textbf{interprete}, invece, è un programma che esegue il codice
sorgente direttamente, istruzione per istruzione, senza produrre un file
eseguibile separato. L'interprete legge una riga di codice, la traduce
in codice macchina e la esegue immediatamente. Questo processo viene
ripetuto per ogni riga del codice sorgente.

È importante notare che alcuni linguaggi di programmazione possono
essere sia compilati che interpretati, a seconda dell'implementazione
disponibile. Ad esempio, Java utilizza sia la compilazione (per generare
bytecode) che l'interpretazione, e la Java Virtual Machine (JVM) spesso
utilizza anche la compilazione just-in-time (JIT) per tradurre il
bytecode in codice macchina nativo durante l'esecuzione.

Detto ciò i passaggi macro perché un programma sia eseguito e possa
produrre gli effetti pronosticati, sono:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Il programmatore scrive il codice sorgente utilizzando un editor di
  testo o un ambiente di sviluppo integrato (integrated development
  environment, IDE). Questo codice contiene le istruzioni del programma,
  scritte secondo la sintassi del linguaggio di programmazione scelto.
\item
  L'interpreto o il compilatore vengono eseguiti con input il programma
  e un componente, l'analizzatore lessicale, legge il codice sorgente e
  lo divide in lessemi, che sono sequenze di caratteri che corrispondono
  agli elementi \emph{atomici} del linguaggio. Ogni lessema viene
  identificato come un token specifico, come una parola chiave, un
  operatore o un identificatore.
\item
  A seguire un secondo compoenente, il parser, riceve la sequenza di
  token dall'analizzatore lessicale e costruisce un albero di sintassi,
  che rappresenta la struttura grammaticale del programma. Il parser
  verifica che il codice rispetti le regole sintattiche del linguaggio.
\item
  Un altro componente effettua la verifica che il programma abbia un
  senso logico. Ad esempio, controlla che le variabili siano dichiarate
  prima di essere utilizzate e che i tipi di dati siano compatibili con
  le operazioni eseguite su di essi.
\item
  Il compilatore, a questo punto, genera una rappresentazione intermedia
  del programma, che è più vicina al linguaggio macchina ma ancora
  indipendente dall'architettura specifica del computer. Ciò è tipico
  dei linguaggi compilati, anche se alcuni interpreti possono generare
  un bytecode intermedio.
\item
  Il compilatore ottimizza codice intermedio al fine di migliorare le
  prestazioni del programma, riducendo il numero di istruzioni o
  migliorando l'efficienza delle operazioni.
\item
  Il codice intermedio ottimizzato viene tradotto in codice macchina,
  che è specifico per l'architettura del computer su cui il programma
  verrà eseguito.
\item
  Linking: Il codice macchina viene combinato con altre librerie e
  moduli necessari per formare un eseguibile completo.
\item
  Esecuzione: L'eseguibile viene caricato nella memoria del computer e
  il processore esegue le istruzioni, portando a termine le operazioni
  definite nel programma.
\end{enumerate}

Nel caso di un interprete, i passaggi di generazione del codice
intermedio e macchina possono essere sostituiti da una valutazione
diretta delle istruzioni del programma, eseguendole una per una. In
pratica, l'interprete traduce ogni singola istruzione del codice
sorgente in un formato conprensibile dalla CPU e passa questa istruzione
alla CPU stessa per l'esecuzione. Questo processo continua fino a quando
tutte le istruzioni del programma non sono state eseguite.

\section{Ciclo di vita del software}\label{ciclo-di-vita-del-software}

Un \textbf{software} è composto da uno o più programmi e, quando
eseguito, realizza un compito con un grado di utilità specifico. La
gerarchia concetttuale, dal più generale all'elemento più granulare, è:
software, programmi, istruzioni.

Così come il disegno dei programmi è quello computazionale degli
algoritmi, il disegno del software è funzionale per determinare i suoi
obiettivi e architetturale per la decomposizione nei programmi.

Per creare il software, quindi, è necessario percorrere una sequenza di
fasi ben definita che, concisamente, è:

\begin{itemize}
\item
  La progettazione di un'applicazione inizia con la fase di
  \textbf{analisi dei requisiti}, in cui si identificano cosa deve fare
  il software, chi sono gli utenti e quali sono i requisiti funzionali e
  non funzionali che deve soddisfare.
\item
  Segue il \textbf{disegno funzionale} che dettaglia come ogni
  componente del sistema possa rispondere alle funzionalità richieste.
  In questa fase si descrivono le operazioni specifiche che ogni
  componente deve eseguire, utilizzando diagrammi di processo per
  rappresentare il flusso di attività al fine di rispondere ai
  requisiti.
\item
  Il \textbf{disegno architetturale} riguarda l'organizzazione ad alto
  livello del sistema software. In questa fase si definiscono i
  componenti principali del sistema e come essi interagiscono tra di
  loro per supportare le attività di processo. Questo include la
  suddivisione del sistema in moduli o componenti, la definizione delle
  interfacce tra di essi e l'uso di tecniche di modellazione per
  rappresentare l'architettura del sistema.
\item
  Una volta che l'architettura è stata progettata, si passa alla fase di
  \textbf{implementazione}, in cui i programmatori scrivono il codice
  sorgente nei linguaggi di programmazione scelti.
\item
  Dopo l'implementazione, è essenziale verificare che il software
  funzioni correttamente:

  \begin{itemize}
  \item
    \textbf{Testing}: Scrivere ed eseguire test per verificare che il
    software soddisfi i requisiti specificati. I test sono di diversi
    generi in funzione dell'oggetto di verifica, come test unitari, per
    segmenti di codice, test di integrazione, per componenti, e test di
    sistema nella sua interezza.
  \item
    \textbf{Debugging}: Identificare e correggere gli errori (bug) nel
    codice. Questo può includere l'uso di strumenti di debugging per
    tracciare l'esecuzione del programma e trovare i punti in cui si
    verificano gli errori.
  \end{itemize}
\item
  Una volta che il software è stato testato e ritenuto pronto, si passa
  alla fasi di messa a disposizione delle funzionalità agli utenti (in
  inglese, \emph{deployment}):

  \begin{itemize}
  \item
    \textbf{Distribuzione}: Rilasciare il software agli utenti finali,
    che può includere l'installazione su server, la distribuzione di
    applicazioni desktop o il rilascio di app mobile.
  \item
    \textbf{Manutenzione}: Continuare a supportare il software dopo il
    rilascio. Questo include la correzione di bug scoperti dopo il
    rilascio, l'aggiornamento del software per miglioramenti e nuove
    funzionalità, e l'adattamento a nuovi requisiti o ambienti.
  \end{itemize}
\end{itemize}

La complessità del processo induce la necessità di avere dei team con
qualità indiivduali diverse e il programmatore, oltre alle competenze
specifiche, deve saper interpretare i vari artifatti di disegno e
saperli tramutare in algoritmi e codice sorgente.

\section{L'Impatto dell'intelligenza artificiale generativa sulla
programmazione}\label{limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione}

Con l'avvento dell'\textbf{intelligenza artificiale generativa} (IA
generativa), la programmazione ha subito una trasformazione
significativa. Prima dell'IA generativa, i programmatori dovevano tutti
scrivere manualmente ogni riga di codice, seguendo rigorosamente la
sintassi e le regole del linguaggio di programmazione scelto. Questo
processo richiedeva una conoscenza approfondita degli algoritmi, delle
strutture dati e delle migliori pratiche di programmazione.

Inoltre, i programmatori dovevano creare ogni funzione, classe e modulo
a mano, assicurandosi che ogni dettaglio fosse corretto, identificavano
e correggevano gli errori nel codice con un processo lungo e laborioso,
che comportava anche la scrittura di casi di test e l'esecuzione di
sessioni di esecuzione di tali casi. Infine, dovebano scrivere
documentazione dettagliata per spiegare il funzionamento del codice e
facilitare la manutenzione futura.

\subsection{Attività del programmatore con l'IA
Generativa}\label{attivituxe0-del-programmatore-con-lia-generativa}

L'IA generativa ha introdotto nuovi strumenti e metodologie che stanno
cambiando il modo in cui i programmatori lavorano:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generazione automatica del codice: Gli strumenti di IA generativa
  possono creare porzioni di codice basate su descrizioni ad alto
  livello fornite dai programmatori. Questo permette di velocizzare
  notevolmente lo sviluppo iniziale e ridurre gli errori di sintassi.
\item
  Assistenza nel debugging: L'IA può identificare potenziali bug e
  suggerire correzioni, rendendo il processo di debugging più efficiente
  e meno dispendioso in termini di tempo.
\item
  Ottimizzazione automatica: Gli algoritmi di IA possono analizzare il
  codice e suggerire o applicare automaticamente ottimizzazioni per
  migliorare le prestazioni.
\item
  Generazione di casi di test: L'IA può creare casi di test per
  verificare la correttezza del codice, coprendo una gamma più ampia di
  scenari di quanto un programmatore potrebbe fare manualmente.
\item
  Documentazione automatica: L'IA può generare documentazione leggendo e
  interpretando il codice, riducendo il carico di lavoro manuale e
  garantendo una documentazione coerente e aggiornata.
\end{enumerate}

\subsection{L'Importanza di imparare a programmare nell'era dell'IA
generativa}\label{limportanza-di-imparare-a-programmare-nellera-dellia-generativa}

Nonostante l'avvento dell'IA generativa, imparare a programmare rimane
fondamentale per diverse ragioni. La programmazione non è solo una
competenza tecnica, ma anche un modo di pensare e risolvere problemi.
Comprendere i fondamenti della programmazione è essenziale per
utilizzare efficacemente gli strumenti di IA generativa. Senza una
solida base, è difficile sfruttare appieno queste tecnologie. Inoltre,
la programmazione insegna a scomporre problemi complessi in parti più
gestibili e a trovare soluzioni logiche e sequenziali, una competenza
preziosa in molti campi.

Anche con l'IA generativa, esisteranno sempre situazioni in cui sarà
necessario personalizzare o ottimizzare il codice per esigenze
specifiche. La conoscenza della programmazione permette di fare queste
modifiche con sicurezza. Inoltre, quando qualcosa va storto, è
indispensabile sapere come leggere e comprendere il codice per
identificare e risolvere i problemi. L'IA può assistere, ma la
comprensione umana rimane cruciale per interventi mirati.

Imparare a programmare consente di sperimentare nuove idee e prototipare
rapidamente soluzioni innovative. La creatività è potenziata dalla
capacità di tradurre idee in codice funzionante. Sapere programmare
aiuta anche a comprendere i limiti e le potenzialità degli strumenti di
IA generativa, permettendo di usarli in modo più strategico ed efficace.

La tecnologia evolve rapidamente, e con una conoscenza della
programmazione si è meglio preparati ad adattarsi alle nuove tecnologie
e metodologie che emergeranno in futuro. Inoltre, la programmazione è
una competenza trasversale applicabile in numerosi settori, dalla
biologia computazionale alla finanza, dall'ingegneria all'arte digitale.
Avere questa competenza amplia notevolmente le opportunità di carriera.

Infine, la programmazione è una porta d'accesso a ruoli più avanzati e
specializzati nel campo della tecnologia, come l'ingegneria del
software, la scienza dei dati e la ricerca sull'IA. Conoscere i principi
della programmazione aiuta a comprendere meglio come funzionano gli
algoritmi di IA, permettendo di contribuire attivamente allo sviluppo di
nuove tecnologie.

\chapter{Paradigmi di programmazione}\label{paradigmi-di-programmazione}

I linguaggi di programmazione possono essere classificati in diversi
tipologie in base al loro scopo e alla loro struttura.

Una delle classificazioni più importanti è quella del \textbf{paradigma
di programmazione}, che definisce il modello e gli stili di risoluzione
dei problemi che un linguaggio supporta per mezzo della codificazione
degli algoritmi.

Tuttavia, è importante notare che molti linguaggi moderni sfruttano
efficacemente più di un paradigma di programmazione, rendendo difficile
assegnare un linguaggio a una sola categoria. Come ha affermato Bjarne
Stroustrup, il creatore di C++:

\begin{quote}
Le funzionalità dei linguaggi esistono per fornire supporto agli stili
di programmazione. Per favore, non considerate una singola funzionalità
di linguaggio come una soluzione, ma come un mattoncino da un insieme
variegato che può essere combinato per esprimere soluzioni.

I principi generali per il design e la programmazione possono essere
espressi semplicemente:

\begin{itemize}
\item
  Esprimere idee direttamente nel codice.
\item
  Esprimere idee indipendenti in modo indipendente nel codice.
\item
  Rappresentare le relazioni tra le idee direttamente nel codice.
\item
  Combinare idee espresse nel codice liberamente, solo dove le
  combinazioni hanno senso.
\item
  Esprimere idee semplici in modo semplice.
\end{itemize}

Questi sono ideali condivisi da molte persone, ma i linguaggi progettati
per supportarli possono differire notevolmente. Una ragione fondamentale
per questo è che un linguaggio incorpora una serie di compromessi
ingegneristici che riflettono le diverse necessità, gusti e storie di
vari individui e comunità.(Stroustrup 2013, 10)
\end{quote}

\section{L'importanza dei paradigmi di
programmazione}\label{limportanza-dei-paradigmi-di-programmazione}

Comprendere i paradigmi di programmazione è fondamentale per diversi
motivi:

\begin{itemize}
\item
  Approccio alla risoluzione dei problemi: Ogni paradigma offre una
  visione diversa su come affrontare e risolvere problemi. Conoscere
  vari paradigmi permette ai programmatori di scegliere l'approccio più
  adatto in base al problema specifico. Ad esempio, per problemi che
  richiedono una manipolazione di stati, la programmazione imperativa
  può essere più intuitiva. Al contrario, per problemi che richiedono
  trasformazioni di dati senza effetti collaterali, la programmazione
  funzionale potrebbe essere più adatta.
\item
  Versatilità e adattabilità: I linguaggi moderni che supportano più
  paradigmi permettono ai programmatori di essere più versatili e
  adattabili. Possono utilizzare il paradigma più efficiente per diverse
  parti del progetto, migliorando sia la leggibilità che le prestazioni
  del codice.
\item
  Manutenzione del codice: La comprensione dei paradigmi aiuta nella
  scrittura di codice più chiaro e manutenibile. Ad esempio, il
  paradigma orientato agli oggetti può essere utile per organizzare
  grandi basi di codice in moduli e componenti riutilizzabili,
  migliorando la gestione del progetto.
\item
  Evoluzione professionale: La conoscenza dei vari paradigmi arricchisce
  le competenze di un programmatore, rendendolo più competitivo nel
  mercato del lavoro. Conoscere più paradigmi permette di comprendere e
  lavorare con una gamma più ampia di linguaggi di programmazione e
  tecnologie.
\item
  Ottimizzazione del codice: Alcuni paradigmi sono più efficienti in
  determinate situazioni. Ad esempio, la programmazione concorrente è
  essenziale per lo sviluppo di software che richiede alta prestazione e
  scalabilità, come nei sistemi distribuiti. Comprendere come
  implementare la concorrenza in vari paradigmi permette di scrivere
  codice più efficiente.
\end{itemize}

\section{Paradigma imperativo}\label{paradigma-imperativo}

La \textbf{programmazione imperativa}, a differenza della programmazione
dichiarativa, è un paradigma di programmazione che descrive l'esecuzione
di un programma come una serie di istruzioni che cambiano il suo stato.
In modo simile al modo imperativo delle lingue naturali, che esprime
comandi per compiere azioni, i programmi imperativi sono una sequenza di
comandi che il computer deve eseguire in sequenza. Un caso particolare
di programmazione imperativa è quella procedurale.

I linguaggi di programmazione imperativa si contrappongono ad altri tipi
di linguaggi, come quelli funzionali e logici. I linguaggi di
programmazione funzionale, come Haskell, non producono sequenze di
istruzioni e non hanno uno stato globale come i linguaggi imperativi. I
linguaggi di programmazione logica, come Prolog, sono caratterizzati
dalla definizione di cosa deve essere calcolato, piuttosto che come deve
avvenire il calcolo, a differenza di un linguaggio di programmazione
imperativo.

L'implementazione hardware di quasi tutti i computer è imperativa perché
è progettata per eseguire il codice macchina, che è scritto in stile
imperativo. Da questa prospettiva a basso livello, lo stato del
programma è definito dal contenuto della memoria e dalle istruzioni nel
linguaggio macchina nativo del processore. Al contrario, i linguaggi
imperativi di alto livello sono caratterizzati da un modello dati e
istruzioni che risultano più facilmente usabili come strumenti di
espressione di passi algoritmici.

\subsection{Esempio in assembly}\label{esempio-in-assembly}

Assembly è una categoria di linguaggi di basso livello, cioè
strettamente legati all'hardware del computer, tanto che ogni processore
ha il suo \emph{dialetto}. Un esempio di un semplice programma scritto
per l'architettura x86, utilizzando la sintassi dell'assembler NASM
(Netwide Assembler), è il seguente che effettua la somma di due numeri e
stampa il risultato:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{section} \FunctionTok{.data}
\NormalTok{    num1 }\DataTypeTok{db} \DecValTok{5}           \CommentTok{; Definisce il primo numero}
\NormalTok{    num2 }\DataTypeTok{db} \DecValTok{3}           \CommentTok{; Definisce il secondo numero}
\NormalTok{    result }\DataTypeTok{db} \DecValTok{0}         \CommentTok{; Variabile per memorizzare il risultato}
\NormalTok{    msg }\DataTypeTok{db} \StringTok{\textquotesingle{}Result: \textquotesingle{}}\OperatorTok{,} \DecValTok{0} \CommentTok{; Messaggio di output}

\KeywordTok{section} \FunctionTok{.bss}
\NormalTok{    result\_str }\DataTypeTok{resb} \DecValTok{4}   \CommentTok{; Buffer per la stringa del risultato}

\KeywordTok{section} \FunctionTok{.text}
    \KeywordTok{global}\NormalTok{ \_start}

\FunctionTok{\_start:}
    \CommentTok{; Somma num1 e num2}
    \KeywordTok{mov} \KeywordTok{al}\OperatorTok{,} \OperatorTok{[}\NormalTok{num1}\OperatorTok{]}      \CommentTok{; Carica il primo numero in AL}
    \KeywordTok{add} \KeywordTok{al}\OperatorTok{,} \OperatorTok{[}\NormalTok{num2}\OperatorTok{]}      \CommentTok{; Aggiunge il secondo numero a AL}
    \KeywordTok{mov} \OperatorTok{[}\NormalTok{result}\OperatorTok{],} \KeywordTok{al}    \CommentTok{; Memorizza il risultato in result}

    \CommentTok{; Converti il risultato in stringa ASCII}
    \KeywordTok{mov} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\NormalTok{result}\OperatorTok{]}   \CommentTok{; Carica il risultato in EAX}
    \KeywordTok{add} \KeywordTok{eax}\OperatorTok{,} \StringTok{\textquotesingle{}0\textquotesingle{}}        \CommentTok{; Converti il valore numerico in carattere ASCII}
    \KeywordTok{mov} \OperatorTok{[}\NormalTok{result\_str}\OperatorTok{],} \KeywordTok{eax} \CommentTok{; Memorizza il carattere ASCII in result\_str}

    \CommentTok{; Stampa il messaggio}
    \KeywordTok{mov} \KeywordTok{eax}\OperatorTok{,} \DecValTok{4}          \CommentTok{; syscall numero per sys\_write}
    \KeywordTok{mov} \KeywordTok{ebx}\OperatorTok{,} \DecValTok{1}          \CommentTok{; file descriptor 1 (stdout)}
    \KeywordTok{mov} \KeywordTok{ecx}\OperatorTok{,}\NormalTok{ msg        }\CommentTok{; puntatore al messaggio}
    \KeywordTok{mov} \KeywordTok{edx}\OperatorTok{,} \DecValTok{8}          \CommentTok{; lunghezza del messaggio}
    \KeywordTok{int} \BaseNTok{0x80}            \CommentTok{; chiamata di sistema}

    \CommentTok{; Stampa il risultato}
    \KeywordTok{mov} \KeywordTok{eax}\OperatorTok{,} \DecValTok{4}          \CommentTok{; syscall numero per sys\_write}
    \KeywordTok{mov} \KeywordTok{ebx}\OperatorTok{,} \DecValTok{1}          \CommentTok{; file descriptor 1 (stdout)}
    \KeywordTok{mov} \KeywordTok{ecx}\OperatorTok{,}\NormalTok{ result\_str }\CommentTok{; puntatore alla stringa del risultato}
    \KeywordTok{mov} \KeywordTok{edx}\OperatorTok{,} \DecValTok{1}          \CommentTok{; lunghezza della stringa del risultato}
    \KeywordTok{int} \BaseNTok{0x80}            \CommentTok{; chiamata di sistema}

    \CommentTok{; Terminazione del programma}
    \KeywordTok{mov} \KeywordTok{eax}\OperatorTok{,} \DecValTok{1}          \CommentTok{; codice di sistema per l\textquotesingle{}uscita}
    \KeywordTok{xor} \KeywordTok{ebx}\OperatorTok{,} \KeywordTok{ebx}        \CommentTok{; codice di ritorno 0}
    \KeywordTok{int} \BaseNTok{0x80}            \CommentTok{; interruzione per chiamare il kernel}
\end{Highlighting}
\end{Shaded}

Le sezioni del codice:

\begin{itemize}
\item
  La sezione \texttt{.data} definisce i dati statici \texttt{num1},
  \texttt{num2}, \texttt{result} e \texttt{msg}.
\item
  Sezione \texttt{.bss} alloca lo spazio per \texttt{result\_str}, che
  conterrà la stringa del risultato.
\item
  Sezione \texttt{.text}definisce \texttt{\_start} come punto di
  ingresso del programma e:

  \begin{itemize}
  \tightlist
  \item
    Implementa la logica principale del programma.
  \item
    Somma i valori di \texttt{num1} e \texttt{num2}.
  \item
    Converte il risultato numerico in una stringa ASCII.
  \item
    Utilizza chiamate al sistema operativo per scrivere il messaggio e
    il risultato su stdout.
  \item
    Termina il programma.
  \end{itemize}
\end{itemize}

L'assembly è usato nello sviluppo di:

\begin{itemize}
\item
  Sistemi operativi, ad esempio il kernel, che ha il controllo del
  sistema e i driver, cioè i programmi utili alla comunicazione
  coll'hardware.
\item
  Applicazioni \emph{embedded}: Microcontrollori di dispositivi medici,
  sistemi di controllo di veicoli, dispositivi IoT, ecc., cioè)dove è
  necessaria un'ottimizzazione estrema delle risorse computazionali.
\item
  Applicazioni HPC (\emph{high performance computing}): Il focus qui è
  eseguire calcoli intensivi e complessi in tempi relativamente brevi.
  Queste applicazioni richiedono un numero di operazioni per unità di
  tempo elevato e sono ottimizzate per sfruttare al massimo le risorse
  hardware disponibili, come CPU, GPU e memoria.
\end{itemize}

\subsection{Esempio in Python}\label{esempio-in-python}

All'altro estremo della immediatezza di comprensione del testo del
codice per un essere umano, troviamo Python, un linguaggio di alto
livello noto per la leggibilità ed eleganza.

Ecco il medesimo esempio, visibilmente più conciso e certamente
intuibile anche avendo basi limitate di programmazione:

\phantomsection\label{annotated-cell-4}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num1 }\OperatorTok{=} \DecValTok{5} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{num2 }\OperatorTok{=} \DecValTok{3}

\NormalTok{result }\OperatorTok{=}\NormalTok{ num1 }\OperatorTok{+}\NormalTok{ num2 }\hspace*{\fill}\NormalTok{\circled{2}}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Il risultato è: "}\NormalTok{, result) }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione delle variabili che identificano gli addendi.
\item[\circled{2}]
Somma dei due numeri.
\item[\circled{3}]
Stampa del risultato della somma.
\end{description}

\subsection{Analisi comparativa}\label{analisi-comparativa}

Assembly:

\begin{itemize}
\item
  Basso livello di astrazione: Assembly lavora direttamente con i
  registri della CPU e la memoria, quindi non astrae granché della
  complessità dell'hardware.
\item
  Scarsa versatilità: Il linguaggio è progettato per una ben definita
  architettura e, quindi, ha una scarsa applicabilità ad altre, anche se
  alcuni dialetti di assembly presentano delle similitudini.
\item
  Elevata precisione: Il programmatore ha un controllo dettagliato su
  ogni singola operazione compiuta dal processore, perché c'è una
  corrispondenza col codice macchina.
\item
  Complessità: Ogni operazione deve essere definita esplicitamente e in
  sequenza, il che rende il codice più lungo e difficile da leggere.
\end{itemize}

Python:

\begin{itemize}
\item
  Alto livello di astrazione: Python fornisce un'astrazione più elevata
  sia dei dati che delle istruzioni, permettendo di ignorare i dettagli
  dei diversi hardware.
\item
  Elevata semplicità: Il codice è più breve e leggibile, facilitando la
  comprensione e la manutenzione.
\item
  Elevata versatilità: Il linguaggio è applicabile senza modifiche a un
  elevato numero di architetture hardware-software.
\item
  Produttività: I programmatori possono concentrarsi sulla complessità
  intrinseca del problema, senza preoccuparsi di molti dettagli
  implementativi del processo di esecuzione.
\end{itemize}

\section{Paradigma procedurale}\label{paradigma-procedurale}

La \textbf{programmazione procedurale} è un paradigma di programmazione,
derivato da quella imperativa, che organizza il codice in unità chiamate
procedure o funzioni. Ogni procedura o funzione è un blocco di codice
che può essere richiamato da altre parti del programma, promuovendo la
riutilizzabilità e la modularità del codice.

La programmazione procedurale è una naturale evoluzione della imperativa
e uno dei paradigmi più antichi e ampiamente utilizzati. Ha avuto
origine negli anni '60 e '70 con linguaggi come Fortan, COBOL e C,
tutt'oggi rilevanti. Questi linguaggi hanno introdotto concetti
fondamentali come funzioni, sottoprogrammi e la separazione tra codice e
dati. Il C, in particolare, ha avuto un impatto duraturo sulla
programmazione procedurale, diventando uno standard de facto per lo
sviluppo di sistemi operativi e software di sistema.

I vantaggi principali sono:

\begin{itemize}
\item
  Modularità: La programmazione procedurale incoraggia la suddivisione
  del codice in funzioni o procedure più piccole e gestibili. Questo
  facilita la comprensione, la manutenzione e il riutilizzo del codice.
\item
  Riutilizzabilità: Le funzioni possono essere riutilizzate in diverse
  parti del programma o in progetti diversi, riducendo la duplicazione
  del codice e migliorando l'efficienza dello sviluppo.
\item
  Struttura e organizzazione: Il codice procedurale è generalmente più
  strutturato e organizzato, facilitando la lettura e la gestione del
  progetto software.
\item
  Facilità di debug e testing: La suddivisione del programma in funzioni
  isolate rende più facile individuare e correggere errori, oltre a
  testare parti specifiche del codice.
\end{itemize}

D'altro canto, presenta anche degli svantaggi che hanno spinto i
ricercatori a continuare l'innovazione:

\begin{itemize}
\item
  Scalabilità limitata: Nei progetti molto grandi, la programmazione
  procedurale può diventare difficile da gestire. La mancanza di
  meccanismi di astrazione avanzati, come quelli offerti dalla
  programmazione orientata agli oggetti, può complicare la gestione
  della complessità.
\item
  Gestione dello stato: La programmazione procedurale si basa spesso su
  variabili globali per condividere stato tra le funzioni, il che può
  portare a bug difficili da individuare e risolvere.
\item
  Difficoltà nell'aggiornamento: Le modifiche a una funzione possono
  richiedere aggiornamenti in tutte le parti del programma che la
  utilizzano, aumentando il rischio di introdurre nuovi errori.
\item
  Meno Adatta per Applicazioni Moderne: Per applicazioni complesse e
  moderne che richiedono la gestione di eventi, interfacce utente
  complesse e modellazione del dominio, la programmazione procedurale
  può essere meno efficace rispetto ad altri paradigmi come quello
  orientato agli oggetti.
\end{itemize}

\subsection{Funzioni e procedure}\label{funzioni-e-procedure}

Nella programmazione procedurale, il codice è suddiviso in unità
elementari chiamate \textbf{funzioni} e \textbf{procedure}. La
differenza principale tra le due è la seguente:

\begin{itemize}
\item
  Funzione: Una funzione è un blocco di codice che esegue un compito
  specifico e restituisce un valore. Le funzioni sono utilizzate per
  calcoli o operazioni che producono un risultato. Ad esempio, una
  funzione che calcola la somma di due numeri in linguaggio C:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ somma}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Procedura: Una procedura è simile a una funzione, ma non restituisce
  un valore. È utilizzata per eseguire azioni o operazioni che non
  necessitano di un risultato. Ad esempio, una procedura che stampa un
  messaggio in Pascal:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{procedure}\NormalTok{ stampaMessaggio;}
\KeywordTok{begin}
\NormalTok{  writeln(}\StringTok{\textquotesingle{}Ciao, Mondo!\textquotesingle{}}\NormalTok{);}
\KeywordTok{end}\NormalTok{;}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\subsection{Creazione di librerie}\label{creazione-di-librerie}

Un altro aspetto importante della programmazione procedurale è la
possibilità di creare \textbf{librerie}, che sono collezioni di funzioni
e procedure riutilizzabili. Le librerie permettono di organizzare e
condividere codice comune tra diversi progetti, aumentando la
produttività e riducendo la duplicazione del codice, nonché abilitando
un modello commerciale che mette a disposizione del software prodotto da
aziende o comunità specializzate.

Esempio di una semplice libreria ipotetica di \emph{somme} in C:

\begin{itemize}
\item
  File header (\texttt{mialibreria.h}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MIALIBRERIA\_H}
\PreprocessorTok{\#define MIALIBRERIA\_H}

\DataTypeTok{int}\NormalTok{ somma\_interi}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\DataTypeTok{char}\OperatorTok{*}\NormalTok{ somma\_stringhe}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ b}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ somma\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{);}

\DataTypeTok{void}\NormalTok{ stampa\_messaggio}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ messaggio}\OperatorTok{,} 
                      \DataTypeTok{void}\OperatorTok{*}\NormalTok{ risultato}\OperatorTok{,} 
                      \DataTypeTok{char}\NormalTok{ tipo}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}
\item
  File di implementazione (\texttt{mialibreria.c}):

\phantomsection\label{annotated-cell-78}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"mialibreria.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ somma\_interi}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
  \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{char}\OperatorTok{*}\NormalTok{ somma\_stringhe}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
  \DataTypeTok{char}\OperatorTok{*}\NormalTok{ risultato }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{strlen}\OperatorTok{(}\NormalTok{a}\OperatorTok{)} \OperatorTok{+}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{b}\OperatorTok{)} \OperatorTok{+} \DecValTok{1}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{1}}

  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{risultato}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{risultato}\OperatorTok{,}\NormalTok{ a}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}
\NormalTok{    strcat}\OperatorTok{(}\NormalTok{risultato}\OperatorTok{,}\NormalTok{ b}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}
  \OperatorTok{\}}

  \ControlFlowTok{return}\NormalTok{ risultato}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ somma\_array\_interi}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ somma }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

  \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    somma }\OperatorTok{+=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
  \OperatorTok{\}}

  \ControlFlowTok{return}\NormalTok{ somma}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ stampa\_messaggio}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ messaggio}\OperatorTok{,} 
                      \DataTypeTok{void}\OperatorTok{*}\NormalTok{ risultato}\OperatorTok{,} 
                      \DataTypeTok{char}\NormalTok{ tipo}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ messaggio}\OperatorTok{);}

  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{tipo }\OperatorTok{==} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{risultato}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{5}}
  \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{tipo }\OperatorTok{==} \CharTok{\textquotesingle{}s\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{char}\OperatorTok{*)}\NormalTok{risultato}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{6}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Allocazione della memoria per la somma delle due stringhe e +1 per il
  carattere di terminazione \texttt{\textbackslash{}0}.
  \item[\circled{2}]
  Controllo se la funzione \texttt{malloc} ha avuto successo
  nell'allocare la memoria richiesta. Se \texttt{risultato} è
  \texttt{NULL}, significa che \texttt{malloc} ha fallito e il blocco di
  codice all'interno dell'\texttt{if} viene saltato, evitando così di
  tentare di accedere a memoria non valida.
  \item[\circled{3}]
  Se l'allocazione ha avuto successo, copia la prima stringa nel
  risultato.
  \item[\circled{4}]
  Concatenazione della seconda stringa nel risultato.
  \item[\circled{5}]
  Stampa del risultato se il tipo è intero.
  \item[\circled{6}]
  Stampa del risultato se il tipo è una stringa.
  \end{description}
\item
  File principale (\texttt{main.c}):

\phantomsection\label{annotated-cell-79}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"mialibreria.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ risultato }\OperatorTok{=}\NormalTok{ somma\_interi}\OperatorTok{(}\DecValTok{5}\OperatorTok{,} \DecValTok{3}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{  stampa\_messaggio}\OperatorTok{(}\StringTok{"Il risultato della somma di interi è: "}\OperatorTok{,} 
                   \OperatorTok{\&}\NormalTok{risultato}\OperatorTok{,} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{);}

  \DataTypeTok{char}\OperatorTok{*}\NormalTok{ risultato\_stringhe }\OperatorTok{=}\NormalTok{ somma\_stringhe}\OperatorTok{(}\StringTok{"Ciao, "}\OperatorTok{,} \StringTok{"mondo!"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{  stampa\_messaggio}\OperatorTok{(}\StringTok{"Il risultato della somma di stringhe è: "}\OperatorTok{,} 
\NormalTok{                   risultato\_stringhe}\OperatorTok{,} \CharTok{\textquotesingle{}s\textquotesingle{}}\OperatorTok{);}
\NormalTok{  free}\OperatorTok{(}\NormalTok{risultato\_stringhe}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}

  \DataTypeTok{int}\NormalTok{ array}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};} 
  \DataTypeTok{int}\NormalTok{ risultato\_array }\OperatorTok{=}\NormalTok{ somma\_array\_interi}\OperatorTok{(}\NormalTok{array}\OperatorTok{,} \DecValTok{5}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}
\NormalTok{  stampa\_messaggio}\OperatorTok{(}\StringTok{"Il risultato della somma dell\textquotesingle{}array di interi è: "}\OperatorTok{,} 
                   \OperatorTok{\&}\NormalTok{risultato\_array}\OperatorTok{,} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{);}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Chiamata della funzione per la somma di due interi.
  \item[\circled{2}]
  Chiamata della funzione per la somma di due stringhe (implementata
  come una concatenazione).
  \item[\circled{3}]
  Liberazione della memoria allocata per la stringa risultante.
  \item[\circled{4}]
  Chiamata della funzione per la somma di un array di interi.
  \end{description}
\end{itemize}

E il medesimo, ma in Python:

\phantomsection\label{annotated-cell-5}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ somma\_interi(a, b):}
  \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

\KeywordTok{def}\NormalTok{ somma\_stringhe(a, b): }\hspace*{\fill}\NormalTok{\circled{1}}
  \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

\KeywordTok{def}\NormalTok{ somma\_array(arr): }\hspace*{\fill}\NormalTok{\circled{2}}
  \ControlFlowTok{return} \BuiltInTok{sum}\NormalTok{(arr) }\hspace*{\fill}\NormalTok{\circled{3}}

\NormalTok{risultato\_interi }\OperatorTok{=}\NormalTok{ somma\_interi(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Il risultato della somma di interi è: }\SpecialCharTok{\{}\NormalTok{risultato\_interi}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{risultato\_stringhe }\OperatorTok{=}\NormalTok{ somma\_stringhe(}\StringTok{"Ciao, "}\NormalTok{, }\StringTok{"mondo!"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Il risultato della somma di stringhe è: }\SpecialCharTok{\{}\NormalTok{risultato\_stringhe}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{array\_interi }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\NormalTok{risultato\_array }\OperatorTok{=}\NormalTok{ somma\_array(array\_interi) }
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Il risultato della somma dell\textquotesingle{}array è: }\SpecialCharTok{\{}\NormalTok{risultato\_array}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Il codice di \texttt{somma\_interi} e \texttt{somma\_stringhe} è
identico e questo ci suggerisce che una delle due è ridondante.
\item[\circled{2}]
La funzione ora prende in input solo l'array e non c'è bisogno di
inserire anche la sua dimensione.
\item[\circled{3}]
In Python, per evitare errori quando si usa la funzione \texttt{sum},
l'array (o lista) deve contenere elementi che supportano l'operazione di
addizione tra di loro. Tipicamente, si usano numeri (interi o a virgola
mobile), ma è possibile anche sommare altri tipi di elementi se
l'operazione di addizione è definita per quel tipo di dato.
\end{description}

Anche qui Python appare più semplice e immediato, sicuramente vincente
sul piano della comprensione del codice e della immediatezza di
utilizzo. In realtà, Python e C hanno sia una forte complementarietà
sulle applicazioni, sia una dipendenza perché molte librerie e
l'interprete stesso di Python sono in C.

\section{Paradigma di orientamento agli
oggetti}\label{paradigma-di-orientamento-agli-oggetti}

La \textbf{programmazione orientata agli oggetti} (in inglese
\emph{object-oriented programming}, OOP) è un paradigma di
programmazione che organizza il software in termini di \emph{oggetti},
ciascuno dei quali rappresenta un'istanza di una matrice detta
\emph{classe}. Una classe definisce un tipo di dato che include
attributi (dati) e metodi (funzionalità). Gli oggetti interagiscono tra
loro attraverso messaggi, permettendo una struttura modulare e
intuitiva.

L'OOP è emersa negli anni '60 e '70 con il linguaggio Simula, il primo
linguaggio di programmazione a supportare questo paradigma. Tuttavia, è
stato con Smalltalk, sviluppato negli anni '70 da Alan Kay e altri
presso Xerox PARC, che l'OOP ha guadagnato popolarità. Il paradigma è
stato ulteriormente consolidato con il linguaggio C++ negli anni '80 e
con Java negli anni '90, rendendolo uno dei più utilizzati per lo
sviluppo software moderno. Oggi numerosi sono i linguaggi a oggetti, ad
esempio Python, C\#, Ruby, Java, Swift, Javascript, ecc. ed altri lo
supportano come PHP (dalla versione 5) e financo il Fortran nella
versione 2003.

Rispetto ai paradigmi precedenti, l'OOP introduce diversi concetti
chiave che ineriscono al disegno architetturale di software:

\begin{itemize}
\item
  \textbf{Classe} e \textbf{oggetto}: La classe è un modello o schema
  per creare oggetti. Contiene definizioni di attributi e metodi.
  L'oggetto è un'istanza di una classe e rappresenta un'entità concreta
  nel programma con stato e comportamento mutevoli.
\item
  \textbf{Incapsulamento}: Nasconde i dettagli interni di un oggetto e
  mostra solo le interfacce necessarie agli altri oggetti. Migliora la
  modularità e protegge l'integrità dei dati.
\item
  \textbf{Ereditarietà} (relazione \emph{is-a}): Permette a una classe
  di estenderne un'altra, ereditandone attributi e metodi. Favorisce il
  riuso del codice e facilita l'estensione delle funzionalità. Si usa
  quando una classe può essere considerata una specializzazione di
  un'altra. Ad esempio, un \texttt{Gatto} è un \texttt{Animale}, quindi
  la classe \texttt{Gatto} eredita dalla classe \texttt{Animale}.
\item
  \textbf{Polimorfismo}: Consente a oggetti di classi diverse di essere
  trattati come oggetti di una classe comune. Facilita l'uso di
  un'interfaccia uniforme per operazioni diverse. Il polimorfismo è
  strettamente legato all'ereditarietà e permette di usare un metodo in
  modi diversi a seconda dell'oggetto che lo invoca. Ad esempio, un
  metodo \texttt{muovi()} può comportarsi diversamente se invocato su un
  oggetto di classe \texttt{Gatto} rispetto a un oggetto di classe
  \texttt{Uccello}, ma entrambi sono trattati come \texttt{Animale}.
\item
  \textbf{Astrazione}: Permette di definire interfacce di alto livello
  per oggetti, senza esporre i dettagli implementativi. Facilita la
  comprensione e la gestione della complessità del sistema, perché,
  assieme a ereditarietà e polimorfismo, permette di pensare in modo più
  naturale, basando la decomposizione del problema anche su relazioni di
  tipo gerarchico e concettuale. Attraverso l'astrazione, si definiscono
  classi e interfacce che rappresentano concetti generici, come
  \texttt{Forma} o \texttt{Veicolo}, senza specificare i dettagli
  concreti delle implementazioni.
\item
  \textbf{Composizione} (relazione \emph{has-a}): Permette a una classe
  di contenere altre classi come parte dei suoi attributi. È una forma
  di relazione che indica che un oggetto è composto da uno o più oggetti
  di altre classi. Si usa quando una classe ha bisogno di utilizzare
  funzionalità di altre classi ma non rappresenta una specializzazione
  di quelle classi. Ad esempio, una classe \texttt{Auto} può avere un
  oggetto \texttt{Motore} come attributo, indicando che \emph{un'Auto ha
  un Motore}.
\end{itemize}

I vantaggi principali dell'OOP sono:

\begin{itemize}
\item
  \textbf{Modularità}: Le classi e gli oggetti favoriscono la
  suddivisione del codice in moduli indipendenti, in una forma più
  granulare rispetto al paradigma procedurale. Non solo le istruzioni
  sono raggruppate per soddisfare una specifica operazione, ma possono
  essere viste come più operazioni su uno stato associato. La modularità
  è rafforzata dalle relazioni \emph{has-a} e \emph{is-a}, che aiutano a
  organizzare il codice in componenti logicamente separati e
  interconnessi.
\item
  \textbf{Riutilizzabilità}: L'uso di classi e l'ereditarietà (relazione
  \emph{is-a}) consentono di riutilizzare il codice in nuovi progetti
  senza riscriverlo, limitando gli effetti collaterali sul codice con
  cui interagiscono. Le classi base possono essere estese per creare
  nuove classi con funzionalità aggiuntive, mantenendo al contempo la
  compatibilità con il codice esistente.
\item
  \textbf{Facilità di manutenzione}: L'incapsulamento e l'astrazione
  riducono la complessità perché permettono una migliore assegnazione
  logica dei principi usati nella progettazione dell'applicazione alle
  singole classi. Ciò facilita la manutenzione del codice, poiché nella
  modifica si possono individuare rapidamente le istruzioni impattate.
  La relazione \emph{has-a} contribuisce ulteriormente alla manutenzione
  isolando le responsabilità all'interno delle classi.
\item
  \textbf{Estendibilità}: Le classi possono essere estese (relazione
  \emph{is-a}) per aggiungere nuove funzionalità senza modificare il
  codice già preesistente, riducendo così gli impatti per il codice che
  ne dipende. Questo approccio facilita l'integrazione di nuove
  caratteristiche e miglioramenti, mantenendo la stabilità del sistema.
\end{itemize}

Anche se sussistono dei caveat:

\begin{itemize}
\item
  Complessità iniziale: L'OOP può essere complesso da apprendere e
  implementare correttamente per i nuovi programmatori.
\item
  Overhead di prestazioni: L'uso intensivo di oggetti può introdurre un
  overhead di memoria e prestazioni rispetto alla programmazione
  procedurale.
\item
  Abuso di ereditarietà: L'uso improprio dell'ereditarietà può portare a
  gerarchie di classi troppo complesse e difficili da gestire, quindi,
  producendo un effetto opposto ad una delle ragioni di esistenza del
  concetto, cioè la semplicità di comunicazione della progettazione del
  software.
\end{itemize}

\subsection{Esempio in Java}\label{esempio-in-java}

In questo esempio, la classe \texttt{Animale} rappresenta una tipo di
dato generico con un attributo \texttt{nome} e un metodo
\texttt{faiVerso}. La classe \texttt{Cane} specializza \texttt{Animale},
usando l'attributo \texttt{nome} e sovrascrivendo il metodo
\texttt{faiVerso}, per fornire un'implementazione coerente colle sue
caratteristiche. La classe \texttt{Main} crea un'istanza di
\texttt{Cane} e chiama il suo metodo \texttt{faiVerso} (\emph{annotato}
con \texttt{@Override}\footnote{In Java, l'annotazione
  \texttt{@Override} è opzionale, ma altamente consigliata. Non omettere
  l'annotazione \texttt{@Override} non causerà un errore di compilazione
  o di runtime. Tuttavia, l'uso di \texttt{@Override} offre dei vantaggi
  importanti perché, innanzitutto, il compilatore può verificare che il
  metodo stia effettivamente sovrascrivendo uno nella classe base e
  segnalare un errore in caso contrario. Inoltre, l'annotazione migliora
  la leggibilità del codice perché indica chiaramente al lettore come il
  metodo è inteso rispetto all'ereditarietà.}), dimostrando il
polimorfismo e l'ereditarietà:

\phantomsection\label{annotated-cell-6}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \BuiltInTok{String}\NormalTok{ nome}\OperatorTok{;}

  \FunctionTok{Animale}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{nome} \OperatorTok{=}\NormalTok{ nome}\OperatorTok{;}
  \OperatorTok{\}}

  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"L\textquotesingle{}animale fa un verso"}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Cane }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{2}}

  \FunctionTok{Cane}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{super}\OperatorTok{(}\NormalTok{nome}\OperatorTok{);}
  \OperatorTok{\}}

  \AttributeTok{@Override} \hspace*{\fill}\NormalTok{\circled{3}}
  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Il cane abbaia"}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Animale mioCane }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{(}\StringTok{"Fido"}\OperatorTok{);}

\NormalTok{    mioCane}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{4}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione della classe \texttt{Animale} che ha il doppio compito di
provvedere all'implementazione per una caratteristica comune
(\texttt{nome} e \texttt{descrizione()}) e una particolare
(\texttt{faiVerso()}).
\item[\circled{2}]
Definizione della classe derivata \texttt{Cane}.
\item[\circled{3}]
\texttt{@Override} indica in esplicito che il \texttt{faiVerso()} del
\texttt{Cane} sovrascrive (non eredita) il \texttt{faiVerso()} di
\texttt{Animale}.
\item[\circled{4}]
Output: \texttt{Il\ cane\ abbaia}.
\end{description}

In realtà, se gli oggetti devono rappresentare animali reali vorrà dire
che non deve essere possibile crearne dalla matrice \texttt{Animale}.
Vediamo, quindi, come implementare il medesimo esempio con una classe
\emph{astratta}, cioè una classe che non può essere usata per generare
direttamente oggetti, sempre in Java.

Nel caso pratico, ogni animale ha il suo verso, quindi dobbiamo
costringere il programmatore che vuole implementare classi
corrispondenti ad animali reali, ad aggiungere tassativamente il metodo
\texttt{faiVerso()} per comunicarne la caratteristica distintiva. Una
modalità è marchiare \texttt{Animale} e il suo metodo da caratterizzare
(\texttt{faiVerso()}), con costrutti ad hoc perché siano,
rispettivamente, identificata come classe astratta (per mezzo della
parola riservata \texttt{abstract}) e metodo da implementare. Al
contempo, \texttt{Cane} non subisce specifiche modifiche sintattiche, ma
deve rispettare il vincolo (implementare \texttt{faiVerso()}) perché,
ereditando le caratteristiche di \texttt{Animale}, possa essere una
classe concreta, cioè da cui si possono creare oggetti. Il codice
risultate è:

\phantomsection\label{annotated-cell-7}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \BuiltInTok{String}\NormalTok{ nome}\OperatorTok{;}

  \FunctionTok{Animale}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{nome} \OperatorTok{=}\NormalTok{ nome}\OperatorTok{;}
  \OperatorTok{\}}

  \KeywordTok{abstract} \BuiltInTok{String} \FunctionTok{faiVerso}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{2}}

  \BuiltInTok{String} \FunctionTok{descrizione}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{3}}
    \ControlFlowTok{return} \StringTok{"L\textquotesingle{}animale si chiama "} \OperatorTok{+}\NormalTok{ nome}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Cane }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{4}}

  \FunctionTok{Cane}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{super}\OperatorTok{(}\NormalTok{nome}\OperatorTok{);}
  \OperatorTok{\}}

  \AttributeTok{@Override}
  \BuiltInTok{String} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
    \ControlFlowTok{return} \StringTok{"Il cane abbaia"}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Coccodrillo }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{5}}

  \FunctionTok{Coccodrillo}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{super}\OperatorTok{(}\NormalTok{nome}\OperatorTok{);}
  \OperatorTok{\}}

  \AttributeTok{@Override}
  \BuiltInTok{String} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{6}}
    \ControlFlowTok{return} \StringTok{""}\OperatorTok{;}  
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Animale mioCane }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{(}\StringTok{"Fido"}\OperatorTok{);}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCane}\OperatorTok{.}\FunctionTok{descrizione}\OperatorTok{());} \hspace*{\fill}\NormalTok{\circled{7}}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCane}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{());} \hspace*{\fill}\NormalTok{\circled{8}}

\NormalTok{    Animale mioCoccodrillo }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Coccodrillo}\OperatorTok{(}\StringTok{"Crocky"}\OperatorTok{);}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCoccodrillo}\OperatorTok{.}\FunctionTok{descrizione}\OperatorTok{());} \hspace*{\fill}\NormalTok{\circled{9}}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCoccodrillo}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{());} \hspace*{\fill}\NormalTok{\circled{10}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione della classe astratta che ha il doppio compito di fornire
una implementazione di default per una caratteristica comune
(\texttt{nome}) e un vincolo di implementazione nelle classe derivate
per una seconda caratteristica comune non implementabile nello stesso
modo per tutte (\texttt{faiVerso()}).
\item[\circled{2}]
Metodo astratto \texttt{faiVerso()} che le classi corrispondenti ad
animali reali dovranno implementare e che dovrà resituire una stringa.
\item[\circled{3}]
Metodo concreto \texttt{faiVerso()} che restituisce una stringa.
\item[\circled{4}]
Definizione della classe derivata \texttt{Cane}.
\item[\circled{5}]
Definizione della classe derivata \texttt{Coccodrillo}.
\item[\circled{6}]
Il coccodrillo non emette versi!
\item[\circled{7}]
Stampa: \texttt{L\textquotesingle{}animale\ si\ chiama\ Fido}.
\item[\circled{8}]
Stampa: \texttt{Il\ cane\ abbaia}.
\item[\circled{9}]
Stampa: \texttt{L\textquotesingle{}animale\ si\ chiama\ Crocky}.
\item[\circled{10}]
Non stampa nulla perché il coccodrillo non emette versi!
\end{description}

\subsection{Template}\label{template}

I \textbf{template}, o generics, non sono specifici dell'OOP, anche se
sono spesso associati a essa. I template permettono di scrivere
funzioni, classi, e altri costrutti di codice in modo generico, cioè
indipendente dal tipo dei dati che manipolano. Questo concetto è
particolarmente utile per creare librerie e moduli riutilizzabili e
flessibili.

Ad esempio, definiamo la classe \texttt{Box} nel modo seguente:

\phantomsection\label{annotated-cell-8}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{template} \OperatorTok{\textless{}}\KeywordTok{typename}\NormalTok{ T}\OperatorTok{\textgreater{}} \hspace*{\fill}\NormalTok{\circled{1}}
\KeywordTok{class}\NormalTok{ Box }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{  T value}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{3}}

\KeywordTok{public}\OperatorTok{:}
  \DataTypeTok{void}\NormalTok{ setValue}\OperatorTok{(}\NormalTok{T val}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ value }\OperatorTok{=}\NormalTok{ val}\OperatorTok{;} \OperatorTok{\}} \hspace*{\fill}\NormalTok{\circled{4}}

\NormalTok{  T getValue}\OperatorTok{()} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ value}\OperatorTok{;} \OperatorTok{\}} \hspace*{\fill}\NormalTok{\circled{5}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
La keyword \texttt{template} definisce un template di classe che può
lavorare con qualsiasi tipo \texttt{T} specificato al momento dell'uso.
\item[\circled{2}]
Dichiarazione della classe \texttt{Box} che utilizza il template di tipo
\texttt{T}.
\item[\circled{3}]
Dichiarazione del membro dati \texttt{value} di tipo \texttt{T}, che
rappresenta il valore contenuto nella scatola.
\item[\circled{4}]
Metodo pubblico \texttt{setValue} che imposta il valore del membro dati
\texttt{value} con il parametro \texttt{val} di tipo \texttt{T}.
\item[\circled{5}]
Metodo pubblico \texttt{getValue} che restituisce il valore del membro
dati \texttt{value} di tipo \texttt{T}.
\end{description}

\texttt{Box} può contenere un valore di qualsiasi tipo specificato al
momento della creazione dell'istanza per mezzo del template \texttt{T}:

\phantomsection\label{annotated-cell-9}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Box}\OperatorTok{\textless{}}\DataTypeTok{int}\OperatorTok{\textgreater{}}\NormalTok{ intBox}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\NormalTok{intBox}\OperatorTok{.}\NormalTok{setValue}\OperatorTok{(}\DecValTok{123}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=}\NormalTok{ intBox}\OperatorTok{.}\NormalTok{getValue}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{3}}

\NormalTok{Box}\OperatorTok{\textless{}}\BuiltInTok{std::}\NormalTok{string}\OperatorTok{\textgreater{}}\NormalTok{ stringBox}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{4}}

\NormalTok{stringBox}\OperatorTok{.}\NormalTok{setValue}\OperatorTok{(}\StringTok{"Hello, World!"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{5}}
\BuiltInTok{std::}\NormalTok{string str }\OperatorTok{=}\NormalTok{ stringBox}\OperatorTok{.}\NormalTok{getValue}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{6}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Creazione di un'istanza di \texttt{Box} con tipo \texttt{int}, chiamata
\texttt{intBox}.
\item[\circled{2}]
Chiamata del metodo \texttt{setValue} per impostare il valore di
\texttt{intBox} a \texttt{123}.
\item[\circled{3}]
Chiamata del metodo \texttt{getValue} per ottenere il valore di
\texttt{intBox} e assegnarlo alla variabile \texttt{x} di tipo
\texttt{int}.
\item[\circled{4}]
Creazione di un'istanza di \texttt{Box} con tipo \texttt{std::string},
chiamata \texttt{stringBox}.
\item[\circled{5}]
Chiamata del metodo \texttt{setValue} per impostare il valore di
\texttt{stringBox} a \texttt{"Hello,\ World!"}.
\item[\circled{6}]
Chiamata del metodo \texttt{getValue} per ottenere il valore di
\texttt{stringBox} e assegnarlo alla variabile \texttt{str} di tipo
\texttt{std::string}.
\end{description}

Anche nei linguaggi non orientati agli oggetti, i template trovano
applicazione. Ad esempio, in Rust, un linguaggio di programmazione
sistemistica non puramente OOP, il codice seguente restituisce il valore
più grande di una lista:

\phantomsection\label{annotated-cell-10}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}\NormalTok{ largest}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{:} \BuiltInTok{PartialOrd}\OperatorTok{\textgreater{}}\NormalTok{(list}\OperatorTok{:} \OperatorTok{\&}\NormalTok{[T]) }\OperatorTok{{-}\textgreater{}} \OperatorTok{\&}\NormalTok{T }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
    \KeywordTok{let} \KeywordTok{mut}\NormalTok{ largest }\OperatorTok{=} \OperatorTok{\&}\NormalTok{list[}\DecValTok{0}\NormalTok{]}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}

    \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ list }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{3}}
        \ControlFlowTok{if}\NormalTok{ item }\OperatorTok{\textgreater{}}\NormalTok{ largest }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{4}}
\NormalTok{            largest }\OperatorTok{=}\NormalTok{ item}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{5}}
        \OperatorTok{\}}
    \OperatorTok{\}}
\NormalTok{    largest }\hspace*{\fill}\NormalTok{\circled{6}}
\OperatorTok{\}}

\KeywordTok{fn}\NormalTok{ main() }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{7}}
    \KeywordTok{let}\NormalTok{ numbers }\OperatorTok{=} \PreprocessorTok{vec!}\NormalTok{[}\DecValTok{34}\OperatorTok{,} \DecValTok{50}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{100}\OperatorTok{,} \DecValTok{65}\NormalTok{]}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{8}}
    \KeywordTok{let}\NormalTok{ max }\OperatorTok{=}\NormalTok{ largest(}\OperatorTok{\&}\NormalTok{numbers)}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{9}}

    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"The largest number is \{\}"}\OperatorTok{,}\NormalTok{ max)}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{10}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione della funzione generica \texttt{largest} che accetta una
lista di riferimenti a un tipo \texttt{T} che implementa il tratto
\texttt{PartialOrd} e restituisce un riferimento a un valore di tipo
\texttt{T}.
\item[\circled{2}]
Inizializzazione della variabile \texttt{largest} con il primo elemento
della lista.
\item[\circled{3}]
Iterazione attraverso ogni elemento della lista.
\item[\circled{4}]
Controllo se l'elemento corrente \texttt{item} è maggiore di
\texttt{largest}.
\item[\circled{5}]
Se \texttt{item} è maggiore, aggiornamento della variabile
\texttt{largest} con \texttt{item}.
\item[\circled{6}]
Restituzione di \texttt{largest}, che è il riferimento al più grande
elemento trovato nella lista.
\item[\circled{7}]
Definizione della funzione \texttt{main}, punto di ingresso del
programma.
\item[\circled{8}]
Creazione di un vettore di numeri interi \texttt{numbers}.
\item[\circled{9}]
Chiamata della funzione \texttt{largest} con un riferimento a
\texttt{numbers} e assegnazione del risultato a \texttt{max}.
\item[\circled{10}]
Stampa del valore più grande trovato nella lista usando la macro
\texttt{println!}.
\end{description}

\subsection{Metaprogrammazione}\label{metaprogrammazione}

La metaprogrammazione è un paradigma che consente al programma di
trattare il codice come dati, permettendo al codice di generare,
manipolare o eseguire altro codice. Anche questo concetto non è
esclusivo dell'OOP. In C++, la metaprogrammazione è strettamente legata
ai template. Un esempio classico è la template metaprogramming (TMP),
che permette di eseguire calcoli a tempo di compilazione.

Un esempio è il codice seguente di calcolo del fattoriale:

\phantomsection\label{annotated-cell-11}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{template}\OperatorTok{\textless{}}\DataTypeTok{int}\NormalTok{ N}\OperatorTok{\textgreater{}}
\KeywordTok{struct}\NormalTok{ Factorial }\OperatorTok{\{}
    \AttributeTok{static} \AttributeTok{const} \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=}\NormalTok{ N }\OperatorTok{*}\NormalTok{ Factorial}\OperatorTok{\textless{}}\NormalTok{N }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{\textgreater{}::}\NormalTok{value}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\OperatorTok{\};}

\KeywordTok{template}\OperatorTok{\textless{}\textgreater{}}
\KeywordTok{struct}\NormalTok{ Factorial}\OperatorTok{\textless{}}\DecValTok{0}\OperatorTok{\textgreater{}} \OperatorTok{\{}
    \AttributeTok{static} \AttributeTok{const} \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Questa riga definisce un membro statico \texttt{value} della struttura
\texttt{Factorial}. Per un dato \texttt{N}, il valore viene calcolato
come \texttt{N} moltiplicato per il valore del fattoriale di
\texttt{N\ -\ 1}. Questo è un esempio di ricorsione a livello di
metaprogrammazione template.
\item[\circled{2}]
Questa riga è una specializzazione del template \texttt{Factorial} per
il caso base quando \texttt{N} è 0. In questo caso, \texttt{value} è
definito come \texttt{1}, terminando la ricorsione template.
\end{description}

La metaprogrammazione è presente anche in linguaggi non OOP come Lisp,
che utilizza le macro per trasformare e generare codice. Un esempio è il
codice proposto di seguito dove è definita la macro \texttt{when}, che
prende due parametri in input, cioè \texttt{test} e \texttt{body}, ove
\texttt{test} è un'espressione condizionale e \texttt{body} un insieme
di istruzioni da eeseguire se la condizione è vera:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{defmacro}\FunctionTok{ when }\NormalTok{(test \&}\KeywordTok{rest}\NormalTok{ body)  }
\NormalTok{  \textasciigrave{}(}\KeywordTok{if}\NormalTok{ ,test                      }
\NormalTok{       (}\KeywordTok{progn}\NormalTok{ ,@body)))           }
\end{Highlighting}
\end{Shaded}

Commento riga per riga:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Definizione di una macro chiamata \texttt{when}, che accetta un
  \texttt{test} e un numero variabile di espressioni (\texttt{body}).
\item
  La macro espande in un'espressione \texttt{if} che valuta
  \texttt{test}. Se \texttt{test} è vero, esegue le espressioni
  contenute in \texttt{body}.
\item
  \texttt{progn} è utilizzato per racchiudere ed eseguire tutte le
  espressioni in \texttt{body} in sequenza. L'operatore \texttt{,@} è
  usato per spalmare gli elementi di \texttt{body} nell'espressione
  \texttt{progn}.
\end{enumerate}

Vediamo un esempio pratico di come si utilizza la macro \texttt{when}.
Il test è valutare se \texttt{x} è maggiore di \texttt{10} e, nel caso,
stampare \texttt{"x\ is\ greater\ than\ 10"} e poi assegnare \texttt{x}
a \texttt{0}. Chiamiamo la macro con i due parametri:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{when}\NormalTok{ (}\OperatorTok{\textgreater{}}\NormalTok{ x }\DecValTok{10}\NormalTok{)                      }
\NormalTok{  (}\KeywordTok{print} \StringTok{"x is greater than 10"}\NormalTok{)     }
\NormalTok{  (}\KeywordTok{setf}\NormalTok{ x }\DecValTok{0}\NormalTok{))                        }
\end{Highlighting}
\end{Shaded}

Commento riga per riga:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Invocazione della macro \texttt{when} con la condizione
  \texttt{\textgreater{}\ x\ 10}.
\item
  Se la condizione è vera, viene eseguita l'istruzione
  \texttt{(print\ "x\ is\ greater\ than\ 10")}, che stampa il messaggio.
\item
  Successivamente, viene eseguita l'istruzione \texttt{(setf\ x\ 0)},
  che assegna il valore \texttt{0} a \texttt{x}.
\end{enumerate}

Questo viene espanso in:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{if}\NormalTok{ (}\OperatorTok{\textgreater{}}\NormalTok{ x }\DecValTok{10}\NormalTok{)                        }
\NormalTok{    (}\KeywordTok{progn}                        
\NormalTok{      (}\KeywordTok{print} \StringTok{"x is greater than 10"}\NormalTok{) }
\NormalTok{      (}\KeywordTok{setf}\NormalTok{ x }\DecValTok{0}\NormalTok{)))                   }
\end{Highlighting}
\end{Shaded}

Commento riga per riga:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  L'istruzione \texttt{if} valuta la condizione
  \texttt{\textgreater{}\ x\ 10}.
\item
  Se la condizione è vera, viene eseguito il blocco \texttt{progn}.
\item
  All'interno del blocco \texttt{progn}, viene eseguita l'istruzione
  \texttt{(print\ "x\ is\ greater\ than\ 10")}.
\item
  Infine, viene eseguita l'istruzione \texttt{(setf\ x\ 0)} all'interno
  del blocco \texttt{progn}.
\end{enumerate}

\section{Paradigma dichiarativo}\label{paradigma-dichiarativo}

La \textbf{programmazione dichiarativa} è un paradigma di programmazione
che si focalizza sul \emph{cosa} deve essere calcolato piuttosto che sul
\emph{come} calcolarlo. In altre parole, i programmi dichiarativi
descrivono il risultato desiderato senza specificare esplicitamente i
passaggi per ottenerlo. Questo è in netto contrasto con la
programmazione imperativa, dove si fornisce una sequenza dettagliata di
istruzioni per modificare lo stato del programma.

La programmazione dichiarativa ha radici nella logica e nella
matematica, ed è emersa come un importante paradigma negli anni '70 e
'80 con l'avvento di linguaggi come Prolog (per la programmazione
logica) e SQL (per la gestione dei database). La programmazione
funzionale, con linguaggi come Haskell, è anch'essa una forma di
programmazione dichiarativa.

I concetti principali associati alla programazione dichiarativa sono:

\begin{itemize}
\item
  Descrizione del risultato: I programmi dichiarativi descrivono le
  proprietà del risultato desiderato senza specificare l'algoritmo per
  ottenerlo. Esempio: In SQL, per ottenere tutti i record di una tabella
  con un certo valore, si scrive una query che descrive la condizione,
  non un algoritmo che scorre i record uno per uno.
\item
  Assenza di stato esplicito: La programmazione dichiarativa evita l'uso
  esplicito di variabili di stato e di aggiornamenti di stato. Ciò
  riduce i rischi di effetti collaterali e rende il codice più facile da
  comprendere e verificare.
\item
  Idempotenza: Le espressioni dichiarative sono spesso idempotenti, cioè
  possono essere eseguite più volte senza cambiare il risultato. Questo
  è particolarmente utile per la concorrenza e la parallelizzazione.
\end{itemize}

Il vantaggio principale è relativo alla sua chiarezza perché ci si
concentra sul risultato desiderato piuttosto che sui dettagli di
implementazione.

La programmazione imperativa specifica come ottenere un risultato
mediante una sequenza di istruzioni, modificando lo stato del programma.
La programmazione dichiarativa, al contrario, specifica cosa deve essere
ottenuto senza descrivere i dettagli di implementazione. In termini di
livello di astrazione, la programmazione dichiarativa si trova a un
livello superiore rispetto a quella imperativa.

\subsection{Linguaggi}\label{linguaggi}

Ecco una lista di alcuni linguaggi di programmazione dichiarativi:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  SQL (Structured Query Language): Utilizzato per la gestione e
  l'interrogazione di database relazionali.
\item
  Prolog: Un linguaggio di programmazione logica usato principalmente
  per applicazioni di intelligenza artificiale e linguistica
  computazionale.
\item
  HTML (HyperText Markup Language): Utilizzato per creare e strutturare
  pagine web.
\item
  CSS (Cascading Style Sheets): Utilizzato per descrivere la
  presentazione delle pagine web scritte in HTML o XML.
\item
  XSLT (Extensible Stylesheet Language Transformations): Un linguaggio
  per trasformare documenti XML in altri formati.
\item
  Haskell: Un linguaggio funzionale che è anche dichiarativo, noto per
  la sua pura implementazione della programmazione funzionale.
\item
  Erlang: Un linguaggio utilizzato per sistemi concorrenti e
  distribuiti, con caratteristiche dichiarative.
\item
  VHDL (VHSIC Hardware Description Language): Utilizzato per descrivere
  il comportamento e la struttura di sistemi digitali.
\item
  Verilog: Un altro linguaggio di descrizione hardware usato per la
  modellazione di sistemi elettronici.
\item
  XQuery: Un linguaggio di query per interrogare documenti XML.
\end{enumerate}

Questi linguaggi rappresentano diversi ambiti di applicazione, dai
database alla descrizione hardware, e sono accomunati dall'approccio
dichiarativo nel quale si specifica cosa ottenere piuttosto che come
ottenerlo.

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-note-color!10!white, colback=white, colframe=quarto-callout-note-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Nota}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

SQL è uno degli esempi più diffusi di linguaggio di programmazione
dichiarativo. Le query SQL descrivono i risultati desiderati piuttosto
che le procedure operative.

Una stored procedure in PL/SQL (Procedural Language/SQL) combina SQL con
elementi di linguaggi di programmazione procedurali come blocchi di
codice, condizioni e cicli. PL/SQL è quindi un linguaggio procedurale,
poiché consente di specificare ``come'' ottenere i risultati attraverso
un flusso di controllo esplicito, rendendolo non puramente dichiarativo.
PL/SQL è utilizzato principalmente con il database Oracle.

Un'alternativa a PL/SQL è T-SQL (Transact-SQL), utilizzato con Microsoft
SQL Server e Sybase ASE. Anche T-SQL estende SQL con funzionalità
procedurali simili, consentendo la scrittura di istruzioni condizionali,
cicli e la gestione delle transazioni. Come PL/SQL, T-SQL è un
linguaggio procedurale e non puramente dichiarativo.

Esistono anche estensioni ad oggetti come il PL/pgSQL (Procedural
Language/PostgreSQL) per il database PostgreSQL.

\end{tcolorbox}

\subsection{Esempi}\label{esempi}

Esempio di una query SQL che estrae tutti i nomi degli utenti con età
maggiore di 30:

Certamente! Ecco il codice SQL con i commenti identificati da un ID
progressivo e l'elenco esplicativo:

\phantomsection\label{annotated-cell-15}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SELECT}\NormalTok{ nome }\hspace*{\fill}\NormalTok{\circled{1}}
\KeywordTok{FROM}\NormalTok{ utenti }\hspace*{\fill}\NormalTok{\circled{2}}
\KeywordTok{WHERE}\NormalTok{ età }\OperatorTok{\textgreater{}} \DecValTok{30}\NormalTok{; }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Seleziona la colonna \texttt{nome}.
\item[\circled{2}]
Dalla tabella \texttt{utenti}.
\item[\circled{3}]
Per le righe dove la colonna \texttt{età} è maggiore di 30.
\end{description}

In Prolog, si definiscono fatti e regole che descrivono relazioni
logiche. Il motore di inferenza di Prolog utilizza queste definizioni
per risolvere query, senza richiedere un algoritmo dettagliato. Di
seguito, sono definiti due fatti (le prime due righe) e due regole (la
terza e la quarta) e quindi si effettua una query che dà come risultato
\texttt{true}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{genitore(padre}\KeywordTok{,}\NormalTok{ figlio)}\KeywordTok{.} 
\NormalTok{genitore(madre}\KeywordTok{,}\NormalTok{ figlio)}\KeywordTok{.}  
\NormalTok{antenato(}\DataTypeTok{X}\KeywordTok{,} \DataTypeTok{Y}\NormalTok{) }\KeywordTok{:{-}}\NormalTok{ genitore(}\DataTypeTok{X}\KeywordTok{,} \DataTypeTok{Y}\NormalTok{)}\KeywordTok{.}  
\NormalTok{antenato(}\DataTypeTok{X}\KeywordTok{,} \DataTypeTok{Y}\NormalTok{) }\KeywordTok{:{-}}\NormalTok{ genitore(}\DataTypeTok{X}\KeywordTok{,} \DataTypeTok{Z}\NormalTok{)}\KeywordTok{,}\NormalTok{ antenato(}\DataTypeTok{Z}\KeywordTok{,} \DataTypeTok{Y}\NormalTok{)}\KeywordTok{.}  

\FunctionTok{?{-}}\NormalTok{ antenato(padre}\KeywordTok{,}\NormalTok{ figlio)}\KeywordTok{.} 
\end{Highlighting}
\end{Shaded}

Commento riga per riga:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Questa regola dichiara che \texttt{padre} è genitore di
  \texttt{figlio}.
\item
  Questa regola dichiara che \texttt{madre} è genitore di
  \texttt{figlio}.
\item
  Questa regola stabilisce che \texttt{X} è antenato di \texttt{Y} se
  \texttt{X} è genitore di \texttt{Y}.
\item
  Questa regola stabilisce che \texttt{X} è antenato di \texttt{Y} se
  \texttt{X} è genitore di \texttt{Z} e \texttt{Z} è antenato di
  \texttt{Y}.
\item
  Riga vuota.
\item
  Questa è una query che chiede se \texttt{padre} è un antenato di
  \texttt{figlio}.
\end{enumerate}

\section{Paradigma funzionale}\label{paradigma-funzionale}

La \textbf{programmazione funzionale} è un paradigma di programmazione
che tratta il calcolo come la valutazione di funzioni matematiche ed
evita lo stato mutabile e i dati modificabili. I programmi funzionali
sono costruiti applicando e componendo funzioni. Questo paradigma è
stato ispirato dal calcolo lambda, una formalizzazione matematica del
concetto di funzione. La programmazione funzionale è un paradigma
alternativo alla programmazione imperativa, che descrive la computazione
come una sequenza di istruzioni che modificano lo stato del programma.

La programmazione funzionale ha radici storiche che risalgono agli anni
'30, con il lavoro di Alonzo Church sul calcolo lambda. I linguaggi di
programmazione funzionale hanno iniziato a svilupparsi negli anni '50 e
'60 con Lisp, ma è stato negli anni '70 e '80 che linguaggi come ML e
Haskell hanno consolidato questo paradigma. Haskell, in particolare, è
stato progettato per esplorare nuove idee in programmazione funzionale e
ha avuto un impatto significativo sulla ricerca e sulla pratica del
software.

La programmazione funzionale è una forma di programmazione dichiarativa
che si basa su funzioni pure e immutabilità. Entrambi i paradigmi
evitano stati mutabili e si concentrano sul risultato finale, ma la
programmazione funzionale utilizza funzioni matematiche come unità
fondamentali di calcolo.

Concetti fondamentali:

\begin{itemize}
\item
  Immutabilità: I dati sono immutabili, il che significa che una volta
  creati non possono essere modificati. Questo riduce il rischio di
  effetti collaterali e rende il codice più prevedibile.
\item
  Funzioni di prima classe e di ordine superiore: Le funzioni possono
  essere passate come argomenti a altre funzioni, ritornate da funzioni,
  e assegnate a variabili. Le funzioni di ordine superiore accettano
  altre funzioni come argomenti o restituiscono funzioni.
\item
  Purezza: Le funzioni pure sono funzioni che, dato lo stesso input,
  restituiscono sempre lo stesso output e non causano effetti
  collaterali. Questo rende il comportamento del programma più facile da
  comprendere e prevedere.
\item
  Trasparenza referenziale: Un'espressione è trasparentemente
  referenziale se può essere sostituita dal suo valore senza cambiare il
  comportamento del programma. Questo facilita l'ottimizzazione e il
  reasonig sul codice.
\item
  Ricorsione: È spesso utilizzata al posto di loop iterativi per
  eseguire ripetizioni, poiché si adatta meglio alla natura immutabile
  dei dati e alla definizione di funzioni.
\item
  Composizione di funzioni: Consente di costruire funzioni complesse
  combinando funzioni più semplici. Questo favorisce la modularità e la
  riusabilità del codice.
\end{itemize}

Il paradigma funzionale ha diversi vantaggi:

\begin{itemize}
\item
  Prevedibilità e facilità di test: Le funzioni pure e l'immutabilità
  rendono il codice più prevedibile e più facile da testare, poiché non
  ci sono stati mutabili o effetti collaterali nascosti.
\item
  Concorrenza: La programmazione funzionale è ben adatta alla
  programmazione concorrente e parallela, poiché l'assenza di stato
  mutabile riduce i problemi di sincronizzazione e competizione per le
  risorse.
\item
  Modularità e riutilizzabilità: La composizione di funzioni e la
  trasparenza referenziale facilitano la creazione di codice modulare e
  riutilizzabile.
\end{itemize}

E qualche svantaggio:

\begin{itemize}
\item
  Curva di apprendimento: La programmazione funzionale può essere
  difficile da apprendere per chi proviene da paradigmi imperativi o
  orientati agli oggetti, a causa dei concetti matematici sottostanti e
  della diversa mentalità necessaria.
\item
  Prestazioni: In alcuni casi, l'uso intensivo di funzioni ricorsive può
  portare a problemi di prestazioni, come il consumo di memoria per le
  chiamate ricorsive. Tuttavia, molte implementazioni moderne offrono
  ottimizzazioni come la ricorsione di coda (in inglese, \emph{tail
  recursion}).
\item
  Disponibilità di librerie e strumenti: Alcuni linguaggi funzionali
  potrebbero non avere la stessa ampiezza di librerie e strumenti
  disponibili rispetto ai linguaggi imperativi più diffusi.
\end{itemize}

\subsection{Linguaggi}\label{linguaggi-1}

Oltre a Haskell, ci sono molti altri linguaggi funzionali, tra cui:

\begin{itemize}
\item
  Erlang: Utilizzato per sistemi concorrenti e distribuiti.
\item
  Elixir: Costruito a partire da Erlang, è utilizzato per applicazioni
  web scalabili.
\item
  F\#: Parte della piattaforma .NET, combina la programmazione
  funzionale con lo OOP.
\item
  Scala: Anch'esso combina programmazione funzionale e orientata agli
  oggetti ed è interoperabile con Java.
\item
  OCaml: Conosciuto per le sue prestazioni e sintassi espressiva.
\item
  Lisp: Uno dei linguaggi più antichi, multi-paradigma con forti
  influenze funzionali.
\item
  Clojure: Dialetto di Lisp per la JVM, adatto alla concorrenza.
\item
  Scheme: Dialetto di Lisp spesso usato nell'educazione.
\item
  ML: Linguaggio influente che ha portato allo sviluppo di OCaml e F\#.
\item
  Racket: Derivato da Scheme, usato nella ricerca accademica.
\end{itemize}

\subsection{Esempio in Haskell}\label{esempio-in-haskell}

Di seguito due funzioni, la prima \texttt{sumToN} è pura e somma i primi
\texttt{n} numeri. \texttt{(*2)} è una funzione che prende un argomento
e lo moltiplica per 2 e ciò rende la seconda funzione
\texttt{applyFunction} una vera funzione di ordine superiore, poiché
accetta \texttt{(*2)} come argomento oltre ad una lista, producendo come
risultato il raddoppio di tutti i suoi elementi:

Certamente! Ecco il codice con i commenti identificati da un ID
progressivo e l'elenco esplicativo che include le descrizioni:

\phantomsection\label{annotated-cell-17}%
\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sumToN ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\NormalTok{sumToN n }\OtherTok{=} \FunctionTok{sum}\NormalTok{ [}\DecValTok{1}\OperatorTok{..}\NormalTok{n] }\hspace*{\fill}\NormalTok{\circled{1}}

\OtherTok{applyFunction ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [b]}
\NormalTok{applyFunction f lst }\OtherTok{=} \FunctionTok{map}\NormalTok{ f lst }\hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{print}\NormalTok{ (sumToN }\DecValTok{10}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{3}}
    \FunctionTok{print}\NormalTok{ (applyFunction (}\OperatorTok{*}\DecValTok{2}\NormalTok{) [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]) }\hspace*{\fill}\NormalTok{\circled{4}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione di una funzione pura che calcola la somma dei numeri da 1 a
\texttt{n}.
\item[\circled{2}]
Funzione di ordine superiore che accetta una funzione e una lista.
\item[\circled{3}]
Nel \texttt{main}, stampa il risultato di \texttt{sumToN\ 10}, che è 55.
\item[\circled{4}]
Nel \texttt{main}, stampa il risultato di
\texttt{applyFunction\ (*2)\ {[}1,\ 2,\ 3,\ 4{]}}, che è
\texttt{{[}2,\ 4,\ 6,\ 8{]}}.
\end{description}

\chapter{Sintassi dei linguaggi di
programmazione}\label{sintassi-dei-linguaggi-di-programmazione}

Abbiamo visto come i linguaggi di programmazione siano degli insiemi di
regole formali con cui si scrivono programmi eseguibili da computer. I
linguaggio di programmazione ha due componenti principali: la
\textbf{sintassi} e la \textbf{semantica}.

Partiamo dalla \textbf{sintassi} di un linguaggio di programmazione che
possiamo considerare come l'insieme di regole che definisce la struttura
e la forma delle istruzioni, cioè le unità logiche di esecuzione del
programma. È come la grammatica in una lingua naturale e stabilisce
quali combinazioni di simboli sono considerate costrutti validi nel
linguaggio.

Per esempio, la sintassi determina quali parole chiave, operatori,
separatori e altri elementi sono ammessi e in quale ordine devono
apparire. Una sintassi corretta è fondamentale per garantire che il
programma sia privo di errori formali e possa essere eseguito senza
problemi.

L'importanza della comprensione della sintassi è simile alla buona
conoscenza per un linguaggio naturale:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Leggibilità del codice: Una corretta comprensione della sintassi
  permette di scrivere codice più chiaro e comprensibile agli altri
  programmatori. Una buona formattazione e organizzazione del codice
  facilita la manutenzione e la collaborazione su progetti di
  programmazione.
\item
  Efficienza nella risoluzione dei problemi: Conoscere bene la sintassi
  del linguaggio aiuta a trovare soluzioni efficienti ai problemi,
  poiché si è consapevoli delle strutture e delle funzionalità native
  del linguaggio che possono essere utilizzate per risolvere determinati
  compiti.
\item
  Sviluppo di codice robusto e sicuro: Una comprensione approfondita
  della sintassi aiuta a scrivere codice più robusto e sicuro, riducendo
  il rischio di bug e vulnerabilità nel software.
\item
  Adattabilità a nuovi contesti e tecnologie: Con una solida conoscenza
  della sintassi di base, è più facile imparare nuovi concetti,
  framework e librerie nel linguaggio di programmazione, consentendoci
  di sfruttare il lavoro e l'innovazione prodotta da altri.
\item
  Possibilità di esplorazione creativa: Capire la sintassi di un
  linguaggio offre la flessibilità necessaria per sperimentare e
  innovare, consentendo ai programmatori di creare soluzioni originali e
  creative ai problemi.
\end{enumerate}

\section{Token}\label{token}

Gli elementi atomici della sintassi sono i \textbf{token}. Essi
compongono tutte le istruzioni e possono essere sia prodotti dal
programmatore che generati dall'analisi del testo da parte
dell'interprete o compilatore. La comprensione di quali token siano
validi, ci permette sia di scrivere istruzioni corrette, sia di
sfruttare appieno i costrutti del linguaggio:

\begin{itemize}
\item
  Parole chiave: Sono termini riservati del linguaggio che hanno
  significati specifici e non possono essere utilizzati per altri scopi,
  come \texttt{if}, \texttt{else}, \texttt{while}, \texttt{for}, ecc.
\item
  Operatori: Simboli utilizzati per eseguire operazioni su
  identificatori e letterali, come \texttt{+}, \texttt{-}, \texttt{*},
  \texttt{/}, \texttt{=}, \texttt{==}, ecc.
\item
  Delimitatori: Caratteri utilizzati per separare elementi del codice,
  come punto e virgola (\texttt{;}), parentesi tonde (\texttt{()}),
  parentesi quadre (\texttt{{[}{]}}), parentesi graffe (\texttt{\{\}}),
  ecc.
\item
  Identificatori: Nomi utilizzati per identificare variabili, funzioni,
  classi, e altri oggetti.
\item
  Letterali: Rappresentazioni di valori costanti nel codice, come numeri
  (\texttt{123}), stringhe (\texttt{"hello"}), caratteri
  (\texttt{\textquotesingle{}a\textquotesingle{}}), ecc.
\item
  Commento: Non fanno parte della logica del programma e sono ignorati
  nell'esecuzione.
\item
  Spazi e tabulazioni: Sono gruppi di caratteri non visualizzabili e
  spesso ignorati.
\end{itemize}

Un \textbf{lessema} è una sequenza di caratteri nel programma sorgente
che corrisponde al pattern di un token ed è identificata
dall'\textbf{analizzatore lessicale} come un'istanza di quel token. Un
\textbf{token} è una coppia composta da un nome di token e un valore
attributo opzionale. Il nome del token è un simbolo astratto che
rappresenta un tipo di unità lessicale, come una particolare parola
chiave o una sequenza di caratteri di input che denota un
identificatore. Un \textbf{pattern} è una descrizione della forma che
possono assumere i lessemi di un token. Ad esempio, nel caso di una
parola chiave come token, il pattern è semplicemente la sequenza di
caratteri che forma la parola chiave. Per gli identificatori e altri
token, il pattern è una struttura più complessa che corrisponde a molte
stringhe.

Un esempio per visualizzare i concetti introdotti:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{10}\NormalTok{:}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  Token coinvolti:

  \begin{itemize}
  \tightlist
  \item
    \texttt{if}: Parola chiave.
  \item
    \texttt{NAME}: Identificatore.
  \item
    \texttt{EQEQUAL}: Operatore.
  \item
    \texttt{NUMBER}: Letterale numerico.
  \item
    \texttt{COLON}: Delimitatore.
  \end{itemize}
\item
  Lessemi:

  \begin{itemize}
  \tightlist
  \item
    Il lessema per il token \texttt{if} è la sequenza di caratteri
    ``if''.
  \item
    Il lessema per il token \texttt{NAME} è ``x''.
  \item
    Il lessema per il token \texttt{EQEQUAL} è ``==''.
  \item
    Il lessema per il token \texttt{NUMBER} ``10''.
  \item
    Il lessema per il token \texttt{COLON} ``:''.
  \end{itemize}
\item
  Pattern:

  \begin{itemize}
  \tightlist
  \item
    Il pattern per il token \texttt{if} è la stringa esatta ``if''.
  \item
    Il pattern per un identificatore è una sequenza di lettere e numeri
    che inizia con una lettera.
  \item
    Il pattern per l'operatore \texttt{==} è la stringa esatta ``==''.
  \item
    Il pattern per un letterale numerico è una sequenza di cifre.
  \item
    Il pattern per il delimitatore \texttt{:} è la stringa esatta ``:''.
  \end{itemize}
\end{itemize}

\section{Analizzatore lessicale e
parser}\label{analizzatore-lessicale-e-parser}

L'\textbf{analizzatore lessicale} (o \emph{lexer}) è un componente del
compilatore o interprete che prende in input il codice sorgente del
programma e lo divide in lessemi. Esso confronta ciascun lessema con i
pattern definiti per il linguaggio di programmazione e genera una
sequenza di token. Questi token sono poi passati al parser.

Ad esempio, il codice \texttt{if\ x\ ==\ 10:} viene trasformato in una
sequenza di token:
\texttt{{[}IF,\ NAME(x),\ EQEQUAL,\ NUMBER(10),\ COLON{]}}.

Il \textbf{parser} è un altro componente del compilatore o interprete
che prende in input la sequenza di token generata dall'analizzatore
lessicale e verifica che la sequenza rispetti le regole sintattiche del
linguaggio di programmazione. Il parser analizza i token per formare una
struttura gerarchica che rappresenti le relazioni grammaticali tra di
essi. Questa struttura interna è spesso un albero di sintassi
(\emph{parse tree} o \emph{syntax tree}), che riflette la struttura
grammaticale del codice sorgente, solitamente descritta usando una forma
standard di notazione come la BNF (Backus-Naur Form) o varianti di essa
\footnote{La BNF (Backus-Naur form o Backus normal form) è una
  metasintassi, ovvero un formalismo attraverso cui è possibile
  descrivere la sintassi di linguaggi formali (il prefisso meta ha
  proprio a che vedere con la natura circolare di questa definizione).
  Si tratta di uno strumento molto usato per descrivere in modo preciso
  e non ambiguo la sintassi dei linguaggi di programmazione, dei
  protocolli di rete e così via, benché non manchino in letteratura
  esempi di sue applicazioni a contesti anche non informatici e
  addirittura non tecnologici. Un esempio è la grammatica di
  \href{https://docs.python.org/3/reference/grammar.html}{Python}.}.
L'albero di sintassi ottenuto viene utilizzato per le successive fasi di
compilazione o interpretazione, come quella di analisi semantica e di
generazione del codice eseguibile. Ad esempio, il parser può verificare
che le espressioni aritmetiche siano ben formate, che le istruzioni
siano correttamente annidate e che le dichiarazioni di variabili siano
valide.

\section{Espressioni}\label{espressioni}

Un'espressione è una combinazione di lessemi che viene valutata per
produrre un risultato. Le espressioni sono fondamentali nei linguaggi di
programmazione perché permettono di eseguire calcoli, prendere decisioni
e manipolare dati.

Ecco alcune tipologie di espressioni (notazioni in Python, ma non molto
dissimili da altri linguaggi):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Espressioni aritmetiche: Combinano letterali numerici, identificatori
  valorizzabili in numeri e operatori aritmetici per eseguire calcoli
  matematici. Esempi: \texttt{5\ +\ 3}, \texttt{y\ /\ 4.0},
  \texttt{"Hello,\ "\ +\ "world!"}.
\item
  Espressioni logiche: Applicano operatori logici per valutare
  condizioni e produrre valori booleani (vero o falso) a letterali e
  identificatori. Esempi: \texttt{x\ or\ 5}, \texttt{not\ y},
  \texttt{a\ and\ b}.
\item
  Espressioni di confronto: Confrontano due valori usando operatori di
  confronto e restituiscono valori booleani, sempre a partire da
  letterali e identificatori. Esempi: \texttt{x\ \textless{}\ y},
  \texttt{x\ !=\ 42}, \texttt{a\ \textgreater{}=\ b}.
\item
  Espressioni di chiamata a funzione: Invocano identificatori
  particolari, funzioni e metodi di oggetti, spesso con parametri
  definiti da identificatori e letterali, per eseguire operazioni più
  complesse. Esempi: \texttt{max(a,\ b)}, \texttt{sin(theta)},
  \texttt{my\_function(x,\ 42)}.
\item
  Espressioni di manipolazione di contenitori di dati: Creano e
  manipolano strutture dati come liste, dizionari, tuple e insiemi
  contenenti identificatori e letterali. Esempi:
  \texttt{{[}1,\ x,\ 3{]}},
  \texttt{\{\ \textquotesingle{}key\textquotesingle{}:\ \textquotesingle{}value\textquotesingle{}\ \}},
  \texttt{(\ \textquotesingle{}y\textquotesingle{},\ 42\ )}
\item
  Espressioni condizionali (ternarie): Valutano espressioni e
  restituiscono un valore basato sul risultato. Esempi:
  \texttt{x\ if\ x\ \textgreater{}\ y\ else\ y},
  \texttt{\textquotesingle{}Even\textquotesingle{}\ if\ n\ \%\ 2\ ==\ 0\ else\ \textquotesingle{}Odd\textquotesingle{}}.
\end{enumerate}

Le espressioni si possono comporre in espressioni più complesse come
accade per quelle matematiche pur che siano rispettate le regole di
compatibilità tra operatori, identificatori e letterali; esempio
\texttt{(x\ \textless{}\ y)\ and\ sin(theta)}.

\section{Istruzioni semplici}\label{istruzioni-semplici}

Le \textbf{istruzioni semplici} sono operazioni atomiche secondo il
linguaggio e sono costituite da tutti i tipi di lessemi per compiere
operazioni di base. I linguaggi di programmazione presentano delle
istruzioni \emph{condivise} nel senso di fondamentali che hanno solo
minime differenze ed altre più particolari, perché dipendenti da
specificità dalla progettazione del linguaggio. Ciò potrebbe essere
anche solo questione di sintassi più che rappresentanti nuovi concetti.

Di seguito un elenco di istruzioni semplici, alcune standard cioè
presenti in tutti o la gran parte dei linguaggi considerati, altre
specifiche ma che mettono in evidenza aspetti rilevanti di
progettazione:

\begin{itemize}
\item
  Espressioni: È eseguibile dal compilatore o interprete, quindi, è una
  delle istruzioni semplici più importanti quando a sé stante, ma sono
  presenti anche all'interno di istruzioni semplici e composte. Alcuni
  esempi in vari linguaggi di somma di due identificatori:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{x\ +\ y}.
  \item
    In Java: \texttt{x\ +\ y;}.
  \item
    In C: \texttt{x\ +\ y;}.
  \item
    In C++: \texttt{x\ +\ y;}.
  \end{itemize}
\item
  Dichiarazione di variabili: La dichiarazione di una variabile
  introduce una nuova variabile nel programma e specifica il suo
  tipo\footnote{Spiegheremo il concetto di tipo a breve, per ora si può
    pensare ad esso come l'insieme dei possibili valori e operazioni che
    si possono effettuare su di essi.}. La dichiarazione non assegna
  necessariamente un valore iniziale alla variabile. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python la dichiarazione avviene automaticamente con
    l'assegnazione, anche se è possibile annotare il tipo di una
    variabile, ad esempio \texttt{x:\ int\ =\ 5}, anche se ciò non
    costringe il programmatore a utilizzare \texttt{x} on interi.
  \item
    In Java: \texttt{int\ x;}.
  \item
    In C: \texttt{int\ x;}.
  \item
    In C++: \texttt{int\ x;}.
  \end{itemize}
\item
  Assegnazione: Utilizza un operatore di assegnazione (ad esempio,
  \texttt{=}) per attribuire un valore rappresentato da un letterale,
  una espressione o un identificatore, ad un identificatore di
  variabile, che possiamo pensare come un nome simbolico rappresentante
  una posizione dove è memorizzato un valore. In alcuni linguaggi deve
  essere preceduta dalla dichiarazione. Esempio:

  \begin{itemize}
  \item
    In Python:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=}\NormalTok{ (x }\OperatorTok{*} \DecValTok{2}\NormalTok{) }\OperatorTok{+}\NormalTok{ (y }\OperatorTok{/} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    \begin{itemize}
    \tightlist
    \item
      \texttt{z}: Identificatore della variabile.
    \item
      \texttt{=}: Operatore di assegnazione.
    \item
      \texttt{(x\ *\ 2)}: Espressione che moltiplica \texttt{x} per
      \texttt{2}.
    \item
      \texttt{(y\ /\ 2)}: Espressione che divide \texttt{y} per
      \texttt{2}.
    \item
      \texttt{+}: Operatore aritmetico che somma i risultati delle due
      espressioni in una più complessa. L'esecuzione dell'istruzione
      produce un risultato valido solo se \texttt{x} e \texttt{y} sono
      associate a valori numerici e ciò perché non tutte le istruzioni
      sintatticamente corrette sono semanticamente corrette. D'altronde
      ciò non deve essere preso come regola, perché se \texttt{*} fosse
      un operatore che ripete quanto a sinistra un numero di volte
      definito dal valore di destra e \texttt{/} la divisione del valore
      di sinistra in parti di numero pari a quanto a destra, allora
      \texttt{x} e \texttt{y} potrebbero essere stringhe.
    \end{itemize}
  \item
    In Java: \texttt{z\ =\ (x\ *\ 2)\ +\ (y\ /\ 2);}.
  \item
    In C: \texttt{z\ =\ (x\ *\ 2)\ +\ (y\ /\ 2);}.
  \item
    In C++: \texttt{z\ =\ (x\ *\ 2)\ +\ (y\ /\ 2);}.
  \end{itemize}
\item
  Assegnazione aumentata: Combina un'operazione e un'assegnazione in
  un'unica istruzione. Esempi per una assegnazione di una variabile del
  valore ottenuto dalla somma di quello proprio con il numero intero 1:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{x\ +=\ 1} è come scrivere \texttt{x\ =\ x\ +\ 1}.
  \item
    In Java: \texttt{x\ +=\ 1;}.
  \item
    In C: \texttt{x\ +=\ 1;}.
  \item
    In C++: \texttt{x\ +=\ 1;}.
  \end{itemize}
\item
  Istruzioni di input/output: Sono espressioni particolari ma
  generalmente evidenziate perché permettono di interagire con l'utente
  o di produrre output, spesso con sintassi ad hoc. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{print("Hello,\ World!")}.
  \item
    In Java: \texttt{System.out.println("Hello,\ World!");}.
  \item
    In C: \texttt{printf("Hello,\ World!\textbackslash{}n");}.
  \item
    In C++:
    \texttt{std::cout\ \textless{}\textless{}\ "Hello,\ World!"\ \textless{}\textless{}\ std::endl;}.
  \end{itemize}
\item
  Istruzioni di controllo del flusso: Permettono di interrompere o
  continuare l'esecuzione di cicli o di saltare a una specifica
  etichetta nel codice. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{break}, \texttt{continue}.
  \item
    In Java: \texttt{break;}, \texttt{continue;}.
  \item
    In C: \texttt{break;}, \texttt{continue;}, \texttt{goto\ label;}.
  \item
    In C++: \texttt{break;}, \texttt{continue;}, \texttt{goto\ label;}.
  \end{itemize}
\item
  Gestione della vita degli oggetti: Include la creazione, l'utilizzo e
  la distruzione dei dati presenti nella memoria del computer. In alcuni
  linguaggi ciò è parzialmente o totalmente a carico del programmatore,
  mentre, all'altro estremo, è completamente gestito dal linguaggio.
  Esempi:

  \begin{itemize}
  \tightlist
  \item
    Creazione di oggetti:

    \begin{itemize}
    \tightlist
    \item
      In C++: \texttt{int*\ ptr\ =\ new\ int;}.
    \item
      In Java: \texttt{String\ str\ =\ new\ String("Hello,\ world!");}
    \item
      In Python: Non è presente una istruzione specifica giacché
      l'espressione \texttt{MyClass()} crea un oggetto di tipo
      \texttt{MyClass}.
    \item
      In C: La creazione di oggetti è spesso gestita manualmente
      attraverso l'allocazione di memoria dinamica con funzioni come
      \texttt{malloc}.
    \end{itemize}
  \item
    Distruzione di oggetti:

    \begin{itemize}
    \tightlist
    \item
      In Python: La gestione della memoria è automatica tramite il
      garbage collector.
    \item
      In Java: In Java, la gestione della memoria è affidata al garbage
      collector.
    \item
      In C++: \texttt{delete\ ptr;}.
    \item
      In C: \texttt{free(ptr);} (richiede
      \texttt{\#include\ \textless{}stdlib.h\textgreater{}}).
    \end{itemize}
  \item
    Eliminazione di variabili:

    \begin{itemize}
    \tightlist
    \item
      In Python: \texttt{del\ x}.
    \end{itemize}
  \end{itemize}
\item
  Ritorno di valori: Utilizzata all'interno di funzioni per restituire
  un valore. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{return\ x}.
  \item
    In Java: \texttt{return\ x;}.
  \item
    In C: \texttt{return\ x;}.
  \item
    In C++: \texttt{return\ x;}.
  \end{itemize}
\item
  Generazione di eccezioni: Utilizzata per generare e inviare
  un'eccezione, cioè una interruzione della sequenza ordinaria delle
  istruzione per segnalare una anomalia. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{raise\ ValueError("Invalid\ input")}.
  \item
    In Java:
    \texttt{throw\ new\ IllegalArgumentException("Invalid\ input");}.
  \item
    In C++: \texttt{throw\ std::invalid\_argument("Invalid\ input");}.
  \item
    In C: Non esiste un equivalente diretto, ma si possono utilizzare
    meccanismi come \texttt{setjmp} e \texttt{longjmp} per la gestione
    degli errori.
  \end{itemize}
\item
  Importazione di moduli: Permettono di importare moduli o parti di
  essi, cioè di utilizzare funzioni, classi, variabili e altri
  identificatori definiti in altri file o librerie. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{import\ math}, \texttt{from\ math\ import\ sqrt}
  \item
    In Java: \texttt{import\ java.util.List;}
  \item
    In C: \texttt{\#include\ \textless{}stdio.h\textgreater{}}
  \item
    In C++: \texttt{\#include\ \textless{}iostream\textgreater{}}
  \end{itemize}
\item
  Dichiarazioni globali e non locali: Permettono di dichiarare variabili
  che esistono nell'ambito globale o non locale. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python: \texttt{global\ x}, \texttt{nonlocal\ y}.
  \item
    In Java: Le variabili globali non sono supportate direttamente; si
    utilizzano campi statici delle classi.
  \item
    In C: Le variabili globali sono dichiarate al di fuori di qualsiasi
    funzione.
  \item
    In C++: Le variabili globali sono dichiarate al di fuori di
    qualsiasi funzione.
  \end{itemize}
\item
  Assert: Utilizzata per verificare se una condizione è vera e, in caso
  contrario, sollevare un'eccezione. Esempi:

  \begin{itemize}
  \tightlist
  \item
    In Python:
    \texttt{assert\ x\ \textgreater{}\ 0,\ "x\ deve\ essere\ positivo"}.
  \item
    In Java:
    \texttt{assert\ x\ \textgreater{}\ 0\ :\ "x\ deve\ essere\ positivo";}.
  \item
    In C: \texttt{assert(x\ \textgreater{}\ 0);} (richiede
    \texttt{\#include\ \textless{}assert.h\textgreater{}}).
  \item
    In C++: \texttt{assert(x\ \textgreater{}\ 0);} (richiede
    \texttt{\#include\ \textless{}cassert\textgreater{}}).
  \end{itemize}
\end{itemize}

\section{Istruzioni composte e blocchi di
codice}\label{istruzioni-composte-e-blocchi-di-codice}

Le \textbf{istruzioni composte} sono costituite da più istruzioni
semplici e possono includere strutture di controllo del flusso, come
condizioni (\texttt{if}), cicli (\texttt{for}, \texttt{while}) ed
eccezioni (\texttt{try}, \texttt{catch}). Queste istruzioni sono
utilizzate per organizzare il flusso di esecuzione del programma e
possono contenere altre istruzioni semplici o composte al loro interno.

Un \textbf{blocco di codice} è una sezione del codice che raggruppa una
serie di istruzioni che devono essere eseguite insieme. I blocchi di
codice sono spesso utilizzati all'interno delle istruzioni composte per
delimitare il gruppo di istruzioni che devono essere eseguite in
determinate condizioni o iterazioni.

In molti linguaggi di programmazione, i blocchi di codice sono
delimitati da parentesi graffe (\texttt{\{\}}), mentre in altri
linguaggi, come Python, l'indentazione è utilizzata per indicare
l'inizio e la fine di un blocco di codice.

Alcuni esempi di istruzione e blocco di codice:

\begin{itemize}
\item
  Esempio in C:

\phantomsection\label{annotated-cell-81}%
\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"x è positivo}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{  y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  In questo esempio:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{if\ (x\ \textgreater{}\ 0)} e quanto nelle parentesi graffe
    è un'istruzione composta. \texttt{if} è una parola chiave seguita da
    una espressione tra delimitatori.
  \item
    \texttt{\{\ printf("x\ è\ positivo\textbackslash{}n");\ y\ =\ x\ *\ 2;\ \}}
    è un blocco di codice che viene eseguito se la condizione
    dell'istruzione \texttt{if} è vera. Sono presenti diversi
    delimitatori, una espressione e una istruzione di assegnamento.
  \end{enumerate}
\item
  Esempio in Python:

\phantomsection\label{annotated-cell-82}%
\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{: }\hspace*{\fill}\NormalTok{\circled{1}}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{  y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

  In questo esempio:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{if\ x\ \textgreater{}\ 0:} è un'istruzione composta.
  \item
    Le righe indentate sotto l'istruzione \texttt{if}, cioè
    \texttt{print("x\ è\ positivo")} e \texttt{y\ =\ x\ *\ 2},
    costituiscono un blocco di codice che viene eseguito se la
    condizione dell'istruzione \texttt{if} è vera.
  \end{enumerate}
\end{itemize}

Alcuni esempi di istruzione e blocco di codice:

\begin{itemize}
\item
  Esempio in C:

\phantomsection\label{annotated-cell-83}%
\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"x è positivo}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  In questo esempio:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{if\ (x\ \textgreater{}\ 0)} e quanto nelle parentesi graffe
    è un'istruzione composta.
  \item
    \texttt{\{\ printf("x\ è\ positivo\textbackslash{}n");\ y\ =\ x\ *\ 2;\ \}}
    è un blocco di codice che viene eseguito se la condizione
    dell'istruzione \texttt{if} è vera.
  \end{enumerate}
\item
  Esempio in Python:

\phantomsection\label{annotated-cell-84}%
\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{: }\hspace*{\fill}\NormalTok{\circled{1}}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

  In questo esempio:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{if\ x\ \textgreater{}\ 0:} è un'istruzione composta.
  \item
    Le righe indentate sotto l'istruzione \texttt{if}
    (\texttt{print("x\ è\ positivo")} e \texttt{y\ =\ x\ *\ 2})
    costituiscono un blocco di codice che viene eseguito se la
    condizione dell'istruzione \texttt{if} è vera.
  \end{enumerate}
\end{itemize}

Di seguito sono elencate le istruzioni composte principali, con
spiegazioni e semplici esempi di sintassi per Python, Java, C e C++:

\begin{itemize}
\item
  Condizionali (\texttt{if}, \texttt{else\ if}, \texttt{else}): Le
  istruzioni condizionali permettono l'esecuzione di blocchi di codice
  basati su espressioni logiche.

  \begin{itemize}
  \item
    Python:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{)}

\ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"x è zero"}\NormalTok{)}

\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"x è negativo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
  \item
    Java:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"x è positivo"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"x è zero"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
  \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"x è negativo"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"x è positivo}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"x è zero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"x è negativo}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C++:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"x è positivo"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"x è zero"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"x è negativo"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\item
  Cicli (\texttt{for}): I cicli \texttt{for} permettono di iterare su un
  insieme di valori o di ripetere l'esecuzione di un blocco di codice
  per un numero specificato di volte.

  \begin{itemize}
  \item
    Python:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}
  \item
    Java:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
  \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C++:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ i }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\end{itemize}

Cicli (\texttt{while}): I cicli \texttt{while} ripetono l'esecuzione di
un blocco di codice finché una condizione specificata rimane vera.

\begin{itemize}
\item
  Python:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(x)}

\NormalTok{  x }\OperatorTok{{-}=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}
\item
  Java:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}

\NormalTok{  x}\OperatorTok{{-}{-};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  C:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}

\NormalTok{  x}\OperatorTok{{-}{-};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  C++:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ x }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}

\NormalTok{  x}\OperatorTok{{-}{-};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Gestione delle eccezioni (\texttt{try}, \texttt{catch}): Le istruzioni
  di gestione delle eccezioni permettono di gestire errori o condizioni
  anomale che possono verificarsi durante l'esecuzione del programma.

  \begin{itemize}
  \item
    Python:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  value }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{input}\NormalTok{(}\StringTok{"Inserisci un numero: "}\NormalTok{))}

\ControlFlowTok{except} \PreprocessorTok{ValueError}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Input non valido"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
  \item
    Java:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \BuiltInTok{Integer}\OperatorTok{.}\FunctionTok{parseInt}\OperatorTok{(}\NormalTok{input}\OperatorTok{);}

\OperatorTok{\}} \ControlFlowTok{catch} \OperatorTok{(}\BuiltInTok{NumberFormatException}\NormalTok{ e}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Input non valido"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C++:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \BuiltInTok{std::}\NormalTok{stoi}\OperatorTok{(}\NormalTok{input}\OperatorTok{);}

\OperatorTok{\}} \ControlFlowTok{catch} \OperatorTok{(}\AttributeTok{const} \BuiltInTok{std::}\NormalTok{invalid\_argument}\OperatorTok{\&}\NormalTok{ e}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Input non valido"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C: C non ha un supporto nativo per la gestione delle eccezioni, ma
    si possono usare meccanismi come \texttt{setjmp} e \texttt{longjmp}.

\phantomsection\label{annotated-cell-100}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}setjmp.h\textgreater{}}

\NormalTok{jmp\_buf buf}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\DataTypeTok{void}\NormalTok{ error}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  longjmp}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \DecValTok{1}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{setjmp}\OperatorTok{(}\NormalTok{buf}\OperatorTok{))} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{3}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Errore rilevato}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}

  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    error}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{5}}
  \OperatorTok{\}}
  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

    \begin{description}
    \tightlist
    \item[\circled{1}]
    Dichiarazione di una variabile di tipo \texttt{jmp\_buf}.
    \item[\circled{2}]
    Salta al punto salvato in buf con valore di ritorno 1.
    \item[\circled{3}]
    Salva il contesto di esecuzione attuale in \texttt{buf}.
    \item[\circled{4}]
    Esegue se \texttt{longjmp} viene chiamato.
    \item[\circled{5}]
    Chiama la funzione error, che salta indietro al punto
    \texttt{setjmp}.
    \end{description}
  \end{itemize}
\item
  Selezione multipla (\texttt{switch}, \texttt{case}, \texttt{default}):
  Le istruzioni di selezione multipla permettono di eseguire uno tra
  diversi blocchi di codice basati sul valore di un'espressione.

  \begin{itemize}
  \item
    Python (a partire da Python 3.10 con \texttt{match}):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{match}\NormalTok{ x:}
  \ControlFlowTok{case} \DecValTok{0}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x è zero"}\NormalTok{)}

  \ControlFlowTok{case} \DecValTok{1}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x è uno"}\NormalTok{)}

  \ControlFlowTok{case}\NormalTok{ \_:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x è un altro numero"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
  \item
    Java:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{x}\OperatorTok{)} \OperatorTok{\{}
  \ControlFlowTok{case} \DecValTok{0}\OperatorTok{:}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"x è zero"}\OperatorTok{);}

    \ControlFlowTok{break}\OperatorTok{;}

  \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"x è uno"}\OperatorTok{);}

    \ControlFlowTok{break}\OperatorTok{;}

  \KeywordTok{default}\OperatorTok{:}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"x è un altro numero"}\OperatorTok{);}

    \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{x}\OperatorTok{)} \OperatorTok{\{}
  \ControlFlowTok{case} \DecValTok{0}\OperatorTok{:}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x è zero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{break}\OperatorTok{;}

  \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x è uno}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{break}\OperatorTok{;}

  \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x è un altro numero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \item
    C++:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{x}\OperatorTok{)} \OperatorTok{\{}
  \ControlFlowTok{case} \DecValTok{0}\OperatorTok{:}
    \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"x è zero"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}

    \ControlFlowTok{break}\OperatorTok{;}

  \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
    \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"x è uno"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}

    \ControlFlowTok{break}\OperatorTok{;}

  \ControlFlowTok{default}\OperatorTok{:}
    \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"x è un altro numero"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}

    \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\end{itemize}

\section{Organizzazione delle istruzioni in un
programma}\label{organizzazione-delle-istruzioni-in-un-programma}

Certamente, ecco il paragrafo completato:

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Organizzazione delle istruzioni in un
programma}\label{organizzazione-delle-istruzioni-in-un-programma-1}

Il programma è solitamente salvato in un file di testo in righe. Queste
righe possono essere classificate in righe fisiche e righe logiche.

Una \textbf{riga fisica} è una linea di testo nel file sorgente del
programma, terminata da un carattere di a capo.

Esempio:

\phantomsection\label{annotated-cell-20}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Questa è una riga fisica.
\end{description}

Una \textbf{riga logica} è una singola istruzione, che può estendersi su
una o più righe fisiche.

Esempio di riga logica con più righe fisiche:

\phantomsection\label{annotated-cell-21}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \OperatorTok{(}\DecValTok{10} \OperatorTok{+} \DecValTok{20} \OperatorTok{+} \DecValTok{30} \OperatorTok{+} \hspace*{\fill}\NormalTok{\circled{1}}
         \DecValTok{40} \OperatorTok{+} \DecValTok{50}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Prima riga fisica della riga logica.
\item[\circled{2}]
Seconda riga fisica della riga logica.
\end{description}

Il concetto di righe fisiche e logiche esiste perché le istruzioni (o
righe logiche) possono essere lunghe e composte, richiedendo più righe
fisiche per migliorare la leggibilità e la gestione del codice.

In molti linguaggi di programmazione, l'uso di righe fisiche e logiche
facilita l'organizzazione e la formattazione del codice. Ad esempio:

\begin{itemize}
\item
  \textbf{Python} utilizza l'indentazione per definire i blocchi di
  codice, quindi una riga logica che si estende su più righe fisiche
  deve continuare con una corretta indentazione. Inoltre, è possibile
  usare il carattere di continuazione (\texttt{\textbackslash{}}) per
  indicare che una riga logica prosegue sulla riga successiva:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{result }\OperatorTok{=}\NormalTok{ (}\DecValTok{10} \OperatorTok{+} \DecValTok{20} \OperatorTok{+} \DecValTok{30} \OperatorTok{+} \OperatorTok{\textbackslash{}}
          \DecValTok{40} \OperatorTok{+} \DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Java} e \textbf{C} utilizzano le parentesi graffe
  (\texttt{\{\}}) per delimitare i blocchi di codice, e le istruzioni
  possono estendersi su più righe fisiche senza il bisogno di un
  carattere di continuazione, grazie al punto e virgola (\texttt{;}) che
  termina le istruzioni:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \OperatorTok{(}\DecValTok{10} \OperatorTok{+} \DecValTok{20} \OperatorTok{+} \DecValTok{30} \OperatorTok{+} 
         \DecValTok{40} \OperatorTok{+} \DecValTok{50}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \OperatorTok{(}\DecValTok{10} \OperatorTok{+} \DecValTok{20} \OperatorTok{+} \DecValTok{30} \OperatorTok{+} 
         \DecValTok{40} \OperatorTok{+} \DecValTok{50}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\end{itemize}

L'uso corretto di righe fisiche e logiche migliora la leggibilità del
codice, rendendolo più facile da capire e mantenere. Inoltre, una buona
formattazione del codice facilita il lavoro di squadra, poiché gli
sviluppatori possono facilmente seguire e comprendere la logica
implementata da altri.

\chapter{Variabili e funzioni}\label{variabili-e-funzioni}

La \textbf{semantica} di un linguaggio di programmazione definisce il
significato delle istruzioni sintatticamente corrette. In altre parole,
la semantica specifica cosa fa un programma quando viene eseguito,
descrivendo l'effetto delle istruzioni sullo stato del sistema. Gli
elementi semantici sono numerosi, possono essere anche complessi e non
tutti presenti in uno specifico linguaggio.

Tra i primi elementi semantici, richiamati già molte volte, troviamo le
variabili e le funzioni.

\section{Variabili}\label{variabili}

Le \textbf{variabili} sono uno dei concetti fondamentali nella
programmazione, essenziali per la manipolazione e la gestione dei dati.
Una variabile è un nome simbolico associato a una locazione di memoria
che può contenere uno o più valori di un certo tipo di dato. Questo
concetto permette agli sviluppatori di astrarre dalla memoria fisica e
concentrarsi sulla logica del programma.

La gestione delle variabili varia tra i diversi linguaggi di
programmazione, quindi esploreremo le variabili con particolare
attenzione a Python, Java, C e C++.

\subsection{Dichiarazione e
inizializzazione}\label{dichiarazione-e-inizializzazione}

La dichiarazione di una variabile è il processo mediante il quale si
introduce una variabile nel programma, specificandone il nome e, in
molti casi, il tipo di dato che essa può contenere. Questo processo
informa il compilatore o l'interprete che una certa variabile esiste e
può essere utilizzata nel codice. Abbiamo visto che esiste una
istruzione specifica in alcuni linguaggi, mentre in altri è implicita
nella assegnazione.

L'inizializzazione di una variabile è il processo di assegnazione di un
valore iniziale alla variabile. Questo può avvenire contestualmente alla
dichiarazione o in un'istruzione separata successiva, quella di
assegnamento.

Esempi:

\begin{itemize}
\item
  In Python, le variabili sono dichiarate automaticamente al momento
  dell'assegnazione del valore. Non è necessario specificare il tipo di
  dato, poiché Python è dinamicamente tipizzato, cioè determina durante
  l'esecuzione il tipo di dato del valore associato alla variabile.

\phantomsection\label{annotated-cell-108}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{10} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{x }\OperatorTok{=} \StringTok{"Hello"} \hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dichiarazione e inizializzazione.
  \item[\circled{2}]
  Cambia il tipo di \texttt{x} dinamicamente a stringa.
  \end{description}
\item
  Java: In Java, le variabili devono essere dichiarate con un tipo di
  dato esplicito. La dichiarazione può avvenire contestualmente
  all'inizializzazione o separatamente.

\phantomsection\label{annotated-cell-109}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Dichiarazione.
\item
  Inizializzazione.
\item
  Dichiarazione e inizializzazione.
\end{enumerate}

\begin{itemize}
\item
  C: In C, la dichiarazione delle variabili richiede la specifica del
  tipo di dato. La dichiarazione e l'inizializzazione possono essere
  separate o combinate.

\phantomsection\label{annotated-cell-110}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Dichiarazione.
\item
  Inizializzazione.
\item
  Dichiarazione e inizializzazione.
\end{enumerate}

\begin{itemize}
\item
  C++: Simile al C, ma con funzionalità aggiuntive come
  l'inizializzazione a lista.

\phantomsection\label{annotated-cell-111}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{3}}
\DataTypeTok{int}\NormalTok{ z}\OperatorTok{\{}\DecValTok{30}\OperatorTok{\};} \hspace*{\fill}\NormalTok{\circled{4}}
\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};} \hspace*{\fill}\NormalTok{\circled{5}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dichiarazione.
  \item[\circled{2}]
  Inizializzazione.
  \item[\circled{3}]
  Dichiarazione e inizializzazione.
  \item[\circled{4}]
  Dichiarazione e inizializzazione a lista di \texttt{z} con l'intero
  30.
  \item[\circled{5}]
  Dichiarazione e inizializzazione a lista di un array con 5 valori
  predefiniti.
  \end{description}
\end{itemize}

\subsection{Ambito delle variabili}\label{ambito-delle-variabili}

L'ambito di una variabile rappresenta la porzione del codice in cui
l'identificatore della variabile è definito e, quindi, può essere
utilizzato. Gli approcci dei diversi linguaggi sono diversi, infatti
Java, C e C++ hanno una gestione dell'ambito delle variabili per cui
quelle dichiarate all'interno di un blocco sono limitate a quel blocco e
non sono visibili al di fuori di esso. In Python, invece, le variabili
definite all'interno di un blocco di un'istruzione composta (come un
ciclo for o una condizione if) rimangono accessibili anche al di fuori
del blocco, purché siano ancora nel medesimo ambito di funzione o modulo
e, soprattutto quel blocco sia stato eseguito.

\begin{itemize}
\item
  Globale: Le variabili globali sono dichiarate al di fuori di qualsiasi
  blocco e sono accessibili ovunque nel programma.

\phantomsection\label{annotated-cell-112}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ globalVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\DataTypeTok{void}\NormalTok{ function}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ globalVar}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Variabile globale.
  \item[\circled{2}]
  Inizio del blocco.
  \item[\circled{3}]
  Accesso alla variabile globale.
  \end{description}
\item
  Locale: Le variabili locali sono dichiarate all'interno di un blocco,
  come una funzione o un loop, e sono accessibili solo all'interno di
  quel blocco.

\phantomsection\label{annotated-cell-113}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\KeywordTok{true}\OperatorTok{)} \OperatorTok{\{}
      \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
    \OperatorTok{\}}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{x}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
      \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{3}}
    \OperatorTok{\}}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{y}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Variabile locale al blocco \texttt{if}.
  \item[\circled{2}]
  Errore: \texttt{x} non è visibile qui!
  \item[\circled{3}]
  Variabile locale al blocco \texttt{for}.
  \item[\circled{4}]
  Errore: \texttt{y} non è visibile qui.
  \end{description}
\item
  In Python, una variabile definita all'interno di un blocco di
  un'istruzione composta, come all'interno di un ciclo \texttt{for} o di
  una condizione \texttt{if}, rimane accessibile anche dopo l'esecuzione
  del blocco:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
\NormalTok{  loopVar }\OperatorTok{=}\NormalTok{ i  }\CommentTok{\# }

\BuiltInTok{print}\NormalTok{(loopVar)  }\CommentTok{\# }
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Variabile locale al ciclo.
  \item
    \texttt{loopVar} è ancora accessibile qui.
  \end{enumerate}
\end{itemize}

\subsection{Visibilità delle
variabili}\label{visibilituxe0-delle-variabili}

La visibilità si riferisce alla possibilità che in una regione di codice
una certa variabile possa essere \emph{vista} e utilizzata. Anche se
correlata all'ambito, la visibilità può essere influenzata da altri
fattori come la modularità e gli spazi di nomi (\emph{namespace}).

\begin{itemize}
\item
  Consideriamo un esempio in C++ per illustrare la differenza tra ambito
  e visibilità:

\phantomsection\label{annotated-cell-115}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{int}\NormalTok{ globalVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\DataTypeTok{void}\NormalTok{ function}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ localVar }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}

  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ globalVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{3}}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ localVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{4}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  function}\OperatorTok{();}

  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ globalVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{5}}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ localVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{6}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Variabile globale (ambito globale).
  \item[\circled{2}]
  Variabile locale (ambito locale alla funzione).
  \item[\circled{3}]
  Visibilità \texttt{globaleVar} all'interno della funzione.
  \item[\circled{4}]
  Visibilità \texttt{localVar} all'interno della funzione.
  \item[\circled{5}]
  Visibilità \texttt{globalVar} all'interno di \texttt{main}.
  \item[\circled{6}]
  Errore: \texttt{localVar} non è visibile qui (ambito locale alla
  funzione function).
  \end{description}
\item
  In Python, le variabili definite all'interno di una funzione sono
  locali a quella funzione, ma le variabili definite all'interno di un
  blocco (come un ciclo \texttt{for} o un \texttt{if}) sono visibili
  all'interno della funzione o del modulo in cui si trovano:

\phantomsection\label{annotated-cell-116}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{globalVar }\OperatorTok{=} \DecValTok{10} \hspace*{\fill}\NormalTok{\circled{1}}

\KeywordTok{def}\NormalTok{ function():}
\NormalTok{  localVar }\OperatorTok{=} \DecValTok{5} \hspace*{\fill}\NormalTok{\circled{2}}

  \ControlFlowTok{if} \VariableTok{True}\NormalTok{:}
\NormalTok{    blockVar }\OperatorTok{=} \DecValTok{20} \hspace*{\fill}\NormalTok{\circled{3}}

  \BuiltInTok{print}\NormalTok{(localVar) }\hspace*{\fill}\NormalTok{\circled{4}}
  \BuiltInTok{print}\NormalTok{(blockVar) }\hspace*{\fill}\NormalTok{\circled{5}}

\NormalTok{function()}

\BuiltInTok{print}\NormalTok{(globalVar) }\hspace*{\fill}\NormalTok{\circled{6}}
\BuiltInTok{print}\NormalTok{(localVar) }\hspace*{\fill}\NormalTok{\circled{7}}
\BuiltInTok{print}\NormalTok{(blockVar) }\hspace*{\fill}\NormalTok{\circled{8}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Variabile globale.
  \item[\circled{2}]
  Variabile locale.
  \item[\circled{3}]
  Visibile all'interno della funzione.
  \item[\circled{4}]
  Visibile.
  \item[\circled{5}]
  Visibile.
  \item[\circled{6}]
  Visibile.
  \item[\circled{7}]
  Errore: non visibile al di fuori della funzione.
  \item[\circled{8}]
  Errore: non visibile al di fuori della funzione.
  \end{description}
\end{itemize}

\subsection{Durata di vita degli oggetti
referenziati}\label{durata-di-vita-degli-oggetti-referenziati}

La durata di vita descrive per quanto tempo un oggetto rimane in memoria
durante l'esecuzione del programma. Questo è distinto dalla variabile (o
puntatore) che fa riferimento all'oggetto.

In alcuni linguaggi di programmazione è presente il \textbf{garbage
collector}, cioè un processo avviato dal compilatore o interprete che si
occupa di rendere nuovamente disponibili le aree di memoria
precedentemente occupate da oggetti non più referenziati da variabili.
Questo accade quando l'esecuzione del programma raggiunge regioni di
codice dove quelle variabili non sono più visibili. In questo modo, la
visibilità è legata alla durata di vita degli oggetti, rendendo la
gestione della memoria non più una preoccupazione del programmatore.

\begin{itemize}
\item
  Variabile automatica: L'oggetto esiste solo durante l'esecuzione del
  blocco di codice in cui è stata dichiarata la variabile a cui è
  associato.

\phantomsection\label{annotated-cell-117}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ function}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ autoVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\OperatorTok{\}} 

\NormalTok{printf}\OperatorTok{(}\StringTok{"autoVar cancellata!"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dichiarazione di \texttt{autoVar} e creazione in memoria di un oggetto
  corrispondente all'intero 10.
  \item[\circled{2}]
  Prima di questa istruzione l'oggetto 10 non è più presente in memoria.
  \end{description}
\item
  Variabile statica: La variabile esiste per tutta la durata del
  programma, ma è accessibile solo all'interno del blocco in cui è
  dichiarata.

\phantomsection\label{annotated-cell-118}%
\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ function}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ staticVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Variabile statica ottenuta con una parola chiave ad hoc in fase di
  dichiarazione.
  \end{description}
\item
  Variabile dinamica: Le variabili dinamiche sono utilizzate per
  riservare memoria che persiste oltre la durata del blocco di codice in
  cui sono state create. L'oggetto è creato in memoria e deve essere
  cancellato esplicitamente dall'utente, utilizzando funzioni di
  gestione della memoria come \texttt{delete}. La variabile che punta
  all'oggetto è separata dall'oggetto stesso, quindi se la variabile non
  è più visibile, l'oggetto continuerà a rimanere in memoria e non sarà
  più eliminabile, causando una perdita di memoria (\emph{memory leak}).

\phantomsection\label{annotated-cell-119}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{void}\NormalTok{ function}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\OperatorTok{*}\NormalTok{ dynamicVar }\OperatorTok{=} \KeywordTok{new} \DataTypeTok{int}\OperatorTok{(}\DecValTok{10}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{1}}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"dynamicVar: "} \OperatorTok{\textless{}\textless{}} \OperatorTok{*}\NormalTok{dynamicVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  function}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{3}}

  \DataTypeTok{int}\OperatorTok{*}\NormalTok{ safeDynamicVar }\OperatorTok{=} \KeywordTok{new} \DataTypeTok{int}\OperatorTok{(}\DecValTok{20}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}

  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"safeDynamicVar: "} \OperatorTok{\textless{}\textless{}} \OperatorTok{*}\NormalTok{safeDynamicVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{5}}

  \KeywordTok{delete}\NormalTok{ safeDynamicVar}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{6}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Allocazione dinamica di un intero all'interno della funzione
  \texttt{function()}.
  \item[\circled{2}]
  Stampa del valore puntato da \texttt{dynamicVar}. Prima della chiusura
  del blocco non viene deallocata \texttt{dynamicVar} per dimostrare il
  problema di perdita di memoria
  \item[\circled{3}]
  Chiamata alla funzione \texttt{function()}. Dopo l'uscita dalla
  funzione, \texttt{dynamicVar} non è più accessibile, causando una
  perdita di memoria poiché non è stata deallocata.
  \item[\circled{4}]
  Allocazione dinamica di un intero.
  \item[\circled{5}]
  Stampa del valore puntato da \texttt{safeDynamicVar}.
  \item[\circled{6}]
  Deallocazione dinamica dell'intero. Corretto uso di allocazione e
  deallocazione dinamica.
  \end{description}
\item
  In Python, la gestione della memoria è automatica grazie al garbage
  collector. Quando non ci sono più riferimenti di variabili a un
  oggetto, il garbage collector lo rimuove dalla memoria.
\end{itemize}

\section{Funzioni}\label{funzioni}

Le funzioni sono blocchi di codice riutilizzabili che eseguono una serie
di istruzioni. Questi costrutti sono fondamentali per la strutturazione
e la modularizzazione del codice, consentendo di definire operazioni che
possono essere invocate più volte durante l'esecuzione di un programma.
La distinzione tra funzioni e metodi è che le funzioni sono
indipendenti, mentre i metodi sono associati a oggetti o classi.

\subsection{Parametri e argomenti}\label{parametri-e-argomenti}

I \textbf{parametri} e gli \textbf{argomenti} sono strumenti
fondamentali per passare informazioni alle funzioni e influenzarne il
comportamento.

\begin{itemize}
\item
  Parametri o parametri formali: I parametri sono definiti nella
  dichiarazione della funzione e rappresentano i nomi delle variabili
  che la funzione utilizzerà per accedere ai dati passati.
\item
  Argomenti o parametri attuali: Gli argomenti sono i valori effettivi
  passati alla funzione quando viene chiamata.
\end{itemize}

Esempio in Python:

\phantomsection\label{annotated-cell-23}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ add(a, b): }\hspace*{\fill}\NormalTok{\circled{1}}
  \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

\NormalTok{result }\OperatorTok{=}\NormalTok{ add(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{2}}

\BuiltInTok{print}\NormalTok{(result) }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
\texttt{a} e \texttt{b} sono parametri della funzione \texttt{add}.
\item[\circled{2}]
\texttt{3} e \texttt{4} sono argomenti passati alla funzione
\texttt{add}.
\item[\circled{3}]
Il risultato della funzione \texttt{add} viene stampato.
\end{description}

\subsection{Valore di ritorno}\label{valore-di-ritorno}

Il valore di ritorno è il risultato prodotto da una funzione, che può
essere utilizzato nell'istruzione chiamante. Una funzione può restituire
un valore utilizzando la parola chiave \texttt{return}.

Esempio in Java:

\phantomsection\label{annotated-cell-24}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{int} \FunctionTok{add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
  \OperatorTok{\}}

  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \FunctionTok{add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{result}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Dichiarazione della funzione \texttt{add} che accetta due parametri
interi.
\item[\circled{2}]
La funzione \texttt{add} ritorna la somma di \texttt{a} e \texttt{b}.
\item[\circled{3}]
Chiamata della funzione \texttt{add} con argomenti \texttt{3} e
\texttt{4}.
\item[\circled{4}]
Il risultato della funzione \texttt{add} viene stampato.
\end{description}

\subsection{Ricorsione}\label{ricorsione}

La \textbf{ricorsione} è la capacità di una funzione di chiamare se
stessa, utile per risolvere problemi che possono essere suddivisi in
sottoproblemi simili. Ogni chiamata ricorsiva deve avvicinarsi a una
condizione di terminazione per evitare loop infiniti.

Esempio in C++ (calcolo del fattoriale):

\phantomsection\label{annotated-cell-25}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{int}\NormalTok{ factorial}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textless{}=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}

  \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial}\OperatorTok{(}\NormalTok{n }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ factorial}\OperatorTok{(}\DecValTok{5}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{4}}

  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ result }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{5}}
  
  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Dichiarazione della funzione \texttt{factorial}.
\item[\circled{2}]
Condizione di terminazione: se \texttt{n} è minore o uguale a 1, ritorna
1.
\item[\circled{3}]
Chiamata ricorsiva: \texttt{factorial} chiama se stessa con
\texttt{n\ -\ 1}.
\item[\circled{4}]
Chiamata della funzione \texttt{factorial} con argomento \texttt{5}.
\item[\circled{5}]
Il risultato della funzione \texttt{factorial} viene stampato.
\end{description}

\subsection{Funzioni di prima classe}\label{funzioni-di-prima-classe}

Le \textbf{funzioni di prima classe} sono funzioni che possono essere
trattate come qualsiasi altra variabile. Possono essere assegnate a
variabili, passate come argomenti e ritornate da altre funzioni.

\begin{itemize}
\item
  Esempio in Python:

\phantomsection\label{annotated-cell-120}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ greet(name):}
  \ControlFlowTok{return} \SpecialStringTok{f"Hello, }\SpecialCharTok{\{}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{!"}

\NormalTok{say\_hello }\OperatorTok{=}\NormalTok{ greet }\hspace*{\fill}\NormalTok{\circled{1}}

\BuiltInTok{print}\NormalTok{(say\_hello(}\StringTok{"World"}\NormalTok{)) }\hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  La funzione \texttt{greet} viene assegnata alla variabile
  \texttt{say\_hello}.
  \item[\circled{2}]
  \texttt{say\_hello} viene chiamata con l'argomento \texttt{"World"}.
  \end{description}
\item
  Esempio in C++:

\phantomsection\label{annotated-cell-121}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}functional\textgreater{}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\AttributeTok{const} \BuiltInTok{std::}\NormalTok{string}\OperatorTok{\&}\NormalTok{ name}\OperatorTok{)} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Hello, "} \OperatorTok{\textless{}\textless{}}\NormalTok{ name }\OperatorTok{\textless{}\textless{}} \StringTok{"!"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{function}\OperatorTok{\textless{}}\DataTypeTok{void}\OperatorTok{(}\AttributeTok{const} \BuiltInTok{std::}\NormalTok{string}\OperatorTok{\&)\textgreater{}}\NormalTok{ say\_hello }\OperatorTok{=}\NormalTok{ greet}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\NormalTok{  say\_hello}\OperatorTok{(}\StringTok{"World"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  La funzione \texttt{greet} viene assegnata alla variabile
  \texttt{say\_hello} utilizzando \texttt{std::function}.
\item
  \texttt{say\_hello} viene chiamata con l'argomento \texttt{"World"}.
\end{enumerate}

\subsection{Funzioni di ordine
superiore}\label{funzioni-di-ordine-superiore}

Le \textbf{funzioni di ordine superiore} sono funzioni che accettano
altre funzioni come argomenti e/o ritornano funzioni come risultati.
Sono fondamentali per la programmazione funzionale.

\begin{itemize}
\item
  Esempio in Python:

\phantomsection\label{annotated-cell-122}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ add(a):}
  \KeywordTok{def}\NormalTok{ inner(b):}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

  \ControlFlowTok{return}\NormalTok{ inner }\hspace*{\fill}\NormalTok{\circled{1}}

\NormalTok{add\_five }\OperatorTok{=}\NormalTok{ add(}\DecValTok{5}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{2}}

\BuiltInTok{print}\NormalTok{(add\_five(}\DecValTok{3}\NormalTok{)) }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  La funzione \texttt{add} ritorna una nuova funzione \texttt{inner} che
  somma \texttt{a} al suo argomento \texttt{b}.
  \item[\circled{2}]
  \texttt{add(5)} ritorna una nuova funzione che somma 5 al suo
  argomento.
  \item[\circled{3}]
  La funzione risultante viene chiamata con l'argomento \texttt{3},
  restituendo \texttt{8}.
  \end{description}
\item
  Esempio in C++:

\phantomsection\label{annotated-cell-123}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}functional\textgreater{}}

\BuiltInTok{std::}\NormalTok{function}\OperatorTok{\textless{}}\DataTypeTok{int}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{)\textgreater{}}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \ControlFlowTok{return} \OperatorTok{[}\NormalTok{a}\OperatorTok{](}\DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\};} \hspace*{\fill}\NormalTok{\circled{2}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \KeywordTok{auto}\NormalTok{ add\_five }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\DecValTok{5}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}

  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ add\_five}\OperatorTok{(}\DecValTok{3}\OperatorTok{)} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{4}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Dichiarazione della funzione \texttt{add} che ritorna un
  \texttt{std::function\textless{}int(int)\textgreater{}}.
\item
  \texttt{add} ritorna una funzione lambda che somma \texttt{a} al suo
  argomento \texttt{b}.
\item
  \texttt{add(5)} ritorna una nuova funzione che somma \texttt{5} al suo
  argomento.
\item
  La funzione risultante viene chiamata con l'argomento \texttt{3},
  restituendo \texttt{8}.
\end{enumerate}

\subsection{Ambito e visibilità}\label{ambito-e-visibilituxe0}

L'ambito e la visibilità degli identificatori delle funzioni sono
concetti sono simili a quelli delle variabili, ma presentano alcune
differenze chiave che è importante comprendere.

\subsubsection{Ambito}\label{ambito}

Per le funzioni distinguiamo sempre i seguenti:

\begin{itemize}
\item
  Ambito globale: Una funzione dichiarata a livello globale, cioè al di
  fuori di qualsiasi altra funzione o blocco di codice, ha un ambito
  globale. Questo significa che la funzione è visibile e può essere
  chiamata da qualsiasi punto del programma dopo la sua dichiarazione.

  Esempio in C++:

\phantomsection\label{annotated-cell-124}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{void}\NormalTok{ globalFunction}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Funzione globale"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  globalFunction}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{2}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dichiarazione della funzione \texttt{globalFunction} a livello
  globale.
  \item[\circled{2}]
  Chiamata della funzione \texttt{globalFunction} all'interno di
  \texttt{main}.
  \end{description}

  Il comportamento è identico in Java e C. In Python, le funzioni
  definite a livello globale hanno ambito globale.
\item
  Ambito locale: Una funzione dichiarata all'interno di un blocco di
  codice (come all'interno di una funzione o di una classe) ha un ambito
  locale. La funzione è visibile e può essere chiamata solo all'interno
  di quel blocco.

  Esempio in Python:

\phantomsection\label{annotated-cell-125}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ outerFunction():}
  \KeywordTok{def}\NormalTok{ localFunction(): }\hspace*{\fill}\NormalTok{\circled{1}}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Funzione locale"}\NormalTok{)}

\NormalTok{  localFunction() }\hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{outerFunction()}

\NormalTok{localFunction() }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dichiarazione della funzione \texttt{localFunction} all'interno di
  \texttt{outerFunction}.
  \item[\circled{2}]
  Chiamata della funzione \texttt{localFunction} all'interno di
  \texttt{outerFunction}.
  \item[\circled{3}]
  Chiamata a \texttt{localFunction} al di fuori di
  \texttt{outerFunction}, che genera un errore poiché
  \texttt{localFunction} non è visibile a questo livello.
  \end{description}

  In Java e C++, le funzioni dichiarate all'interno di un blocco (come
  metodi all'interno di una classe) sono accessibili solo all'interno di
  quel blocco, simile a Python.

  In C, le funzioni locali non sono standard, ma è possibile ottenere un
  comportamento simile usando funzioni statiche o funzioni inline
  definite all'interno di un file sorgente specifico.
\end{itemize}

\subsubsection{Visibilità}\label{visibilituxe0}

La visibilità si riferisce a dove nel codice l'identificatore di una
funzione può essere utilizzato. La visibilità è strettamente legata
all'ambito, ma può essere influenzata anche da altre considerazioni come
la modularità e le regole di accesso.

\begin{itemize}
\item
  Visibilità Globale: Le funzioni con ambito globale sono visibili
  ovunque nel programma come per le variabili.
\item
  Visibilità Locale: Le funzioni con ambito locale sono visibili solo
  all'interno del blocco in cui sono dichiarate. Questo è utile per
  creare funzioni di supporto (\emph{helper}) o interne che non devono
  essere accessibili dall'esterno.

  Esempio in Python:

\phantomsection\label{annotated-cell-126}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ outerFunction():}
  \KeywordTok{def}\NormalTok{ helperFunction(): }\hspace*{\fill}\NormalTok{\circled{1}}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Funzione helper"}\NormalTok{)}

\NormalTok{  helperFunction() }\hspace*{\fill}\NormalTok{\circled{2}}

  \BuiltInTok{print}\NormalTok{(}\StringTok{"Funzione esterna"}\NormalTok{)}

\NormalTok{outerFunction()}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dichiarazione della funzione \texttt{helperFunction} all'interno di
  \texttt{outerFunction}.
  \item[\circled{2}]
  Chiamata della funzione \texttt{helperFunction} all'interno di
  \texttt{outerFunction}.
  \end{description}
\end{itemize}

\subsubsection{Differenze tra funzioni con variabili e
oggetti}\label{differenze-tra-funzioni-con-variabili-e-oggetti}

Sebbene l'ambito e la visibilità delle funzioni condividano concetti
simili con le variabili e gli oggetti, ci sono alcune differenze chiave:

\begin{itemize}
\item
  Durata di vita: Le variabili locali (automatiche) hanno una durata di
  vita limitata al blocco di codice in cui sono dichiarate. Quando il
  controllo esce dal blocco, la memoria allocata per la variabile viene
  liberata. Le funzioni, tuttavia, non vengono ``distrutte'' quando il
  controllo esce dal loro ambito; semplicemente non sono più visibili e
  chiamabili. In Python, le variabili definite all'interno di un blocco
  di un'istruzione composta rimangono accessibili finché sono nello
  stesso ambito di funzione o modulo, mentre le funzioni definite
  all'interno di un'altra funzione (nested functions) sono visibili solo
  all'interno di quella funzione.
\item
  Allocazione dinamica: In C++, le variabili e gli oggetti possono
  essere allocati dinamicamente usando \texttt{new} e deallocati usando
  \texttt{delete}. Le funzioni non richiedono un'allocazione esplicita
  di memoria; la loro dichiarazione è sufficiente per renderle
  utilizzabili nell'ambito definito.
\end{itemize}

\section{Spazio di nomi, moduli e
file}\label{spazio-di-nomi-moduli-e-file}

In molti linguaggi di programmazione, la gestione dell'ambito e della
visibilità delle variabili e delle funzioni può essere ulteriormente
organizzata utilizzando spazio di nomi (\emph{namespace}), moduli,
header e file separati. Questa organizzazione aiuta a evitare conflitti
di nome e a mantenere il codice più modulare e manutenibile.

\subsection{Python}\label{python}

In Python, i moduli sono file che contengono definizioni di variabili,
funzioni e classi. I moduli possono essere importati in altri moduli o
script per riutilizzare il codice. Quando un modulo viene importato, gli
identificatori definiti in quel modulo (come variabili, funzioni e
classi) diventano accessibili attraverso il nome del modulo. Sebbene i
moduli siano spesso implementati come file separati, è possibile
definirli anche all'interno di un file di codice sorgente principale.

Esempio di modulo (\texttt{mymodule.py}):

\phantomsection\label{annotated-cell-26}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# mymodule.py}
\NormalTok{my\_var }\OperatorTok{=} \DecValTok{10} \hspace*{\fill}\NormalTok{\circled{1}}

\KeywordTok{def}\NormalTok{ my\_function():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Funzione del modulo"}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Variabile globale nel modulo.
\item[\circled{2}]
Funzione nel modulo.
\end{description}

Importazione di un modulo in un altro file sorgente (\texttt{main.py}):

\phantomsection\label{annotated-cell-27}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# main.py}
\ImportTok{import}\NormalTok{ mymodule }\hspace*{\fill}\NormalTok{\circled{1}}

\BuiltInTok{print}\NormalTok{(mymodule.my\_var) }\hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{mymodule.my\_function() }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Importazione del modulo \texttt{mymodule}.
\item[\circled{2}]
Accesso alla variabile \texttt{my\_var} dal modulo \texttt{mymodule}.
\item[\circled{3}]
Chiamata della funzione \texttt{my\_function} dal modulo
\texttt{mymodule}.
\end{description}

\subsection{Java}\label{java}

In Java, i pacchetti (\emph{package}) sono utilizzati per organizzare le
classi in namespace separati. Ogni classe deve dichiarare il pacchetto
di appartenenza.

\subsubsection{Pacchetti}\label{pacchetti}

Esempio di classe in un pacchetto (\texttt{mypackage/MyClass.java}):

\phantomsection\label{annotated-cell-28}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// mypackage/MyClass.java}
\KeywordTok{package}\ImportTok{ mypackage}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ MyClass }\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ myVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}

    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{myMethod}\OperatorTok{()} \OperatorTok{\{}
        \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Metodo del pacchetto"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{3}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Dichiarazione del pacchetto \texttt{mypackage}.
\item[\circled{2}]
Variabile globale di classe.
\item[\circled{3}]
Metodo della classe.
\end{description}

Importazione di una classe da un pacchetto in un'altra classe
(\texttt{Main.java}):

\phantomsection\label{annotated-cell-29}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Main.java}
\KeywordTok{import} \ImportTok{mypackage}\OperatorTok{.}\ImportTok{MyClass}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
        \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{MyClass}\OperatorTok{.}\FunctionTok{myVar}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{        MyClass}\OperatorTok{.}\FunctionTok{myMethod}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{3}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Importazione della classe \texttt{MyClass} dal pacchetto
\texttt{mypackage}.
\item[\circled{2}]
Accesso alla variabile \texttt{myVar} dalla classe \texttt{MyClass}.
\item[\circled{3}]
Chiamata del metodo \texttt{myMethod} dalla classe \texttt{MyClass}.
\end{description}

\subsection{C}\label{c}

In C, i file di intestazione (\emph{header file}) sono utilizzati per
dichiarare funzioni e variabili che possono essere utilizzate in più
file sorgente, a mo' di libreria.

Esempio di file di intestazione (\texttt{mymodule.h}):

\phantomsection\label{annotated-cell-30}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// mymodule.h}
\PreprocessorTok{\#ifndef MYMODULE\_H }
\PreprocessorTok{\#define MYMODULE\_H}

\KeywordTok{extern} \DataTypeTok{int}\NormalTok{ myVar}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\DataTypeTok{void}\NormalTok{ myFunction}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{2}}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Dichiarazione della variabile globale \texttt{myVar}.
\item[\circled{2}]
Dichiarazione della funzione \texttt{myFunction}.
\end{description}

Esempio di file sorgente (\texttt{mymodule.c}):

\phantomsection\label{annotated-cell-31}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// mymodule.c}
\PreprocessorTok{\#include }\ImportTok{"mymodule.h"}

\DataTypeTok{int}\NormalTok{ myVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

\DataTypeTok{void}\NormalTok{ myFunction}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Funzione del modulo}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione della variabile globale \texttt{myVar}.
\item[\circled{2}]
Definizione della funzione \texttt{myFunction}.
\end{description}

Utilizzo del file di intestazione in un altro file sorgente
(\texttt{main.c}):

\phantomsection\label{annotated-cell-32}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// main.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"mymodule.h"}\PreprocessorTok{ }\hspace*{\fill}\NormalTok{\circled{1}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ myVar}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{    myFunction}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{3}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Inclusione del file di intestazione \texttt{mymodule.h}.
\item[\circled{2}]
Accesso alla variabile \texttt{myVar} dichiarata in \texttt{mymodule.h}.
\item[\circled{3}]
Chiamata della funzione \texttt{myFunction} dichiarata in
\texttt{mymodule.h}.
\end{description}

\subsection{C++}\label{c-1}

In C++, la parola chiave \texttt{namespace} è utilizzata per organizzare
le classi, le funzioni e le variabili in spazi di nomi separati, simili
ai pacchetti in Java.

Esempio di dichiarazione di uno spazio di nomi (\texttt{mymodule.h}):

\phantomsection\label{annotated-cell-33}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// mymodule.h}
\PreprocessorTok{\#ifndef MYMODULE\_H }
\PreprocessorTok{\#define MYMODULE\_H}

\KeywordTok{namespace}\NormalTok{ mynamespace }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
    \AttributeTok{extern} \DataTypeTok{int}\NormalTok{ myVar}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}

    \DataTypeTok{void}\NormalTok{ myFunction}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{3}}
\OperatorTok{\}}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Dichiarazione dello spazio di nomi \texttt{mynamespace}.
\item[\circled{2}]
Dichiarazione della variabile globale \texttt{myVar} all'interno dello
spazio di nomi.
\item[\circled{3}]
Dichiarazione della funzione \texttt{myFunction} all'interno dello
spazio di nomi.
\end{description}

Esempio di definizione dello spazio di nomi (\texttt{mymodule.cpp}):

\phantomsection\label{annotated-cell-34}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// mymodule.cpp}
\PreprocessorTok{\#include }\ImportTok{"mymodule.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\KeywordTok{namespace}\NormalTok{ mynamespace }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ myVar }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}

    \DataTypeTok{void}\NormalTok{ myFunction}\OperatorTok{()} \OperatorTok{\{}
        \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Funzione del namespace"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione della variabile globale \texttt{myVar} all'interno dello
spazio di nomi.
\item[\circled{2}]
Definizione della funzione \texttt{myFunction} all'interno dello spazio
di nomi.
\end{description}

Utilizzo dello spazio di nomi in un altro file sorgente
(\texttt{main.cpp}):

\phantomsection\label{annotated-cell-35}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// main.cpp}
\PreprocessorTok{\#include }\ImportTok{"mymodule.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
    \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ mynamespace}\OperatorTok{::}\NormalTok{myVar }\OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{    mynamespace}\OperatorTok{::}\NormalTok{myFunction}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{2}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Accesso alla variabile \texttt{myVar} all'interno dello spazio di nomi
\texttt{mynamespace}.
\item[\circled{2}]
Chiamata della funzione \texttt{myFunction} all'interno dello spazio di
nomi \texttt{mynamespace}.
\end{description}

\subsection{Impatti}\label{impatti}

L'uso di spazio di nomi, moduli e file di intestazione influisce
sull'ambito e sulla visibilità delle variabili e delle funzioni. In
generale, questi meccanismi consentono una maggiore modularità e
organizzazione del codice, facilitando la gestione di grandi progetti.

\begin{itemize}
\item
  Ambito: L'ambito delle variabili e delle funzioni può essere limitato
  a uno spazio di nomi o a un modulo, riducendo il rischio di conflitti
  di nome.
\item
  Visibilità: Le variabili e le funzioni dichiarate in namespace o
  moduli possono essere visibili solo all'interno di quel namespace o
  modulo, a meno che non vengano esplicitamente esportate.
\item
  Durata di vita degli oggetti: La durata di vita degli oggetti non è
  direttamente influenzata dallo spazio di nomi o moduli, ma
  l'organizzazione del codice può rendere più chiaro quando e dove gli
  oggetti vengono creati e distrutti.
\end{itemize}

\chapter{Modello dati}\label{modello-dati}

Un \textbf{modello dati} è una rappresentazione formale dei tipi di dati
e delle operazioni che possono essere eseguite su di essi. Esso
definisce le strutture fondamentali attraverso le quali i dati vengono
organizzati, memorizzati, manipolati e interagiscono all'interno del
programma.

Le componenti il modello dati sono:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Tipi di dati:

  \begin{itemize}
  \item
    Tipi primitivi: Questi sono i tipi di dati fondamentali che il
    linguaggio supporta nativamente, come numeri interi, numeri in
    virgola mobile, caratteri e booleani.
  \item
    Tipi compositi: Questi sono tipi di dati costruiti combinando tipi
    primitivi. Esempi comuni includono array, liste, tuple, set e
    dizionari.
  \item
    Tipi di dati definiti dall'utente: Questi sono tipi di dati che
    possono essere definiti dagli utenti del linguaggio, come le
    \texttt{struct} in C oppure le classi in Python o C++, che
    permettono di creare tipi di dati personalizzati.
  \end{itemize}
\item
  Operazioni:

  \begin{itemize}
  \item
    Operazioni aritmetiche: Operazioni che possono essere eseguite sui
    tipi di dati, come addizione, sottrazione, moltiplicazione e
    divisione per i numeri.
  \item
    Operazioni logiche: Operazioni che coinvolgono valori booleani, come
    AND, OR e NOT.
  \item
    Operazioni di sequenza: Operazioni che si possono eseguire su
    sequenze di dati, come l'indicizzazione, la \emph{slicing} e
    l'iterazione.
  \item
    Altre operazioni ad hoc per il tipo di dato.
  \end{itemize}
\item
  Regole di comportamento:

  \begin{itemize}
  \item
    Mutabilità: Determina se un oggetto può essere modificato dopo la
    sua creazione. Oggetti mutabili, come liste e dizionari in Python,
    possono essere cambiati. Oggetti immutabili, come tuple e stringhe,
    non possono essere modificati dopo la loro creazione.
  \item
    Copia e clonazione: Regole che determinano come i dati vengono
    copiati. Per esempio, in Python, la copia di una lista crea una
    nuova lista con gli stessi elementi, mentre la copia di un intero
    crea solo un riferimento allo stesso valore.
  \end{itemize}
\end{enumerate}

\section{Linguaggi procedurali}\label{linguaggi-procedurali}

Nei linguaggi di programmazione procedurali, il modello dati è
incentrato su tipi di dati semplici e compositi che supportano lo stile
di programmazione orientato alle funzioni e procedure. Alcune
caratteristiche tipiche includono:

\begin{itemize}
\item
  Tipi primitivi: Numeri interi, numeri a virgola mobile, caratteri e
  booleani.
\item
  Strutture composite: Array, strutture (\texttt{struct}) e unioni
  (\texttt{union}). Gli array permettono di gestire collezioni di
  elementi dello stesso tipo, mentre le strutture permettono di
  combinare vari tipi di dati sotto un unico nome. Le unioni consentono
  di memorizzare diversi tipi di dati nello stesso spazio di memoria, ma
  solo uno di essi può essere attivo alla volta.
\item
  Operazioni basate su funzioni: Le operazioni sui dati vengono eseguite
  attraverso funzioni che manipolano i valori passati come argomenti.
\end{itemize}

Esempio in C:

\phantomsection\label{annotated-cell-37}%
\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_DATI }\DecValTok{100}

\KeywordTok{union}\NormalTok{ Valore }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \DataTypeTok{int}\NormalTok{ intero}\OperatorTok{;}
  \DataTypeTok{float}\NormalTok{ decimale}\OperatorTok{;}
  \DataTypeTok{char}\NormalTok{ carattere}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Dato }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{2}}
  \DataTypeTok{char}\NormalTok{ tipo}\OperatorTok{;}  
  \CommentTok{// \textquotesingle{}i\textquotesingle{} per int, \textquotesingle{}f\textquotesingle{} per float, \textquotesingle{}c\textquotesingle{} per char}
  \KeywordTok{union}\NormalTok{ Valore valore}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ stampa\_dato}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Dato d}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{3}}
  \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{d}\OperatorTok{.}\NormalTok{tipo}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{:}
\NormalTok{      printf}\OperatorTok{(}\StringTok{"Intero: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{intero}\OperatorTok{);}
      \ControlFlowTok{break}\OperatorTok{;}

    \ControlFlowTok{case} \CharTok{\textquotesingle{}f\textquotesingle{}}\OperatorTok{:}
\NormalTok{      printf}\OperatorTok{(}\StringTok{"Float: }\SpecialCharTok{\%f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{decimale}\OperatorTok{);}
      \ControlFlowTok{break}\OperatorTok{;}

    \ControlFlowTok{case} \CharTok{\textquotesingle{}c\textquotesingle{}}\OperatorTok{:}
\NormalTok{      printf}\OperatorTok{(}\StringTok{"Carattere: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{carattere}\OperatorTok{);}
      \ControlFlowTok{break}\OperatorTok{;}

    \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{      printf}\OperatorTok{(}\StringTok{"Tipo sconosciuto}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
      \ControlFlowTok{break}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ confronta\_dato}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Dato d1}\OperatorTok{,} \KeywordTok{struct}\NormalTok{ Dato d2}\OperatorTok{)} \OperatorTok{\{}
  \ControlFlowTok{if} \OperatorTok{(}\NormalTok{d1}\OperatorTok{.}\NormalTok{tipo }\OperatorTok{!=}\NormalTok{ d2}\OperatorTok{.}\NormalTok{tipo}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}

  \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{d1}\OperatorTok{.}\NormalTok{tipo}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ d1}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{intero }\OperatorTok{==}\NormalTok{ d2}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{intero}\OperatorTok{;}

    \ControlFlowTok{case} \CharTok{\textquotesingle{}f\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ d1}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{decimale }\OperatorTok{==}\NormalTok{ d2}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{decimale}\OperatorTok{;}

    \ControlFlowTok{case} \CharTok{\textquotesingle{}c\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ d1}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{carattere }\OperatorTok{==}\NormalTok{ d2}\OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{carattere}\OperatorTok{;}

    \ControlFlowTok{default}\OperatorTok{:} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ inserisci\_dato}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Dato dati}\OperatorTok{[],} \DataTypeTok{int} \OperatorTok{*}\NormalTok{count}\OperatorTok{,} \KeywordTok{struct}\NormalTok{ Dato nuovo\_dato}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{4}}
  \ControlFlowTok{if} \OperatorTok{(*}\NormalTok{count }\OperatorTok{\textless{}}\NormalTok{ MAX\_DATI}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    dati}\OperatorTok{[*}\NormalTok{count}\OperatorTok{]} \OperatorTok{=}\NormalTok{ nuovo\_dato}\OperatorTok{;}

    \OperatorTok{(*}\NormalTok{count}\OperatorTok{)++;}

  \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Array pieno, impossibile inserire nuovo dato.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ cancella\_dato}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Dato dati}\OperatorTok{[],} \DataTypeTok{int} \OperatorTok{*}\NormalTok{count}\OperatorTok{,} \KeywordTok{struct}\NormalTok{ Dato dato\_da\_cancellare}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{5}}
  \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \OperatorTok{*}\NormalTok{count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{confronta\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ dato\_da\_cancellare}\OperatorTok{))} \OperatorTok{\{}
      \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}} \OperatorTok{*}\NormalTok{count }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        dati}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ dati}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{];}
      \OperatorTok{\}}

      \OperatorTok{(*}\NormalTok{count}\OperatorTok{){-}{-};}

\NormalTok{      i}\OperatorTok{{-}{-};} 
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \KeywordTok{struct}\NormalTok{ Dato dati}\OperatorTok{[}\NormalTok{MAX\_DATI}\OperatorTok{];} \hspace*{\fill}\NormalTok{\circled{6}}
  \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

  \KeywordTok{struct}\NormalTok{ Dato dato1 }\OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{,} \OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{intero }\OperatorTok{=} \DecValTok{42}\OperatorTok{\};}
  \KeywordTok{struct}\NormalTok{ Dato dato2 }\OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}f\textquotesingle{}}\OperatorTok{,} \OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{decimale }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{\};}
  \KeywordTok{struct}\NormalTok{ Dato dato3 }\OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}c\textquotesingle{}}\OperatorTok{,} \OperatorTok{.}\NormalTok{valore}\OperatorTok{.}\NormalTok{carattere }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{\};}
  
\NormalTok{  inserisci\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{,} \OperatorTok{\&}\NormalTok{count}\OperatorTok{,}\NormalTok{ dato1}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{7}}
\NormalTok{  inserisci\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{,} \OperatorTok{\&}\NormalTok{count}\OperatorTok{,}\NormalTok{ dato2}\OperatorTok{);}
\NormalTok{  inserisci\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{,} \OperatorTok{\&}\NormalTok{count}\OperatorTok{,}\NormalTok{ dato3}\OperatorTok{);}

  \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{8}}
\NormalTok{    stampa\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
  \OperatorTok{\}}

\NormalTok{  cancella\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{,} \OperatorTok{\&}\NormalTok{count}\OperatorTok{,}\NormalTok{ dato1}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{9}}

\NormalTok{  printf}\OperatorTok{(}\StringTok{"Dopo cancellazione:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

  \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    stampa\_dato}\OperatorTok{(}\NormalTok{dati}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
  \OperatorTok{\}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione di una \texttt{union}.
\item[\circled{2}]
Definizione di una \texttt{struct} che include la \texttt{union}.
\item[\circled{3}]
Funzione per stampare i valori in base al tipo.
\item[\circled{4}]
Funzione per inserire un nuovo dato alla fine dell'array.
\item[\circled{5}]
Funzione per cancellare tutte le occorrenze di un dato dall'array.
\item[\circled{6}]
Definizione di un array di \texttt{struct} Dato.
\item[\circled{7}]
Inserimento di dati nell'array.
\item[\circled{8}]
Stampa dei dati nell'array.
\item[\circled{9}]
Cancellazione di un dato specifico e ristampa dell'array.
\end{description}

L'esempio mostra come nel modello dati del linguaggio C possono essere
definiti dei tipi compositi (\texttt{Dato}, \texttt{Valore}) e delle
operazioni su quelli (\texttt{stampa\_dato}, \texttt{confronta\_dato},
\texttt{inserisci\_dato}, \texttt{cancella\_dato}). Il codice, pur
realizzante una semplice libreria, appare \emph{slegato}, cioè con
funzioni che si applicano a tipi di dati specifici solo
dall'interpretazione degli identificatori della funzione stessa e dei
suoi parametri, cioè senza un legame esplicito e non ambiguo, tra tipo e
funzione.

\section{Linguaggi orientati agli
oggetti}\label{linguaggi-orientati-agli-oggetti}

La programmazione orientata agli oggetti è un paradigma che utilizza
\textbf{oggetti} per rappresentare concetti ed entità del mondo reale o
astratto. Questo approccio si basa su un processo mentale fondamentale
per risolvere problemi complessi: la decomposizione. Un problema
complesso è più facilmente risolvibile se diviso in parti più piccole,
ciascuna delle quali possiede uno stato e la possibilità di interagire
con le altre parti. Questa divisione può essere effettuata per gradi,
come se si osservasse sempre più da vicino il problema, effettivamente
continunandone la specificazione, fino a raggiungere un livello
sufficientemente di dettaglio da poter essere realizzato come
istruzioni, codificate in costrutti permessi dalla sintassi del
linguaggio, dell'oggetto.

\subsection{Oggetti}\label{oggetti}

Lo stato di un oggetto è definito dai suoi attributi, i cui valori
possono essere altri oggetti già disponibili, sia definiti dall'utente
che dal linguaggio. L'interazione tra diversi oggetti avviene attraverso
i metodi, che sono funzioni associate agli oggetti che possono
modificare lo stato dell'oggetto o invocare metodi su altri oggetti.

I membri di un oggetto (attributi e metodi) possono avere diverse
limitazioni di accesso, definite dal concetto di visibilità:

\begin{itemize}
\item
  Pubblica: Gli attributi e i metodi pubblici sono accessibili da
  qualsiasi parte del programma. Questa visibilità permette a qualsiasi
  altro oggetto o funzione di interagire con questi membri.
\item
  Privata: Gli attributi e i metodi privati sono accessibili solo da
  altri membri dell'oggetto e rispondono alla esigenza di separare il
  codice di interfaccia da quello utile al funzionamento interno.
\item
  Protetta: Gli attributi e i metodi protetti sono accessibili da tutti
  i membri del medesimo oggetto ma, a differenza dei privati, anche da
  quelli degli oggetti derivati. Questo fornisce un livello intermedio
  di accesso, utile per la gestione dell'ereditarietà.
\end{itemize}

L'\textbf{incapsulamento} è il principio su cui si basa la gestione
della visibilità e guida la separazione del codice realizzante le
specificità di un oggetto, da come è fruito dagli altri oggetti. Questo
protegge l'integrità del suo stato e ne facilita la manutenzione del
codice stesso, permettendo modifiche di implementazione, senza impatti
sul codice esterno fintantoché non si cambiano i membri pubblici.
Inoltre, se ben sfruttata nella progettazione, rende il codice più
comprensibile e riduce la superficie d'attacco.

\subsection{Classi}\label{classi}

Un oggetto può essere generato da una struttura statica che ne definisce
tutte le caratteristiche, la \textbf{classe}, oppure può essere creato a
partire da un altro oggetto esistente, noto come \textbf{prototipo}.

Nella programmazione ad oggetti basata su classi, ogni oggetto è
un'istanza \emph{vivente} di una classe predefinita, che ne rappresenta
il progetto o l'archetipo. La classe definisce i membri e la visibilità,
quindi, in definitiva tutte le proprietà comuni agli oggetti dello
stesso tipo o matrice. Gli oggetti vengono creati chiamando un metodo
speciale della classe, noto come costruttore e, all'atto della loro
vita, un secondo metodo, il distruttore, che si occupa di effettuare le
azioni di terminazione.

La classe può inoltre definire metodi e attributi particolari, che
possono essere ereditati da altre classi, cioè possono essere utilizzati
da quest'ultime al pari dei propri membri. In tal modo, il linguaggio
permette la costruzioni di gerarchie di classi che modellano relazioni
di specializzazione, dalla più generale alla più particolare.

Ciò, oltre ad essere uno strumento di progettazione utile di per sé,
facilita il riuso del codice per mezzo dell'estensione, al posto della
modifica, di funzionalità. La classe che eredita da un'altra classe si
definisce \emph{derivata} dalla classe che, a sua volta, è detta
\emph{base}.

\subsection{Prototipi}\label{prototipi}

Alternativamente, alcuni linguaggi usano il concetto di prototipo, in
cui gli oggetti sono le entità principali e non esiste una matrice
separata come la classe. In questo paradigma, ogni oggetto può servire
da prototipo per altri e ciò significa che, invece di creare nuove
istanze di una classe, si creano nuovi oggetti clonando o estendendo
quelli esistenti. È possibile aggiungere o modificare proprietà e metodi
di un oggetto prototipo e, in tal caso, queste modifiche si
propagheranno in tutti gli oggetti che derivano da esso.

Il paradigma basato su prototipi offre maggiore flessibilità e dinamismo
rispetto a quello basato su classi, poiché la struttura degli oggetti
può essere modificata in modo dinamico. D'altronde, questo approccio può
anche introdurre complessità e rendere più difficile la gestione delle
gerarchie di oggetti e la comprensione del codice, poiché non esistono
strutture fisse come le classi.

\subsection{Esempi di gerarchie di classi e
prototipi}\label{esempi-di-gerarchie-di-classi-e-prototipi}

Vediamo le differenze tra classi e prototipi, riprendendo l'esempio in
Java nella versione semplificata (senza astrazione):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Animale }\OperatorTok{\{} 
    \BuiltInTok{String}\NormalTok{ nome}\OperatorTok{;}

    \FunctionTok{Animale}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{this}\OperatorTok{.}\FunctionTok{nome} \OperatorTok{=}\NormalTok{ nome}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
        \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"L\textquotesingle{}animale fa un verso"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Cane }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{} 

    \FunctionTok{Cane}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{super}\OperatorTok{(}\NormalTok{nome}\OperatorTok{);}
    \OperatorTok{\}}

    \AttributeTok{@Override}
    \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
        \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Il cane abbaia"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        Animale mioCane }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{(}\StringTok{"Fido"}\OperatorTok{);}

\NormalTok{        mioCane}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{();} 
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Implementiamo il medesimo programma in Javascript\footnote{In
  JavaScript, le classi come sintassi sono state introdotte in
  ECMAScript 6 (ES6), per semplificare la creazione di oggetti e la
  gestione dell'ereditarietà prototipale. Tuttavia, è importante capire
  che sotto il cofano, JavaScript non utilizza classi nel senso
  tradizionale come in linguaggi come Java o C++ e non esiste un
  meccanismo nativo per creare classi astratte, anche se è possibile
  simulare il comportamento delle classi astratte utilizzando varie
  tecniche. Una comune è quella di lanciare un'eccezione se un metodo
  funzionalmente astratto non viene sovrascritto nella classe derivata.},
linguaggio che usa il concetto di prototipo:

\phantomsection\label{annotated-cell-39}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ Animale }\OperatorTok{=}\NormalTok{ \{ }\hspace*{\fill}\NormalTok{\circled{1}}
    \DataTypeTok{nome}\OperatorTok{:} \StringTok{"Generic"}\OperatorTok{,}

    \DataTypeTok{init}\OperatorTok{:} \KeywordTok{function}\NormalTok{(nome) \{}
        \KeywordTok{this}\OperatorTok{.}\AttributeTok{nome} \OperatorTok{=}\NormalTok{ nome}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{,}

    \DataTypeTok{faiVerso}\OperatorTok{:} \KeywordTok{function}\NormalTok{() \{}
        \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{"L\textquotesingle{}animale fa un verso"}\NormalTok{)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{\}}\OperatorTok{;}

\KeywordTok{let}\NormalTok{ Cane }\OperatorTok{=} \BuiltInTok{Object}\OperatorTok{.}\FunctionTok{create}\NormalTok{(Animale)}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{Cane}\OperatorTok{.}\AttributeTok{faiVerso} \OperatorTok{=} \KeywordTok{function}\NormalTok{() \{ }\hspace*{\fill}\NormalTok{\circled{3}}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{"Il cane abbaia"}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}

\KeywordTok{let}\NormalTok{ mioCane }\OperatorTok{=} \BuiltInTok{Object}\OperatorTok{.}\FunctionTok{create}\NormalTok{(Cane)}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{4}}
\NormalTok{mioCane}\OperatorTok{.}\FunctionTok{init}\NormalTok{(}\StringTok{"Fido"}\NormalTok{)}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{5}}

\NormalTok{mioCane}\OperatorTok{.}\FunctionTok{faiVerso}\NormalTok{()}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{6}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Definizione dell'oggetto prototipo \texttt{Animale}.
\item[\circled{2}]
Creazione di un nuovo oggetto basato sul prototipo \texttt{Animale}.
\item[\circled{3}]
Viene creato un nuovo oggetto \texttt{Cane} basato sul prototipo
\texttt{Animale}, usando \texttt{Object.create(Animale)}. Questo
permette a \texttt{Cane} di ereditare proprietà e metodi da
\texttt{Animale}. Il metodo \texttt{faiVerso} viene sovrascritto
nell'oggetto \texttt{Cane} per specificare il comportamento da cane.
\item[\circled{4}]
Un nuovo oggetto \texttt{mioCane} viene creato basandosi sul prototipo
\texttt{Cane} usando \texttt{Object.create(Cane)}.
\item[\circled{5}]
Il metodo \texttt{init} viene chiamato per inizializzare il nome
dell'oggetto \texttt{mioCane}.
\item[\circled{6}]
Quando viene chiamato \texttt{mioCane.faiVerso()}, il metodo
sovrascritto nell'oggetto \texttt{Cane} viene eseguito, mostrando
\texttt{Il\ cane\ abbaia}.
\end{description}

\subsection{Ereditarietà}\label{ereditarietuxe0}

Come abbiamo visto, l'ereditarietà è un meccanismo che permette a una
classe di ereditare membri da un'altra classe. Essa si può presentare
singola o \textbf{multipla}, ove la prima consente a una classe derivata
di estendere solo una classe base. Questo è il modello di ereditarietà
più comune e supportato da molti linguaggi di programmazione orientati
agli oggetti, come Java e C\#.

L'ereditarietà multipla è tale da permettere a una classe di ricevere
attributi e metodi contemporaneamente da più classi base. Questo
meccanismo risponde all'esigenza di specializzare più concetti allo
stesso tempo. Va sottolineato che è uno strumento potente prono, però,
ad abusi, perché può introdurre complessità nella gestione delle
gerarchie di classi e causare conflitti quando lo stesso metodo è
ereditato da più classi, situazione nota come \emph{problema del
diamante}. Pertanto, alcuni linguaggi ne limitano l'applicazione, come
Java che consente solo l'ereditarietà multipla di interfacce, ma non di
classi. Altri, come Go, non supportano l'ereditarietà per scelta di
progettazione. Go enfatizza la composizione rispetto all'ereditarietà
per promuovere uno stile di programmazione più essenziale e flessibile.
La composizione consente di costruire comportamenti complessi aggregando
oggetti più semplici, evitando le complicazioni delle gerarchie di
classi multilivello. Il C++, invece, supporta completamente
l'ereditarietà multipla.

\subsection{Interfacce e classi
astratte}\label{interfacce-e-classi-astratte}

Le \textbf{interfacce} e le \textbf{classi astratte} sono due concetti
fondamentali nella programmazione orientata agli oggetti, che consentono
di definire contratti che le classi concrete devono rispettare.

Un'interfaccia è un contratto che specifica un insieme di metodi che una
classe deve implementare, senza fornire l'implementazione effettiva di
questi metodi. Sono utilizzate per definire comportamenti comuni che
possono essere condivisi da classi diverse, indipendentemente dalla loro
posizione nella gerarchia delle classi. Le classi che implementano
un'interfaccia devono fornire una definizione concreta per tutti i
metodi dichiarati nell'interfaccia. In Java, ad esempio, le interfacce
sono definite con la parola chiave \texttt{interface}.

Una classe astratta è una classe che non può essere istanziata
direttamente. Può contenere sia metodi astratti (senza codice al loro
interno, che devono essere implementati dalle classi derivate) sia
metodi concreti (con codice allinterno, che possono essere utilizzati
dalle classi derivate). Le classi astratte sono utilizzate per fornire
una base comune con alcune implementazioni di default e lasciare ad
altre classi il compito di completare l'implementazione. In Java, le
classi astratte sono definite con la parola chiave \texttt{abstract}.

Esempio di interfaccia, classa astratta e ereditarietà multipla in Java:

\phantomsection\label{annotated-cell-40}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{interface}\NormalTok{ Domesticazione }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
  \DataTypeTok{void} \FunctionTok{assegnaAddomesticato}\OperatorTok{(}\DataTypeTok{boolean}\NormalTok{ addomesticato}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
  \DataTypeTok{boolean} \FunctionTok{ottieniAddomesticato}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{3}}
\OperatorTok{\}}

\KeywordTok{abstract} \KeywordTok{class}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{4}}
  \BuiltInTok{String}\NormalTok{ nome}\OperatorTok{;}

  \FunctionTok{Animale}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{nome} \OperatorTok{=}\NormalTok{ nome}\OperatorTok{;}
  \OperatorTok{\}}

  \KeywordTok{abstract} \BuiltInTok{String} \FunctionTok{faiVerso}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{5}}

  \BuiltInTok{String} \FunctionTok{descrizione}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{6}}
    \ControlFlowTok{return} \StringTok{"L\textquotesingle{}animale si chiama "} \OperatorTok{+}\NormalTok{ nome}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Cane }\KeywordTok{extends}\NormalTok{ Animale }\KeywordTok{implements}\NormalTok{ Domesticazione }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{7}}
  \KeywordTok{private} \DataTypeTok{boolean}\NormalTok{ addomesticato}\OperatorTok{;} \hspace*{\fill}\NormalTok{\circled{8}}

  \FunctionTok{Cane}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{super}\OperatorTok{(}\NormalTok{nome}\OperatorTok{);}
  \OperatorTok{\}}

  \AttributeTok{@Override}
  \BuiltInTok{String} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{9}}
    \ControlFlowTok{return} \StringTok{"Il cane abbaia"}\OperatorTok{;}
  \OperatorTok{\}}

  \AttributeTok{@Override}
  \KeywordTok{public} \DataTypeTok{void} \FunctionTok{assegnaAddomesticato}\OperatorTok{(}\DataTypeTok{boolean}\NormalTok{ addomesticato}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{10}}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{addomesticato} \OperatorTok{=}\NormalTok{ addomesticato}\OperatorTok{;} 
  \OperatorTok{\}}

  \AttributeTok{@Override}
  \KeywordTok{public} \DataTypeTok{boolean} \FunctionTok{ottieniAddomesticato}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{11}}
    \ControlFlowTok{return}\NormalTok{ addomesticato}\OperatorTok{;} 
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Coccodrillo }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{12}}

  \FunctionTok{Coccodrillo}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ nome}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{super}\OperatorTok{(}\NormalTok{nome}\OperatorTok{);}
  \OperatorTok{\}}

  \AttributeTok{@Override}
  \BuiltInTok{String} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
    \ControlFlowTok{return} \StringTok{""}\OperatorTok{;}  
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Cane mioCane }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{(}\StringTok{"Fido"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{13}}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCane}\OperatorTok{.}\FunctionTok{descrizione}\OperatorTok{());} 
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCane}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{());}    

\NormalTok{    mioCane}\OperatorTok{.}\FunctionTok{assegnaAddomesticato}\OperatorTok{(}\KeywordTok{true}\OperatorTok{);} 
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Cane addomesticato: "} \OperatorTok{+} 
\NormalTok{                       mioCane}\OperatorTok{.}\FunctionTok{ottieniAddomesticato}\OperatorTok{());}

\NormalTok{    Coccodrillo mioCoccodrillo }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Coccodrillo}\OperatorTok{(}\StringTok{"Crocky"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{14}}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCoccodrillo}\OperatorTok{.}\FunctionTok{descrizione}\OperatorTok{());} 
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\NormalTok{mioCoccodrillo}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{());}   
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Interfaccia che definisce una proprietà che gli animali possono
possedere, la domesticazione. Da notare che la domesticazione è una
proprietà \emph{complementare} alle altre caratterizzanti l'animale,
addirittura non aprioristica.
\item[\circled{2}]
Metodo per impostare lo stato di addomesticamento dell'animale.
\item[\circled{3}]
Metodo per verificare se è addomesticato.
\item[\circled{4}]
Classe astratta che ha l'implementazione di una caratteristica condivisa
dalle classi derivate, \texttt{descrizione()}, e un metodo astratto per
una seconda, \texttt{faiVerso()}, che, deve essere sempre presente negli
oggetti di tipo base animale, ma non ne è comume l'implementazione.
\item[\circled{5}]
Metodo astratto.
\item[\circled{6}]
Metodo concreto.
\item[\circled{7}]
Il cane è un animale che può essere addomesticato, quindi la classe
\texttt{Cane} deriva \texttt{Animale} (cioè deve implementare
necessariamente \texttt{faiVerso()}) e implementa
\texttt{Domesticazione} (cioè deve implementare
\texttt{assegnaAddomesticato()} e \texttt{ottieniAddomesticato()}).
\texttt{descrizione()} viene ereditato colla implementazione di
\texttt{Animale}.
\item[\circled{8}]
Variabile utile a registrare se il cane è stato addomesticato.
\item[\circled{9}]
\texttt{Cane} implementa \texttt{faiVerso()} di \texttt{Animale}.
\item[\circled{10}]
\texttt{Cane} implementa \texttt{assegnaAddomesticato()} di
\texttt{Domesticazione}.
\item[\circled{11}]
\texttt{Cane} implementa \texttt{ottieniAddomesticato()} di
\texttt{Domesticazione}.
\item[\circled{12}]
Il coccodrillo non è addomesticabile, quindi, \texttt{Coccodrillo} non
implementa l'interfaccia \texttt{Domesticazione}, ma è comunque un
animale quindi deriva \texttt{Animale} e ne implementa l'unico metodo
astratto \texttt{faiVerso()}. Non essendo addomesticabile, non ha
neanche l'attributo \texttt{addomesticato}.
\item[\circled{13}]
Creazione dell'oggetto \texttt{Cane}.
\item[\circled{14}]
Creazione dell'oggetto \texttt{Coccodrillo}.
\end{description}

Le interfacce e le classi astratte sono strumenti potenti per promuovere
la riusabilità del codice e l'estensibilità dei sistemi software, poiché
permettono di definire contratti chiari e di implementare diverse
versioni di una funzionalità senza modificare il codice preesistente.

\subsection{Polimorfismo}\label{polimorfismo}

Il \textbf{polimorfismo} è un concetto chiave della programmazione
orientata agli oggetti che permette a oggetti di classi diverse di
essere trattati come oggetti di una classe comune. È uno strumento
complementare all'ereditarietà, nelle mani del programmatore, utile a
modellare comportamenti comuni per oggetti di tipi diversi, permettendo
al codice di interagire con questi oggetti senza conoscere esattamente
il loro tipo specifico. In termini pratici, il polimorfismo permette di
chiamare metodi su oggetti di tipi diversi e ottenere comportamenti
specifici a seconda del tipo di oggetto su cui viene chiamato il
medesimo metodo.

Il concetto di polimorfismo è strettamente legato all'idea di contratto
tra oggetti. Questo contratto è definito dalle interfacce o dalle classi
base e specifica quali metodi devono essere implementati dalle classi
derivate. Quando un oggetto di una classe derivata è trattato come un
oggetto della classe base o di un'interfaccia, si garantisce che esso
rispetti il contratto definito dalla classe base o dall'interfaccia.

Esistono due tipi principali di polimorfismo:

\begin{itemize}
\tightlist
\item
  Polimorfismo statico: Conosciuto soprattutto come
  \textbf{overloading}, si verifica quando più metodi nella stessa
  classe hanno lo stesso nome ma firme diverse (diverso numero o tipo di
  parametri). Il compilatore decide quale metodo chiamare in base alla
  firma del metodo.
\end{itemize}

Esempio in Java che supporta l'overloading:

\phantomsection\label{annotated-cell-41}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Esempio }\OperatorTok{\{}
  \DataTypeTok{void} \FunctionTok{stampa}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{)} \OperatorTok{\{}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Intero: "} \OperatorTok{+}\NormalTok{ a}\OperatorTok{);}
  \OperatorTok{\}}

  \DataTypeTok{void} \FunctionTok{stampa}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ a}\OperatorTok{)} \OperatorTok{\{}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Stringa: "} \OperatorTok{+}\NormalTok{ a}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Esempio es }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Esempio}\OperatorTok{();}

\NormalTok{    es}\OperatorTok{.}\FunctionTok{stampa}\OperatorTok{(}\DecValTok{5}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{    es}\OperatorTok{.}\FunctionTok{stampa}\OperatorTok{(}\StringTok{"ciao"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{2}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Chiama il metodo \texttt{stampa(int\ a)}.
\item[\circled{2}]
Chiama il metodo \texttt{stampa(String\ a)}.
\end{description}

\begin{itemize}
\tightlist
\item
  Polimorfismo dinamico: Noto come \textbf{overriding}, si verifica
  quando una classe derivata fornisce una specifica implementazione di
  un metodo già definito nella sua classe base. L'implementazione da
  chiamare è determinata a runtime, cioè a tempo di esecuzione e non
  compilazione, in base al tipo dell'oggetto.
\end{itemize}

Esempio in Java riprendendo l'esempio con gli animali:

\phantomsection\label{annotated-cell-42}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Animale }\OperatorTok{\{}
  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"L\textquotesingle{}animale fa un verso"}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Cane }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{}
  \AttributeTok{@Override}
  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Il cane abbaia"}\OperatorTok{);}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Animale mioAnimale }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{1}}

\NormalTok{    mioAnimale}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{2}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
L'oggetto \texttt{mioAnimale} è dichiarato come tipo \texttt{Animale} ma
istanziato come \texttt{Cane}. Questo è un esempio di polimorfismo.
\item[\circled{2}]
Il metodo \texttt{faiVerso()} viene chiamato sull'oggetto
\texttt{mioAnimale}, ma viene eseguita la versione del metodo
\texttt{faiVerso()} definita nella classe \texttt{Cane}, grazie al
polimorfismo.
\end{description}

Il polimorfismo è strettamente legato all'ereditarietà, poiché
l'ereditarietà è spesso il meccanismo che permette al polimorfismo di
funzionare. Quando una classe derivata estende una classe base e
sovrascrive i suoi metodi, permette agli oggetti della classe derivata
di essere trattati come oggetti della classe base ma di comportarsi in
modo specifico alla classe derivata.

I linguaggi di programmazione hanno delle differenze in relazione al
supporto del polimorfismo:

\begin{itemize}
\item
  Java: Supporta sia l'overloading che l'overriding.
\item
  C++: Supporta sia l'overloading che l'overriding. Fornisce meccanismi
  per specificare il tipo di legame (statico o dinamico) usando parole
  chiave come \texttt{virtual}.
\item
  Python: Supporta l'overriding, ma non l'overloading nello stesso senso
  di Java o C++. Python permette la definizione di metodi con argomenti
  predefiniti o argomenti variabili per ottenere un effetto simile
  all'overloading.
\end{itemize}

Esempio in Java da confrontare con quello seguente in Python:

\phantomsection\label{annotated-cell-43}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Animale }\OperatorTok{\{}
  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{1}}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"L\textquotesingle{}animale fa un verso"}\OperatorTok{);} 
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ Cane }\KeywordTok{extends}\NormalTok{ Animale }\OperatorTok{\{}
  \AttributeTok{@Override}
  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{()} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{2}}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Il cane abbaia"}\OperatorTok{);} 
  \OperatorTok{\}}

  \DataTypeTok{void} \FunctionTok{faiVerso}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ suono}\OperatorTok{)} \OperatorTok{\{} \hspace*{\fill}\NormalTok{\circled{3}}
    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Il cane fa: "} \OperatorTok{+}\NormalTok{ suono}\OperatorTok{);} 
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Main }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Animale mioAnimale }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{4}}
\NormalTok{    mioAnimale}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{();} \hspace*{\fill}\NormalTok{\circled{5}}

\NormalTok{    Cane mioCane }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cane}\OperatorTok{();}
\NormalTok{    mioCane}\OperatorTok{.}\FunctionTok{faiVerso}\OperatorTok{(}\StringTok{"bau"}\OperatorTok{);} \hspace*{\fill}\NormalTok{\circled{6}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Metodo \texttt{faiVerso()} definito nella classe base \texttt{Animale}.
\item[\circled{2}]
Overriding del metodo \texttt{faiVerso()} nella classe derivata
\texttt{Cane}.
\item[\circled{3}]
Overloading del metodo \texttt{faiVerso()} nella classe derivata
\texttt{Cane}.
\item[\circled{4}]
Dichiarazione di un oggetto di tipo \texttt{Animale}, ma istanziato come
\texttt{Cane}.
\item[\circled{5}]
Chiamata al metodo \texttt{faiVerso()}, che esegue la versione del
metodo nella classe \texttt{Cane} grazie al polimorfismo.
\item[\circled{6}]
Chiamata al metodo \texttt{faiVerso(String\ suono)}, che dimostra
l'overloading del metodo nella classe \texttt{Cane}.
\end{description}

E in Python diventa:

\phantomsection\label{annotated-cell-44}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Animale:}
  \KeywordTok{def}\NormalTok{ fai\_verso(}\VariableTok{self}\NormalTok{): }\hspace*{\fill}\NormalTok{\circled{1}}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"L\textquotesingle{}animale fa un verso"}\NormalTok{)  }

\KeywordTok{class}\NormalTok{ Cane(Animale):}
  \KeywordTok{def}\NormalTok{ fai\_verso(}\VariableTok{self}\NormalTok{): }\hspace*{\fill}\NormalTok{\circled{2}}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Il cane abbaia"}\NormalTok{)  }

  \KeywordTok{def}\NormalTok{ fai\_verso\_con\_suono(}\VariableTok{self}\NormalTok{, suono): }\hspace*{\fill}\NormalTok{\circled{3}}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Il cane fa: }\SpecialCharTok{\{}\NormalTok{suono}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)  }

\NormalTok{mio\_animale }\OperatorTok{=}\NormalTok{ Cane() }\hspace*{\fill}\NormalTok{\circled{4}}
\NormalTok{mio\_animale.fai\_verso() }\hspace*{\fill}\NormalTok{\circled{5}}

\NormalTok{mio\_cane }\OperatorTok{=}\NormalTok{ Cane()}
\NormalTok{mio\_cane.fai\_verso\_con\_suono(}\StringTok{"bau"}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{6}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Metodo \texttt{fai\_verso()} definito nella classe base
\texttt{Animale}.
\item[\circled{2}]
Overriding del metodo \texttt{fai\_verso()} nella classe derivata
\texttt{Cane}.
\item[\circled{3}]
Definizione di un metodo aggiuntivo \texttt{fai\_verso\_con\_suono}
nella classe derivata \texttt{Cane} (Python non supporta l'overloading
nello stesso senso di Java).
\item[\circled{4}]
Dichiarazione e istanziazione di un oggetto \texttt{mio\_animale} come
\texttt{Cane}.
\item[\circled{5}]
Chiamata al metodo \texttt{fai\_verso()}, che esegue la versione del
metodo nella classe \texttt{Cane} grazie al polimorfismo.
\item[\circled{6}]
Chiamata al metodo \texttt{fai\_verso\_con\_suono(suono)}, che dimostra
una forma di polimorfismo simile all'overloading in Python.
\end{description}

L'overriding è possibile grazie al \textbf{dynamic dispatch}, un
meccanismo che consente di selezionare a runtime il metodo corretto da
invocare in base al tipo effettivo dell'oggetto. Lo \textbf{static
disptach}, al contrario, avviene al tempo di compilazione.

Ma il dispatch, cioè l'individuazione del metodo da eseguire, può essere
singolo (\textbf{single dispatch}), così come presente nella maggior
parte dei linguaggi orientati agli oggetti come Java e C++, e dove la
scelta del metodo dipende solo dal tipo dell'oggetto sul quale il metodo
stesso viene chiamato. Questo tipo di dispatch è sufficiente per
supportare il polimorfismo detto di \emph{sottotipo}, dove le classi
derivate possono sovrascrivere i metodi della classe base e il metodo
corretto viene selezionato a runtime in base al tipo effettivo
dell'oggetto.

Il \textbf{multiple dispatch}, invece, estende ulteriormente le capacità
del polimorfismo permettendo la selezione del metodo da invocare
basandosi sui tipi runtime di più di un argomento. Questo è
particolarmente utile in scenari dove il comportamento dipende da
combinazioni di tipi di oggetti, e non solo dal tipo dell'oggetto su cui
il metodo è chiamato. Linguaggi come Julia e CLOS (Common Lisp Object
System)supportano nativamente il multiple dispatch, mentre linguaggi
come Java e C++ non lo supportano direttamente ma possono emularlo
attraverso pattern come il \emph{visitor}.

\subsection{Altri concetti}\label{altri-concetti}

Dopo aver compreso i concetti fondamentali della programmazione
orientata agli oggetti (OOP), come oggetti, classi, prototipi,
ereditarietà e polimorfismo, è importante esplorare altri aspetti
avanzati che contribuiscono alla potenza e alla flessibilità di questo
paradigma.

\subsubsection{Mixin e trait}\label{mixin-e-trait}

I \textbf{mixin} e i \textbf{trait} sono concetti che permettono di
aggiungere funzionalità a una classe senza utilizzare l'ereditarietà
classica.

I mixin sono classi che offrono metodi che possono essere utilizzati da
altre classi senza essere una classe base di queste ultime. Permettono
di combinare comportamenti comuni tra diverse classi.

Esempio:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ MixinA:}
    \KeywordTok{def}\NormalTok{ metodo\_a(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Metodo A"}\NormalTok{)}

\KeywordTok{class}\NormalTok{ MixinB:}
    \KeywordTok{def}\NormalTok{ metodo\_b(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Metodo B"}\NormalTok{)}

\KeywordTok{class}\NormalTok{ ClasseConMixin(MixinA, MixinB):}
    \ControlFlowTok{pass}

\NormalTok{obj }\OperatorTok{=}\NormalTok{ ClasseConMixin()}
\NormalTok{obj.metodo\_a()}
\NormalTok{obj.metodo\_b()}
\end{Highlighting}
\end{Shaded}

I trait sono simili ai mixin e permettono di definire metodi che possono
essere riutilizzati in diverse classi. Sono supportati nativamente in
linguaggi come Scala e Rust.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait}\NormalTok{ TraitA }\OperatorTok{\{}
    \KeywordTok{def} \FunctionTok{metodoA}\OperatorTok{():} \BuiltInTok{Unit} \OperatorTok{=} \FunctionTok{println}\OperatorTok{(}\StringTok{"Metodo A"}\OperatorTok{)}
\OperatorTok{\}}

\KeywordTok{trait}\NormalTok{ TraitB }\OperatorTok{\{}
    \KeywordTok{def} \FunctionTok{metodoB}\OperatorTok{():} \BuiltInTok{Unit} \OperatorTok{=} \FunctionTok{println}\OperatorTok{(}\StringTok{"Metodo B"}\OperatorTok{)}
\OperatorTok{\}}

\KeywordTok{class}\NormalTok{ ClasseConTrait }\KeywordTok{extends}\NormalTok{ TraitA }\KeywordTok{with}\NormalTok{ TraitB}

\KeywordTok{val}\NormalTok{ obj }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ClasseConTrait}\OperatorTok{()}
\NormalTok{obj}\OperatorTok{.}\FunctionTok{metodoA}\OperatorTok{()}
\NormalTok{obj}\OperatorTok{.}\FunctionTok{metodoB}\OperatorTok{()}
\end{Highlighting}
\end{Shaded}

\subsubsection{Duck Typing}\label{duck-typing}

Il \textbf{duck typing} è un concetto che si applica principalmente nei
linguaggi dinamici, dove l'importanza è data al comportamento degli
oggetti piuttosto che alla loro appartenenza a una specifica classe. Se
un oggetto implementa i metodi richiesti da una certa operazione, allora
può essere utilizzato per quella operazione, indipendentemente dal suo
tipo.

Esempio:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Anatra:}
    \KeywordTok{def}\NormalTok{ quack(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Quack!"}\NormalTok{)}

\KeywordTok{class}\NormalTok{ Persona:}
    \KeywordTok{def}\NormalTok{ quack(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Sono una persona che imita un\textquotesingle{}anatra"}\NormalTok{)}

\KeywordTok{def}\NormalTok{ fai\_quack(oggetto):}
\NormalTok{    oggetto.quack()}

\NormalTok{anatra }\OperatorTok{=}\NormalTok{ Anatra()}
\NormalTok{persona }\OperatorTok{=}\NormalTok{ Persona()}

\NormalTok{fai\_quack(anatra)}
\NormalTok{fai\_quack(persona)}
\end{Highlighting}
\end{Shaded}

\chapter{Altri concetti semantici}\label{altri-concetti-semantici}

Dopo aver esplorato variabili, funzioni e oggetti, ci sono altri
concetti semantici essenziali nei linguaggi di programmazione che
completano la comprensione del comportamento dei programmi. Questi
concetti includono la concorrenza, l'input/output (I/O), le annotazioni
e i metadati, e le macro e la metaprogrammazione.

\section{Concorrenza}\label{concorrenza}

La concorrenza è la capacità di un programma di eseguire più sequenze di
istruzioni in parallelo, migliorando le prestazioni e la reattività. La
concorrenza è particolarmente utile in applicazioni che richiedono
l'elaborazione simultanea di compiti indipendenti, come server web,
sistemi di gestione di basi di dati e applicazioni interattive.

Un concetto fondamentale della concorrenza è il \textbf{thread}, che
rappresenta la più piccola unità di elaborazione eseguibile in modo
indipendente. I thread permettono l'esecuzione parallela di codice
all'interno di un programma, ma introducono la necessità di gestire
l'accesso concorrente alle risorse condivise.

La \textbf{sincronizzazione} è essenziale per evitare condizioni di
gara, che si verificano quando il risultato dell'esecuzione dipende
dalla sequenza temporale in cui i thread accedono alle risorse.
Meccanismi come i \textbf{lock} e i \textbf{mutex} garantiscono che solo
un thread alla volta possa accedere a una risorsa condivisa, prevenendo
conflitti e garantendo la consistenza dei dati.

In linguaggi moderni, come Python e JavaScript, la gestione delle
operazioni asincrone è facilitata da costrutti come
\textbf{async/await}. Questi costrutti migliorano l'efficienza e la
reattività delle applicazioni, permettendo di eseguire operazioni di I/O
senza bloccare il thread principale.

\section{Input/Output (I/O)}\label{inputoutput-io}

L'input/output (I/O) gestisce la comunicazione tra un programma e il suo
ambiente esterno. Il \textbf{File I/O} permette la lettura e la
scrittura su file, consentendo di memorizzare e recuperare dati
persistenti. In molti linguaggi, come C e Python, le operazioni di file
I/O sono supportate da funzioni o metodi che aprono, leggono, scrivono e
chiudono file.

Il \textbf{Network I/O} facilita la comunicazione tra sistemi diversi
attraverso reti, consentendo di inviare e ricevere dati tra computer.
Linguaggi come Java e Python offrono librerie per la gestione delle
connessioni di rete, il trasferimento di dati e la comunicazione tra
client e server.

Lo \textbf{Standard I/O} comprende l'interazione con l'utente tramite
input da tastiera e output su schermo. In C, funzioni come
\texttt{scanf} e \texttt{printf} gestiscono lo standard I/O, mentre in
Python si utilizzano \texttt{input} e \texttt{print}.

\section{Annotazioni e Metadati}\label{annotazioni-e-metadati}

Le annotazioni e i metadati forniscono informazioni aggiuntive al
compilatore o al runtime, influenzando il comportamento del programma o
fornendo dettagli utili per la documentazione e l'analisi del codice.

Le \textbf{annotazioni} sono utilizzate per specificare comportamenti
speciali o configurazioni. In Java, le annotazioni come
\texttt{@Deprecated} indicano che un metodo è obsoleto,
\texttt{@Override} segnala che un metodo sovrascrive un metodo della
superclasse, e \texttt{@Entity} e \texttt{@Table} in JPA (Jakarta
Persistence) definiscono la relazione tra entità e tabelle nel contesto
di un database. In Python, le annotazioni dei tipi (type hint) indicano
i tipi delle variabili, dei parametri di funzione e dei valori di
ritorno, migliorando la leggibilità e facilitando il type checking
automatico.

Le \textbf{docstring} in Python sono commenti strutturati che
documentano il codice. Utilizzate per descrivere moduli, classi, metodi
e funzioni, le docstring rendono il codice più leggibile e comprensibile
e possono essere utilizzate per generare documentazione automatica.

\section{Macro e Metaprogrammazione}\label{macro-e-metaprogrammazione}

Le macro e la metaprogrammazione permettono di scrivere codice che
manipola altre porzioni di codice, migliorando la flessibilità e il
riutilizzo.

Le \textbf{macro} sono sequenze di istruzioni predefinite che possono
essere inserite nel codice durante la fase di precompilazione. In C, le
macro sono utilizzate con il preprocessore per definire costanti,
funzioni inline e codice condizionale. Le macro permettono di evitare la
duplicazione di codice, ma possono anche introdurre complessità e
difficoltà di debug.

La \textbf{metaprogrammazione} consiste nello scrivere codice che genera
o modifica altre parti del codice a runtime o a compile-time. In Python,
la metaprogrammazione include l'uso di decoratori, che sono funzioni che
modificano il comportamento di altre funzioni, e metaclassi, che
permettono di controllare la creazione e il comportamento delle classi.
L'introspezione, che consente di esaminare gli oggetti durante
l'esecuzione del programma, è un'altra potente tecnica di
metaprogrammazione.

\part{Seconda parte: Le basi di Python}

\chapter{Introduzione a Python}\label{introduzione-a-python}

Python è un linguaggio di programmazione multiparadigma, cioè abilita o
supporta più paradigmi di programmazione, e multipiattaforma, potendo
essere installato e utilizzato su gran parte dei sistemi operativi e
hardware.

La storia di Python inizia colla pubblicazione del codice sorgente, da
parte del suo creatore Guido van Rossum, nel 1991, nella versione 0.9.0.
Circa tre anni, nel 1994, raggiungerà la prima versione definitiva,
quindi nove anni dopo il C++ e un anno prima di PHP e due rispetto a
Java.

Python offre una combinazione unica di eleganza, semplicità, praticità e
versatilità. Questa eleganza e semplicità derivano dal fatto che è stato
progettato per essere molto simile al linguaggio naturale inglese,
rendendo il codice leggibile e comprensibile. La sintassi di Python è
pulita e minimalista, evitando simboli superflui come parentesi graffe e
punti e virgola, e utilizzando indentazioni per definire blocchi di
codice, il che forza una struttura coerente e essenziale. La semantica
del linguaggio è intuitiva e coerente, il che riduce la curva di
apprendimento e minimizza gli errori, anche per programmatori non
professionali.

Python è gestito dalla Python Software Foundation (PSF),
un'organizzazione no-profit che si occupa dello sviluppo e della
promozione del linguaggio. Il sito ufficiale di Python,
\href{https://www.python.org}{python.org}, è la risorsa principale dove
è possibile trovare la documentazione ufficiale, scaricare il
linguaggio, e accedere a tutorial, guide e altre risorse utili.

Il processo di aggiornamento di Python è trasparente e comunitario. Le
proposte di miglioramento del linguaggio vengono discusse attraverso le
\emph{Python Enhancement Proposals} (proposte di aggiornamento di
Python, PEP), documenti di design che forniscono informazioni alle
comunità di Python su nuove funzionalità proposte, miglioramenti al
linguaggio e altre questioni correlate. Le PEP vengono valutate e
accettate da un comitato di sviluppo centrale.

Python è distribuito sotto la Python Software Foundation License, una
licenza open-source che consente l'uso, la modifica e la distribuzione
del linguaggio senza costi. Questa licenza garantisce che Python rimanga
libero e accessibile a tutti, permettendo l'uso commerciale e non
commerciale. Per quanto riguarda i documenti e la documentazione, essi
sono generalmente distribuiti sotto la licenza Creative Commons
Attribution-NonCommercial-ShareAlike (CC BY-NC-SA), che consente di
condividere e adattare il materiale, purché venga attribuito
correttamente, non sia utilizzato per scopi commerciali e sia
distribuito con la stessa licenza.

Tecnicamente, Python è un linguaggio interpretato e dinamico. Essere
interpretato significa che il codice sorgente di Python viene eseguito
direttamente dall'interprete, senza la necessità di una fase di
compilazione separata. Questo offre vantaggi come la facilità di
esecuzione del codice e il supporto per il debugging interattivo, ma può
comportare una velocità di esecuzione inferiore rispetto ai linguaggi
compilati.

Essere dinamico significa che molti aspetti del linguaggio, come i tipi
delle variabili, vengono determinati a runtime piuttosto che a
compile-time. Questo consente una maggiore flessibilità e facilita lo
sviluppo rapido, poiché non è necessario dichiarare esplicitamente i
tipi di variabili. Tuttavia, questo approccio può anche portare a errori
di tipo che vengono rilevati solo durante l'esecuzione del programma.

Diventerai rapidamente produttivo con Python grazie alla sua coerenza e
regolarità, alla sua ricca libreria standard e ai numerosi pacchetti e
strumenti di terze parti prontamente disponibili. Python è facile da
imparare, quindi è molto adatto se sei nuovo alla programmazione, ma è
anche potente abbastanza per i più sofisticati esperti. Questa
semplicità ha attratto una comunità ampia e attiva che ha contribuito
sia alle librerie di programmi incluse nell'implementazione ufficiale,
che a molte librerie scaricabili liberamente, ampliando ulteriormente
l'ecosistema di Python.

\section{Perché Python è un linguaggio di alto
livello?}\label{perchuxe9-python-uxe8-un-linguaggio-di-alto-livello}

Python è considerato un linguaggio di programmazione di alto livello,
cioè utilizza un livello di astrazione elevato rispetto alla complessità
dell'ambiente in cui i suoi programmi sono eseguiti. Il programmatore ha
a disposizione una sintassi che è più intuitiva rispetto ad altri
linguaggi come Java, C++, PHP tradizionalmente anch'essi definiti di
alto livello.

Infatti, consente ai programmatori di scrivere codice in modo più
concettuale e indipendente dalle caratteristiche degli hardware, anche
molto diversi, su cui è disponibile. Ad esempio, invece di preoccuparsi
di allocare e deallocare memoria manualmente, Python gestisce queste
operazioni automaticamente. Questo libera il programmatore dai dettagli
del sistema operativo e dell'elettronica, permettendogli di concentrarsi
sulla logica del problema da risolvere.

Ciò ha un effetto importante sulla versatilità perché spesso è
utilizzato come \emph{interfaccia utente} per linguaggi di livello più
basso come C, C++ o Fortran. Questo permette a Python di sfruttare le
prestazioni dei linguaggi compilati per le parti critiche e
computazionalmente intensive del codice, mantenendo al contempo una
sintassi semplice e leggibile per la maggior parte del programma. Buoni
compilatori per i linguaggi compilati classici possono sì generare
codice binario che gira più velocemente di Python, tuttavia, nella
maggior parte dei casi, le prestazioni delle applicazioni codificate in
Python sono sufficienti.

\section{Python come linguaggio
multiparadigma}\label{python-come-linguaggio-multiparadigma}

Python è un linguaggio di programmazione multiparadigma, il che
significa che supporta diversi paradigmi di programmazione, permettendo
di mescolare e combinare gli stili a seconda delle necessità
dell'applicazione. Ecco alcuni dei paradigmi supportati da Python:

\begin{itemize}
\item
  Programmazione imperativa: Puoi scrivere ed eseguire script Python
  direttamente dalla linea di comando, permettendo un approccio
  interattivo e immediato alla programmazione, come se fosse una
  calcolatrice.
\item
  Programmazione procedurale: In Python, è possibile organizzare il
  codice in funzioni e moduli, rendendo più semplice la gestione e la
  riutilizzabilità del codice. Puoi raccogliere il codice in file
  separati e importarli come moduli, migliorando la struttura e la
  leggibilità del programma.
\item
  Programmazione orientata agli oggetti: Python supporta pienamente la
  programmazione orientata agli oggetti, consentendo la definizione di
  classi e oggetti. Questo paradigma è utile per modellare dati
  complessi e relazioni tra essi. Le caratteristiche orientate agli
  oggetti di Python sono concettualmente simili a quelle del C++, ma più
  semplici da usare.
\item
  Programmazione funzionale: Python include funzionalità di
  programmazione funzionale, come funzioni di prima classe e di ordine
  superiore, lambda e strumenti come \texttt{map}, \texttt{filter} e
  \texttt{reduce}.
\end{itemize}

Questa flessibilità rende Python adatto a una vasta gamma di
applicazioni e consente ai programmatori di scegliere l'approccio più
adatto al problema da risolvere.

\section{Regole formali e
esperienziali}\label{regole-formali-e-esperienziali}

Python non è solo un linguaggio con regole sintattiche precise e ben
progettate, ma possiede anche una propria filosofia, un insieme di
regole di buon senso esperienziali che sono complementari alla sintassi
formale. Questa filosofia è spesso riassunta nel \textbf{zen di Python},
una raccolta di aforismi che catturano i principi fondamentali del
design di Python. Tali principi aiutano i programmatori a comprendere e
utilizzare al meglio le potenzialità del linguaggio e dell'ecosistema
Python.

Ecco alcuni dei principi dello zen di Python\footnote{\href{https://peps.python.org/pep-0020/}{PEP
  20 -- The Zen of Python}}:

\begin{itemize}
\item
  La leggibilità conta: Il codice dovrebbe essere scritto in modo che
  sia facile da leggere e comprendere.
\item
  Esplicito è meglio di implicito: È preferibile scrivere codice chiaro
  e diretto piuttosto che utilizzare scorciatoie criptiche.
\item
  Semplice è meglio di complesso: Il codice dovrebbe essere il più
  semplice possibile per risolvere il problema.
\item
  Complesso è meglio di complicato: Quando la semplicità non è
  sufficiente, la complessità è accettabile, ma il codice non dovrebbe
  mai essere complicato.
\item
  Pratico batte puro: Le soluzioni pragmatiche sono preferibili alle
  soluzioni eleganti ma poco pratiche.
\end{itemize}

Questi principi, insieme alle regole sintattiche, guidano il
programmatore nell'adottare buone pratiche di sviluppo e nel creare
codice che sia non solo funzionale ma anche mantenibile e comprensibile
da altri.

\section{L'ecosistema}\label{lecosistema}

Fino ad ora abbiamo visto Python come linguaggio, ma è molto di più:
Python è anche una vasta collezione di strumenti e risorse a
disposizione degli sviluppatori, strutturata in un ecosistema completo,
di cui il linguaggio ne rappresenta la parte formale. Questo ecosistema
è disponibile completamente, anche come sorgente, sul sito ufficiale
\href{https://www.python.org/}{python.org}.

\subsection{L'interprete}\label{linterprete}

L'interprete Python è lo strumento di esecuzione dei programmi. È il
software che legge ed esegue il codice Python. Python è un linguaggio
interpretato, il che significa che il codice viene eseguito direttamente
dall'interprete, senza bisogno di essere compilato in un linguaggio
macchina. Esistono diverse implementazioni dell'interprete Python:

\begin{itemize}
\item
  \textbf{CPython}: L'implementazione di riferimento dell'interprete
  Python, scritta in C. È la versione più utilizzata e quella ufficiale.
\item
  PyPy: Un interprete alternativo che utilizza tecniche di compilazione
  just-in-time (JIT) per migliorare le prestazioni.
\item
  Jython: Un'implementazione di Python che gira sulla JVM (Java Virtual
  Machine).
\item
  IronPython: Un'implementazione di Python integrata col .NET Framework
  della Microsoft.
\end{itemize}

\subsection{L'ambiente di sviluppo}\label{lambiente-di-sviluppo}

IDLE (integrated development and learning environment) è l'ambiente di
sviluppo integrato ufficiale per Python. È incluso nell'installazione
standard di Python ed è progettato per essere semplice e facile da
usare, ideale per i principianti. Offre diverse funzionalità utili:

\begin{itemize}
\item
  Editor di codice: Con evidenziazione della sintassi, indentazione
  automatica e controllo degli errori.
\item
  Shell interattiva: Permette di eseguire codice Python in modo
  interattivo.
\item
  Strumenti di debug: Include un debugger integrato con punti di
  interruzione e stepping.
\end{itemize}

\subsection{Le librerie standard}\label{le-librerie-standard}

Una delle caratteristiche più potenti di Python è il vasto insieme di
librerie\footnote{\href{https://docs.python.org/3/library/index.html}{Documentazione
  delle librerie standard di Python}} utilizzabili in CPython e IDLE,
che fornisce moduli e pacchetti per quasi ogni necessità di
programmazione. Alcuni esempi, tra le decine e al solo allo scopo di
illustrarne la varietà, includono:

\begin{itemize}
\item
  \texttt{os}: Fornisce funzioni per interagire con il sistema
  operativo.
\item
  \texttt{sys}: Offre accesso a funzioni e oggetti del runtime di
  Python.
\item
  \texttt{datetime}: Consente di lavorare con date e orari.
\item
  \texttt{json}: Permette di leggere e scrivere dati in formato JSON.
\item
  \texttt{re}: Supporta la manipolazione di stringhe tramite espressioni
  regolari.
\item
  \texttt{http}: Include moduli per l'implementazione di client e server
  HTTP.
\item
  \texttt{unittest}: Fornisce un framework per il testing del codice.
\item
  \texttt{math} e \texttt{cmath}: Contengono funzioni matematiche di
  base e complesse.
\item
  \texttt{itertools}, \texttt{functools}, \texttt{operator}: Offrono
  supporto per il paradigma di programmazione funzionale.
\item
  \texttt{csv}: Gestisce la lettura e scrittura di file CSV.
\item
  \texttt{typing}: Fornisce supporto per l'annotazione dei tipi di
  variabili, funzioni e classi.
\item
  \texttt{email}: Permette di creare, gestire e inviare email,
  facilitando la manipolazione di messaggi email MIME.
\item
  \texttt{hashlib}: Implementa algoritmi di hash sicuri come SHA-256 e
  MD5.
\item
  \texttt{asyncio}: Supporta la programmazione asincrona per la
  scrittura di codice concorrente e a bassa latenza.
\item
  \texttt{wave}: Fornisce strumenti per leggere e scrivere file audio
  WAV.
\end{itemize}

\subsection{Moduli di estensione}\label{moduli-di-estensione}

Python supporta l'estensione del suo core tramite moduli scritti in C,
C++ o altri linguaggi. Questi moduli permettono di ottimizzare parti
critiche del codice o di interfacciarsi con librerie e API esterne:

\begin{itemize}
\item
  \textbf{Cython}: Permette di scrivere moduli C estesi utilizzando una
  sintassi simile a Python. Cython è ampiamente utilizzato per
  migliorare le prestazioni di parti critiche del codice, specialmente
  in applicazioni scientifiche e di calcolo numerico. Ad esempio, molte
  librerie scientifiche popolari come SciPy e scikit-learn utilizzano
  Cython per accelerare le operazioni computazionalmente intensive.
\item
  \textbf{ctypes}: Permette di chiamare funzioni in librerie dinamiche C
  direttamente da Python. È utile per interfacciarsi con librerie
  esistenti scritte in C, rendendo Python estremamente versatile per
  l'integrazione con altre tecnologie. Ciò è utile in applicazioni che
  devono interfacciarsi con hardware specifico o utilizzare librerie
  legacy.
\item
  \textbf{CFFI} (C Foreign Function Interface): Un'altra interfaccia per
  chiamare librerie C da Python. È progettata per essere facile da usare
  e per supportare l'uso di librerie C complesse con Python. CFFI è
  utilizzato in progetti come PyPy e gevent, permettendo di scrivere
  codice ad alte prestazioni e di gestire le chiamate a funzioni C in
  modo efficiente.
\end{itemize}

\subsection{Utility e strumenti
aggiuntivi}\label{utility-e-strumenti-aggiuntivi}

Python include anche una serie di strumenti e utility che facilitano lo
sviluppo e la gestione dei progetti:

\begin{itemize}
\item
  \textbf{pip}: Il gestore dei pacchetti di Python. Permette di
  installare e gestire moduli aggiuntivi, cioè non inclusi nello
  standard.
\item
  \textbf{venv}: Uno strumento per creare ambienti virtuali isolati, che
  permettono di gestire separatamente le dipendenze di diversi progetti.
\item
  Documentazione: Python include una documentazione dettagliata,
  accessibile tramite il comando pydoc o attraverso il sito ufficiale.
\end{itemize}

\section{L'algoritmo di ordinamento bubble
sort}\label{lalgoritmo-di-ordinamento-bubble-sort}

Per chiudere il capitolo sul primo approccio a Python, possiamo
confrontare un algoritmo, di bassa complessità ma non triviale, in
diversi linguaggi di programmazione. Un buon esempio potrebbe essere
l'implementazione dell'algoritmo di ordinamento \emph{bubble sort} di
una lista di valori. Vediamo come viene scritto in Python, C, C++, Java,
Rust e Scala:

\begin{itemize}
\item
  Python in versione procedurale:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bubble\_sort(arr):}
\NormalTok{  n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
      \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{]:}
\NormalTok{        arr[j], arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{], arr[j]}

\CommentTok{\# Esempio di utilizzo}
\NormalTok{arr }\OperatorTok{=}\NormalTok{ [}\DecValTok{64}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{90}\NormalTok{]}

\NormalTok{bubble\_sort(arr)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Array ordinato con bubble sort: "}\NormalTok{, arr)}
\end{Highlighting}
\end{Shaded}
\item
  Python in versione sintatticamente orientata agli oggetti, ma
  praticamente procedurale:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ BubbleSort:}
  \AttributeTok{@staticmethod}
  \KeywordTok{def}\NormalTok{ bubble\_sort(arr):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr)}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
      \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
        \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{]:}
\NormalTok{          arr[j], arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{], arr[j]}

\CommentTok{\# Esempio di utilizzo}
\NormalTok{arr }\OperatorTok{=}\NormalTok{ [}\DecValTok{64}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{90}\NormalTok{]}

\NormalTok{BubbleSort.bubble\_sort(arr)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Array ordinato con bubble sort: "}\NormalTok{, arr)}
\end{Highlighting}
\end{Shaded}
\item
  Python in versione orientata agli oggetti, con una interfaccia di
  ordinamento implementata con due algoritmi (bubble e insertion sort):

\phantomsection\label{annotated-cell-129}%
\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ abc }\ImportTok{import}\NormalTok{ ABC, abstractmethod }\hspace*{\fill}\NormalTok{\circled{1}}

\CommentTok{\# Classe astratta per algoritmi di ordinamento}
\KeywordTok{class}\NormalTok{ SortAlgorithm(ABC): }\hspace*{\fill}\NormalTok{\circled{2}}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, arr):}
    \VariableTok{self}\NormalTok{.\_arr }\OperatorTok{=}\NormalTok{ arr}

  \AttributeTok{@abstractmethod}
  \KeywordTok{def}\NormalTok{ sort(}\VariableTok{self}\NormalTok{): }\hspace*{\fill}\NormalTok{\circled{3}}
    \CommentTok{\# Metodo astratto che deve essere implementato dalle sottoclassi}
    \ControlFlowTok{pass}

  \KeywordTok{def}\NormalTok{ get\_array(}\VariableTok{self}\NormalTok{):}
    \CommentTok{\# Metodo per ottenere l\textquotesingle{}array corrente}
    \ControlFlowTok{return} \VariableTok{self}\NormalTok{.\_arr}

  \KeywordTok{def}\NormalTok{ set\_array(}\VariableTok{self}\NormalTok{, arr):}
    \CommentTok{\# Metodo per impostare un nuovo array}
    \VariableTok{self}\NormalTok{.\_arr }\OperatorTok{=}\NormalTok{ arr}

\CommentTok{\# Implementazione dell\textquotesingle{}algoritmo di bubble sort}
\KeywordTok{class}\NormalTok{ BubbleSort(SortAlgorithm): }\hspace*{\fill}\NormalTok{\circled{4}}
  \KeywordTok{def}\NormalTok{ sort(}\VariableTok{self}\NormalTok{):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.\_arr)}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
      \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
        \ControlFlowTok{if} \VariableTok{self}\NormalTok{.\_arr[j] }\OperatorTok{\textgreater{}} \VariableTok{self}\NormalTok{.\_arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{]:}
          \VariableTok{self}\NormalTok{.\_arr[j], }\VariableTok{self}\NormalTok{.\_arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{], }\VariableTok{self}\NormalTok{.\_arr[j]}

\CommentTok{\# Implementazione dell\textquotesingle{}algoritmo di insertion sort}
\KeywordTok{class}\NormalTok{ InsertionSort(SortAlgorithm):}
  \KeywordTok{def}\NormalTok{ sort(}\VariableTok{self}\NormalTok{):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.\_arr)):}
\NormalTok{      key }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_arr[i]}

\NormalTok{      j }\OperatorTok{=}\NormalTok{ i }\OperatorTok{{-}} \DecValTok{1}

      \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textgreater{}=} \DecValTok{0} \KeywordTok{and}\NormalTok{ key }\OperatorTok{\textless{}} \VariableTok{self}\NormalTok{.\_arr[j]:}
        \VariableTok{self}\NormalTok{.\_arr[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=} \VariableTok{self}\NormalTok{.\_arr[j]}

\NormalTok{        j }\OperatorTok{{-}=} \DecValTok{1}

      \VariableTok{self}\NormalTok{.\_arr[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ key}

\CommentTok{\# Esempio di utilizzo con bubble sort}
\NormalTok{arr }\OperatorTok{=}\NormalTok{ [}\DecValTok{64}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{90}\NormalTok{]}

\NormalTok{bubble\_sorter }\OperatorTok{=}\NormalTok{ BubbleSort(arr)}

\NormalTok{bubble\_sorter.sort()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Array ordinato con bubble sort: "}\NormalTok{, bubble\_sorter.get\_array())}

\CommentTok{\# Esempio di utilizzo con insertion sort}
\NormalTok{arr }\OperatorTok{=}\NormalTok{ [}\DecValTok{64}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{90}\NormalTok{]}

\NormalTok{insertion\_sorter }\OperatorTok{=}\NormalTok{ InsertionSort(arr)}

\NormalTok{insertion\_sorter.sort()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Array ordinato con insertion sort: "}\NormalTok{, insertion\_sorter.get\_array())}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Importiamo \texttt{ABC} e \texttt{abstractmethod} dal modulo
  \texttt{abc} per definire la classe astratta.
  \item[\circled{2}]
  \texttt{SortAlgorithm} è una classe astratta che rappresenta
  l'interfaccia di algoritmi di ordinamento.
  \item[\circled{3}]
  \texttt{sort} è un metodo astratto che deve essere implementato nelle
  sottoclassi.
  \item[\circled{4}]
  \texttt{BubbleSort} è una sottoclasse di \texttt{SortAlgorithm} che
  implementa l'algoritmo di ordinamento a bolle. Idem per
  \texttt{InsertionSort}.
  \end{description}
\item
  Python in versione funzionale:

\phantomsection\label{annotated-cell-130}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bubble\_sort(arr):}
  \KeywordTok{def}\NormalTok{ sort\_pass(arr, n): }\hspace*{\fill}\NormalTok{\circled{1}}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
      \ControlFlowTok{return}\NormalTok{ arr}

\NormalTok{    new\_arr }\OperatorTok{=}\NormalTok{ arr[:] }\hspace*{\fill}\NormalTok{\circled{2}}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{):}
      \ControlFlowTok{if}\NormalTok{ new\_arr[i] }\OperatorTok{\textgreater{}}\NormalTok{ new\_arr[i }\OperatorTok{+} \DecValTok{1}\NormalTok{]:}
\NormalTok{        new\_arr[i], new\_arr[i }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ new\_arr[i }\OperatorTok{+} \DecValTok{1}\NormalTok{], new\_arr[i]}

    \ControlFlowTok{return}\NormalTok{ sort\_pass(new\_arr, n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{3}}

  \ControlFlowTok{return}\NormalTok{ sort\_pass(arr, }\BuiltInTok{len}\NormalTok{(arr)) }\hspace*{\fill}\NormalTok{\circled{4}}

\CommentTok{\# Esempio di utilizzo}
\NormalTok{arr }\OperatorTok{=}\NormalTok{ [}\DecValTok{64}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{90}\NormalTok{]}

\NormalTok{sorted\_arr }\OperatorTok{=}\NormalTok{ bubble\_sort(arr)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Sorted array is:"}\NormalTok{, sorted\_arr)}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  All'interno di \texttt{bubble\_sort}, è definita una funzione interna
  \texttt{sort\_pass} che esegue un singolo passaggio dell'algoritmo di
  ordinamento a bolle.
  \item[\circled{2}]
  Viene creata una copia dell'array arr chiamata \texttt{new\_arr}. Poi,
  per ogni coppia di elementi
  \texttt{(new\_arr{[}i{]},\ new\_arr{[}i\ +\ 1{]})}, se
  \texttt{new\_arr{[}i{]}} è maggiore di \texttt{new\_arr{[}i\ +\ 1{]}},
  vengono scambiati.
  \item[\circled{3}]
  La funzione \texttt{sort\_pass} viene chiamata ricorsivamente con
  \texttt{new\_arr} e decrementando n di 1.
  \item[\circled{4}]
  La funzione \texttt{bubble\_sort} avvia il processo chiamando
  \texttt{sort\_pass} con l'array completo e la sua lunghezza.
  \end{description}
\item
  C:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ bubble\_sort}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{,}\NormalTok{ temp}\OperatorTok{;}

  \ControlFlowTok{for} \OperatorTok{(}\NormalTok{i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
      \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{\textgreater{}}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{])} \OperatorTok{\{}
\NormalTok{        temp }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}

\NormalTok{        arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{];}

\NormalTok{        arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{]} \OperatorTok{=}\NormalTok{ temp}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{64}\OperatorTok{,} \DecValTok{34}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{12}\OperatorTok{,} \DecValTok{22}\OperatorTok{,} \DecValTok{11}\OperatorTok{,} \DecValTok{90}\OperatorTok{\};}
  \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{arr}\OperatorTok{)/}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}

\NormalTok{  bubble\_sort}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}

\NormalTok{  printf}\OperatorTok{(}\StringTok{"Array ordinato con bubble sort: "}\OperatorTok{);}

  \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
  \OperatorTok{\}}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  C++:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ std}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ BubbleSort }\OperatorTok{\{}
\KeywordTok{public}\OperatorTok{:}
  \DataTypeTok{void}\NormalTok{ sort}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
      \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{\textgreater{}}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{])} \OperatorTok{\{}
          \DataTypeTok{int}\NormalTok{ temp }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}

\NormalTok{          arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{];}

\NormalTok{          arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{]} \OperatorTok{=}\NormalTok{ temp}\OperatorTok{;}
        \OperatorTok{\}}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}

  \DataTypeTok{void}\NormalTok{ printArray}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{      cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{\textless{}\textless{}} \StringTok{" "}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ endl}\OperatorTok{;}
  \OperatorTok{\}}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{64}\OperatorTok{,} \DecValTok{34}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{12}\OperatorTok{,} \DecValTok{22}\OperatorTok{,} \DecValTok{11}\OperatorTok{,} \DecValTok{90}\OperatorTok{\};}
  \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{arr}\OperatorTok{)/}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}

\NormalTok{  BubbleSort bs}\OperatorTok{;}
\NormalTok{  bs}\OperatorTok{.}\NormalTok{sort}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}

\NormalTok{  cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Array ordinato con bubble sort: "}\OperatorTok{;}
\NormalTok{  bs}\OperatorTok{.}\NormalTok{printArray}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}

  \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Java:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ BubbleSort }\OperatorTok{\{}

  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{bubbleSort}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[])} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{.}\FunctionTok{length}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
      \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{\textgreater{}}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{])} \OperatorTok{\{}

          \DataTypeTok{int}\NormalTok{ temp }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}

\NormalTok{          arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{];}

\NormalTok{          arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{+}\DecValTok{1}\OperatorTok{]} \OperatorTok{=}\NormalTok{ temp}\OperatorTok{;}
        \OperatorTok{\}}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}

  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main}\OperatorTok{(}\BuiltInTok{String}\NormalTok{ args}\OperatorTok{[])} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{64}\OperatorTok{,} \DecValTok{34}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{12}\OperatorTok{,} \DecValTok{22}\OperatorTok{,} \DecValTok{11}\OperatorTok{,} \DecValTok{90}\OperatorTok{\};}

    \FunctionTok{bubbleSort}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}

    \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println}\OperatorTok{(}\StringTok{"Array ordinato con bubble sort: "}\OperatorTok{);}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ arr}\OperatorTok{.}\FunctionTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
      \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{print}\OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{+} \StringTok{" "}\OperatorTok{);}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Rust:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}\NormalTok{ bubble\_sort(arr}\OperatorTok{:} \OperatorTok{\&}\KeywordTok{mut}\NormalTok{ [}\DataTypeTok{i32}\NormalTok{]) }\OperatorTok{\{}
  \KeywordTok{let}\NormalTok{ n }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{.}\NormalTok{len()}\OperatorTok{;}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \DecValTok{0}\OperatorTok{..}\NormalTok{n }\OperatorTok{\{}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \DecValTok{0}\OperatorTok{..}\NormalTok{n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1} \OperatorTok{\{}
      \ControlFlowTok{if}\NormalTok{ arr[j] }\OperatorTok{\textgreater{}}\NormalTok{ arr[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{\{}
\NormalTok{        arr}\OperatorTok{.}\NormalTok{swap(j}\OperatorTok{,}\NormalTok{ j}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{fn}\NormalTok{ main() }\OperatorTok{\{}
  \KeywordTok{let} \KeywordTok{mut}\NormalTok{ arr }\OperatorTok{=}\NormalTok{ [}\DecValTok{64}\OperatorTok{,} \DecValTok{34}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{12}\OperatorTok{,} \DecValTok{22}\OperatorTok{,} \DecValTok{11}\OperatorTok{,} \DecValTok{90}\NormalTok{]}\OperatorTok{;}

\NormalTok{  bubble\_sort(}\OperatorTok{\&}\KeywordTok{mut}\NormalTok{ arr)}\OperatorTok{;}

  \PreprocessorTok{println!}\NormalTok{(}\StringTok{"Array ordinato con bubble sort: \{:?\}"}\OperatorTok{,}\NormalTok{ arr)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Scala:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object}\NormalTok{ BubbleSort }\OperatorTok{\{}
  \KeywordTok{def} \FunctionTok{bubbleSort}\OperatorTok{(}\NormalTok{arr}\OperatorTok{:} \ExtensionTok{Array}\OperatorTok{[}\BuiltInTok{Int}\OperatorTok{]):} \BuiltInTok{Unit} \OperatorTok{=} \OperatorTok{\{}
    \KeywordTok{val}\NormalTok{ n }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{.}\NormalTok{length}

    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{i }\OperatorTok{\textless{}{-}} \DecValTok{0}\NormalTok{ until n}\OperatorTok{)} \OperatorTok{\{}
      \ControlFlowTok{for} \OperatorTok{(}\NormalTok{j }\OperatorTok{\textless{}{-}} \DecValTok{0}\NormalTok{ until n }\OperatorTok{{-}}\NormalTok{ i }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\FunctionTok{arr}\OperatorTok{(}\NormalTok{j}\OperatorTok{)} \OperatorTok{\textgreater{}} \FunctionTok{arr}\OperatorTok{(}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{))} \OperatorTok{\{}
          \KeywordTok{val}\NormalTok{ temp }\OperatorTok{=} \FunctionTok{arr}\OperatorTok{(}\NormalTok{j}\OperatorTok{)}

          \FunctionTok{arr}\OperatorTok{(}\NormalTok{j}\OperatorTok{)} \OperatorTok{=} \FunctionTok{arr}\OperatorTok{(}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{)}

          \FunctionTok{arr}\OperatorTok{(}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{=}\NormalTok{ temp}
        \OperatorTok{\}}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}

  \KeywordTok{def} \FunctionTok{main}\OperatorTok{(}\NormalTok{args}\OperatorTok{:} \ExtensionTok{Array}\OperatorTok{[}\ExtensionTok{String}\OperatorTok{]):} \BuiltInTok{Unit} \OperatorTok{=} \OperatorTok{\{}
    \KeywordTok{val}\NormalTok{ arr }\OperatorTok{=} \ExtensionTok{Array}\OperatorTok{(}\DecValTok{64}\OperatorTok{,} \DecValTok{34}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \DecValTok{12}\OperatorTok{,} \DecValTok{22}\OperatorTok{,} \DecValTok{11}\OperatorTok{,} \DecValTok{90}\OperatorTok{)}

    \FunctionTok{bubbleSort}\OperatorTok{(}\NormalTok{arr}\OperatorTok{)}

    \FunctionTok{println}\OperatorTok{(}\StringTok{"Array ordinato con bubble sort: "} \OperatorTok{+}\NormalTok{ arr}\OperatorTok{.}\FunctionTok{mkString}\OperatorTok{(}\StringTok{", "}\OperatorTok{))}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Confrontando questi esempi, possiamo osservare le differenze sintattiche
e di stile tra Python ed altri, importanti, linguaggi. Python si
distingue per la sua sintassi concisa e espressiva soprattutto nella
versione procedurale. L'implementazione colla gerarchia di oggetti ha un
piccolo incremento di complessità che è ripagato dalla possibilità di
creare gerarchie di algoritmi di ordinamento, con impatti nulli sul
codice preesistente.

La versione procedurale in Python e l'implementazione C, già a primo
acchito, presentano un evidente diverso grado di chiarezza del codice.
Inoltre, la riga \texttt{int\ n\ =\ sizeof(arr)/sizeof(arr{[}0{]});} in
C si rende necessaria per calcolare il numero di valori a partire dalle
dimensioni totale della lista e del singolo elemento, rispetto a
\texttt{n\ =\ len(arr)} di Python, dove chiediamo direttamente il numero
di valori.

Il C++ e Java aggiungono caratteristiche relative agli oggetti e
funzionalità di alto livello rispetto a C, al prezzo di una sintassi più
complessa e verbosa. Rust e Scala sono linguaggi più moderni e si
pongono nel mezzo tra C, C++ e Java e Python.

\chapter{Scaricare e installare
Python}\label{scaricare-e-installare-python}

\section{Scaricamento}\label{scaricamento}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Visita il sito ufficiale di Python: Vai su
  \href{https://www.python.org/}{python.org}.
\item
  Naviga alla pagina di download: Clicca su \emph{Downloads} nel menu
  principale.
\item
  Scarica il pacchetto di installazione:

  \begin{itemize}
  \item
    Per Windows: Cerca Python 3.12.x e fai partire il download
    (assicurati di scaricare la versione più recente).
  \item
    Per macOS: Come per Windows.
  \item
    Per Linux: Python è spesso preinstallato. Se non lo è, usa il
    gestore di pacchetti della tua distribuzione (ad esempio
    \texttt{apt} per Ubuntu: \texttt{sudo\ apt-get\ install\ python3}).
  \end{itemize}
\end{enumerate}

\section{Installazione}\label{installazione}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Esegui il file di installazione:

  \begin{itemize}
  \item
    Su Windows: Esegui il file \texttt{.exe} scaricato. Assicurati di
    selezionare l'opzione \texttt{Add\ Python\ to\ PATH} durante
    l'installazione.
  \item
    Su macOS: Apri il file \texttt{.pkg} scaricato e segui le
    istruzioni.
  \item
    Su Linux: Usa il gestore di pacchetti per installare Python.
  \end{itemize}
\item
  Verifica l'installazione:

  \begin{itemize}
  \item
    Apri il terminale (Command Prompt su Windows, Terminal su macOS e
    Linux).
  \item
    Digita \texttt{python\ -\/-version} o \texttt{python3\ -\/-version}
    e premi Invio. Dovresti vedere la versione di Python installata.
  \end{itemize}
\end{enumerate}

\section{Esecuzione del primo programma: ``Hello,
World!''}\label{esecuzione-del-primo-programma-hello-world}

È consuetudine eseguire come primo programma la visualizzazione della
stringa ``Hello, World!''\footnote{La tradizione del programma ``Hello,
  World!'' ha una lunga storia che risale ai primi giorni della
  programmazione. Questo semplice programma è generalmente il primo
  esempio utilizzato per introdurre i nuovi programmatori alla sintassi
  e alla struttura di un linguaggio di programmazione. Il programma
  ``Hello, World!'' è diventato famoso grazie a Brian Kernighan, che lo
  ha incluso nel suo libro (Kernighan e Ritchie 1988) pubblicato nel
  1978. Tuttavia, il suo utilizzo risale a un testo precedente di
  Kernighan, (Kernighan 1973), pubblicato nel 1973, dove veniva
  utilizzato un esempio simile.}. Possiamo farlo in diversi modi e ciò è
una delle caratteristiche più apprezzate di Python.

\subsection{REPL}\label{repl}

Il primo modo prevede l'utilizzo del REPL di Python. Il REPL
(read-eval-print loop) è un ambiente interattivo di esecuzione di
comandi Python generato dall'interprete, secondo il ciclo:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Read: Legge un input dell'utente.
\item
  Eval: Valuta l'input.
\item
  Print: Visualizza il risultato dell'esecuzione.
\item
  Loop: Ripete il ciclo.
\end{enumerate}

Eseguiamo il nostro primo ``Hello, World!'':

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Apri il terminale ed esegui l'interprete Python digitando
  \texttt{python} o \texttt{python3} e premi il tasto di invio della
  tastiera.
\item
  Scrivi ed esegui il programma:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Premi il tasto di invio per vedere il risultato immediatamente.

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-warning-color!10!white, colback=white, colframe=quarto-callout-warning-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Attenzione}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Il REPL e l'interprete Python sono strettamente collegati, ma non sono
esattamente la stessa cosa. Quando avvii l'interprete Python senza
specificare un file di script da eseguire (digitando semplicemente
\texttt{python} o \texttt{python3} nel terminale), entri in modalità
REPL. Nel REPL, l'interprete Python legge l'input direttamente
dall'utente, lo esegue, stampa il risultato e poi attende il prossimo
input. In sintesi, l'interprete può eseguire programmi Python completi
salvati in file, il REPL è progettato per un'esecuzione interattiva e
immediata di singole istruzioni.

\end{tcolorbox}

\subsection{Interprete}\label{interprete}

Un altro modo per eseguire il nostro programma ``Hello, World!'' è
utilizzare l'interprete Python per eseguire un file di codice sorgente.
Questo metodo è utile per scrivere programmi più complessi e per
mantenere il codice per usi futuri.

Ecco come fare sui diversi sistemi operativi.

\section{Windows}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Crea un file di testo:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Apri il tuo editor di testo preferito, come Notepad.
  \item
    Scrivi il seguente codice nel file:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{2}
  \tightlist
  \item
    Salva il file con il nome \texttt{hello.txt}.
  \end{enumerate}
\item
  Rinomina il file (facoltativo): se desideri mantenere il file senza
  estensione \texttt{.txt}, puoi rinominarlo in \texttt{hello}
  direttamente dall'Esplora file.
\item
  Esegui il file Python:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Apri il prompt dei comandi.
  \item
    Naviga fino alla directory in cui hai salvato il file. Ad esempio,
    se il file si trova nella cartella \texttt{Documenti}, puoi
    digitare:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \%HOMEPATH\%}\DataTypeTok{\textbackslash{}D}\NormalTok{ocumenti}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{2}
  \tightlist
  \item
    Esegui l'interprete Python passando come argomento il file che hai
    creato:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{python hello.txt}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{3}
  \tightlist
  \item
    oppure, se il tuo sistema utilizza \texttt{python3}:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{python3 hello.txt}
\end{Highlighting}
\end{Shaded}
\item
  Visualizza il risultato:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Hello, World!}
\end{Highlighting}
\end{Shaded}

\section{macOS}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Crea un file di testo:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Apri il tuo editor di testo preferito, come TextEdit.
  \item
    Scrivi il seguente codice nel file:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{2}
  \tightlist
  \item
    Salva il file con il nome \texttt{hello.txt}.
  \end{enumerate}
\item
  Rinomina il file (facoltativo): se desideri mantenere il file senza
  estensione \texttt{.txt}, puoi rinominarlo in \texttt{hello}
  direttamente dal Finder.
\item
  Esegui il file Python:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Apri il terminale del sistema operativo.
  \item
    Naviga fino alla directory in cui hai salvato il file. Ad esempio,
    se il file si trova nella cartella \texttt{Documenti}, puoi
    digitare:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/Documents}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{2}
  \tightlist
  \item
    Esegui l'interprete Python passando come argomento il file che hai
    creato:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{python3}\NormalTok{ hello.txt}
\end{Highlighting}
\end{Shaded}
\item
  Visualizza il risultato:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Hello,}\NormalTok{ World!}
\end{Highlighting}
\end{Shaded}

\section{Linux}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Crea un file di testo:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Apri il tuo editor di testo preferito, come Gedit o Nano.
  \item
    Scrivi il seguente codice nel file:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{2}
  \tightlist
  \item
    Salva il file con il nome \texttt{hello.txt}.
  \end{enumerate}
\item
  Rinomina il file (facoltativo): se desideri mantenere il file senza
  estensione \texttt{.txt}, puoi rinominarlo in \texttt{hello}
  utilizzando il comando \texttt{mv} nel terminale:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mv}\NormalTok{ hello.txt hello}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Esegui il file Python:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Apri il terminale del sistema operativo.
  \item
    Naviga fino alla directory in cui hai salvato il file. Ad esempio,
    se il file si trova nella cartella \texttt{Documenti}, puoi
    digitare:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ \textasciitilde{}/Documenti}
\end{Highlighting}
\end{Shaded}

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \setcounter{enumii}{2}
  \tightlist
  \item
    Esegui l'interprete Python passando come argomento il file che hai
    creato:
  \end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{python3}\NormalTok{ hello.txt}
\end{Highlighting}
\end{Shaded}
\item
  Visualizza il risultato:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Hello,}\NormalTok{ World!}
\end{Highlighting}
\end{Shaded}

Con queste istruzioni, dovresti essere in grado di eseguire il programma
``Hello, World!'' utilizzando un file Python su Windows, macOS e Linux.

\subsection{IDE}\label{ide}

Utilizzo di un IDE (integrated development environment) installato sul
computer. Ecco alcuni dei più comuni e gratuiti.

\section{IDLE}

È incluso con l'installazione di Python.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Avvia IDLE.
\item
  Crea un nuovo file (\texttt{File\ -\textgreater{}\ New\ File}).
\item
  Scrivi il programma:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Salva il file (\texttt{File\ -\textgreater{}\ Salva}).
\item
  Esegui il programma (\texttt{Run\ -\textgreater{}\ Run\ Module}).
\end{enumerate}

\section{PyCharm}

Proprietario ma con una versione liberamente fruibile.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Scarica e installa PyCharm da
  \href{https://www.jetbrains.com/pycharm/download/}{jetbrains.com/pycharm/download}.
\item
  Crea un nuovo progetto associando l'interprete Python.
\item
  Crea un nuovo file Python
  (\texttt{File\ -\textgreater{}\ New\ -\textgreater{}\ Python\ File}).
\item
  Scrivi il programma:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Esegui il programma (\texttt{Run\ -\textgreater{}\ Run...}).
\end{enumerate}

\section{Visual Studio Code}

Proprietario ma liberamente fruibile.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Scarica e installa VS Code da
  \href{https://code.visualstudio.com/}{code.visualstudio.com}.
\item
  Installa l'estensione Python.
\item
  Apri o crea una nuova cartella di progetto.
\item
  Crea un nuovo file Python
  (\texttt{File\ -\textgreater{}\ Nuovo\ file}).
\item
  Scrivi il programma:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\item
  Salva il file con estensione \texttt{.py}, ad esempio
  \texttt{hello\_world.py}.
\item
  Esegui il programma utilizzando il terminale integrato
  (\texttt{Visualizza\ -\textgreater{}\ Terminale}) e digitando
  \texttt{python\ hello\_world.py}.
\end{enumerate}

\subsection{Esecuzione nel browser}\label{esecuzione-nel-browser}

Puoi eseguire Python direttamente nel browser, senza installare nulla.
Anche qui abbiamo diverse alternative, sia eseguendo il codice
localmente, che utilizzando piattaforme online.

\section{Repl.it}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Visita \href{https://repl.it/}{repl.it}.
\item
  Crea un nuovo progetto selezionando Python.
\item
  Scrivi il programma:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Clicca su ``Run'' per eseguire il programma.
\end{enumerate}

\section{Google Colab}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Visita
  \href{https://colab.research.google.com/}{colab.research.google.com}.
\item
  Crea un nuovo notebook.
\item
  In una cella di codice, scrivi:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Premi il pulsante di esecuzione accanto alla cella.
\end{enumerate}

\section{PyScript}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Visita il sito ufficiale di \href{https://pyscript.net/}{PyScript} per
  ulteriori informazioni su come iniziare.
\item
  Crea un file HTML con il seguente contenuto:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{\textless{}!DOCTYPE}\NormalTok{ html}\DataTypeTok{\textgreater{}}
\DataTypeTok{\textless{}}\KeywordTok{html}\OtherTok{ lang}\OperatorTok{=}\StringTok{"en"}\DataTypeTok{\textgreater{}}
\DataTypeTok{\textless{}}\KeywordTok{head}\DataTypeTok{\textgreater{}}
    \DataTypeTok{\textless{}}\KeywordTok{meta}\OtherTok{ charset}\OperatorTok{=}\StringTok{"UTF{-}8"}\DataTypeTok{\textgreater{}}
    \DataTypeTok{\textless{}}\KeywordTok{title}\DataTypeTok{\textgreater{}}\NormalTok{Hello, World with PyScript}\DataTypeTok{\textless{}/}\KeywordTok{title}\DataTypeTok{\textgreater{}}
    \DataTypeTok{\textless{}}\KeywordTok{link}\OtherTok{ rel}\OperatorTok{=}\StringTok{"stylesheet"}\OtherTok{ href}\OperatorTok{=}\StringTok{"https://pyscript.net/latest/pyscript.css"}\DataTypeTok{\textgreater{}}
    \DataTypeTok{\textless{}}\KeywordTok{script}\OtherTok{ defer src}\OperatorTok{=}\StringTok{"https://pyscript.net/latest/pyscript.js"}\DataTypeTok{\textgreater{}\textless{}/}\KeywordTok{script}\DataTypeTok{\textgreater{}}
\DataTypeTok{\textless{}/}\KeywordTok{head}\DataTypeTok{\textgreater{}}
\DataTypeTok{\textless{}}\KeywordTok{body}\DataTypeTok{\textgreater{}}
    \DataTypeTok{\textless{}}\KeywordTok{py{-}script}\DataTypeTok{\textgreater{}}
\NormalTok{        print("Hello, World!")}
    \DataTypeTok{\textless{}/}\KeywordTok{py{-}script}\DataTypeTok{\textgreater{}}
\DataTypeTok{\textless{}/}\KeywordTok{body}\DataTypeTok{\textgreater{}}
\DataTypeTok{\textless{}/}\KeywordTok{html}\DataTypeTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Salva il file con estensione \texttt{.html} (ad esempio,
  \texttt{hello.html}).
\item
  Apri il file salvato in un browser web. Vedrai l'output
  \texttt{Hello,\ World!} direttamente nella pagina.
\end{enumerate}

\subsection{Jupyter Notebook}\label{jupyter-notebook}

Jupyter Notebook è un ambiente di sviluppo interattivo per la
programmazione che permette di creare e condividere documenti contenenti
codice eseguibile, visualizzazioni, testo formattato e altro ancora.
Originariamente sviluppato come parte del progetto IPython, Jupyter
supporta non solo Python, ma anche numerosi altri linguaggi di
programmazione attraverso i cosiddetti kernel tra cui R, Julia e Scala.

\section{Uso locale}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Assicurati di avere Python e Jupyter installati sul tuo computer. Se
  non li hai, puoi installarli utilizzando Anaconda o pip:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{pip}\NormalTok{ install notebook}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Avvia Jupyter Notebook dal terminale:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{jupyter}\NormalTok{ notebook}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Crea un nuovo notebook Python.
\item
  In una cella di codice, scrivi:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Premi \texttt{Shift\ +\ Enter} per eseguire la cella.
\end{enumerate}

\section{JupyterHub}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Visita l'istanza di JupyterHub della tua istituzione o azienda
  (\href{https://jupyter.org/hub}{maggiori informazioni}).
\item
  Accedi con le tue credenziali.
\item
  Crea un nuovo notebook Python.
\item
  In una cella di codice, scrivi:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Premi \texttt{Shift\ +\ Enter} per eseguire la cella.
\end{enumerate}

\section{Binder}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Visita \href{https://mybinder.org/}{mybinder.org}.
\item
  Inserisci l'URL del repository GitHub che contiene il tuo notebook o
  il tuo progetto Python.
\item
  Clicca su ``Launch''.
\item
  Una volta avviato l'ambiente, crea un nuovo notebook o apri uno
  esistente.
\item
  In una cella di codice, scrivi:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Premi \texttt{Shift\ +\ Enter} per eseguire la cella.
\end{enumerate}

Binder è un servizio simile a Colab, anche se quest'ultimo offre
strumenti generalmente più avanzati in termini di risorse computazionali
e collaborazione. Binder di contro è basato su GitHub e ciò può essere
utile in alcuni contesti.

\chapter{La struttura lessicale di
Python}\label{la-struttura-lessicale-di-python}

Per iniziare ad imparare Python come linguaggio, partiamo da una
semplificazione della stuttura lessicale, cioè dall'insieme di regole
sintattiche più significative, sia per comprendere le regole di
composizione di programmi comprensibili all'interprete, sia per
sfrutturne appieno tutte le potenzialità.

Ogni programma Python è costituito da una serie di file di testo
contenenti il codice sorgente con una certa codifica, il default è
l'UTF-8, ed ogni file si può vedere come una sequenza di istruzioni,
righe e token. Le istruzioni danno la granularità dell'algoritmo, le
righe definiscono come queste istruzioni sono distribuite nel testo e,
infine, i token sono gli elementi atomici che hanno un significato per
il linguaggio.

\section{Righe}\label{righe}

Le righe sono di due tipi: \textbf{logiche} e \textbf{fisiche}. Le
seconde sono le più facilmente individuabili nel testo di un programma,
perché sono terminate da un carattere di a capo. Una o più righe fisiche
costituiscono una riga logica che corrisponde ad una istruzione. Esiste
una eccezione, poco usata e consigliata in Python, per cui una riga
fisica contiene più istruzioni separate da \texttt{;}.

Vi sono due modi per dividere una riga logica in righe fisiche. Il primo
è terminare con il backslash (\texttt{\textbackslash{}}, poco usata la
traduzione \emph{barra rovesciata} o simili) tutte le righe fisiche meno
l'ultima (intendendo con ciò che il backslash precede l'a capo):

\phantomsection\label{annotated-cell-53}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1} \OperatorTok{+} \DecValTok{2} \OperatorTok{+}\NormalTok{ \textbackslash{} }\hspace*{\fill}\NormalTok{\circled{1}}
     \DecValTok{3}

\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{5} \KeywordTok{and}\NormalTok{ \textbackslash{} }\hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{   x }\OperatorTok{\textless{}} \DecValTok{9}\NormalTok{: }\hspace*{\fill}\NormalTok{\circled{3}}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"5 \textless{} x \textless{} 9"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
L'istruzione di assegnamento è spezzata su due righe fisiche.
\item[\circled{2}]
L'istruzione condizionale ha due espressioni che devono essere entrambe
vere, ognuna su una riga fisica.
\item[\circled{3}]
Non importa quanto sono indentate le righe fisiche successive alla prima
e ciò può essere sfruttato per incrementare la leggibilità, ad esempio,
allineando le espressioni \texttt{x\ \textgreater{}\ 5} e
\texttt{x\ \textless{}\ 9} in colonna.
\end{description}

Il secondo è per mezzo di parentesi, giacché tutte le righe fisiche che
seguono una con parentesi tonda \texttt{(}, quadra \texttt{{[}} o graffa
\texttt{\{} aperta, fino a quella con l'analoga parentesi chiusa, sono
unite in una logica. Le regole di indentazione, che vedremo nel seguito,
si applicano solo alla prima riga fisica.

Esempi sintatticamente corretti ma sconsigliabili, per l'inerente
illeggibilità:

\phantomsection\label{annotated-cell-54}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ (}\DecValTok{1} \OperatorTok{+} \DecValTok{2} \hspace*{\fill}\NormalTok{\circled{1}}
     \OperatorTok{+} \DecValTok{3} \OperatorTok{+} \DecValTok{4}\NormalTok{)}

\NormalTok{y }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }
           \DecValTok{3}\NormalTok{, }\DecValTok{4} \OperatorTok{+} \hspace*{\fill}\NormalTok{\circled{2}}
      \DecValTok{5}\NormalTok{] }

\NormalTok{z }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2} \hspace*{\fill}\NormalTok{\circled{3}}
\NormalTok{     , }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]   }
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
L'espressione è spezzata su due righe fisiche e le parentesi tonde
rappresentano un'alternativa all'uso del backslash.
\item[\circled{2}]
Le righe fisiche della lista non hanno la stessa indentazione e una
espressione è spezzata su due righe.
\item[\circled{3}]
La lista è spezzata su due righe fisiche e un delimitatore inizia la
riga anziché terminare la precedente.
\end{description}

\section{Commenti}\label{commenti}

Un commento inizia con un carattere cancelletto (\texttt{\#}) e termina
alla fine della riga fisica. I commenti non possono coesistere con il
backslash come separatore di riga logica, giacché entrambi devono
chiudere la riga fisica.

Esempi non sintatticamente corretti:

\phantomsection\label{annotated-cell-55}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1} \OperatorTok{+} \DecValTok{2} \OperatorTok{+}\NormalTok{ \textbackslash{} }\CommentTok{\# Commento }\hspace*{\fill}\NormalTok{\circled{1}}
     \DecValTok{3}

\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{5} \KeywordTok{and} \CommentTok{\# Commento \textbackslash{} }\hspace*{\fill}\NormalTok{\circled{2}}
\NormalTok{   x }\OperatorTok{\textless{}} \DecValTok{9}\NormalTok{: }
  \BuiltInTok{print}\NormalTok{(}\StringTok{"5 \textless{} x \textless{} 9"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Il backslash deve terminare la riga fisica, quindi non può essere
seguito da un commento. Se necessario può andare o alla riga successiva,
scelta consigliata, o alla precedente. L'interprete segnalerà l'errore
\href{https://docs.python.org/3/library/exceptions.html\#SyntaxError}{\texttt{SyntaxError}}.
\item[\circled{2}]
Il commento rende il backslash parte di esso quindi non segnala più la
fine della riga fisica e, all'esecuzione, si avrà anche qui un errore di
tipo \texttt{SyntaxError}, perché \texttt{and} deve essere seguito da
un'espressione.
\end{description}

\section{Indentazione}\label{indentazione}

Indentazione significa che spazi o, in alternativa, tabulazioni
precedono un carattere che non sia nessuno dei due. Il numero di spazi
ottenuto dopo la trasformazione delle tabulazioni in spazi, si definisce
livello di indentazione. L'indentazione del codice è il modo che Python
utilizza per raggruppare le istruzioni in un blocco, ove tutte devono
presentare la medesima indentazione. La prima riga logica che ha una
indentazione minore della precedente, segnala che il blocco è stato
chiuso proprio da quest'ultima. Anche le clausole di un'istruzione
composta devono avere la stessa indentazione.

La prima istruzione di un file o la prima inserita al prompt
\texttt{\textgreater{}\textgreater{}\textgreater{}} del REPL non deve
presentare spazi o tabulazioni, cioè ha un livello di indentazione pari
a 0.

Alcuni esempi:

\begin{itemize}
\item
  Definizione di una funzione:

\phantomsection\label{annotated-cell-161}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ somma(a, b): }\hspace*{\fill}\NormalTok{\circled{1}}
\NormalTok{  risultato }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\hspace*{\fill}\NormalTok{\circled{2}}

  \ControlFlowTok{return}\NormalTok{ risultato }
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Prima riga senza indentazione.
  \item[\circled{2}]
  Questa riga e la successiva appartengono allo stesso blocco e,
  pertanto, hanno la medesima indentazione.
  \end{description}
\item
  Test di condizione:

\phantomsection\label{annotated-cell-162}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{10}

\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{: }\hspace*{\fill}\NormalTok{\circled{1}}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x è negativo"}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{2}}

\ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{==} \DecValTok{0}\NormalTok{: }
      \BuiltInTok{print}\NormalTok{(}\StringTok{"x è zero"}\NormalTok{) }

\ControlFlowTok{else}\NormalTok{: }
        \BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Le tre clausole \texttt{if} , \texttt{then} e \texttt{else} hanno
  identica indentazione.
  \item[\circled{2}]
  I tre blocchi hanno come unico vincolo quello di avere un livello
  maggiore della riga precedente. I blocchi corrispondenti alle diverse
  clausole non devono avere lo stesso livello di indentazione, anche se
  è buona prassi farlo.
  \end{description}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-warning-color!10!white, colback=white, colframe=quarto-callout-warning-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Attenzione}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Non si possono avere sia spazi che tabulazioni per definire il livello
di indentazione nello stesso file. Ciò perché renderebbe ambiguo il
numero di spazi che si ottiene dopo la trasformazione delle tabulazioni
in spazi. Quindi, o si usano spazi, scelta raccomandata, o tabulazioni.

\end{tcolorbox}

\section{Token}\label{token-1}

Le righe logiche sono composte da token che si categorizzano in parole
chiave, identificatori, operatori, delimitatori e letterali. I token
sono separati da un numero arbitrario di spazi e tabulazioni. Ad
esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}  \OperatorTok{+}  \DecValTok{2}  \OperatorTok{+}  \DecValTok{3}

\ControlFlowTok{if}\NormalTok{    x }\OperatorTok{\textgreater{}} \DecValTok{5}    \KeywordTok{and}\NormalTok{    x }\OperatorTok{\textless{}} \DecValTok{9}\NormalTok{: }
  \BuiltInTok{print}\NormalTok{(}\StringTok{"5 \textless{} x \textless{} 9"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\subsection{Identificatori}\label{identificatori}

Un identificatore è un nome assegnato ad un oggetto, cioè una variabile,
una funzione, una classe, un modulo e altro. Esso è \emph{case
sensitive} cioè \texttt{python} e \texttt{Python} sono due
identificatori diversi.

Alcuni esempi:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{intero }\OperatorTok{=} \DecValTok{42}  \CommentTok{\# Identificatore di numero intero}
\NormalTok{decimale }\OperatorTok{=} \FloatTok{3.14}  \CommentTok{\# Identificatore di numero decimale}
\NormalTok{testo }\OperatorTok{=} \StringTok{"Ciao, mondo!"}  \CommentTok{\# Identificatore di stringa}
\NormalTok{lista }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]  }\CommentTok{\# Identificatore di lista}
\NormalTok{dizionario }\OperatorTok{=}\NormalTok{ \{}\StringTok{"chiave"}\NormalTok{: }\StringTok{"valore"}\NormalTok{\}  }\CommentTok{\# Identificatore di dizionario}

\KeywordTok{def}\NormalTok{ mia\_funzione(): }\CommentTok{\# Identificatore di funzione}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Questa è una funzione"}\NormalTok{)}

\CommentTok{\# Classe}
\KeywordTok{class}\NormalTok{ MiaClasse: }\CommentTok{\# Identificatore di classe}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, valore): }\CommentTok{\# Identificatore di metodo e parametro}
    \VariableTok{self}\NormalTok{.valore }\OperatorTok{=}\NormalTok{ valore  }\CommentTok{\# Identificatore di attributo}
    
  \KeywordTok{def}\NormalTok{ metodo(}\VariableTok{self}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Questo è un metodo della classe"}\NormalTok{)}

\ImportTok{import}\NormalTok{ math  }\CommentTok{\# Identificatore di modulo}

\KeywordTok{def}\NormalTok{ mio\_generatore(): }\CommentTok{\# Identificatore di generatore}
  \ControlFlowTok{yield} \DecValTok{1}
  \ControlFlowTok{yield} \DecValTok{2}
  \ControlFlowTok{yield} \DecValTok{3}

\NormalTok{mio\_oggetto }\OperatorTok{=}\NormalTok{ MiaClasse(}\DecValTok{10}\NormalTok{)  }\CommentTok{\# Identificatore di istanza}
\end{Highlighting}
\end{Shaded}

\subsection{Parole chiave}\label{parole-chiave}

Le parole chiave sono parole che non possono essere usate per scopi
diversi da quelli predefiniti nel linguaggio e, quindi, non possono
essere usate come identificatori. Ad esempio, \texttt{True} che
rappresenta il valore logico di verità, non può essere usato per
definire ad esempio una variabile.

Esistono anche delle parole chiave contestuali, cioè che sono tali solo
in alcuni contesti ed altrove possono essee usate come identificatori.
Usiamo il codice seguente per ottenere una lista di parole chiave e
parole chiave contestuali:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ keyword}

\CommentTok{\# Otteniamo la lista delle parole chiave}
\NormalTok{parole\_chiave }\OperatorTok{=}\NormalTok{ keyword.kwlist}

\CommentTok{\# Otteniamo la lista delle parole chiave contestuali}
\NormalTok{parole\_chiave\_contestuale }\OperatorTok{=}\NormalTok{ keyword.softkwlist}

\CommentTok{\# Stampiamo la lista delle parole chiave}
\BuiltInTok{print}\NormalTok{(parole\_chiave)}

\CommentTok{\# Stampiamo la lista delle parole chiave contestuali}
\BuiltInTok{print}\NormalTok{(parole\_chiave\_contestuale)}
\end{Highlighting}
\end{Shaded}

Nella tabella seguente invece un elenco completo con breve descrizione:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.1852}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.8148}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Parola chiave
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descrizione
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Valori booleani & \\
\texttt{False} & Valore booleano falso \\
\texttt{True} & Valore booleano vero \\
Operatori logici & \\
\texttt{and} & Operatore logico AND \\
\texttt{or} & Operatore logico OR \\
\texttt{not} & Operatore logico NOT \\
Operatori di controllo di flusso & \\
\texttt{if} & Utilizzato per creare un'istruzione condizionale \\
\texttt{elif} & Utilizzato per aggiungere condizioni in un blocco if \\
\texttt{else} & Utilizzato per specificare il blocco di codice da
eseguire se le condizioni precedenti sono false \\
\texttt{for} & Utilizzato per creare un ciclo for \\
\texttt{while} & Utilizzato per creare un ciclo while \\
\texttt{break} & Interrompe il ciclo in corso \\
\texttt{continue} & Salta l'iterazione corrente del ciclo e passa alla
successiva \\
\texttt{pass} & Indica un blocco di codice vuoto \\
\texttt{return} & Utilizzato per restituire un valore da una funzione \\
Gestione delle eccezioni & \\
\texttt{try} & Utilizzato per definire un blocco di codice da eseguire e
gestire le eccezioni \\
\texttt{except} & Utilizzato per catturare le eccezioni in un blocco
try-except \\
\texttt{finally} & Blocco di codice che viene eseguito alla fine di un
blocco try, indipendentemente dal fatto che si sia verificata
un'eccezione \\
\texttt{raise} & Utilizzato per sollevare un'eccezione \\
Definizione delle funzioni e classi & \\
\texttt{def} & Utilizzato per definire una funzione \\
\texttt{class} & Utilizzato per definire una classe \\
\texttt{lambda} & Utilizzato per creare funzioni anonime \\
Gestione contesto di dichiarazione di variabili & \\
\texttt{global} & Utilizzato per dichiarare variabili globali \\
\texttt{nonlocal} & Utilizzato per dichiarare variabili non locali \\
Operazioni su moduli & \\
\texttt{import} & Utilizzato per importare moduli \\
\texttt{from} & Utilizzato per importare specifici elementi da un
modulo \\
\texttt{as} & Utilizzato per creare alias, ad esempio negli import \\
Operatori di identità e appartenenza & \\
\texttt{in} & Utilizzato per verificare se un valore esiste in una
sequenza \\
\texttt{is} & Operatore di confronto di identità \\
Gestione delle risorse & \\
\texttt{with} & Utilizzato per garantire un'azione di pulizia come il
rilascio delle risorse \\
Programmazione asincrona & \\
\texttt{async} & Utilizzato per definire funzioni asincrone \\
\texttt{await} & Utilizzato per attendere un risultato in una funzione
asincrona \\
Varie & \\
\texttt{del} & Utilizzato per eliminare oggetti \\
\texttt{assert} & Utilizzato per le asserzioni, verifica che
un'espressione sia vera \\
\texttt{yield} & Utilizzato per restituire un generatore da una
funzione \\
\texttt{None} & Rappresenta l'assenza di valore o un valore nullo \\
Parole chiave contestuali & \\
\texttt{match} & Utilizzato nell'istruzione \texttt{match} per il
pattern matching \\
\texttt{case} & Utilizzato nell'istruzione \texttt{match} per definire
un ramo \\
\texttt{\_} & Utilizzato come identificatore speciale nell'istruzione
\texttt{match} per indicare un pattern di default o ignorare valori \\
\texttt{type} & Utilizzato in specifici contesti per dichiarazioni di
tipo \\
\end{longtable}

Esempi di uso di parole chiave contestuali:

\begin{itemize}
\item
  \texttt{match}, \texttt{case} e \texttt{\_}:

\phantomsection\label{annotated-cell-163}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ process\_value(value): }\hspace*{\fill}\NormalTok{\circled{1}}
  \ControlFlowTok{match}\NormalTok{ value: }\hspace*{\fill}\NormalTok{\circled{2}}
    \ControlFlowTok{case} \DecValTok{1}\NormalTok{: }\hspace*{\fill}\NormalTok{\circled{3}}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Uno"}\NormalTok{)}

    \ControlFlowTok{case} \DecValTok{2}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Due"}\NormalTok{)}

    \ControlFlowTok{case}\NormalTok{ \_: }\hspace*{\fill}\NormalTok{\circled{4}}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Altro"}\NormalTok{)}

\NormalTok{match }\OperatorTok{=} \StringTok{"Questo è un identificatore valido"} \hspace*{\fill}\NormalTok{\circled{5}}

\CommentTok{\# Test della funzione}
\NormalTok{process\_value(}\DecValTok{1}\NormalTok{)  }\CommentTok{\# Output: Uno}
\NormalTok{process\_value(}\DecValTok{2}\NormalTok{)  }\CommentTok{\# Output: Due}
\NormalTok{process\_value(}\DecValTok{3}\NormalTok{)  }\CommentTok{\# Output: Altro}

\CommentTok{\# Stampa della variabile \textasciigrave{}match\textasciigrave{}}
\BuiltInTok{print}\NormalTok{(match)  }\CommentTok{\# Output: Questo è un identificatore valido}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Definiamo una funzione che utilizza il pattern matching.
  \item[\circled{2}]
  Uso di \texttt{match} come parola chiave.
  \item[\circled{3}]
  Uso di \texttt{case} come parola chiave.
  \item[\circled{4}]
  Uso di \texttt{\_} come parola chiave.
  \item[\circled{5}]
  Utilizzo di \texttt{match} come identificatore per una variabile.
  \end{description}
\item
  \texttt{type}:

\phantomsection\label{annotated-cell-164}%
\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ typing }\ImportTok{import}\NormalTok{ TypeAlias}

\BuiltInTok{type}\NormalTok{ Point }\OperatorTok{=} \BuiltInTok{tuple}\NormalTok{[}\BuiltInTok{float}\NormalTok{, }\BuiltInTok{float}\NormalTok{] }\hspace*{\fill}\NormalTok{\circled{1}}

\CommentTok{\# Utilizzo dell\textquotesingle{}alias di tipo}
\KeywordTok{def}\NormalTok{ distanza(p1: Point, p2: Point) }\OperatorTok{{-}\textgreater{}} \BuiltInTok{float}\NormalTok{:}
  \ControlFlowTok{return}\NormalTok{ ((p1[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ p2[}\DecValTok{0}\NormalTok{]) }\OperatorTok{**} \DecValTok{2} \OperatorTok{+}\NormalTok{ (p1[}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ p2[}\DecValTok{1}\NormalTok{]) }\OperatorTok{**} \DecValTok{2}\NormalTok{) }\OperatorTok{**} \FloatTok{0.5}

\CommentTok{\# Test della funzione con alias di tipo}
\NormalTok{punto1: Point }\OperatorTok{=}\NormalTok{ (}\FloatTok{1.0}\NormalTok{, }\FloatTok{2.0}\NormalTok{) }
\NormalTok{punto2: Point }\OperatorTok{=}\NormalTok{ (}\FloatTok{4.0}\NormalTok{, }\FloatTok{6.0}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(distanza(punto1, punto2))  }\CommentTok{\# Output: 5.0}

\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(punto1)) }\CommentTok{\# Output: \textless{}class \textquotesingle{}tuple\textquotesingle{}\textgreater{} }\hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Uso di \texttt{type} come parola chiave.
  \item[\circled{2}]
  Uso di \texttt{type} identificatore di una funzione.
  \end{description}
\end{itemize}

\subsection{Classi riservate di
identificatori}\label{classi-riservate-di-identificatori}

Alcune classi di identificatori (oltre alle parole chiave) hanno
significati speciali in Python. Queste classi sono identificate dai
pattern di caratteri di sottolineatura (underscore) all'inizio e alla
fine dei nomi. Tuttavia, l'uso di questi identificatori non impone
limitazioni rigide al programmatore, ma è importante seguire le
convenzioni per evitare ambiguità e problemi di compatibilità.

Identificatori speciali:

\begin{itemize}
\item
  \texttt{\_}:

  \begin{itemize}
  \item
    Non importato da \texttt{from\ module\ import\ *}: Gli
    identificatori che iniziano con un singolo underscore non vengono
    importati con un'istruzione di importazione globale. Questo è un
    meccanismo per indicare che tali variabili o funzioni sono destinate
    ad essere \emph{private} al modulo e non dovrebbero essere usate
    direttamente da altri moduli. Esempio:

\phantomsection\label{annotated-cell-165}%
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nel modulo example.py\textasciigrave{}}
\NormalTok{\_private\_variable }\OperatorTok{=} \StringTok{"Variabile da non esportare\textquotesingle{}"} \hspace*{\fill}\NormalTok{\circled{1}}

\CommentTok{\# In altro modulo diverso da example.py}
\ImportTok{from}\NormalTok{ example }\ImportTok{import} \OperatorTok{*}

\BuiltInTok{print}\NormalTok{(\_private\_variable) }\hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

    \begin{description}
    \tightlist
    \item[\circled{1}]
    Nel modulo \texttt{example.py} viene definita la variabile come
    privata.
    \item[\circled{2}]
    Genera un errore:
    \texttt{NameError:\ name\ \textquotesingle{}\_private\_variable\textquotesingle{}\ is\ not\ defined}
    \end{description}
  \item
    Pattern nei match: Nel contesto di un pattern di corrispondenza
    all'interno di un'istruzione \texttt{match}, \texttt{\_} è una
    parola chiave contestuale che denota un \emph{wildcard} (carattere
    jolly), coem indicato sopra.
  \item
    Interprete interattivo: L'interprete interattivo rende disponibile
    il risultato dell'ultima valutazione nella variabile \texttt{\_}. Il
    valore di \texttt{\_} è memorizzato nel modulo
    \href{https://docs.python.org/3/library/builtins.html}{\texttt{builtins}},
    insieme ad altre funzioni e variabili predefinite come
    \texttt{print()}, permettendo l'accesso globale a \texttt{\_}
    durante una sessione interattiva. Esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{result }\OperatorTok{=} \DecValTok{5} \OperatorTok{+} \DecValTok{3}
\BuiltInTok{print}\NormalTok{(\_)  }\CommentTok{\# Output: 8 (nell\textquotesingle{}interprete interattivo)}
\end{Highlighting}
\end{Shaded}
  \item
    Altro uso: Altrove, \texttt{\_} è un identificatore regolare. Viene
    spesso usato per nominare elementi speciali per l'utente, ma non
    speciali per Python stesso. Il nome \texttt{\_} è comunemente usato
    in congiunzione con l'internazionalizzazione (vedi la documentazione
    del modulo
    \href{https://docs.python.org/3/library/gettext.html}{\texttt{gettext}}
    per ulteriori informazioni su questa convenzione) ed è anche
    comunemente utilizzato per variabili non usate. Esempio:

\phantomsection\label{annotated-cell-167}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\_ }\OperatorTok{=} \StringTok{"Valore non usato"} \hspace*{\fill}\NormalTok{\circled{1}}

\ImportTok{import}\NormalTok{ gettext}

\NormalTok{gettext.install(}\StringTok{\textquotesingle{}myapplication\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(\_(}\StringTok{\textquotesingle{}Hello, world\textquotesingle{}}\NormalTok{)) }\hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

    \begin{description}
    \tightlist
    \item[\circled{1}]
    Uso di \texttt{\_} come variabile regolare.
    \item[\circled{2}]
    Uso di \_ per internazionalizzazione.
    \end{description}
  \end{itemize}
\item
  \texttt{\_\_*\_\_}: Questi nomi, informalmente noti come nomi
  \emph{dunder}\footnote{I nomi con doppio underscore (\texttt{\_\_})
    sono chiamati \emph{dunder} come abbreviazione di \emph{double
    underscore}.}, sono definiti dall'interprete e dalla sua
  implementazione (inclusa la libreria standard). Altri potrebbero
  essere definiti nelle versioni future di Python. Qualsiasi uso di nomi
  \texttt{\_\_*\_\_}, in qualsiasi contesto, che non segua l'uso
  esplicitamente documentato, è soggetto a discontinuazione senza
  preavviso. Esempio:

\phantomsection\label{annotated-cell-168}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ MyClass:}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, value): }\hspace*{\fill}\NormalTok{\circled{1}}
    \VariableTok{self}\NormalTok{.\_\_value }\OperatorTok{=}\NormalTok{ value}

  \KeywordTok{def} \FunctionTok{\_\_str\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
    \ControlFlowTok{return} \SpecialStringTok{f"MyClass con valore }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{\_\_value}\SpecialCharTok{\}}\SpecialStringTok{"} \hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{obj }\OperatorTok{=}\NormalTok{ MyClass(}\DecValTok{10}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(obj) }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Dunder per metodo chiamato alla creazione dell'oggetto.
  \item[\circled{2}]
  Dunder chiamato da \texttt{print} con parametro l'oggetto.
  \item[\circled{3}]
  Output: MyClass con valore 10
  \end{description}
\item
  \texttt{\_\_*}: I nomi in questa categoria, quando utilizzati
  all'interno di una definizione di classe, vengono riscritti dal
  compilatore (processo noto come name \emph{mangling}) per evitare
  conflitti di nome tra attributi ``privati'' delle classi base e delle
  classi derivate. Questo aiuta a garantire che gli attributi destinati
  ad essere privati non vengano accidentalmente sovrascritti nelle
  sottoclassi. Esempio:

\phantomsection\label{annotated-cell-169}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ BaseClass:}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
    \VariableTok{self}\NormalTok{.\_\_private\_attr }\OperatorTok{=} \StringTok{"Base"}

\KeywordTok{class}\NormalTok{ DerivedClass(BaseClass):}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
    \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{()}

    \VariableTok{self}\NormalTok{.\_\_private\_attr }\OperatorTok{=} \StringTok{"Derived"}

\NormalTok{base\_obj }\OperatorTok{=}\NormalTok{ BaseClass()}
\NormalTok{derived\_obj }\OperatorTok{=}\NormalTok{ DerivedClass()}

\BuiltInTok{print}\NormalTok{(base\_obj.\_BaseClass\_\_private\_attr) }\hspace*{\fill}\NormalTok{\circled{1}}
\BuiltInTok{print}\NormalTok{(derived\_obj.\_DerivedClass\_\_private\_attr) }\hspace*{\fill}\NormalTok{\circled{2}}
\end{Highlighting}
\end{Shaded}

  \begin{description}
  \tightlist
  \item[\circled{1}]
  Accesso al nome di \texttt{BaseClass}.
  \item[\circled{2}]
  Accesso al nome di \texttt{DerivedClass}.
  \end{description}
\end{itemize}

\subsection{Operatori}\label{operatori}

Gli operatori sono rappresentati da simboli non alfanumerici e, quando
applicati a uno o più identificatori, letterali o espressioni (definiti
genericamente operandi), producono un risultato. Attenzione a non
confondere la definizione di operatore come token, come considerata qui,
con quella di operatore come funzionalità algoritmica, poiché alcune
parole chiave sono operatori algoritmici e anche le funzioni possono
agire come operatori.

Esempi:

\phantomsection\label{annotated-cell-59}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{5}
\NormalTok{y }\OperatorTok{=} \DecValTok{10}

\NormalTok{z }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\hspace*{\fill}\NormalTok{\circled{1}}

\BuiltInTok{sum} \OperatorTok{=} \DecValTok{3} \OperatorTok{+} \DecValTok{4} \hspace*{\fill}\NormalTok{\circled{2}}

\NormalTok{result }\OperatorTok{=}\NormalTok{ (x }\OperatorTok{*}\NormalTok{ y) }\OperatorTok{+}\NormalTok{ (z }\OperatorTok{/} \DecValTok{2}\NormalTok{) }\hspace*{\fill}\NormalTok{\circled{3}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Utilizza l'operatore \texttt{+} sugli identificatori \texttt{x} e
\texttt{y}.
\item[\circled{2}]
Utilizza l'operatore \texttt{+} su letterali.
\item[\circled{3}]
Utilizza vari operatori su espressioni.
\end{description}

In tabella l'elenco degli operatori:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.6111}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Tipo di operatore
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Operatore
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descrizione
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Aritmetici & \texttt{+} & Addizione \\
& \texttt{-} & Sottrazione \\
& \texttt{*} & Moltiplicazione \\
& \texttt{/} & Divisione \\
& \texttt{//} & Divisione intera \\
& \texttt{\%} & Modulo \\
& \texttt{**} & Esponenziazione \\
& \texttt{@} & Matrice (operatore di moltiplicazione) \\
Confronto & \texttt{\textless{}} & Minore \\
& \texttt{\textgreater{}} & Maggiore \\
& \texttt{\textless{}=} & Minore o uguale \\
& \texttt{\textgreater{}=} & Maggiore o uguale \\
& \texttt{==} & Uguale \\
& \texttt{!=} & Diverso \\
Bitwise & \texttt{\&} & AND bit a bit \\
& \texttt{\textbar{}} & OR bit a bit \\
& \texttt{\^{}} & XOR bit a bit \\
& \texttt{\textasciitilde{}} & NOT bit a bit \\
& \texttt{\textless{}\textless{}} & Shift a sinistra \\
& \texttt{\textgreater{}\textgreater{}} & Shift a destra \\
Assegnazione & \texttt{:=} & Operatore di assegnazione in espressione
(walrus o tricheco) \\
\end{longtable}

Esempio su \texttt{@} che illustra un aspetto importante: il
comportamento degli operatori può (o meglio, deve) essere definito
quando si creano dei tipi di oggetto. Infatti, nel codice seguente, è
definita una matrice assieme a una delle operazioni matematiche più
comuni che è la moltiplicazione, implementata per mezzo di
\texttt{\_\_matmul\_\_}:

\phantomsection\label{annotated-cell-60}%
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Matrice:}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, righe):}
    \VariableTok{self}\NormalTok{.righe }\OperatorTok{=}\NormalTok{ righe}
    \VariableTok{self}\NormalTok{.num\_righe }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(righe)}
    \VariableTok{self}\NormalTok{.num\_colonne }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(righe[}\DecValTok{0}\NormalTok{]) }\ControlFlowTok{if}\NormalTok{ righe }\ControlFlowTok{else} \DecValTok{0}

  \KeywordTok{def} \FunctionTok{\_\_matmul\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, altra):}
    \ControlFlowTok{if} \VariableTok{self}\NormalTok{.num\_colonne }\OperatorTok{!=}\NormalTok{ altra.num\_righe: }\hspace*{\fill}\NormalTok{\circled{1}}
      \ControlFlowTok{raise} \PreprocessorTok{ValueError}\NormalTok{(}\StringTok{"Non è possibile moltiplicare le matrici: "}
                       \StringTok{"dimensioni incompatibili."}\NormalTok{)}
    
\NormalTok{    risultato }\OperatorTok{=}\NormalTok{ [[}\DecValTok{0} \ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(altra.num\_colonne)] }\hspace*{\fill}\NormalTok{\circled{2}}
           \ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\VariableTok{self}\NormalTok{.num\_righe)]}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\VariableTok{self}\NormalTok{.num\_righe): }\hspace*{\fill}\NormalTok{\circled{3}}
      \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(altra.num\_colonne):}
        \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\VariableTok{self}\NormalTok{.num\_colonne):}
\NormalTok{          risultato[i][j] }\OperatorTok{+=}\NormalTok{ (}\VariableTok{self}\NormalTok{.righe[i][k] }\OperatorTok{*}
\NormalTok{                    altra.righe[k][j])}
    
    \ControlFlowTok{return}\NormalTok{ Matrice(risultato)}

  \KeywordTok{def} \FunctionTok{\_\_repr\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{): }\hspace*{\fill}\NormalTok{\circled{4}}
    \ControlFlowTok{return} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{.join([}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{, riga)) }\ControlFlowTok{for}\NormalTok{ riga }\KeywordTok{in} \VariableTok{self}\NormalTok{.righe])}

\CommentTok{\# Definizione di due matrici}
\NormalTok{A }\OperatorTok{=}\NormalTok{ Matrice([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], }
\NormalTok{             [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]])}
\NormalTok{B }\OperatorTok{=}\NormalTok{ Matrice([[}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], }
\NormalTok{             [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{]])}

\CommentTok{\# Moltiplicazione di matrici utilizzando l\textquotesingle{}operatore @}
\NormalTok{C }\OperatorTok{=}\NormalTok{ A }\OperatorTok{@}\NormalTok{ B}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Matrice A:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(A)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Matrice B:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(B)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Risultato di A @ B:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(C) }\hspace*{\fill}\NormalTok{\circled{5}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Controlla se le dimensioni sono compatibili per la moltiplicazione.
\item[\circled{2}]
Inizializza la matrice risultato con zeri.
\item[\circled{3}]
Esegue la moltiplicazione delle matrici.
\item[\circled{4}]
Rappresentazione leggibile della matrice.
\item[\circled{5}]
Chiama \texttt{\_\_matmul\_\_} per ottenere la stringa su due righe:
\texttt{19\ 22} e \texttt{43\ 50}.
\end{description}

Infine, \texttt{@} è anche un delimitatore.

\subsection{Delimitatori}\label{delimitatori}

In Python, alcuni token servono come delimitatori nella grammatica del
linguaggio. I delimitatori sono caratteri che separano le varie
componenti del codice, come espressioni, blocchi di codice, parametri di
funzioni e istruzioni.

La seguente tabella include tutti i delimitatori e i principali
utilizzi:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2619}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7381}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Delimitatore
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descrizione
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{(} & Utilizzata per raggruppare espressioni, chiamate di
funzione e definizioni di tupla \\
\texttt{)} & Utilizzata per chiudere le parentesi tonde aperte \\
\texttt{{[}} & Utilizzate per definire liste e accedere agli elementi
delle liste, tuple, o stringhe \\
\texttt{{]}} & Utilizzate per chiudere le parentesi quadre aperte \\
\texttt{\{} & Utilizzate per definire dizionari e set \\
\texttt{\}} & Utilizzate per chiudere le parentesi graffe aperte \\
\texttt{,} & Utilizzata per separare elementi in liste, tuple, e
argomenti nelle chiamate di funzione \\
\texttt{:} & Utilizzato per definire blocchi di codice (come in
\texttt{if}, \texttt{for}, \texttt{while}, \texttt{def}, \texttt{class})
e per gli slice \\
\texttt{.} & Utilizzato per accedere agli attributi di un oggetto. Può
apparire in letterali decimnali e immaginari \\
\texttt{;} & Utilizzato per separare istruzioni multiple sulla stessa
riga \\
\texttt{@} & Utilizzato per dichiarare decoratori per funzioni e
metodi \\
\texttt{=} & Operatore utilizzato per assegnare valori a variabili \\
\texttt{-\textgreater{}} & Annotazione del tipo di ritorno delle
funzioni \\
\texttt{+=} & Assegnazione aumentata con addizione. Aggiunge il valore a
destra a quello a sinistra e assegna il risultato alla variabile a
sinistra. Come i successivi, è sia un delimitatore che un operatore \\
\texttt{-=} & Assegnazione aumentata con sottrazione \\
\texttt{*=} & Assegnazione aumentata con moltiplicazione \\
\texttt{/=} & Assegnazione aumentata con divisione \\
\texttt{//=} & Assegnazione aumentata con divisione intera \\
\texttt{\%=} & Assegnazione aumentata con modulo \\
\texttt{@=} & Assegnazione aumentata con moltiplicazione di matrici \\
\texttt{\&=} & Assegnazione aumentata con AND bit a bit \\
\texttt{\textbar{}=} & Assegnazione aumentata con OR bit a bit \\
\texttt{\^{}=} & Assegnazione aumentata con XOR bit a bit \\
\texttt{\textgreater{}\textgreater{}=} & Assegnazione aumentata con
shift a destra \\
\texttt{\textless{}\textless{}=} & Assegnazione aumentata con shift a
sinistra \\
\texttt{**=} & Assegnazione aumentata con esponenziazione \\
\end{longtable}

Una sequenza di tre punti, comunemente indicata come ellissi anche al
difuori dei linguaggi di programmazione,\footnote{L'ellissi è usata, ad
  esempio, in C per dichiarare funzioni che accettano un numero
  variaible di parametri e i Javascript come operatore per espandere gli
  array o le proprietà di un oggetto.} è trattata come un token a sé e
corrisponde ad un oggetto predefinito chiamato
\href{https://docs.python.org/3/reference/datamodel.html\#ellipsis}{Ellipsis},
con applicazioni in diversi contesti:

\phantomsection\label{annotated-cell-61}%
\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(...)) }\hspace*{\fill}\NormalTok{\circled{1}}

\KeywordTok{def}\NormalTok{ funzione\_da\_completare():}
\NormalTok{  ... }\hspace*{\fill}\NormalTok{\circled{2}}

\KeywordTok{class}\NormalTok{ ClasseEsempio:}
  \KeywordTok{def}\NormalTok{ metodo\_da\_completare(}\VariableTok{self}\NormalTok{):}
\NormalTok{    ...}

\ImportTok{from}\NormalTok{ typing }\ImportTok{import}\NormalTok{ Callable}

\KeywordTok{def}\NormalTok{ funzione\_variadica(func: Callable[..., }\BuiltInTok{int}\NormalTok{]): }\hspace*{\fill}\NormalTok{\circled{3}}
  \ControlFlowTok{pass}

\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{array }\OperatorTok{=}\NormalTok{ np.array([[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{],    [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]], }
\NormalTok{                  [[}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]]) }

\BuiltInTok{print}\NormalTok{(array[..., }\DecValTok{1}\NormalTok{]) }\hspace*{\fill}\NormalTok{\circled{4}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Otteniamo il tipo dell'oggetto ellissi. L'output è
\texttt{\textless{}class\ \textquotesingle{}ellipsis\textquotesingle{}\textgreater{}}.
\item[\circled{2}]
Utilizzo come segnaposto per indicare che la funzione è da completare.
Da notare che chiamare la funzione \texttt{funzione\_da\_completare()}
non dà errore.
\item[\circled{3}]
L'uso di \texttt{Callable{[}...,\ int{]}} indica una funzione che può
accettare un numero variabile di argomenti di qualsiasi tipo e
restituire un valore di tipo int.
\item[\circled{4}]
\texttt{numpy} è una libreria di calcolo matriciale molto diffusa.
L'ellissi è utilizzata per effettuare uno sezione complessa della
matrice secondo tutte le dimensioni precedenti all'ultima. In altre
parole, l'ellissi permette di selezionare interamente tutte le
dimensioni tranne l'ultima specificata. Il risultato stampato in console
è su due righe: \texttt{{[}{[}\ 2\ \ 5{]}} e \texttt{{[}\ 8\ 11{]}{]}}.
\end{description}

Alcuni caratteri ASCII hanno un significato speciale come parte di altri
token o sono significativi per l'analizzatore lessicale:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2706}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7294}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Carattere
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descrizione
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\textquotesingle{}} & Utilizzato per definire stringhe di
caratteri. \\
\texttt{"} & Utilizzato per definire stringhe di caratteri. \\
\texttt{\#} & Simbolo di commento. Utilizzato per indicare un commento,
che viene ignorato dall'interprete Python. \\
\texttt{\textbackslash{}} & Backslash. Utilizzato per caratteri di
escape nelle stringhe e per continuare le righe di codice su più righe
fisiche. \\
\end{longtable}

Alcuni caratteri ASCII non sono utilizzati in Python e la loro presenza
al difuori dei letterali di stringa e dei commenti genera un errore:
\texttt{\$}, \texttt{?}, \texttt{\textasciigrave{}}.

\subsection{Letterali}\label{letterali}

I letterali sono notazioni per valori costanti di alcuni tipi
predefiniti nel linguaggio. Esistono diversi tipi di letterali, ognuno
rappresenta un tipo di dato specifico e ha una sintassi particolare.

\subsubsection{Numerici}\label{numerici}

I letterali numerici includono interi, numeri a virgola mobile e numeri
complessi:

\begin{itemize}
\item
  Interi, possono essere scritti in base decimale, ottale, esadecimale o
  binaria:

  \begin{itemize}
  \tightlist
  \item
    Decimale: \texttt{10}, \texttt{-3}.
  \item
    Ottale: \texttt{0o12}, \texttt{-0o7}.
  \item
    Esadecimale: \texttt{0xA}, \texttt{-0x1F}.
  \item
    Binario: \texttt{0b1010}, \texttt{-0b11}.
  \end{itemize}
\item
  Virgola mobile, possono essere rappresentati con una parte intera e
  una decimale, oppure con notazione scientifica:

  \begin{itemize}
  \tightlist
  \item
    Virgola mobile: \texttt{3.14}, \texttt{-0.001}.
  \item
    Notazione scientifica: \texttt{1e10}, \texttt{-2.5e-3}.
  \end{itemize}
\item
  Complessi, appresentati da una parte reale e una parte immaginaria:
  \texttt{3+4j}, \texttt{-1-0.5j}.
\end{itemize}

\subsubsection{Stringhe}\label{stringhe}

I letterali di stringa possono essere racchiusi tra virgolette singole o
doppie. Possono anche essere multi-linea se racchiusi tra triple
virgolette singole o doppie:

\begin{itemize}
\item
  Stringhe racchiuse tra virgolette singole o doppie:

  \begin{itemize}
  \tightlist
  \item
    Singole: \texttt{\textquotesingle{}ciao\textquotesingle{}}.
  \item
    Doppie: \texttt{"mondo"}.
  \end{itemize}
\item
  Stringhe multi-linea racchiuse tra triple virgolette singole o doppie:

  \begin{itemize}
  \tightlist
  \item
    Triple singole:
    \texttt{\textquotesingle{}\textquotesingle{}\textquotesingle{}testo\ multi-linea\textquotesingle{}\textquotesingle{}\textquotesingle{}}.
  \item
    Triple doppie: \texttt{"""testo\ multi-linea"""}.
  \end{itemize}
\end{itemize}

Le stringhe tra tripli apici possono avere degli a capo e degli apici
(non tripli) all'interno.

Esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stringa\_multilinea }\OperatorTok{=} \StringTok{"""Questa è una stringa}
\StringTok{molto "importante"."""}

\BuiltInTok{print}\NormalTok{(stringa\_multilinea)}
\end{Highlighting}
\end{Shaded}

Tutte le stringhe sono codificate in Unicode, con il prefisso \texttt{b}
la stringa è di tipo byte ed è limitata ai 128 caratteri dell'ASCII. Se
si prepone \texttt{r}, che sta per \emph{raw} cioè grezzo, allora la
codifica è sempre Unicode ma i caratteri di escape\footnote{In Python,
  il carattere di escape \texttt{\textbackslash{}} è utilizzato nelle
  stringhe per inserire caratteri speciali che non possono essere
  facilmente digitati sulla tastiera o che hanno significati speciali.

  Alcuni esempi comuni includono:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textbackslash{}n} per una nuova linea (linefeed).
  \item
    \texttt{\textbackslash{}t} per una tabulazione.
  \item
    \texttt{\textbackslash{}\textbackslash{}} per inserire un backslash.
  \item
    \texttt{\textbackslash{}\textquotesingle{}} per un apostrofo.
  \item
    \texttt{\textbackslash{}"} per una doppia virgoletta.
  \end{itemize}

  Questi caratteri permettono di includere simboli speciali nelle
  stringhe senza interrompere la sintassi del codice.} non sono
intepretati.

\subsubsection{F-stringhe}\label{f-stringhe}

Le f-stringhe (stringhe formattate) sono racchiuse tra virgolette
singole, doppie o triple e sono precedute dal prefisso \texttt{f} o
\texttt{F}. Permettono di includere espressioni Python all'interno.

Si possono avere stringhe formattate grezze ma non byte.

Esempio:

\phantomsection\label{annotated-cell-63}%
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome }\OperatorTok{=} \StringTok{"Python"}

\NormalTok{f\_stringa }\OperatorTok{=} \SpecialStringTok{f\textquotesingle{}Ciao, }\SpecialCharTok{\{}\NormalTok{nome}\SpecialCharTok{.}\NormalTok{upper()}\SpecialCharTok{\}}\SpecialStringTok{!\textquotesingle{}} \hspace*{\fill}\NormalTok{\circled{1}}

\NormalTok{definizione }\OperatorTok{=} \StringTok{"Linguaggio"}

\NormalTok{f\_stringa\_multi\_linea }\OperatorTok{=} \SpecialStringTok{f\textquotesingle{}\textquotesingle{}\textquotesingle{}Questo è un esempio}
\SpecialStringTok{di f{-}stringa multi{-}linea}
\SpecialStringTok{in }\SpecialCharTok{\{}\NormalTok{definizione}\SpecialCharTok{.}\NormalTok{lower() }\OperatorTok{+} \StringTok{\textquotesingle{} \textquotesingle{}} \OperatorTok{+}\NormalTok{ nome}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}} \hspace*{\fill}\NormalTok{\circled{2}}

\BuiltInTok{print}\NormalTok{(f\_stringa) }\hspace*{\fill}\NormalTok{\circled{3}}

\BuiltInTok{print}\NormalTok{(f\_stringa\_multi\_linea) }\hspace*{\fill}\NormalTok{\circled{4}}
\end{Highlighting}
\end{Shaded}

\begin{description}
\tightlist
\item[\circled{1}]
Viene chiamato il metodo della stringa lower() per avere il maiuscolo.
\item[\circled{2}]
Usiamo un'espressione di concatenazione di stringhe.
\item[\circled{3}]
Output: \texttt{Output:\ Ciao,\ python!}.
\item[\circled{4}]
Output composto dalle tre righe \texttt{Questo\ è\ un\ esempio},
\texttt{di\ f-stringa\ multi-linea} e \texttt{in\ linguaggio\ Python}.
\end{description}

\section{Istruzioni}\label{istruzioni}

Un programma Python è una sequenza di istruzioni che si distinguono in
\textbf{semplici} e \textbf{composte}.

\subsection{Istruzioni semplici}\label{istruzioni-semplici-1}

Un'istruzione semplice è sempre contenuta in una riga logica, che può
presentare più istruzioni semplici separate da \texttt{;}. È permesso ma
scaonsigliato perché in pochi casi porta a codice leggibile.

In Python, le istruzioni semplici sono:

\begin{itemize}
\item
  Assegnazione, attribuisce un valore a una variabile:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{10}
\end{Highlighting}
\end{Shaded}
\item
  Istruzioni di importazione, permettono di utilizzare gli
  identificatori definiti in altri moduli:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ math}
\ImportTok{from}\NormalTok{ math }\ImportTok{import}\NormalTok{ sqrt}
\end{Highlighting}
\end{Shaded}
\item
  Istruzioni di controllo del flusso nei cicli:

  \begin{itemize}
  \tightlist
  \item
    \texttt{break}: Interrompe un ciclo.
  \item
    \texttt{continue}: Salta all'iterazione successiva di un ciclo.
  \item
    \texttt{pass}: Non esegue alcuna operazione.
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==} \DecValTok{5}\NormalTok{:}
        \ControlFlowTok{break}
\end{Highlighting}
\end{Shaded}
\item
  Istruzioni di gestione dell'uscita da una funzione, della generazione
  di valori o del sollevamento di eccezioni:

  \begin{itemize}
  \tightlist
  \item
    \texttt{return}: Restituisce un valore da una funzione.
  \item
    \texttt{yield}: Restituisce un generatore.
  \item
    \texttt{raise}: Solleva un'eccezione per segnalare uan condizione di
    errore.
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ func():}
    \ControlFlowTok{return}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}
\item
  Istruzioni di asserzione in cui si verifica una condizione e viene
  generata un'eccezione se la condizione è falsa:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{assert}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"x deve essere positivo"}
\end{Highlighting}
\end{Shaded}
\item
  Istruzioni di diichiarazione di modifica dell'ambito di variabili:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{global}\NormalTok{ x}
\KeywordTok{nonlocal}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Un'espressione è una istruzione semplice ed, infatti, inserita nel REPL,
ne viene prodotto il risultato della valutazione. D'altronde, una
espressione è spesso utilizzata per chiamare funzioni che hanno effetti
collaterali, come, ad esempio, produrre un output:

\begin{itemize}
\item
  Produzione di output:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Funzione che stampa un messaggio}
\KeywordTok{def}\NormalTok{ stampa\_messaggio(messaggio):}
  \BuiltInTok{print}\NormalTok{(messaggio)}

\CommentTok{\# Istruzione di espressione che chiama la funzione }
\CommentTok{\# con un effetto collaterale (stampa del messaggio)}
\NormalTok{stampa\_messaggio(}\StringTok{"Ciao, mondo!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Modifica di parametri:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Funzione che modifica un argomento mutabile (lista)}
\KeywordTok{def}\NormalTok{ aggiungi\_elemento(lista, elemento):}
\NormalTok{  lista.append(elemento)}

\CommentTok{\# Lista iniziale}
\NormalTok{numeri }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}

\CommentTok{\# Istruzione di espressione che chiama la funzione }
\CommentTok{\# con un effetto collaterale (modifica dell\textquotesingle{}argomento)}
\NormalTok{aggiungi\_elemento(numeri, }\DecValTok{4}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(numeri)  }\CommentTok{\# Output: [1, 2, 3, 4]}
\end{Highlighting}
\end{Shaded}
\item
  Modifica di variabili globali:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Variabile globale}
\NormalTok{contatore }\OperatorTok{=} \DecValTok{0}

\CommentTok{\# Funzione che modifica una variabile globale}
\KeywordTok{def}\NormalTok{ incrementa\_contatore():}
  \KeywordTok{global}\NormalTok{ contatore}

\NormalTok{  contatore }\OperatorTok{+=} \DecValTok{1}

\CommentTok{\# Istruzione di espressione che chiama la funzione }
\CommentTok{\# con un effetto collaterale (modifica della variabile globale)}
\NormalTok{incrementa\_contatore()}

\BuiltInTok{print}\NormalTok{(contatore)  }\CommentTok{\# Output: 1}
\end{Highlighting}
\end{Shaded}
\item
  Lancio di eccezioni:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Funzione che solleva un\textquotesingle{}eccezione}
\KeywordTok{def}\NormalTok{ solleva\_eccezione(messaggio):}
  \ControlFlowTok{raise} \PreprocessorTok{ValueError}\NormalTok{(messaggio)}

\CommentTok{\# Istruzione di espressione che chiama la funzione con un effetto collaterale (sollevamento di un\textquotesingle{}eccezione)}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  solleva\_eccezione(}\StringTok{"Qualcosa è andato storto!"}\NormalTok{)}

\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ e:}
  \BuiltInTok{print}\NormalTok{(e)  }\CommentTok{\# Output: Qualcosa è andato storto!}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Un assegnamento con \texttt{=} è anch'esso un'istruzione semplice e non
può mai essere all'interno di una espressione, dove, invece, si può
usare l'operatore \emph{tricheco} \texttt{:=}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{:=} \BuiltInTok{len}\NormalTok{(}\StringTok{"Python"}\NormalTok{)) }\OperatorTok{\textgreater{}} \DecValTok{5}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"La lunghezza della stringa è }\SpecialCharTok{\{}\NormalTok{n}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{) }
  \CommentTok{\# Output: La lunghezza della stringa è 6}
\end{Highlighting}
\end{Shaded}

\subsection{Istruzioni composte}\label{istruzioni-composte}

Una istruzione composta è costituita da altre istruzioni (semplici o
composte). Il controllo dell'esecuzione delle istruzioni componenti
avviene per mezzo di una o più clausole che iniziano tutte con una
parola chiave, sono terminate da \texttt{:} e seguite da un blocco di
codice. Ogni blocco deve avere almeno una istruzione semplice, ma può
non avere una propria riga logica, cioè stare sulla stessa riga fisica e
logica del \texttt{:}.

Alcuni esempi del rapporto tra istruzioni e righe:

\begin{itemize}
\item
  Blocco di istruzioni separato su più righe con medesima indentazione:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{)}

\NormalTok{  x }\OperatorTok{+=} \DecValTok{1}

  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"x ora è }\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Blocco come singola istruzione sulla stessa riga logica:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{: }\BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Diverse istruzioni semplici sulla stessa riga logica (non
  consigliato):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{: }\BuiltInTok{print}\NormalTok{(}\StringTok{"x è positivo"}\NormalTok{)}\OperatorTok{;}\NormalTok{ x }\OperatorTok{+=} \DecValTok{1}\OperatorTok{;} \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"x ora è }\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Ed ecco le principali istruzioni composte:

\begin{itemize}
\item
  \texttt{if}, controlla l'esecuzione di un blocco di codice in base a
  una condizione:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ condizione:}
    \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{for}, itera su una sequenza (come una lista, una tupla o una
  stringa):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ elemento }\KeywordTok{in}\NormalTok{ sequenza:}
    \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{while}, esegue un blocco di codice finché una condizione è
  vera:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while}\NormalTok{ condizione:}
    \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{try}, gestisce gli errori che possono verificarsi durante
  l'esecuzione di un blocco di codice:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
    \CommentTok{\# blocco di codice}
\ControlFlowTok{except}\NormalTok{ Eccezione:}
    \CommentTok{\# blocco di codice per gestire l\textquotesingle{}eccezione}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{with}, gestisce l'allocazione e la deallocazione di risorse:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}file.txt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{def}, definisce una funzione:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ nome\_funzione(parametri):}
    \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{class}, definisce una classe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ NomeClasse:}
    \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{match}, esegue il pattern matching su un valore:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{match}\NormalTok{ valore:}
    \ControlFlowTok{case}\NormalTok{ pattern:}
        \CommentTok{\# blocco di codice}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\chapter{Modello dati}\label{modello-dati-1}

Un \textbf{modello dati} è una rappresentazione astratta che definisce
come i dati sono organizzati, archiviati e manipolati all'interno di un
sistema informatico. In altre parole, un modello dati stabilisce le
strutture dei dati e le relazioni tra essi, fornendo un quadro
concettuale per comprendere e gestire le informazioni.

\subsection{Componenti di un Modello
Dati}\label{componenti-di-un-modello-dati}

Un modello dati tipicamente include le seguenti componenti:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Entità}: Le entità rappresentano oggetti o concetti del mondo
  reale che possiedono attributi e hanno un'esistenza indipendente. Ad
  esempio, in un database di una biblioteca, entità possono essere
  ``Libri'', ``Autori'', e ``Utenti''.
\item
  \textbf{Attributi}: Gli attributi sono proprietà o caratteristiche
  delle entità. Per esempio, l'entità ``Libro'' può avere attributi come
  ``Titolo'', ``Autore'', ``Anno di pubblicazione'' e ``ISBN''.
\item
  \textbf{Relazioni}: Le relazioni definiscono le associazioni tra le
  entità. Ad esempio, una relazione può indicare che ``Autore'' scrive
  ``Libro'' o che ``Utente'' prende in prestito ``Libro''.
\item
  \textbf{Vincoli}: I vincoli sono regole che limitano i dati ammessi
  all'interno del modello, garantendo l'integrità e la coerenza dei
  dati. Un esempio di vincolo è che un ISBN deve essere univoco per ogni
  libro.
\end{enumerate}

\subsection{Tipi di Modelli Dati}\label{tipi-di-modelli-dati}

Esistono diversi tipi di modelli dati, ciascuno con il proprio livello
di astrazione e applicazioni specifiche:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Modello Dati Concettuale}: Questo modello fornisce una visione
  ad alto livello della struttura dei dati, senza preoccuparsi di come i
  dati saranno fisicamente implementati. È spesso rappresentato mediante
  diagrammi E/R (Entità-Relazione).
\item
  \textbf{Modello Dati Logico}: Questo modello traduce il modello
  concettuale in strutture che possono essere implementate in un sistema
  di gestione di database (DBMS). Definisce tabelle, colonne, chiavi
  primarie e chiavi esterne.
\item
  \textbf{Modello Dati Fisico}: Questo modello descrive
  l'implementazione effettiva dei dati nel DBMS, includendo dettagli
  come i tipi di dati specifici, gli indici, le partizioni, e le
  modalità di memorizzazione.
\end{enumerate}

\subsection{Importanza del Modello
Dati}\label{importanza-del-modello-dati}

Un modello dati ben progettato è fondamentale per diverse ragioni:

\begin{itemize}
\tightlist
\item
  \textbf{Organizzazione dei Dati}: Fornisce una struttura chiara e
  logica per l'archiviazione e l'accesso ai dati.
\item
  \textbf{Efficienza}: Ottimizza le operazioni di database, migliorando
  la velocità e la scalabilità.
\item
  \textbf{Integrità dei Dati}: Assicura che i dati siano accurati,
  coerenti e privi di errori.
\item
  \textbf{Manutenzione}: Facilita la manutenzione e l'espansione del
  sistema, consentendo aggiornamenti e modifiche più agevoli.
\end{itemize}

\subsection{Conclusione}\label{conclusione}

Un modello dati è essenziale per la progettazione e la gestione
efficiente dei dati in qualsiasi sistema informatico. Comprendere i
principi dei modelli dati è cruciale per sviluppatori, amministratori di
database e analisti di dati, poiché fornisce le basi per costruire
applicazioni solide e scalabili.

L'operazione di un programma Python si basa sui dati che gestisce. I
valori dei dati in Python sono noti come oggetti; ogni oggetto, alias
valore, ha un tipo. Il tipo di un oggetto determina quali operazioni
l'oggetto supporta (in altre parole, quali operazioni è possibile
eseguire sul valore). Il tipo determina anche gli attributi e gli
elementi dell'oggetto (se presenti) e se l'oggetto può essere
modificato. Un oggetto che può essere modificato è noto come oggetto
mutabile, mentre uno che non può essere modificato è un oggetto
immutabile. Trattiamo gli attributi e gli elementi degli oggetti nella
sezione ``Object attributes and items''.

La funzione incorporata \texttt{type(obj)} accetta qualsiasi oggetto
come argomento e restituisce l'oggetto di tipo che rappresenta il tipo
di \texttt{obj}. La funzione incorporata \texttt{isinstance(obj,\ type)}
restituisce True quando l'oggetto \texttt{obj} ha il tipo \texttt{type}
(o qualsiasi sua sottoclasse); altrimenti, restituisce False.
L'argomento \texttt{type} di \texttt{isinstance} può anche essere una
tupla di tipi (Python 3.10+ o più tipi uniti con l'operatore
\texttt{\textbar{}}), nel qual caso restituisce True se il tipo di
\texttt{obj} corrisponde a uno qualsiasi dei tipi dati, o a qualsiasi
sottoclasse di quei tipi.

Python ha tipi incorporati per tipi di dati fondamentali come numeri,
stringhe, tuple, liste, dizionari e insiemi, come trattato nelle sezioni
seguenti.

\chapter{Esercizi}\label{esercizi}

\section{Fondamenti}\label{fondamenti}

\subsection{★☆☆☆☆ Python come
calcolatrice}\label{python-come-calcolatrice}

Provare le operazioni su booleani, numeri interi, in virgola mobile e
stringhe, nel REPL.

\subsubsection{Numeri}\label{numeri}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare gli operatori matematici su costanti numeriche e osservare i
risultati e gli errori nel REPL, perché è più immediato rispetto
all'esecuzione completa del programma.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Se eseguite nel REPL i print sono inutili!}

\CommentTok{\# Moltiplicazione}
\NormalTok{x }\OperatorTok{=} \DecValTok{5} \OperatorTok{*} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(x)}

\NormalTok{x }\OperatorTok{=} \DecValTok{5} \OperatorTok{*} \FloatTok{2.}
\BuiltInTok{print}\NormalTok{(x) }\CommentTok{\# Cosa notiamo?}

\CommentTok{\# Divisione in virgola mobile}
\NormalTok{x }\OperatorTok{=} \DecValTok{5} \OperatorTok{/} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(x)}

\NormalTok{x }\OperatorTok{=} \DecValTok{4} \OperatorTok{/} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(x) }\CommentTok{\# Cosa notiamo?}

\NormalTok{x }\OperatorTok{=} \DecValTok{4} \OperatorTok{/} \FloatTok{2.}
\BuiltInTok{print}\NormalTok{(x)}

\CommentTok{\# Confronto}
\NormalTok{x }\OperatorTok{=} \DecValTok{5} \OperatorTok{\textgreater{}} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(x)}

\NormalTok{x }\OperatorTok{=} \DecValTok{5} \OperatorTok{\textgreater{}} \FloatTok{2.}
\BuiltInTok{print}\NormalTok{(x) }\CommentTok{\# Cosa notiamo?}

\CommentTok{\# Diversità}
\NormalTok{x }\OperatorTok{=} \DecValTok{4} \OperatorTok{!=} \FloatTok{4.}
\BuiltInTok{print}\NormalTok{(x) }\CommentTok{\# Cosa notiamo?}

\NormalTok{x }\OperatorTok{=} \DecValTok{0} \OperatorTok{!=}\NormalTok{ (}\DecValTok{1} \OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x) }\CommentTok{\# Cosa notiamo?}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
10.0
2.5
2.0
2.0
True
True
False
False
\end{verbatim}

\subsubsection{Stringhe}\label{stringhe-1}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare gli operatori su stringhe, sempre nel REPL.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Se eseguite nel REPL i print sono inutili!}

\NormalTok{s }\OperatorTok{=} \StringTok{"Hello"} \OperatorTok{+} \StringTok{\textquotesingle{} \textquotesingle{}} \OperatorTok{+} \StringTok{\textquotesingle{}World!\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(s)}

\NormalTok{ss }\OperatorTok{=}\NormalTok{ s}

\NormalTok{ss }\OperatorTok{*=} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(ss)}
\BuiltInTok{print}\NormalTok{(s) }\CommentTok{\# Cosa notiamo per s e ss?}

\CommentTok{\# Appartenenza}
\NormalTok{b }\OperatorTok{=} \StringTok{\textquotesingle{}el\textquotesingle{}} \KeywordTok{in}\NormalTok{ s}
\BuiltInTok{print}\NormalTok{(b) }

\NormalTok{b }\OperatorTok{=} \StringTok{\textquotesingle{}oo\textquotesingle{}} \KeywordTok{not} \KeywordTok{in}\NormalTok{ s}
\BuiltInTok{print}\NormalTok{(b)}

\CommentTok{\# Confronto}
\NormalTok{b }\OperatorTok{=} \StringTok{"Ciao Mondo!"} \OperatorTok{\textless{}}\NormalTok{ s }
\BuiltInTok{print}\NormalTok{(b) }\CommentTok{\# È rispettato l\textquotesingle{}ordine lessicografico?}

\NormalTok{l\_s}\OperatorTok{=} \BuiltInTok{len}\NormalTok{(s)}
\BuiltInTok{print}\NormalTok{(l\_s)}

\CommentTok{\# Slicing della stringa come contenitore di caratteri}
\NormalTok{s\_ }\OperatorTok{=}\NormalTok{ ss[:l\_s] }
\BuiltInTok{print}\NormalTok{(s\_) }

\NormalTok{l\_ss }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(ss) }
\BuiltInTok{print}\NormalTok{(l\_ss)}

\CommentTok{\# Modo alternativo di ottenere la stringa originale solo usando ss}
\NormalTok{s\_ }\OperatorTok{=}\NormalTok{ ss[:}\BuiltInTok{int}\NormalTok{(l\_ss }\OperatorTok{/} \DecValTok{2}\NormalTok{)] }
\BuiltInTok{print}\NormalTok{(s\_) }

\CommentTok{\# Metodo per rendere la stringa in maiuscolo}
\NormalTok{su }\OperatorTok{=}\NormalTok{ s.upper()}
\BuiltInTok{print}\NormalTok{(su)}

\CommentTok{\# Uguaglianza}
\NormalTok{b }\OperatorTok{=}\NormalTok{ s }\OperatorTok{==}\NormalTok{ su}
\BuiltInTok{print}\NormalTok{(b) }\CommentTok{\# Cosa notiamo?}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hello World!
Hello World!Hello World!
Hello World!
True
True
True
12
Hello World!
24
Hello World!
HELLO WORLD!
False
\end{verbatim}

\subsubsection{Espressioni}\label{espressioni-1}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Costruire delle espressioni per comprendere come mischiare numeri e
stringhe, la precedenza degli operatori e le conversioni di tipo, sempre
nel REPL.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{42}
\NormalTok{s }\OperatorTok{=} \StringTok{"42"}

\CommentTok{\# Congiunzione}
\NormalTok{b }\OperatorTok{=}\NormalTok{ n }\KeywordTok{and}\NormalTok{ s}
\BuiltInTok{print}\NormalTok{(b) }\CommentTok{\# Cosa notiamo?}

\CommentTok{\# Disgiunzione}
\NormalTok{b }\OperatorTok{=}\NormalTok{ n }\KeywordTok{or}\NormalTok{ s}
\BuiltInTok{print}\NormalTok{(b) }

\CommentTok{\# Negazione e congiunzione}
\NormalTok{b }\OperatorTok{=}\NormalTok{ n }\KeywordTok{and} \KeywordTok{not}\NormalTok{ s}
\BuiltInTok{print}\NormalTok{(b) }\CommentTok{\# Cosa notiamo?}

\CommentTok{\# Conversione di tipo in stringa e appartenenza}
\NormalTok{b }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(}\DecValTok{2}\NormalTok{) }\KeywordTok{in}\NormalTok{ s}
\BuiltInTok{print}\NormalTok{(b)}

\CommentTok{\# Conversione di tipo in intero e divisione}
\NormalTok{b }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(s) }\OperatorTok{/} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(b)}

\CommentTok{\# Espressione con precedenza data dall\textquotesingle{}ordine degli operatori }
\NormalTok{e }\OperatorTok{=} \DecValTok{2} \OperatorTok{+}\NormalTok{ n }\OperatorTok{*} \DecValTok{3}
\BuiltInTok{print}\NormalTok{(e)}

\CommentTok{\# Espressione con precedenza modificata colle parentesi }
\NormalTok{e }\OperatorTok{=}\NormalTok{ (}\DecValTok{2} \OperatorTok{+}\NormalTok{ n) }\OperatorTok{*} \DecValTok{3}
\BuiltInTok{print}\NormalTok{(e) }\CommentTok{\# Cosa notiamo?}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42
42
False
True
21.0
128
132
\end{verbatim}

\section{Funzioni e istruzioni
composte}\label{funzioni-e-istruzioni-composte}

\subsection{★★☆☆☆ Numeri pari o dispari}\label{numeri-pari-o-dispari}

Definire una funzione che prende in input un numero intero e restituisce
una stringa di \texttt{Pari} o \texttt{Dispari}.

\subsubsection{Riscaldamento: sperimentazione dell'operatore
modulo}\label{riscaldamento-sperimentazione-delloperatore-modulo}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare l'operatore modulo \texttt{\%} che restituisce il resto della
divisione di due interi con diversi input sia pari che dispari ed anche
non numerici per vedere cosa accade.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{42}

\ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Pari"}\NormalTok{)}

\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(Dispari)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Pari
\end{verbatim}

\subsubsection{Soluzione 1: test con operatore
modulo}\label{soluzione-1-test-con-operatore-modulo}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare l'operatore modulo \texttt{\%} che restituisce il resto della
divisione di due interi all'interno di una funzione. Questa prende in
input un numero intero e restituisce la stringa richiesta.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pari\_o\_dispari(n):}
  \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
    \ControlFlowTok{return} \StringTok{"Pari"}

  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return} \StringTok{"Dispari"}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{42}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{73}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Pari
Dispari
\end{verbatim}

\subsubsection{Soluzione 2: test con operatore modulo e controllo degli
input}\label{soluzione-2-test-con-operatore-modulo-e-controllo-degli-input}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare l'operatore modulo \texttt{\%} e la funzione \texttt{isinstance}
per verificare il tipo in input.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pari\_o\_dispari(n):}
  \ControlFlowTok{if} \KeywordTok{not} \BuiltInTok{isinstance}\NormalTok{(n, }\BuiltInTok{int}\NormalTok{):}
    \ControlFlowTok{return} \StringTok{"Errore: l\textquotesingle{}input deve essere un numero intero!"}
    
  \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
    \ControlFlowTok{return} \StringTok{"Pari"}

  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return} \StringTok{"Dispari"}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{42}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{73}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Pari
Dispari
\end{verbatim}

\subsubsection{Soluzione 3: test con operatore modulo e generazione di
errore su input non
intero}\label{soluzione-3-test-con-operatore-modulo-e-generazione-di-errore-su-input-non-intero}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare l'operatore modulo \texttt{\%}, la funzione \texttt{isinstance}
per verificare il tipo in input e \texttt{assert} in caso di input non
corretto.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pari\_o\_dispari(n):}
  \ControlFlowTok{assert} \BuiltInTok{isinstance}\NormalTok{(n, }\BuiltInTok{int}\NormalTok{), }\OperatorTok{\textbackslash{}}
    \StringTok{"Errore: l\textquotesingle{}input deve essere un numero intero!"}
    
  \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
    \ControlFlowTok{return} \StringTok{"Pari"}

  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return} \StringTok{"Dispari"}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{42}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{73}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}

\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\CommentTok{risultato = pari\_o\_dispari("42")}

\CommentTok{print(risultato)}

\CommentTok{risultato = pari\_o\_dispari(73.)}

\CommentTok{print(risultato)}
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Pari
Dispari
\end{verbatim}

\begin{verbatim}
'\nrisultato = pari_o_dispari("42")\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73.)\n\nprint(risultato)\n'
\end{verbatim}

\subsubsection{Soluzione 4: uso di funzione
built-in}\label{soluzione-4-uso-di-funzione-built-in}

\begin{tcolorbox}[enhanced jigsaw, leftrule=.75mm, arc=.35mm, opacityback=0, rightrule=.15mm, titlerule=0mm, colbacktitle=quarto-callout-tip-color!10!white, colback=white, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, toprule=.15mm, bottomtitle=1mm, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Suggerimento}, breakable, coltitle=black, opacitybacktitle=0.6, left=2mm]

Usare la funzione \texttt{divmod} che restituisce il quoziente e il
resto della divisione di due interi.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pari\_o\_dispari(n):}
\NormalTok{  \_, remainder }\OperatorTok{=} \BuiltInTok{divmod}\NormalTok{(n, }\DecValTok{2}\NormalTok{)}

  \ControlFlowTok{return} \StringTok{"Pari"} \ControlFlowTok{if}\NormalTok{ remainder }\OperatorTok{==} \DecValTok{0} \ControlFlowTok{else} \StringTok{"Dispari"}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{42}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}

\NormalTok{risultato }\OperatorTok{=}\NormalTok{ pari\_o\_dispari(}\DecValTok{73}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(risultato)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Pari
Dispari
\end{verbatim}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{part}{Appendici}
\appendix

\chapter*{Riferimenti}\label{riferimenti}
\addcontentsline{toc}{chapter}{Riferimenti}

\markboth{Riferimenti}{Riferimenti}

\phantomsection\label{refs}
\begin{CSLReferences}{1}{0}
\bibitem[\citeproctext]{ref-kernighan1973b}
Kernighan, Brian W. 1973. {«A Tutorial Introduction to the Programming
Language B»}. Murray Hill, NJ: Bell Laboratories.

\bibitem[\citeproctext]{ref-kernighan1988c}
Kernighan, Brian W., e Dennis M. Ritchie. 1988. \emph{The C Programming
Language}. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.

\bibitem[\citeproctext]{ref-10.5555ux2f578826}
Stone, Harold S. 1971. \emph{Introduction to Computer Organization and
Data Structures}. USA: \url{https://dl.acm.org/doi/10.5555/578826};
McGraw-Hill, Inc.

\bibitem[\citeproctext]{ref-stroustrup2013}
Stroustrup, Bjarne. 2013. \emph{The C++ Programming Language}. 4th ed.
\url{https://dl.acm.org/doi/10.5555/2543987}; Addison-Wesley
Professional.

\end{CSLReferences}


\backmatter

\end{document}
