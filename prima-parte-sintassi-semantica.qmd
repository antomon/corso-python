---
reference-location: margin
citation-location: margin
---

# Sintassi e semantica dei linguaggi di programmazione

I linguaggi di programmazione sono strumenti utilizzati per implementare algoritmi in modo che possano essere eseguiti da un computer. Un linguaggio di programmazione ha due componenti principali: la **sintassi** e la **semantica**.

## Sintassi

La **sintassi** di un linguaggio di programmazione è l'insieme di regole che definiscono come devono essere scritte le istruzioni, cioè le unità logiche di esecuzione del programma. È come la grammatica in una lingua naturale e stabilisce quali combinazioni di simboli sono considerate costrutti validi nel linguaggio.

Partiamo dagli elementi atomici della sintassi, detti **token**, per poi risalire fino al programma:

- Parole chiave: Sono termini riservati del linguaggio che hanno significati specifici e non possono essere utilizzati per altri scopi, come `if`, `else`, `while`, `for`, ecc.

- Operatori: Simboli utilizzati per eseguire operazioni su identificatori e letterali, come `+`, `-`, `*`, `/`, `=`, `==`, ecc.

- Delimitatori: Caratteri utilizzati per separare elementi del codice, come punto e virgola (`;`), parentesi tonde (`()`), parentesi quadre (`[]`), parentesi graffe (`{}`), ecc.

- Identificatori: Nomi utilizzati per identificare variabili, funzioni, classi, e altri oggetti.

- Letterali: Rappresentazioni di valori costanti nel codice, come numeri (`123`), stringhe (`"hello"`), caratteri (`'a'`), ecc.

- Commento: Non fanno parte della logica del programma e sono ignorati nell'esecuzione.

- Spazi e tabulazioni: Sono gruppi di caratteri non visualizzabili spesso ignorati. 

Un **lessema** è una sequenza di caratteri nel programma sorgente che corrisponde al pattern di un token ed è identificata dall'**analizzatore lessicale** come un'istanza di quel token. Un **token** è una coppia composta da un nome di token e un valore attributo opzionale. Il nome del token è un simbolo astratto che rappresenta un tipo di unità lessicale, come una particolare parola chiave o una sequenza di caratteri di input che denota un identificatore. Un **pattern** è una descrizione della forma che possono assumere i lessemi di un token. Ad esempio, nel caso di una parola chiave come token, il pattern è semplicemente la sequenza di caratteri che forma la parola chiave. Per gli identificatori e altri token, il pattern è una struttura più complessa che corrisponde a molte stringhe.

Un esempio per visualizzare i concetti introdotti:

```python
if x == 10:
```

- Token coinvolti:

  - `if`: Parola chiave.
  - `NAME`: Identificatore.
  - `EQEQUAL`: Operatore.
  - `NUMBER`: Letterale numerico.
  - `COLON`: Delimitatore.

- Lessemi:

  - Il lessema per il token `if` è la sequenza di caratteri "if".
  - Il lessema per il token `NAME` è "x".
  - Il lessema per il token `EQEQUAL` è  "==".
  - Il lessema per il token `NUMBER` "10".
  - Il lessema per il token `COLON` ":".

- Pattern:

  - Il pattern per il token `if` è la stringa esatta "if".
  - Il pattern per un identificatore è una sequenza di lettere e numeri che inizia con una lettera.
  - Il pattern per l'operatore `==` è la stringa esatta "==".
  - Il pattern per un letterale numerico è una sequenza di cifre.
  - Il pattern per il delimitatore `:` è la stringa esatta ":".

### Analizzatore lessicale e parser

L'**analizzatore lessicale** (o _lexer_) è un componente del compilatore o interprete che prende in input il codice sorgente del programma e lo divide in lessemi. Esso confronta ciascun lessema con i pattern definiti per il linguaggio di programmazione e genera una sequenza di token. Questi token sono poi passati al parser.

Il **parser** è un altro componente del compilatore o interprete che prende in input la sequenza di token generata dall'analizzatore lessicale e verifica che la sequenza rispetti le regole sintattiche del linguaggio di programmazione. Il parser analizza i token per formare una struttura gerarchica che rappresenti le relazioni grammaticali tra di essi. Questa struttura interna è spesso un albero di sintassi (_parse tree_ o _syntax tree_), che riflette la struttura grammaticale del codice sorgente, solitamente descritta usando una forma standard di notazione come la BNF (Backus-Naur Form) o varianti di essa.[^1-prima-parte-sintassi-semantica] L'albero di sintassi viene utilizzato per ulteriori fasi di compilazione o interpretazione, come l'analisi semantica e la generazione del codice. Ad esempio, il parser può verificare che le espressioni aritmetiche siano ben formate, che le istruzioni siano correttamente annidate e che le dichiarazioni di variabili siano valide.

[^1-prima-parte-sintassi-semantica]: La BNF (Backus-Naur form o Backus normal form) è una metasintassi, ovvero un formalismo attraverso cui è possibile descrivere la sintassi di linguaggi formali (il prefisso meta ha proprio a che vedere con la natura circolare di questa definizione). Si tratta di uno strumento molto usato per descrivere in modo preciso e non ambiguo la sintassi dei linguaggi di programmazione, dei protocolli di rete e così via, benché non manchino in letteratura esempi di sue applicazioni a contesti anche non informatici e addirittura non tecnologici. Un esempio è la grammatica di [Python](https://docs.python.org/3/reference/grammar.html)

### Espressioni

Un'espressione è una combinazione di lessemi che viene valutata per produrre un risultato. 

Esempi di espressioni includono:

- `5 + 3`.
- `x * 2`.
- `y / 4.0`.
- `max(a, b)`.
- `"Hello, " + "world!"`.

### Istruzioni semplici

Le **istruzioni semplici** sono operazioni atomiche secondo il linguaggio e sono costituite da lessemi ed espressioni per compiere operazioni di base. Gli esempi principali includono: 

- Assegnazione: Utilizza un operatore di assegnazione (ad esempio, `=`) per attribuire un valore a una variabile, che possiamo pensare come un nome simbolico rappresentante una posizione dove è memorizzato un valore. Esempio:

  ```python
  x = 5
  ```
  - `x`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `5`: Letterale numerico intero.

- Input/output: Utilizza parole chiave o funzioni di libreria per leggere valori dall'input o scrivere valori all'output. Esempio:

  ```python
  print("Hello, World!")
  ```
  - `print`: Parola chiave o identificatore di funzione di libreria.
  - `"Hello, World!"`: Letterale stringa.
  L'esecuzione dell'istruzione produce `"Hello, World!"` in output.

- Assegnazione ad espressione: Combinazione di variabili, operatori e valori che producono un risultato assegnato ad una variabile. Esempio:

    ```python
    z = (x * 2) + (y / 2)
    ```
  - `z`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `(x * 2)`: Espressione che moltiplica `x` per `2`.
  - `(y / 2)`: Espressione che divide `y` per `2`.
  - `+`: Operatore aritmetico che somma i risultati delle due espressioni in una più complessa.
  L'esecuzione dell'istruzione produce un risultato valido solo se `x` e `y` sono associate a valori numerici e ciò perché non tutte le istruzioni sintatticamente corrette sono semanticamente corrette. D'altronde ciò non deve essere preso come regola, perché se `*` fosse un operatore che ripete quanto a sinistra un numero di volte definito dal valore di destra e `/` la divisione del valore di sinistra in parti di numero pari a quanto a destra, allora `x` e `y` potrebbero essere stringhe.

### Istruzioni complesse e blocchi di codice

Le **istruzioni complesse** sono costituite da più istruzioni semplici e possono includere strutture di controllo del flusso, come condizioni (`if`), cicli (`for`, `while`) ed eccezioni (`try`, `catch`). Queste istruzioni sono utilizzate per organizzare il flusso di esecuzione del programma e possono contenere altre istruzioni semplici o complesse al loro interno.

Un **blocco di codice** è una sezione del codice che raggruppa una serie di istruzioni che devono essere eseguite insieme. I blocchi di codice sono spesso utilizzati all'interno delle istruzioni complesse per delimitare il gruppo di istruzioni che devono essere eseguite in determinate condizioni o iterazioni. 

In molti linguaggi di programmazione, i blocchi di codice sono delimitati da parentesi graffe (`{}`), mentre in altri linguaggi, come Python, l'indentazione è utilizzata per indicare l'inizio e la fine di un blocco di codice.

Alcuni esempi di istruzione e blocco di codice:

- Esempio in C:

  ```c
  if (x > 0) {
    printf("x è positivo\n");

    y = x * 2;
  }
  ```
  In questo esempio:
  - `if (x > 0)` è un'istruzione complessa.
  - `{ printf("x è positivo\n"); y = x * 2; }` è un blocco di codice che viene eseguito se la condizione dell'istruzione `if` è vera.

- Esempio in Python:

  ```python
  if x > 0:
    print("x è positivo")

    y = x * 2
  ```
  In questo esempio:
  - `if x > 0:` è un'istruzione complessa.
  - Le righe indentate sotto l'istruzione `if` (`print("x è positivo")` e `y = x * 2`) costituiscono un blocco di codice che viene eseguito se la condizione dell'istruzione `if` è vera.

Altri esempi: 

- Condizioni: Istruzioni che eseguono un blocco di codice solo se una condizione è vera. Esempio:

  ```c
  #include <stdio.h>

  x = 42;

  if (x > 0) {
      printf("x è positivo\n");
  }
  ```
  - `if`: Parola chiave che introduce la condizione.
  - `(x > 0)`: Condizione composta da: `x` identificatore di variabile, `>` operatore di confronto e `0` letterale numerico intero.
  - `{ ... }`: Delimitatori che racchiudono il blocco di codice.
  - `print("x è positivo")`: Istruzione di output.

- Cicli: Istruzioni che ripetono un blocco di codice. Esempio:

  ```c
  #include <stdio.h>

  int n = 42;
  int somma = 0;
  int i;

  for (i = 0; i < n; i++) {
      somma = somma + i;
  }
  ```
  - `for`: Parola chiave che introduce il ciclo.
  - `(i = 0; i < n; i++)`: Espressione di controllo del ciclo composta da: `i = 0` assegnazione iniziale, `i < n` condizione di ciclo e `i++` incremento della variabile `i`.
  - `{ ... }`: Delimitatori che racchiudono il blocco di codice.
  - `somma = somma + i`: Operazione aritmetica.

### Organizzazione del codice in un programma

Il programma è solitamente salvato in un file di testo in righe. Queste righe possono essere classificate in righe fisiche e righe logiche.

Una **riga fisica** è una linea di testo nel file sorgente del programma, terminata da un carattere di a capo. 

Esempio:

```c
int x = 10; /* <1> */ 
```
1. Questa è una riga fisica.

Una **riga logica** è una singola istruzione, che può estendersi su una o più righe fisiche.

Esempio di riga logica con più righe fisiche:

```c
int y = (10 + 20 + 30 + /* <1> */
         40 + 50); /* <2> */
```
1. Prima riga fisica della riga logica.
2. Seconda riga fisica della riga logica.

Il concetto di righe fisiche e logiche esiste perché le istruzioni (o righe logiche) possono essere lunghe e complesse, richiedendo più righe fisiche per migliorare la leggibilità e la gestione del codice.

## Semantica

La **semantica** di un linguaggio di programmazione definisce il significato delle istruzioni sintatticamente corrette. In altre parole, la semantica specifica cosa fa un programma quando viene eseguito, descrivendo l'effetto delle istruzioni sullo stato del sistema. Gli elementi semantici sono numerosi, possono essere anche complessi e non tutti presenti in uno specifico linguaggio. 

Di seguito ne sono riportati alcuni tra i principali elementi semantici.

### Modello dati

Un **modello dati** è una rappresentazione formale dei tipi di dati e delle operazioni che possono essere eseguite su di essi. Esso definisce le strutture fondamentali attraverso le quali i dati vengono organizzati, memorizzati, manipolati e interagiscono all'interno del programma. 

Le componenti il modello dati sono:

1. Tipi di dati:

    - Tipi primitivi: Questi sono i tipi di dati fondamentali che il linguaggio supporta nativamente, come numeri interi, numeri in virgola mobile, caratteri e booleani.

    - Tipi compositi: Questi sono tipi di dati costruiti combinando tipi primitivi. Esempi comuni includono array, liste, tuple, set e dizionari.

    - Tipi di dati definiti dall'utente: Questi sono tipi di dati che possono essere definiti dagli utenti del linguaggio, come le `struct` in C oppure le classi in Python o C++, che permettono di creare tipi di dati personalizzati. 

2. Operazioni:

    - Operazioni aritmetiche: Operazioni che possono essere eseguite sui tipi di dati, come addizione, sottrazione, moltiplicazione e divisione per i numeri.

    - Operazioni logiche: Operazioni che coinvolgono valori booleani, come AND, OR e NOT.

    - Operazioni di sequenza: Operazioni che si possono eseguire su sequenze di dati, come l'indicizzazione, la _slicing_ e l'iterazione.

3. Regole di comportamento:

    - Mutabilità: Determina se un oggetto può essere modificato dopo la sua creazione. Oggetti mutabili, come liste e dizionari in Python, possono essere cambiati. Oggetti immutabili, come tuple e stringhe, non possono essere modificati dopo la loro creazione.

    - Copia e clonazione: Regole che determinano come i dati vengono copiati. Per esempio, in Python, la copia di una lista crea una nuova lista con gli stessi elementi, mentre la copia di un intero crea solo un riferimento allo stesso valore.

#### Linguaggi procedurali

Nei linguaggi di programmazione procedurali, il modello dati è incentrato su tipi di dati semplici e compositi che supportano lo stile di programmazione orientato alle funzioni e procedure. Alcune caratteristiche tipiche includono:

- Tipi primitivi: Numeri interi, numeri a virgola mobile, caratteri e booleani.

- Strutture composite: Array, strutture (`struct`) e unioni (`union`). Gli array permettono di gestire collezioni di elementi dello stesso tipo, mentre le strutture permettono di combinare vari tipi di dati sotto un unico nome. Le unioni consentono di memorizzare diversi tipi di dati nello stesso spazio di memoria, ma solo uno di essi può essere attivo alla volta.

- Operazioni basate su funzioni: Le operazioni sui dati vengono eseguite attraverso funzioni che manipolano i valori passati come argomenti.

Esempio in C:

```c
#include <stdio.h>
#include <string.h>

#define MAX_DATI 100

union Valore { /* <1> */
  int intero;
  float decimale;
  char carattere;
};

struct Dato {  /* <2> */
  char tipo;  
  // 'i' per int, 'f' per float, 'c' per char
  union Valore valore;
};

void stampa_dato(struct Dato d) { /* <3> */
  switch (d.tipo) {
    case 'i':
      printf("Intero: %d\n", d.valore.intero);
      break;

    case 'f':
      printf("Float: %f\n", d.valore.decimale);
      break;

    case 'c':
      printf("Carattere: %c\n", d.valore.carattere);
      break;

    default:
      printf("Tipo sconosciuto\n");
      break;
  }
}

int confronta_dato(struct Dato d1, struct Dato d2) {
  if (d1.tipo != d2.tipo) return 0;

  switch (d1.tipo) {
    case 'i': return d1.valore.intero == d2.valore.intero;

    case 'f': return d1.valore.decimale == d2.valore.decimale;

    case 'c': return d1.valore.carattere == d2.valore.carattere;

    default: return 0;
  }
}

void inserisci_dato(struct Dato dati[], int *count, struct Dato nuovo_dato) { /* <4> */
  if (*count < MAX_DATI) {
    dati[*count] = nuovo_dato;

    (*count)++;

  } else {
    printf("Array pieno, impossibile inserire nuovo dato.\n");
  }
}

void cancella_dato(struct Dato dati[], int *count, struct Dato dato_da_cancellare) { /* <5> */
  for (int i = 0; i < *count; i++) {
    if (confronta_dato(dati[i], dato_da_cancellare)) {
      for (int j = i; j < *count - 1; j++) {
        dati[j] = dati[j + 1];
      }

      (*count)--;

      i--; 
    }
  }
}

int main() {
  struct Dato dati[MAX_DATI]; /* <6> */
  int count = 0;

  struct Dato dato1 = {'i', .valore.intero = 42};
  struct Dato dato2 = {'f', .valore.decimale = 3.14};
  struct Dato dato3 = {'c', .valore.carattere = 'A'};
  
  inserisci_dato(dati, &count, dato1); /* <7> */
  inserisci_dato(dati, &count, dato2);
  inserisci_dato(dati, &count, dato3);

  for (int i = 0; i < count; i++) { /* <8> */
    stampa_dato(dati[i]);
  }

  cancella_dato(dati, &count, dato1); /* <9> */

  printf("Dopo cancellazione:\n");

  for (int i = 0; i < count; i++) {
    stampa_dato(dati[i]);
  }

  return 0;
}
```
1. Definizione di una `union`.
2. Definizione di una `struct` che include la `union`.
3. Funzione per stampare i valori in base al tipo.
4. Funzione per inserire un nuovo dato alla fine dell'array.
5. Funzione per cancellare tutte le occorrenze di un dato dall'array.
6. Definizione di un array di `struct` Dato.
7. Inserimento di dati nell'array.
8. Stampa dei dati nell'array.
9. Cancellazione di un dato specifico e ristampa dell'array.

L'esempio mostra come nel modello dati del linguaggio C possono essere definiti dei tipi compositi (`Dato`, `Valore`) e delle operazioni su quelli (`stampa_dato`, `confronta_dato`, `inserisci_dato`, `cancella_dato`). Il codice, pur realizzante una semplice libreria, appare _slegato_, cioè con funzioni che si applicano a tipi di dati specifici solo dall'interpretazione degli identificatori della funzione stessa e dei suoi parametri, cioè senza un legame esplicito e non ambiguo, tra tipo e funzione.

#### Linguaggi orientati agli oggetti

La programmazione orientata agli oggetti è un paradigma che utilizza **oggetti** per rappresentare concetti ed entità del mondo reale o astratto. Questo approccio si basa su un processo mentale fondamentale per risolvere problemi complessi: la decomposizione. Un problema complesso è più facilmente risolvibile se diviso in parti più piccole, ciascuna delle quali possiede uno stato e la possibilità di interagire con le altre parti. Questa divisione può essere effettuata per gradi, come se si osservasse sempre più da vicino il problema, effettivamente continunandone la specificazione, fino a raggiungere un livello sufficientemente di dettaglio da poter essere realizzato come istruzioni, codificate in costrutti permessi dalla sintassi del linguaggio, dell'oggetto.

##### Oggetti

Lo stato di un oggetto è definito dai suoi attributi, i cui valori possono essere altri oggetti già disponibili, sia definiti dall'utente che dal linguaggio. L'interazione tra diversi oggetti avviene attraverso i metodi, che sono funzioni associate agli oggetti che possono modificare lo stato dell'oggetto o invocare metodi su altri oggetti.

I membri di un oggetto (attributi e metodi) possono avere diverse limitazioni di accesso, definite dal concetto di visibilità:

- Pubblica: Gli attributi e i metodi pubblici sono accessibili da qualsiasi parte del programma. Questa visibilità permette a qualsiasi altro oggetto o funzione di interagire con questi membri.
  
- Privata: Gli attributi e i metodi privati sono accessibili solo da altri membri dell'oggetto e rispondono alla esigenza di separare il codice di interfaccia da quello utile al funzionamento interno.
  
- Protetta: Gli attributi e i metodi protetti sono accessibili da tutti i membri del medesimo oggetto ma, a differenza dei privati, anche da quelli degli oggetti derivati. Questo fornisce un livello intermedio di accesso, utile per la gestione dell'ereditarietà.

L'**incapsulamento** è il principio su cui si basa la gestione della visibilità e guida la separazione del codice realizzante le specificità di un oggetto, da come è fruito dagli altri oggetti. Questo protegge l'integrità del suo stato e ne facilita la manutenzione del codice stesso, permettendo modifiche di implementazione, senza impatti sul codice esterno fintantoché non si cambiano i membri pubblici. Inoltre, se ben sfruttata nella progettazione, rende il codice più comprensibile e riduce la superficie d'attacco.

##### Classi

Un oggetto può essere generato da una struttura statica che ne definisce tutte le caratteristiche, la **classe**, oppure può essere creato a partire da un altro oggetto esistente, noto come **prototipo**.

Nella programmazione ad oggetti basata su classi, ogni oggetto è un'istanza _vivente_ di una classe predefinita, che ne rappresenta il progetto o l'archetipo. La classe definisce i membri e la visibilità, quindi, in definitiva tutte le proprietà comuni agli oggetti dello stesso tipo o matrice. Gli oggetti vengono creati chiamando un metodo speciale della classe, noto come costruttore e, all'atto della loro vita, un secondo metodo, il distruttore, che si occupa di effettuare le azioni di terminazione. 

La classe può inoltre definire metodi e attributi particolari, che possono essere ereditati da altre classi, cioè possono essere utilizzati da quest'ultime al pari dei propri membri. In tal modo, il linguaggio permette la costruzioni di gerarchie di classi che modellano relazioni di specializzazione, dalla più generale alla più particolare.

Ciò, oltre ad essere uno strumento di progettazione utile di per sé, facilita il riuso del codice per mezzo dell'estensione, al posto della modifica, di funzionalità. La classe che eredita da un'altra classe si definisce _derivata_ dalla classe che, a sua volta, è detta _base_.

##### Prototipi

Alternativamente, alcuni linguaggi usano il concetto di prototipo, in cui gli oggetti sono le entità principali e non esiste una matrice separata come la classe. In questo paradigma, ogni oggetto può servire da prototipo per altri e ciò significa che, invece di creare nuove istanze di una classe, si creano nuovi oggetti clonando o estendendo quelli esistenti. È possibile aggiungere o modificare proprietà e metodi di un oggetto prototipo e, in tal caso, queste modifiche si propagheranno in tutti gli oggetti che derivano da esso.

Il paradigma basato su prototipi offre maggiore flessibilità e dinamismo rispetto a quello basato su classi, poiché la struttura degli oggetti può essere modificata in modo dinamico. D'altronde, questo approccio può anche introdurre complessità e rendere più difficile la gestione delle gerarchie di oggetti e la comprensione del codice, poiché non esistono strutture fisse come le classi.

##### Esempi di gerarchie di classi e prototipi

Vediamo le differenze tra classi e prototipi, riprendendo l'esempio in Java nella versione semplificata (senza astrazione):

```java
class Animale { 
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    void faiVerso() {
        System.out.println("L'animale fa un verso");
    }
}

class Cane extends Animale { 

    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }
}

public class Main {
    public static void main(String[] args) {
        Animale mioCane = new Cane("Fido");

        mioCane.faiVerso(); 
    }
}
```

Implementiamo il medesimo programma in Javascript[^2-prima-parte-sintassi-semantica], linguaggio che usa il concetto di prototipo: 

```javascript
let Animale = { // <1>
    nome: "Generic",

    init: function(nome) {
        this.nome = nome;
    },

    faiVerso: function() {
        console.log("L'animale fa un verso");
    }
};

let Cane = Object.create(Animale); // <2>

Cane.faiVerso = function() { // <3>
    console.log("Il cane abbaia");
};

let mioCane = Object.create(Cane); // <4>
mioCane.init("Fido"); // <5>

mioCane.faiVerso(); // <6>
```
1. Definizione dell'oggetto prototipo `Animale`.
2. Creazione di un nuovo oggetto basato sul prototipo `Animale`. 
3. Viene creato un nuovo oggetto `Cane` basato sul prototipo `Animale`, usando `Object.create(Animale)`. Questo permette a `Cane` di ereditare proprietà e metodi da `Animale`. Il metodo `faiVerso` viene sovrascritto nell'oggetto `Cane` per specificare il comportamento da cane.
4. Un nuovo oggetto `mioCane` viene creato basandosi sul prototipo `Cane` usando `Object.create(Cane)`.
5. Il metodo `init` viene chiamato per inizializzare il nome dell'oggetto `mioCane`.
6. Quando viene chiamato `mioCane.faiVerso()`, il metodo sovrascritto nell'oggetto `Cane` viene eseguito, mostrando `Il cane abbaia`.

[^2-prima-parte-sintassi-semantica]: In JavaScript, le classi come sintassi sono state introdotte in ECMAScript 6 (ES6), per semplificare la creazione di oggetti e la gestione dell'ereditarietà prototipale. Tuttavia, è importante capire che sotto il cofano, JavaScript non utilizza classi nel senso tradizionale come in linguaggi come Java o C++ e non esiste un meccanismo nativo per creare classi astratte, anche se è possibile simulare il comportamento delle classi astratte utilizzando varie tecniche. Una comune è quella di lanciare un'eccezione se un metodo funzionalmente astratto non viene sovrascritto nella classe derivata.

##### Ereditarietà

Come abbiamo visto, l'ereditarietà è un meccanismo che permette a una classe di ereditare membri da un'altra classe. In realtà, l'ereditarietà può essere multipla cioè essere tale da permettere a una classe di ricevere attributi e metodi contemporaneamente da più classi base. Questo meccanismo risponde all'esigenza di specializzare più concetti allo stesso tempo. 

Va sottolineato che l'ereditarietà multipla è uno strumento potente prono ad abusi perché può introdurre complessità nella gestione delle gerarchie di classi e causare conflitti tra metodi ereditati da più classi. Per esempio, se due classi base definiscono un metodo con lo stesso nome, la classe derivata deve specificare quale metodo utilizzare o come combinarli.

Alcuni linguaggi di programmazione, come Go, impediscono l'ereditarietà per progettazione del linguaggio. Questo approccio è adottato per favorire la composizione degli oggetti rispetto all'ereditarietà, promuovendo l'uso di interfacce e la combinazione di comportamenti attraverso l'aggregazione, piuttosto che attraverso gerarchie di classi complesse.

Esempio di ereditarietà multipla in Java:

```java
class Animale { 
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    void faiVerso() {
        System.out.println("L'animale fa un verso");
    }
}

class Domestico { 
    void viviInCasa() {
        System.out.println("L'animale vive in casa");
    }
}

class Selvatico { 
    void viviInNatura() {
        System.out.println("L'animale vive in natura");
    }
}

class Cane extends Animale { 
    Domestico domestico = new Domestico();

    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }

    void viviInCasa() {
        domestico.viviInCasa();
    }
}

class Lupo extends Animale { 
    Selvatico selvatico = new Selvatico();

    Lupo(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il lupo ulula");
    }

    void viviInNatura() {
        selvatico.viviInNatura();
    }
}

public class Main {
    public static void main(String[] args) {
        Cane mioCane = new Cane("Fido");
        mioCane.faiVerso(); 
        mioCane.viviInCasa();

        Lupo mioLupo = new Lupo("Lupo");
        mioLupo.faiVerso();
        mioLupo.viviInNatura();
    }
}
```














- Variabile: È un nome simbolico associato a locazione di memoria che può contenere uno o più valori. È fondamentale per la manipolazione di dati perché sono un mezzo per astrarre dalla costante memorizzata. Le variabili possono essere associate a diversi tipi di dati e durate di vita. La semantica delle variabili include la loro dichiarazione, inizializzazione, uso e visibilità:

  - Dichiarazione: La dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. La dichiarazione informa il compilatore o l'interprete che una certa variabile esiste e può essere utilizzata nel codice.

  - Inizializzazione: L'inizializzazione di una variabile è il processo di assegnare un valore iniziale alla variabile. L'inizializzazione può avvenire contestualmente alla dichiarazione o in un'istruzione separata successiva.

  - Visibilità: Indica dove la variabile può essere utilizzata all'interno del codice (ad esempio, variabili locali o globali).

  - Durata di Vita: Descrive per quanto tempo la variabile rimane in memoria durante l'esecuzione del programma (ad esempio, automatica, statica, dinamica).

- Tipo di dati: I tipi di dati definiscono il dominio dei valori che una variabile può assumere e le operazioni che possono essere eseguite su quei valori. Un tipo di dato determina la natura del valore (ad esempio, numero intero, carattere, booleano) e le operazioni che possono essere effettuate su di esso. Generalmente si distinguono in:

  - Tipo primitivo: I tipi di dati fondamentali forniti da un linguaggio, come integer, float, boolean e character.

  - Tipo complesso: Tipo di dati costituiti da più tipi primitivi, come array, struct e oggetti.

  - Tipo di dati utente: Tipo definito dall'utente, come classi e tipi personalizzati, che permette di creare strutture dati più complesse e specifiche per il problema da risolvere.

- Ambito (in inglese, _scope_): L'ambito rappresenta la porzione del codice in cui un identificatore (come una variabile o una funzione) è definito e, quindi, esiste. L'ambito determina dove un identificatore può essere dichiarato e utilizzato. Tipicamente gli ambiti sono:

  - Globale: Identificatori dichiarati a livello globale, accessibili ovunque nel programma.

  - Locale: Identificatori dichiarati all'interno di un blocco, come una funzione o un loop, e accessibili solo all'interno di quel blocco.

  - Statico e dinamico: L'ambito statico è determinato a tempo di compilazione, mentre l'ambito dinamico è determinato a runtime, influenzando come e dove gli identificatori possono essere utilizzati.

- Visibilità: La visibilità si riferisce a dove nel codice un identificatore può essere visto e utilizzato. Anche se correlata all'ambito, la visibilità può essere influenzata da altri fattori come la modularità e i namespace, che organizzano e separano gli identificatori per evitare conflitti di nome. La visibilità è generalmente:

  - Globale: Un identificatore dichiarato con visibilità globale può essere utilizzato in qualsiasi parte del programma.

  - Locale: Un identificatore dichiarato con visibilità locale è visibile solo all'interno del blocco di codice in cui è stato dichiarato.

- Funzioni e metodi: Le funzioni e i metodi sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Alcuni concetti collegati sono:

  - Parametri e argomenti: Valori passati alle funzioni per influenzarne il comportamento. I parametri sono definiti nella dichiarazione della funzione, mentre gli argomenti sono i valori effettivi passati quando la funzione è chiamata.

  - Valore di ritorno: Il risultato prodotto da una funzione, che può essere utilizzato nell'istruzione chiamante.

  - Overloading: Definizione di più funzioni con lo stesso nome ma diversi parametri, consentendo diverse implementazioni basate sui tipi e il numero di argomenti.

  - Ricorsione: Capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili.

  - Funzioni di prima classe: Le funzioni possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.

  - Funzioni di ordine superiore: Funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati.

- Durata di vita delle variabili: La durata di vita delle variabili si riferisce a quanto tempo una variabile rimane in memoria durante l'esecuzione del programma. Alcune tipologie di durata:

  - Automatica: Variabili che esistono solo durante l'esecuzione del blocco in cui sono dichiarate.

  - Statica: Variabili che esistono per tutta la durata del programma e mantengono il loro valore tra diverse chiamate di funzione.

  - Dinamica: Variabili allocate dinamicamente durante l'esecuzione del programma, solitamente gestite manualmente dall'utente (ad esempio, usando `malloc`/`free` in C) o automaticamente tramite garbage collection.

- Durata di vita di altri identificatori: 

  - Funzioni: Le funzioni stesse generalmente hanno una durata di vita che coincide con la durata del programma. Tuttavia, i puntatori a funzione e le chiusure (in inglese, closures) possono avere durate di vita diverse in alcuni linguaggi.

  - Classi e oggetti: Le classi hanno una durata di vita che coincide con la durata del programma, mentre gli oggetti (istanze di classi) hanno durate di vita dinamiche, determinate dalla loro allocazione e deallocazione.

  - Moduli: In linguaggi come Python, i moduli hanno una durata di vita che coincide con la durata del programma o del processo di importazione.

- Controllo di flusso: Determina l'ordine in cui le istruzioni vengono eseguite e alcuni esempi sono:

  - Condizionali: Strutture che permettono al programma di prendere decisioni (`if`, `else`, `switch`/`case`).

  - Cicli: Strutture che ripetono un blocco di codice (`for`, `while`, `do`-`while`).

  - Eccezioni: Meccanismi per gestire errori e condizioni anomale (`try`, `catch`, `throw`), permettendo al programma di continuare l'esecuzione in modo controllato.

- Classi e oggetti: Le classi sono trutture che definiscono proprietà (variabili) e comportamenti (metodi) comuni a tutti gli oggetti di quel tipo. Le classi rappresentano il modello o il blueprint da cui vengono creati gli oggetti. L'oggetto è l'istanza concreta di una classe. Gli oggetti sono entità che combinano dati e comportamenti secondo la struttura definita dalla loro classe. Si applicano i seguenti: 

  - Encapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie, migliorando la modularità e la manutenzione del codice.

  - Ereditarietà: Permette di creare nuove classi basate su classi esistenti, riutilizzando e estendendo il comportamento delle classi base.

  - Polimorfismo: Consente a metodi di comportarsi diversamente a seconda dell'oggetto su cui vengono invocati, fornendo flessibilità e estendibilità.

- Gestione della memoria utilizzata dal programma: La gestione della memoria è fondamentale per il funzionamento efficiente di un programma. Ne esistono diverse modalità: 

  - Allocazione dinamica: La memoria è allocata e deallocata a runtime, permettendo una gestione flessibile delle risorse.

  - Garbage collection: Automatizza la deallocazione della memoria non utilizzata, riducendo il rischio di sfruttamento non ottimale (memory leak) e semplificando la gestione della memoria.

- Spazio di nomi (in inglese namespace): I namespace organizzano variabili, funzioni e altri identificatori per evitare conflitti di nome.

- Moduli e librerie: I moduli e le librerie suddividono il codice in unità riutilizzabili e organizzate, da importare in programmi. I moduli possono definire degli spazi di nomi. 

- Concorrenza: La concorrenza permette l'esecuzione parallela di più sequenze di istruzioni, migliorando le prestazioni e la reattività. Alcuni concetti relativi sono:

  - Thread: Un thread è la più piccola unità di elaborazione che può essere eseguita in modo indipendente. I thread consentono l'esecuzione parallela di codice all'interno di un programma.

  - Sincronizzazione: Meccanismi per gestire l'accesso concorrente alle risorse condivise, prevenendo condizioni di gara e garantendo la consistenza dei dati.

  - Lock e mutex: Meccanismi per prevenire condizioni di corsa (in inglese race condition), cioè un fenomeno che si presenta nei sistemi concorrenti quando, in presenza di una sequenza di processi multipli, il risultato finale dell'esecuzione dei processi dipende dalla temporizzazione o dalla sequenza con cui vengono eseguiti. Garantiscono, pertanto, l'accesso sicuro alle risorse condivise.

  - Async/await: Gestione di operazioni asincrone, migliorando l'efficienza e la reattività delle applicazioni.

- Input/output (I/O): L'input/output gestisce la comunicazione tra il programma e l'ambiente esterno.

  - File I/O: Lettura e scrittura su file per memorizzare e recuperare dati persistenti.

  - Network I/O: Comunicazione attraverso reti per inviare e ricevere dati tra sistemi diversi.

  - Standard I/O: Interazione con l'utente tramite input da tastiera e output su schermo.

- Annotazioni e metadati: Le annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l'analisi del codice.

  - Annotazioni: Informazioni extra utilizzate per specificare comportamenti speciali o configurazioni. Ad esempio, in Java, le annotazioni possono essere utilizzate per indicare che un metodo è obsoleto (`@Deprecated`), per sovrascrivere un metodo della superclasse (`@Override`), o per specificare la relazione tra entità nel contesto di framework come JPA (Jakarta Persistence; `@Entity`, `@Table`). In Python, le annotazioni sono utilizzate principalmente per indicare i tipi di variabili, parametri di funzione e valori di ritorno (type hint). Non influenzano direttamente il comportamento del programma, ma sono utili per la documentazione e il type checking anche automatico.

  - Docstring: Commenti strutturati che documentano il codice, spesso utilizzati per generare documentazione automatica. In Python, ad esempio, le docstring possono essere utilizzate per descrivere il funzionamento di moduli, classi, metodi e funzioni, rendendo il codice più leggibile e comprensibile.

- Macro e metaprogrammazione: Le macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice.

  - Macro: Sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale.

  - Metaprogrammazione: Tecniche per scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time, migliorando la flessibilità e il riutilizzo del codice. In Python include l'uso di decoratori, metaclassi e introspezione.

Questi elementi semantici combinati determinano il comportamento e la logica di un programma, influenzando il modo in cui il codice viene scritto, eseguito e mantenuto. 

## Applicazione dei concetti di sintassi e semantica

Dissezioniamo un algoritmo molto semplice per illustrare come sintassi e semantica di un linguaggio abbiano ruoli distinti e complementari in un programma. È importante comprendere che un buon programmatore deve avere tutte e tre le competenze, cioè conoscere le specificità formali del linguaggio (o di più linguaggi), quindi, la sua sintassi e semantica e saper comporre algoritmi, che potrà realizzare grazie proprio a quelle.

Consideriamo un esempio semplice di algoritmo per calcolare la somma dei numeri da 1 a n. In input si avrà un numero intero `n` e in output il risultato. In pseudocodice (cioè mimiamo il rigore sintattico di un linguaggio di programmazione, ma utilizziamo la lingua italiana) si può rappresentare così:

```bash
Inizializza somma a 0
Per ogni numero i da 1 a n:
  Aggiungi i a somma
Restituisci somma
```

O, in alternativa, possiamo definire una funzione che implementa l'algoritmo: 

```bash
funzione calcola_somma(n):
  somma = 0
  per i da 1 a n:
    somma = somma + i
  ritorna somma
```

Effettuiamo una analisi dettagliata della funzione per indicare quali elementi sintattici e semantici sono presenti. Partiamo dalla prima riga:

```bash
funzione calcola_somma(n):
```

- Sintassi:

  - `funzione`: Parola chiave che introduce la definizione di una funzione.
  - `calcola_somma`: Identificatore della funzione.
  - `(n)`: Delimitatori che contengono un identificatore.

- Semantica: Definisce una funzione chiamata `calcola_somma` che accetta un parametro `n`.

La seconda riga ha l'inizializzazione della variabile che conterrà il risultato: 

```bash
somma = 0
```

- Sintassi:
  - `somma`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `0`: Letterale numero intero.

- Semantica:
  - Inizializza la variabile `somma` a `0`.

A seguire la definizione di un ciclo: 

```bash
per i da 1 a n:
```

- Sintassi:

  - `per`: Parola chiave che introduce il ciclo.
  - `i`: Identificatore della variabile di controllo del ciclo.
  - `da 1 a n`: Espressione di controllo del ciclo che indica l'intervallo.

- Semantica: Itera la variabile `i` da `1` a `n`.

Un assegnamento per accumulare i valori nella variabile di ritorno:

```bash
somma = somma + i
```

- Sintassi:

  - `somma`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `somma + i`: Espressione aritmetica composta da: `somma` identificatore di variabile, `+` operatore aritmetico e `i` identificatore di variabile.

- Semantica: Aggiunge il valore di `i` alla variabile `somma` e assegna il risultato a `somma`.

E finalmente il risultato del calcolo viene restituito al chiamante: 

```bash
ritorna somma
```

- Sintassi:
  - `ritorna`: Parola chiave che indica la restituzione di un valore.
  - `somma`: Identificatore della variabile.

- Semantica:
  - Restituisce il valore della variabile `somma` come risultato della funzione.

