---
reference-location: margin
citation-location: margin
---

# Sintassi e semantica dei linguaggi di programmazione e algoritmi dei programmi

## Sintassi e semantica dei linguaggi di programmazione

I linguaggi di programmazione sono strumenti utilizzati per implementare algoritmi in modo che possano essere eseguiti da un computer. Un linguaggio di programmazione ha due componenti principali: la **sintassi** e la **semantica**.

## Sintassi

La **sintassi** di un linguaggio di programmazione è l'insieme di regole che definiscono come devono essere scritte le istruzioni, cioè le unità logiche di esecuzione del programma. È come la grammatica in una lingua naturale e stabilisce quali combinazioni di simboli sono considerate costrutti validi nel linguaggio.

Partiamo dagli elementi atomici della sintassi, detti **token**, per poi risalire fino al programma:

- Parole chiave: Sono termini riservati del linguaggio che hanno significati specifici e non possono essere utilizzati per altri scopi, come `if`, `else`, `while`, `for`, ecc.

- Operatori: Simboli utilizzati per eseguire operazioni su identificatori e letterali, come `+`, `-`, `*`, `/`, `=`, `==`, ecc.

- Delimitatori: Caratteri utilizzati per separare elementi del codice, come punto e virgola (`;`), parentesi tonde (`()`), parentesi quadre (`[]`), parentesi graffe (`{}`), ecc.

- Identificatori: Nomi utilizzati per identificare variabili, funzioni, classi, e altri oggetti.

- Letterali: Rappresentazioni di valori costanti nel codice, come numeri (`123`), stringhe (`"hello"`), caratteri (`'a'`), ecc.

- Commento: Non fanno parte della logica del programma e sono ignorati nell'esecuzione.

- Spazi e tabulazioni: Sono gruppi di caratteri non visualizzabili spesso ignorati. 

Un **lessema** è una sequenza di caratteri nel programma sorgente che corrisponde al pattern di un token ed è identificata dall'**analizzatore lessicale** come un'istanza di quel token. Un **token** è una coppia composta da un nome di token e un valore attributo opzionale. Il nome del token è un simbolo astratto che rappresenta un tipo di unità lessicale, come una particolare parola chiave o una sequenza di caratteri di input che denota un identificatore. Un **pattern** è una descrizione della forma che possono assumere i lessemi di un token. Ad esempio, nel caso di una parola chiave come token, il pattern è semplicemente la sequenza di caratteri che forma la parola chiave. Per gli identificatori e altri token, il pattern è una struttura più complessa che corrisponde a molte stringhe.

Un esempio per visualizzare i concetti introdotti:

```python
if x == 10:
```

- Token coinvolti:

  - `if`: Parola chiave.
  - `NAME`: Identificatore.
  - `EQEQUAL`: Operatore.
  - `NUMBER`: Letterale numerico.
  - `COLON`: Delimitatore.

- Lessemi:

  - Il lessema per il token `if` è la sequenza di caratteri "if".
  - Il lessema per il token `NAME` è "x".
  - Il lessema per il token `EQEQUAL` è  "==".
  - Il lessema per il token `NUMBER` "10".
  - Il lessema per il token `COLON` ":".

- Pattern:

  - Il pattern per il token `if` è la stringa esatta "if".
  - Il pattern per un identificatore è una sequenza di lettere e numeri che inizia con una lettera.
  - Il pattern per l'operatore `==` è la stringa esatta "==".
  - Il pattern per un letterale numerico è una sequenza di cifre.
  - Il pattern per il delimitatore `:` è la stringa esatta ":".

### Analizzatore lessicale e parser

L'**analizzatore lessicale** (o _lexer_) è un componente del compilatore o interprete che prende in input il codice sorgente del programma e lo divide in lessemi. Esso confronta ciascun lessema con i pattern definiti per il linguaggio di programmazione e genera una sequenza di token. Questi token sono poi passati al parser.

Il **parser** è un altro componente del compilatore o interprete che prende in input la sequenza di token generata dall'analizzatore lessicale e verifica che la sequenza rispetti le regole sintattiche del linguaggio di programmazione. Il parser analizza i token per formare una struttura gerarchica che rappresenti le relazioni grammaticali tra di essi. Questa struttura interna è spesso un albero di sintassi (_parse tree_ o _syntax tree_), che riflette la struttura grammaticale del codice sorgente, solitamente descritta usando una forma standard di notazione come la BNF (Backus-Naur Form) o varianti di essa.[^1] L'albero di sintassi viene utilizzato per ulteriori fasi di compilazione o interpretazione, come l'analisi semantica e la generazione del codice. Ad esempio, il parser può verificare che le espressioni aritmetiche siano ben formate, che le istruzioni siano correttamente annidate e che le dichiarazioni di variabili siano valide.

[^1]: La BNF (Backus-Naur Form o Backus Normal Form) è una metasintassi, ovvero un formalismo attraverso cui è possibile descrivere la sintassi di linguaggi formali (il prefisso meta ha proprio a che vedere con la natura circolare di questa definizione). Si tratta di uno strumento molto usato per descrivere in modo preciso e non ambiguo la sintassi dei linguaggi di programmazione, dei protocolli di rete e così via, benché non manchino in letteratura esempi di sue applicazioni a contesti anche non informatici e addirittura non tecnologici. Un esempio è la grammatica di [Python](https://docs.python.org/3/reference/grammar.html)

### Espressioni

Un'espressione è una combinazione di lessemi che viene valutata per produrre un risultato. 

Esempi di espressioni includono:

- `5 + 3`.
- `x * 2`.
- `y / 4.0`.
- `max(a, b)`.
- `"Hello, " + "world!"`.

### Istruzioni semplici

Le **istruzioni semplici** sono operazioni atomiche secondo il linguaggio e sono costituite da lessemi ed espressioni per compiere operazioni di base. Gli esempi principali includono: 

- Assegnazione: Utilizza un operatore di assegnazione (ad esempio, `=`) per attribuire un valore a una variabile, che possiamo pensare come un nome simbolico rappresentante una posizione dove è memorizzato un valore. Esempio:

  ```python
  x = 5
  ```
  - `x`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `5`: Letterale numerico intero.

- Input/output: Utilizza parole chiave o funzioni di libreria per leggere valori dall'input o scrivere valori all'output. Esempio:

  ```python
  print("Hello, World!")
  ```
  - `print`: Parola chiave o identificatore di funzione di libreria.
  - `"Hello, World!"`: Letterale stringa.
  L'esecuzione dell'istruzione produce `"Hello, World!"` in output.

- Assegnazione ad espressione: Combinazione di variabili, operatori e valori che producono un risultato assegnato ad una variabile. Esempio:

    ```python
    z = (x * 2) + (y / 2)
    ```
  - `z`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `(x * 2)`: Espressione che moltiplica `x` per `2`.
  - `(y / 2)`: Espressione che divide `y` per `2`.
  - `+`: Operatore aritmetico che somma i risultati delle due espressioni in una più complessa.
  L'esecuzione dell'istruzione produce un risultato valido solo se `x` e `y` sono associate a valori numerici e ciò perché non tutte le istruzioni sintatticamente corrette sono semanticamente corrette. D'altronde ciò non deve essere preso come regola, perché se `*` fosse un operatore che ripete quanto a sinistra un numero di volte definito dal valore di destra e `/` la divisione del valore di sinistra in parti di numero pari a quanto a destra, allora `x` e `y` potrebbero essere stringhe.

### Istruzioni complesse e blocchi di codice

Le **istruzioni complesse** sono costituite da più istruzioni semplici e possono includere strutture di controllo del flusso, come condizioni (`if`), cicli (`for`, `while`) ed eccezioni (`try`, `catch`). Queste istruzioni sono utilizzate per organizzare il flusso di esecuzione del programma e possono contenere altre istruzioni semplici o complesse al loro interno.

Un **blocco di codice** è una sezione del codice che raggruppa una serie di istruzioni che devono essere eseguite insieme. I blocchi di codice sono spesso utilizzati all'interno delle istruzioni complesse per delimitare il gruppo di istruzioni che devono essere eseguite in determinate condizioni o iterazioni. 

In molti linguaggi di programmazione, i blocchi di codice sono delimitati da parentesi graffe (`{}`), mentre in altri linguaggi, come Python, l'indentazione è utilizzata per indicare l'inizio e la fine di un blocco di codice.

Alcuni esempi di istruzione e blocco di codice:

- Esempio in C:

  ```c
  if (x > 0) {
      printf("x è positivo\n");
      y = x * 2;
  }
  ```
  In questo esempio:
  - `if (x > 0)` è un'istruzione complessa.
  - `{ printf("x è positivo\n"); y = x * 2; }` è un blocco di codice che viene eseguito se la condizione dell'istruzione `if` è vera.

- Esempio in Python:

```python
  if x > 0:
      print("x è positivo")
      y = x * 2
  ```
  In questo esempio:
  - `if x > 0:` è un'istruzione complessa.
  - Le righe indentate sotto l'istruzione `if` (`print("x è positivo")` e `y = x * 2`) costituiscono un blocco di codice che viene eseguito se la condizione dell'istruzione `if` è vera.

Altri esempi: 

- Condizioni: Istruzioni che eseguono un blocco di codice solo se una condizione è vera. Esempio:

  ```c
  #include <stdio.h>

  x = 42;

  if (x > 0) {
      printf("x è positivo\n");
  }
  ```
  - `if`: Parola chiave che introduce la condizione.
  - `(x > 0)`: Condizione composta da: `x` identificatore di variabile, `>` operatore di confronto e `0` letterale numerico intero.
  - `{ ... }`: Delimitatori che racchiudono il blocco di codice.
  - `print("x è positivo")`: Istruzione di output.

- Cicli: Istruzioni che ripetono un blocco di codice. Esempio:

  ```c
  #include <stdio.h>

  int n = 42;
  int somma = 0;
  int i;

  for (i = 0; i < n; i++) {
      somma = somma + i;
  }
  ```
  - `for`: Parola chiave che introduce il ciclo.
  - `(i = 0; i < n; i++)`: Espressione di controllo del ciclo composta da: `i = 0` assegnazione iniziale, `i < n` condizione di ciclo e `i++` incremento della variabile `i`.
  - `{ ... }`: Delimitatori che racchiudono il blocco di codice.
  - `somma = somma + i`: Operazione aritmetica.

### Organizzazione del codice in un programma

Il programma è solitamente salvato in un file di testo in righe. Queste righe possono essere classificate in righe fisiche e righe logiche.

Una **riga fisica** è una linea di testo nel file sorgente del programma, terminata da un carattere di a capo. 

Esempio:

```c
int x = 10; // Questa è una riga fisica
```

Una **riga logica** è una singola istruzione, che può estendersi su una o più righe fisiche.

Esempio di riga logica con più righe fisiche:

```c
int y = (10 + 20 + 30 + // Prima riga fisica della riga logica
         40 + 50); // Seconda riga fisica della riga logica
```

Il concetto di righe fisiche e logiche esiste perché le istruzioni (o righe logiche) possono essere lunghe e complesse, richiedendo più righe fisiche per migliorare la leggibilità e la gestione del codice.

## Semantica

La **semantica** di un linguaggio di programmazione definisce il significato delle istruzioni sintatticamente corrette. In altre parole, la semantica specifica cosa fa un programma quando viene eseguito, descrivendo l'effetto delle istruzioni sullo stato del sistema. Gli elementi semantici sono numerosi, possono essere anche molto complessi e non tutti presenti in uno specifico linguaggio. Di seguito ne sono elencati alcuni tra i più diffusi:

- Variabile: È un nome simbolico associato a locazione di memoria che può contenere uno o più valori. È fondamentale per la manipolazione di dati perché sono un mezzo per astrarre dalla costante memorizzata. Le variabili possono essere associate a diversi tipi di dati e durate di vita. La semantica delle variabili include la loro dichiarazione, inizializzazione, uso e visibilità:

  - Dichiarazione: La dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. La dichiarazione informa il compilatore o l'interprete che una certa variabile esiste e può essere utilizzata nel codice.

  - Inizializzazione: L'inizializzazione di una variabile è il processo di assegnare un valore iniziale alla variabile. L'inizializzazione può avvenire contestualmente alla dichiarazione o in un'istruzione separata successiva.

  - Visibilità: Indica dove la variabile può essere utilizzata all'interno del codice (ad esempio, variabili locali o globali).

  - Durata di Vita: Descrive per quanto tempo la variabile rimane in memoria durante l'esecuzione del programma (ad esempio, automatica, statica, dinamica).

- Tipo di dati: I tipi di dati definiscono il dominio dei valori che una variabile può assumere e le operazioni che possono essere eseguite su quei valori. Un tipo di dato determina la natura del valore (ad esempio, numero intero, carattere, booleano) e le operazioni che possono essere effettuate su di esso. Generalmente si distinguono in:

  - Tipo primitivo: I tipi di dati fondamentali forniti da un linguaggio, come integer, float, boolean e character.

  - Tipo complesso: Tipo di dati costituiti da più tipi primitivi, come array, struct e oggetti.

  - Tipo di dati utente: Tipo definito dall'utente, come classi e tipi personalizzati, che permette di creare strutture dati più complesse e specifiche per il problema da risolvere.

- Ambito (in inglese, _scope_): L'ambito rappresenta la porzione del codice in cui un identificatore (come una variabile o una funzione) è definito e, quindi, esiste. L'ambito determina dove un identificatore può essere dichiarato e utilizzato. Tipicamente gli ambiti sono:

  - Globale: Identificatori dichiarati a livello globale, accessibili ovunque nel programma.

  - Locale: Identificatori dichiarati all'interno di un blocco, come una funzione o un loop, e accessibili solo all'interno di quel blocco.

  - Statico e dinamico: L'ambito statico è determinato a tempo di compilazione, mentre l'ambito dinamico è determinato a runtime, influenzando come e dove gli identificatori possono essere utilizzati.

- Visibilità: La visibilità si riferisce a dove nel codice un identificatore può essere visto e utilizzato. Anche se correlata all'ambito, la visibilità può essere influenzata da altri fattori come la modularità e i namespace, che organizzano e separano gli identificatori per evitare conflitti di nome. La visibilità è generalmente:

  - Globale: Un identificatore dichiarato con visibilità globale può essere utilizzato in qualsiasi parte del programma.

  - Locale: Un identificatore dichiarato con visibilità locale è visibile solo all'interno del blocco di codice in cui è stato dichiarato.

- Funzioni e metodi: Le funzioni e i metodi sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Alcuni concetti collegati sono:

  - Parametri e argomenti: Valori passati alle funzioni per influenzarne il comportamento. I parametri sono definiti nella dichiarazione della funzione, mentre gli argomenti sono i valori effettivi passati quando la funzione è chiamata.

  - Valore di ritorno: Il risultato prodotto da una funzione, che può essere utilizzato nell'istruzione chiamante.

  - Overloading: Definizione di più funzioni con lo stesso nome ma diversi parametri, consentendo diverse implementazioni basate sui tipi e il numero di argomenti.

  - Ricorsione: Capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili.

  - Funzioni di prima classe: Le funzioni possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.

  - Funzioni di ordine superiore: Funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati.

- Durata di vita delle variabili: La durata di vita delle variabili si riferisce a quanto tempo una variabile rimane in memoria durante l'esecuzione del programma. Alcune tipologie di durata:

  - Automatica: Variabili che esistono solo durante l'esecuzione del blocco in cui sono dichiarate.

  - Statica: Variabili che esistono per tutta la durata del programma e mantengono il loro valore tra diverse chiamate di funzione.

  - Dinamica: Variabili allocate dinamicamente durante l'esecuzione del programma, solitamente gestite manualmente dall'utente (ad esempio, usando `malloc`/`free` in C) o automaticamente tramite garbage collection.

- Durata di vita di altri identificatori: 

  - Funzioni: Le funzioni stesse generalmente hanno una durata di vita che coincide con la durata del programma. Tuttavia, i puntatori a funzione e le chiusure (in inglese, closures) possono avere durate di vita diverse in alcuni linguaggi.

  - Classi e oggetti: Le classi hanno una durata di vita che coincide con la durata del programma, mentre gli oggetti (istanze di classi) hanno durate di vita dinamiche, determinate dalla loro allocazione e deallocazione.

  - Moduli: In linguaggi come Python, i moduli hanno una durata di vita che coincide con la durata del programma o del processo di importazione.

- Controllo di flusso: Determina l'ordine in cui le istruzioni vengono eseguite e alcuni esempi sono:

  - Condizionali: Strutture che permettono al programma di prendere decisioni (`if`, `else`, `switch`/`case`).

  - Cicli: Strutture che ripetono un blocco di codice (`for`, `while`, `do`-`while`).

  - Eccezioni: Meccanismi per gestire errori e condizioni anomale (`try`, `catch`, `throw`), permettendo al programma di continuare l'esecuzione in modo controllato.

- Classi e oggetti: Le classi sono trutture che definiscono proprietà (variabili) e comportamenti (metodi) comuni a tutti gli oggetti di quel tipo. Le classi rappresentano il modello o il blueprint da cui vengono creati gli oggetti. L'oggetto è l'istanza concreta di una classe. Gli oggetti sono entità che combinano dati e comportamenti secondo la struttura definita dalla loro classe. Si applicano i seguenti: 

  - Encapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie, migliorando la modularità e la manutenzione del codice.

  - Ereditarietà: Permette di creare nuove classi basate su classi esistenti, riutilizzando e estendendo il comportamento delle classi base.

  - Polimorfismo: Consente a metodi di comportarsi diversamente a seconda dell'oggetto su cui vengono invocati, fornendo flessibilità e estendibilità.

- Gestione della memoria utilizzata dal programma: La gestione della memoria è fondamentale per il funzionamento efficiente di un programma. Ne esistono diverse modalità: 

  - Allocazione dinamica: La memoria è allocata e deallocata a runtime, permettendo una gestione flessibile delle risorse.

  - Garbage collection: Automatizza la deallocazione della memoria non utilizzata, riducendo il rischio di sfruttamento non ottimale (memory leak) e semplificando la gestione della memoria.

- Spazio di nomi (in inglese namespace): I namespace organizzano variabili, funzioni e altri identificatori per evitare conflitti di nome.

- Moduli e librerie: I moduli e le librerie suddividono il codice in unità riutilizzabili e organizzate, da importare in programmi. I moduli possono definire degli spazi di nomi. 

- Concorrenza: La concorrenza permette l'esecuzione parallela di più sequenze di istruzioni, migliorando le prestazioni e la reattività. Alcuni concetti relativi sono:

  - Thread: Un thread è la più piccola unità di elaborazione che può essere eseguita in modo indipendente. I thread consentono l'esecuzione parallela di codice all'interno di un programma.

  - Sincronizzazione: Meccanismi per gestire l'accesso concorrente alle risorse condivise, prevenendo condizioni di gara e garantendo la consistenza dei dati.

  - Lock e mutex: Meccanismi per prevenire condizioni di corsa (in inglese race condition), cioè un fenomeno che si presenta nei sistemi concorrenti quando, in presenza di una sequenza di processi multipli, il risultato finale dell'esecuzione dei processi dipende dalla temporizzazione o dalla sequenza con cui vengono eseguiti. Garantiscono, pertanto, l'accesso sicuro alle risorse condivise.

  - Async/await: Gestione di operazioni asincrone, migliorando l'efficienza e la reattività delle applicazioni.

- Input/output (I/O): L'input/output gestisce la comunicazione tra il programma e l'ambiente esterno.

  - File I/O: Lettura e scrittura su file per memorizzare e recuperare dati persistenti.

  - Network I/O: Comunicazione attraverso reti per inviare e ricevere dati tra sistemi diversi.

  - Standard I/O: Interazione con l'utente tramite input da tastiera e output su schermo.

- Annotazioni e metadati: Le annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l'analisi del codice.

  - Annotazioni: Informazioni extra utilizzate per specificare comportamenti speciali o configurazioni. Ad esempio, in Java, le annotazioni possono essere utilizzate per indicare che un metodo è obsoleto (`@Deprecated`), per sovrascrivere un metodo della superclasse (`@Override`), o per specificare la relazione tra entità nel contesto di framework come JPA (Jakarta Persistence; `@Entity`, `@Table`). In Python, le annotazioni sono utilizzate principalmente per indicare i tipi di variabili, parametri di funzione e valori di ritorno (type hint). Non influenzano direttamente il comportamento del programma, ma sono utili per la documentazione e il type checking anche automatico.

  - Docstring: Commenti strutturati che documentano il codice, spesso utilizzati per generare documentazione automatica. In Python, ad esempio, le docstring possono essere utilizzate per descrivere il funzionamento di moduli, classi, metodi e funzioni, rendendo il codice più leggibile e comprensibile.

- Macro e metaprogrammazione: Le macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice.

  - Macro: Sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale.

  - Metaprogrammazione: Tecniche per scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time, migliorando la flessibilità e il riutilizzo del codice. In Python include l'uso di decoratori, metaclassi e introspezione.

Questi elementi semantici combinati determinano il comportamento e la logica di un programma, influenzando il modo in cui il codice viene scritto, eseguito e mantenuto. 

## Applicazione dei concetti di sintassi e semantica

Dissezioniamo un algoritmo molto semplice per illustrare come sintassi e semantica di un linguaggio abbiano ruoli distinti e complementari in un programma. È importante comprendere che un buon programmatore deve avere tutte e tre le competenze, cioè conoscere le specificità formali del linguaggio (o di più linguaggi), quindi, la sua sintassi e semantica e saper comporre algoritmi, che potrà realizzare grazie proprio a quelle.

Consideriamo un esempio semplice di algoritmo per calcolare la somma dei numeri da 1 a n. In input si avrà un numero intero `n` e in output il risultato. In pseudocodice (cioè mimiamo il rigore sintattico di un linguaggio di programmazione, ma utilizziamo la lingua italiana) si può rappresentare così:

```bash
Inizializza somma a 0
Per ogni numero i da 1 a n:
  Aggiungi i a somma
Restituisci somma
```

O, in alternativa, possiamo definire una funzione che implementa l'algoritmo: 

```bash
funzione calcola_somma(n):
  somma = 0
  per i da 1 a n:
    somma = somma + i
  ritorna somma
```

Effettuiamo una analisi dettagliata della funzione per indicare quali elementi sintattici e semantici sono presenti. Partiamo dalla prima riga:

```bash
funzione calcola_somma(n):
```

- Sintassi:

  - `funzione`: Parola chiave che introduce la definizione di una funzione.
  - `calcola_somma`: Identificatore della funzione.
  - `(n)`: Delimitatori che contengono un identificatore.

- Semantica: Definisce una funzione chiamata `calcola_somma` che accetta un parametro `n`.

La seconda riga ha l'inizializzazione della variabile che conterrà il risultato: 

```bash
somma = 0
```

- Sintassi:
  - `somma`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `0`: Letterale numero intero.

- Semantica:
  - Inizializza la variabile `somma` a `0`.

A seguire la definizione di un ciclo: 

```bash
per i da 1 a n:
```

- Sintassi:

  - `per`: Parola chiave che introduce il ciclo.
  - `i`: Identificatore della variabile di controllo del ciclo.
  - `da 1 a n`: Espressione di controllo del ciclo che indica l'intervallo.

- Semantica: Itera la variabile `i` da `1` a `n`.

Un assegnamento per accumulare i valori nella variabile di ritorno:

```bash
somma = somma + i
```

- Sintassi:

  - `somma`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `somma + i`: Espressione aritmetica composta da: `somma` identificatore di variabile, `+` operatore aritmetico e `i` identificatore di variabile.

- Semantica: Aggiunge il valore di `i` alla variabile `somma` e assegna il risultato a `somma`.

E finalmente il risultato del calcolo viene restituito al chiamante: 

```bash
ritorna somma
```

- Sintassi:
  - `ritorna`: Parola chiave che indica la restituzione di un valore.
  - `somma`: Identificatore della variabile.

- Semantica:
  - Restituisce il valore della variabile `somma` come risultato della funzione.

