---
reference-location: margin
citation-location: margin
---

# Paradigmi di programmazione

I linguaggi di programmazione possono essere classificati in diversi tipologie in base al loro scopo e alla loro struttura. 

Una delle classificazioni più importanti è quella del **paradigma di programmazione**, che definisce il modello e gli stili di risoluzione dei problemi che un linguaggio supporta. Tuttavia, è importante notare che molti linguaggi moderni sfruttano efficacemente più di un paradigma di programmazione, rendendo difficile assegnare un linguaggio a una sola categoria. Come ha affermato Bjarne Stroustrup, il creatore di C++: 

> Le funzionalità dei linguaggi esistono per fornire supporto agli stili di programmazione. Per favore, non considerate una singola funzionalità di linguaggio come una soluzione, ma come un mattoncino da un insieme variegato che può essere combinato per esprimere soluzioni.
>  
> I principi generali per il design e la programmazione possono essere espressi semplicemente:
>   
> - Esprimere idee direttamente nel codice.
>   
> - Esprimere idee indipendenti in modo indipendente nel codice.
>   
> - Rappresentare le relazioni tra le idee direttamente nel codice.
>   
> - Combinare idee espresse nel codice liberamente, solo dove le combinazioni hanno senso.
>   
> - Esprimere idee semplici in modo semplice.
>  
> Questi sono ideali condivisi da molte persone, ma i linguaggi progettati per supportarli possono differire notevolmente. Una ragione fondamentale per questo è che un linguaggio incorpora una serie di compromessi ingegneristici che riflettono le diverse necessità, gusti e storie di vari individui e comunità.[@stroustrup2013, p. 10]

## L'importanza dei paradigmi di programmazione

Comprendere i paradigmi di programmazione è fondamentale per diversi motivi:

- Approccio alla risoluzione dei problemi: Ogni paradigma offre una visione diversa su come affrontare e risolvere problemi. Conoscere vari paradigmi permette ai programmatori di scegliere l'approccio più adatto in base al problema specifico. Ad esempio, per problemi che richiedono una manipolazione di stati, la programmazione imperativa può essere più intuitiva. Al contrario, per problemi che richiedono trasformazioni di dati senza effetti collaterali, la programmazione funzionale potrebbe essere più adatta.

- Versatilità e adattabilità: I linguaggi moderni che supportano più paradigmi permettono ai programmatori di essere più versatili e adattabili. Possono utilizzare il paradigma più efficiente per diverse parti del progetto, migliorando sia la leggibilità che le prestazioni del codice.

- Manutenzione del codice: La comprensione dei paradigmi aiuta nella scrittura di codice più chiaro e manutenibile. Ad esempio, il paradigma orientato agli oggetti può essere utile per organizzare grandi basi di codice in moduli e componenti riutilizzabili, migliorando la gestione del progetto.

- Evoluzione professionale: La conoscenza dei vari paradigmi arricchisce le competenze di un programmatore, rendendolo più competitivo nel mercato del lavoro. Conoscere più paradigmi permette di comprendere e lavorare con una gamma più ampia di linguaggi di programmazione e tecnologie.

- Ottimizzazione del codice: Alcuni paradigmi sono più efficienti in determinate situazioni. Ad esempio, la programmazione concorrente è essenziale per lo sviluppo di software che richiede alta prestazione e scalabilità, come nei sistemi distribuiti. Comprendere come implementare la concorrenza in vari paradigmi permette di scrivere codice più efficiente.

## Paradigma imperativo

La **programmazione imperativa**, a differenza della programmazione dichiarativa, è un paradigma di programmazione che descrive l'esecuzione di un programma come una serie di istruzioni che cambiano il suo stato. In modo simile al modo imperativo nelle lingue naturali, che esprime comandi per compiere azioni, i programmi imperativi sono una sequenza di comandi che il computer deve eseguire. Un caso particolare di programmazione imperativa è quella procedurale.

I linguaggi di programmazione imperativa si contrappongono ad altri tipi di linguaggi, come quelli funzionali e logici. I linguaggi di programmazione funzionale, come Haskell, non producono sequenze di istruzioni e non hanno uno stato globale come i linguaggi imperativi. I linguaggi di programmazione logica, come Prolog, sono caratterizzati dalla definizione di cosa deve essere calcolato, piuttosto che come deve avvenire il calcolo, a differenza di un linguaggio di programmazione imperativo.

L'implementazione hardware di quasi tutti i computer è imperativa perché è progettata per eseguire il codice macchina, che è scritto in stile imperativo. Da questa prospettiva a basso livello, lo stato del programma è definito dal contenuto della memoria e dalle istruzioni nel linguaggio macchina nativo del processore. I linguaggi imperativi di alto livello utilizzano variabili e istruzioni più complesse, ma seguono ancora lo stesso paradigma per mantenere la coerenza nella traduzione (compilazione o interpretazione) del codice.

### Esempio in Assembly

Assembly è un linguaggio a basso livello strettamente legato all'hardware del computer. Ecco un esempio di un semplice programma scritto per l'architettura x86, utilizzando la sintassi dell'assembler NASM (Netwide Assembler). Il codice somma due numeri e stampa il risultato:

```nasm
section .data
    num1 db 5           ; Definisce il primo numero
    num2 db 3           ; Definisce il secondo numero
    result db 0         ; Variabile per memorizzare il risultato

section .text
    global _start

_start:
    mov al, [num1]      ; Carica il primo numero in AL
    add al, [num2]      ; Aggiunge il secondo numero a AL
    mov [result], al    ; Memorizza il risultato in result

    ; Print result (pseudocodice per semplicità)
    ; In realtà, si dovrebbe convertire il risultato in ASCII e chiamare le syscall appropriate.
    
    ; Terminazione del programma
    mov eax, 1          ; Codice di sistema per l'uscita
    int 0x80            ; Interruzione per chiamare il kernel
```

Le sezioni del codice:

- Dati: La sezione `.data` è utilizzata per dichiarare variabili statiche inizializzate.

- Testo: La sezione `.text` contiene il codice eseguibile. L'etichetta `_start` indica il punto di ingresso del programma.

- Registri: I registri come `al` e `eax` sono utilizzati per operazioni aritmetiche e per la memorizzazione temporanea dei dati.

- Chiamate di sistema: L'interruzione `int 0x80` è usata per eseguire chiamate di sistema in Linux. ```int 0x80```

L'Assembly x86 è usato nello sviluppo di:

- Sistemi operativi: Utilizzato nello sviluppo di kernel e driver.

- Applicazioni _embedded_: Microcontrollori di dispositivi medici, sistemi di controllo di veicoli, dispositivi IoT, ecc., cioè)dove è necessaria un'ottimizzazione estrema delle risorse computazionali.

- Applicazioni HPC (_high performance computing_): Il focus qui è eseguire calcoli intensivi e complessi in tempi relativamente brevi. Queste applicazioni richiedono un numero di operazioni per unità di tempo elevato e sono ottimizzate per sfruttare al massimo le risorse hardware disponibili, come CPU, GPU e memoria.

### Esempio in Python

All'altro estremo della immediatezza di comprensione del testo del codice troviamo Python, un linguaggio di alto livello noto per la leggibilità ed eleganza. 

Ecco il medesimo esempio:

```python
# Definizione delle variabili
num1 = 5
num2 = 3

# Somma dei due numeri
result = num1 + num2

# Stampa del risultato
print("Il risultato è:", result)
```

### Analisi comparativa

Assembly:

- Basso livello di astrazione: Assembly lavora direttamente con i registri della CPU e la memoria, quindi non astrae granché della complessità dell'hardware.

- Versatilità: Il linguaggio è progettato per una ben definita architettura e, quindi, ha una scarsa applicabilità ad altre. 

- Precisione: Il programmatore ha un controllo dettagliato su ogni singola operazione.

- Complessità: Ogni operazione deve essere definita esplicitamente e in sequenza, il che rende il codice più lungo e difficile da leggere.

Python:

- Alto livello di astrazione: Python fornisce un'astrazione più elevata, permettendo di ignorare i dettagli dell'hardware.

- Semplicità: Il codice è più breve e leggibile, facilitando la comprensione e la manutenzione.

- Versatilità: Il linguaggio è applicabile senza modifiche a un elevato numero di architetture hardware-software.

- Produttività: I programmatori possono concentrarsi sulla logica del problema senza preoccuparsi dei dettagli implementativi.

## Paradigma procedurale

La **programmazione procedurale** è un paradigma di programmazione, derivato da quella imperativa, che organizza il codice in unità chiamate procedure o funzioni. Ogni procedura o funzione è un blocco di codice che può essere richiamato da altre parti del programma, promuovendo la riutilizzabilità e la modularità del codice.

La programmazione procedurale è una naturale evoluzione della imperativa e uno dei paradigmi più antichi e ampiamente utilizzati. Ha avuto origine negli anni '60 e '70 con linguaggi come Fortan, COBOL e C, tutt'oggi rilevanti. Questi linguaggi hanno introdotto concetti fondamentali come funzioni, sottoprogrammi e la separazione tra codice e dati. Il C, in particolare, ha avuto un impatto duraturo sulla programmazione procedurale, diventando uno standard de facto per lo sviluppo di sistemi operativi e software di sistema.

I vantaggi principali sono:

- Modularità: La programmazione procedurale incoraggia la suddivisione del codice in funzioni o procedure più piccole e gestibili. Questo facilita la comprensione, la manutenzione e il riutilizzo del codice.

- Riutilizzabilità: Le funzioni possono essere riutilizzate in diverse parti del programma o in progetti diversi, riducendo la duplicazione del codice e migliorando l'efficienza dello sviluppo.

- Struttura e organizzazione: Il codice procedurale è generalmente più strutturato e organizzato, facilitando la lettura e la gestione del progetto software.

- Facilità di debug e testing: La suddivisione del programma in funzioni isolate rende più facile individuare e correggere errori, oltre a testare parti specifiche del codice.

D'altro canto, presenta anche degli svantaggi che hanno spinto i ricercatori a continuare l'innovazione:

- Scalabilità limitata: Nei progetti molto grandi, la programmazione procedurale può diventare difficile da gestire. La mancanza di meccanismi di astrazione avanzati, come quelli offerti dalla programmazione orientata agli oggetti, può complicare la gestione della complessità.

- Gestione dello stato: La programmazione procedurale si basa spesso su variabili globali per condividere stato tra le funzioni, il che può portare a bug difficili da individuare e risolvere.

- Difficoltà nell'aggiornamento: Le modifiche a una funzione possono richiedere aggiornamenti in tutte le parti del programma che la utilizzano, aumentando il rischio di introdurre nuovi errori.

- Meno Adatta per Applicazioni Moderne: Per applicazioni complesse e moderne che richiedono la gestione di eventi, interfacce utente complesse e modellazione del dominio, la programmazione procedurale può essere meno efficace rispetto ad altri paradigmi come quello orientato agli oggetti.

### Funzioni e procedure

Nella programmazione procedurale, il codice è suddiviso in unità elementari chiamate **funzioni** e **procedure**. La differenza principale tra le due è la seguente:

- Funzione: Una funzione è un blocco di codice che esegue un compito specifico e restituisce un valore. Le funzioni sono utilizzate per calcoli o operazioni che producono un risultato. Ad esempio, una funzione che calcola la somma di due numeri in linguaggio C:

  ```c
  int somma(int a, int b) {
      return a + b;
  }
  ```

- Procedura: Una procedura è simile a una funzione, ma non restituisce un valore. È utilizzata per eseguire azioni o operazioni che non necessitano di un risultato. Ad esempio, una procedura che stampa un messaggio in Pascal:

  ```pascal
  procedure stampaMessaggio;
  begin
      writeln('Ciao, Mondo!');
  end;
  ```

### Creazione di librerie

Un altro aspetto importante della programmazione procedurale è la possibilità di creare **librerie**, che sono collezioni di funzioni e procedure riutilizzabili. Le librerie permettono di organizzare e condividere codice comune tra diversi progetti, aumentando la produttività e riducendo la duplicazione del codice.

Esempio di una semplice libreria in C:

- File header (`mialibreria.h`):

    ```c
    #ifndef MIALIBRERIA_H
    #define MIALIBRERIA_H

    int somma(int a, int b);
    void stampaMessaggio(const char* messaggio);

    #endif
    ```

- File di implementazione (`mialibreria.c`):

    ```c
    #include "mialibreria.h"
    #include <stdio.h>

    int somma(int a, int b) {
        return a + b;
    }

    void stampaMessaggio(const char* messaggio) {
        printf("%s\n", messaggio);
    }
    ```

- File principale (`main.c`):

    ```c
    #include "mialibreria.h"

    int main() {
        int risultato = somma(5, 3);
        stampaMessaggio("Il risultato è:");
        printf("%d\n", risultato);
        return 0;
    }
    ```

## Paradigma di orientamento agli oggetti

La **programmazione orientata agli oggetti** (in inglese, _object-oriented programming_, OOP) è un paradigma di programmazione che organizza il software in termini di _oggetti_, ciascuno dei quali rappresenta un'istanza di una "classe". Una classe definisce un tipo di dato che include attributi (dati) e metodi (funzionalità). Gli oggetti interagiscono tra loro attraverso messaggi, permettendo una struttura modulare e intuitiva.

L'OOP è emersa negli anni '60 e '70 con il linguaggio Simula, il primo linguaggio di programmazione a supportare questo paradigma. Tuttavia, è stato con Smalltalk, sviluppato negli anni '70 da Alan Kay e altri presso Xerox PARC, che l'OOP ha guadagnato popolarità. Il paradigma è stato ulteriormente consolidato con il linguaggio C++ negli anni '80 e con Java negli anni '90, rendendolo uno dei più utilizzati per lo sviluppo software moderno. Oggi numerosi sono i linguaggi a oggetti, ad esempio Python, C#, Ruby, Swift, Javascript, ecc. ed altri lo supportano come PHP (dalla versione 5) e financo il Fortran nella versione 2003. 

Rispetto ai paradigmi precedenti, l'OOP introduce diversi concetti chiave che ineriscono al disegno architetturale di software:

- Classe e oggetto: La classe è un modello o schema per creare oggetti. Contiene definizioni di attributi e metodi. L'oggetto è un'istanza di una classe e rappresenta un'entità concreta con stato e comportamento.

- Incapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie. Migliora la modularità e protegge l'integrità dei dati.

- Ereditarietà: Permette a una classe di estenderne un'altra, ereditandone attributi e metodi. Favorisce il riuso del codice e facilita l'estensione delle funzionalità.

- Polimorfismo: Consente a oggetti di classi diverse di essere trattati come oggetti di una classe comune. Facilita l'uso di un'interfaccia uniforme per operazioni diverse.

- Astrazione: Permette di definire interfacce di alto livello per oggetti, senza esporre i dettagli implementativi. Facilita la comprensione e la gestione della complessità del sistema.

I vantaggi principali dell'OOP sono:

- Modularità: Le classi e gli oggetti favoriscono la suddivisione del codice in moduli indipendenti, migliorando la manutenibilità e la riusabilità del software.

- Riutilizzabilità: L'uso di classi e l'ereditarietà consentono di riutilizzare il codice in nuovi progetti senza riscriverlo.

- Facilità di manutenzione: L'incapsulamento e l'astrazione riducono la complessità e facilitano la manutenzione del codice.

- Estendibilità: Le classi possono essere estese per aggiungere nuove funzionalità senza modificare il codice esistente.

- Affidabilità: Il polimorfismo e l'ereditarietà migliorano l'affidabilità del codice, poiché le modifiche possono essere fatte in una classe base e propagate alle classi derivate.

Anche se sussistono dei caveat:

- Complessità iniziale: L'OOP può essere complesso da apprendere e implementare correttamente per i nuovi programmatori.

- Overhead di prestazioni: L'uso intensivo di oggetti può introdurre un overhead di memoria e prestazioni rispetto alla programmazione procedurale.

- Abuso di ereditarietà: L'uso improprio dell'ereditarietà può portare a gerarchie di classi troppo complesse e difficili da gestire.

### Esempio in Java

In questo esempio, la classe `Animale` rappresenta una classe base con un attributo `nome` e un metodo `faiVerso`. La classe `Cane` estende `Animale` e sovrascrive il metodo `faiVerso` per fornire un'implementazione specifica. La classe `Main` crea un'istanza di `Cane` e chiama il metodo `faiVerso`, dimostrando il polimorfismo e l'ereditarietà:

```java
// Definizione della classe base
class Animale {
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    void faiVerso() {
        System.out.println("L'animale fa un verso");
    }
}

// Definizione della classe derivata
class Cane extends Animale {

    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }
}

// Classe principale
public class Main {
    public static void main(String[] args) {
        Animale mioCane = new Cane("Fido");
        mioCane.faiVerso(); // Stampa: Il cane abbaia
    }
}
```

Vediamo come implementare il medesimo esempio con una classe astratta in Java. `Animale` è la classe astratta, cioè che non può essere istanziata in un oggetto e `Cane` è una classe concreta che la estende:

```java
// Definizione della classe astratta
abstract class Animale {
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    // Metodo astratto
    abstract void faiVerso();

    // Metodo concreto
    void descrizione() {
        System.out.println("L'animale si chiama " + nome);
    }
}

// Definizione della classe derivata
class Cane extends Animale {

    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }
}

// Classe principale
public class Main {
    public static void main(String[] args) {
        Animale mioCane = new Cane("Fido");
        mioCane.descrizione(); // Stampa: L'animale si chiama Fido
        mioCane.faiVerso();    // Stampa: Il cane abbaia
    }
}
```

### Template 

I template, o generics, non sono specifici dell'OOP, anche se sono spesso associati a essa. I template permettono di scrivere funzioni, classi, e altri costrutti di codice in modo generico, cioè indipendente dal tipo dei dati che manipolano. Questo concetto è particolarmente utile per creare librerie e moduli riutilizzabili e flessibili. 

Ad esempio, definiamo la classe `Box` nel modo seguente:

```cpp
template <typename T>
class Box {
    T value;
public:
    void setValue(T val) { value = val; }
    T getValue() { return value; }
};
```

Essa può contenere un valore di qualsiasi tipo specificato al momento della creazione dell'istanza per mezzo del template `T`:

```cpp
// Box contiene un intero
Box<int> intBox;
intBox.setValue(123);
int x = intBox.getValue();

// Box contiene una stringa
Box<std::string> stringBox;
stringBox.setValue("Hello, World!");
std::string str = stringBox.getValue();
```

Anche nei linguaggi non orientati agli oggetti, i template trovano applicazione. Ad esempio, in Rust, un linguaggio di programmazione sistemistica non puramente OOP, il codice seguente restituisce il valore più grande di una lista:

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    let max = largest(&numbers);
    println!("The largest number is {}", max);
}
```

### Metaprogrammazione

La metaprogrammazione è un paradigma che consente al programma di trattare il codice come dati, permettendo al codice di generare, manipolare o eseguire altro codice. Anche questo concetto non è esclusivo dell'OOP. In C++, la metaprogrammazione è strettamente legata ai template. Un esempio classico è la template metaprogramming (TMP), che permette di eseguire calcoli a tempo di compilazione. Un esempio è il codice seguente di calcolo del fattoriale:

```cpp
template<int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};
template<>
struct Factorial<0> {
    static const int value = 1;
};
```

La metaprogrammazione è presente anche in linguaggi non OOP come Lisp, che utilizza le macro per trasformare e generare codice. 

Nel codice sotto proposto è definita la macro `when`, che prende due parametri in input, cioè `test` e `body`, ove `test` è un'espressione condizionale e `body` un insieme di istruzioni da eeseguire se la condizione è vera:

```commonlisp
(defmacro when (test &rest body)
  `(if ,test
       (progn ,@body)))
```

Vediamo un esempio pratico di come si utilizza la macro `when`. Il test è valutare se `x` è maggiore di `10` e, nel caso, stampare `"x is greater than 10"` e poi assegnare `x` a `0`. Chiamiamo la macro con i due parametri:

```commonlisp
(when (> x 10)
  (print "x is greater than 10")
  (setf x 0))
```

Questo viene espanso in:

```commonlisp
(if (> x 10)
    (progn
      (print "x is greater than 10")
      (setf x 0)))
```

## Paradigma dichiarativo

La **programmazione dichiarativa** è un paradigma di programmazione che si focalizza sul _cosa_ deve essere calcolato piuttosto che sul _come_ calcolarlo. In altre parole, i programmi dichiarativi descrivono il risultato desiderato senza specificare esplicitamente i passaggi per ottenerlo. Questo è in netto contrasto con la programmazione imperativa, dove si fornisce una sequenza dettagliata di istruzioni per modificare lo stato del programma.

La programmazione dichiarativa ha radici nella logica e nella matematica, ed è emersa come un importante paradigma negli anni '70 e '80 con l'avvento di linguaggi come Prolog (per la programmazione logica) e SQL (per la gestione dei database). La programmazione funzionale, con linguaggi come Haskell, è anch'essa una forma di programmazione dichiarativa.

I concetti principali associati alla programazione dichiarativa sono:

- Descrizione del risultato: I programmi dichiarativi descrivono le proprietà del risultato desiderato senza specificare l'algoritmo per ottenerlo. Esempio: In SQL, per ottenere tutti i record di una tabella con un certo valore, si scrive una query che descrive la condizione, non un algoritmo che scorre i record uno per uno.

- Assenza di stato esplicito: La programmazione dichiarativa evita l'uso esplicito di variabili di stato e di aggiornamenti di stato. Ciò riduce i rischi di effetti collaterali e rende il codice più facile da comprendere e verificare.

- Idempotenza: Le espressioni dichiarative sono spesso idempotenti, cioè possono essere eseguite più volte senza cambiare il risultato. Questo è particolarmente utile per la concorrenza e la parallelizzazione.

Il vantaggio principale è relativo alla sua chiarezza perché ci si concentra sul risultato desiderato piuttosto che sui dettagli di implementazione.

La programmazione imperativa specifica come ottenere un risultato mediante una sequenza di istruzioni, modificando lo stato del programma. La programmazione dichiarativa, al contrario, specifica cosa deve essere ottenuto senza descrivere i dettagli di implementazione. In termini di livello di astrazione, la programmazione dichiarativa si trova a un livello superiore rispetto a quella imperativa.

### Linguaggi

Ecco una lista di alcuni linguaggi di programmazione dichiarativi:

1. SQL (Structured Query Language): Utilizzato per la gestione e l'interrogazione di database relazionali.

2. Prolog: Un linguaggio di programmazione logica usato principalmente per applicazioni di intelligenza artificiale e linguistica computazionale.

3. HTML (HyperText Markup Language): Utilizzato per creare e strutturare pagine web.

4. CSS (Cascading Style Sheets): Utilizzato per descrivere la presentazione delle pagine web scritte in HTML o XML.

5. XSLT (Extensible Stylesheet Language Transformations): Un linguaggio per trasformare documenti XML in altri formati.

6. Haskell: Un linguaggio funzionale che è anche dichiarativo, noto per la sua pura implementazione della programmazione funzionale.

7. Erlang: Un linguaggio utilizzato per sistemi concorrenti e distribuiti, con caratteristiche dichiarative.

8. VHDL (VHSIC Hardware Description Language): Utilizzato per descrivere il comportamento e la struttura di sistemi digitali.

9.  Verilog: Un altro linguaggio di descrizione hardware usato per la modellazione di sistemi elettronici.

10. XQuery: Un linguaggio di query per interrogare documenti XML.

Questi linguaggi rappresentano diversi ambiti di applicazione, dai database alla descrizione hardware, e sono accomunati dall'approccio dichiarativo nel quale si specifica cosa ottenere piuttosto che come ottenerlo.

::: {.callout-note}

## Nota

SQL è uno degli esempi più significativi di linguaggio di programmazione dichiarativo. Le query SQL descrivono i risultati desiderati piuttosto che le procedure operative.

Una stored procedure in PL/SQL (Procedural Language/SQL) combina SQL con elementi di linguaggi di programmazione procedurali come blocchi di codice, condizioni e cicli. PL/SQL è quindi un linguaggio procedurale, poiché consente di specificare "come" ottenere i risultati attraverso un flusso di controllo esplicito, rendendolo non puramente dichiarativo. PL/SQL è utilizzato principalmente con il database Oracle.

Un'alternativa a PL/SQL è T-SQL (Transact-SQL), utilizzato con Microsoft SQL Server e Sybase ASE. Anche T-SQL estende SQL con funzionalità procedurali simili, consentendo la scrittura di istruzioni condizionali, cicli e la gestione delle transazioni. Come PL/SQL, T-SQL è un linguaggio procedurale e non puramente dichiarativo.

Esistono anche estensioni ad oggetti come il PL/pgSQL (Procedural Language/PostgreSQL) per il database PostgreSQL.
:::

### Esempi

Esempio di una query SQL che estrae tutti i nomi degli utenti con età maggiore di 30: 

```sql
SELECT nome
FROM utenti
WHERE età > 30;
```

In Prolog, si definiscono fatti e regole che descrivono relazioni logiche. Il motore di inferenza di Prolog utilizza queste definizioni per risolvere query, senza richiedere un algoritmo dettagliato. Di seguito, sono definiti due fatti (le prime due righe) e due regole (la terza e la quarta) e quindi si effettua una query che dà come risultato `true`:

```prolog
genitore(padre, figlio).
genitore(madre, figlio).
antenato(X, Y) :- genitore(X, Y).
antenato(X, Y) :- genitore(X, Z), antenato(Z, Y).

?- antenato(padre, figlio).
```

## Paradigma funzionale

La **programmazione funzionale** è un paradigma di programmazione che tratta il calcolo come la valutazione di funzioni matematiche ed evita lo stato mutabile e i dati modificabili. I programmi funzionali sono costruiti applicando e componendo funzioni. Questo paradigma è stato ispirato dal calcolo lambda, una formalizzazione matematica del concetto di funzione. La programmazione funzionale è un paradigma alternativo alla programmazione imperativa, che descrive la computazione come una sequenza di istruzioni che modificano lo stato del programma.

La programmazione funzionale ha radici storiche che risalgono agli anni '30, con il lavoro di Alonzo Church sul calcolo lambda. I linguaggi di programmazione funzionale hanno iniziato a svilupparsi negli anni '50 e '60 con Lisp, ma è stato negli anni '70 e '80 che linguaggi come ML e Haskell hanno consolidato questo paradigma. Haskell, in particolare, è stato progettato per esplorare nuove idee in programmazione funzionale e ha avuto un impatto significativo sulla ricerca e sulla pratica del software.

La programmazione funzionale è una forma di programmazione dichiarativa che si basa su funzioni pure e immutabilità. Entrambi i paradigmi evitano stati mutabili e si concentrano sul risultato finale, ma la programmazione funzionale utilizza funzioni matematiche come unità fondamentali di calcolo.

Concetti fondamentali:

- Immutabilità: I dati sono immutabili, il che significa che una volta creati non possono essere modificati. Questo riduce il rischio di effetti collaterali e rende il codice più prevedibile.

- Funzioni di prima classe e di ordine superiore: Le funzioni possono essere passate come argomenti a altre funzioni, ritornate da funzioni, e assegnate a variabili. Le funzioni di ordine superiore accettano altre funzioni come argomenti o restituiscono funzioni.

- Purezza: Le funzioni pure sono funzioni che, dato lo stesso input, restituiscono sempre lo stesso output e non causano effetti collaterali. Questo rende il comportamento del programma più facile da comprendere e prevedere.

- Trasparenza referenziale: Un'espressione è trasparentemente referenziale se può essere sostituita dal suo valore senza cambiare il comportamento del programma. Questo facilita l'ottimizzazione e il reasonig sul codice.

- Ricorsione: È spesso utilizzata al posto di loop iterativi per eseguire ripetizioni, poiché si adatta meglio alla natura immutabile dei dati e alla definizione di funzioni.

- Composizione di funzioni: Consente di costruire funzioni complesse combinando funzioni più semplici. Questo favorisce la modularità e la riusabilità del codice.

Il paradigma funzionale ha diversi vantaggi:

- Prevedibilità e facilità di test: Le funzioni pure e l'immutabilità rendono il codice più prevedibile e più facile da testare, poiché non ci sono stati mutabili o effetti collaterali nascosti.

- Concorrenza: La programmazione funzionale è ben adatta alla programmazione concorrente e parallela, poiché l'assenza di stato mutabile riduce i problemi di sincronizzazione e competizione per le risorse.

- Modularità e riutilizzabilità: La composizione di funzioni e la trasparenza referenziale facilitano la creazione di codice modulare e riutilizzabile.

E qualche svantaggio:

- Curva di apprendimento: La programmazione funzionale può essere difficile da apprendere per chi proviene da paradigmi imperativi o orientati agli oggetti, a causa dei concetti matematici sottostanti e della diversa mentalità necessaria.

- Prestazioni: In alcuni casi, l'uso intensivo di funzioni ricorsive può portare a problemi di prestazioni, come il consumo di memoria per le chiamate ricorsive. Tuttavia, molte implementazioni moderne offrono ottimizzazioni come la ricorsione di coda (in inglese, _tail recursion_).

- Disponibilità di librerie e strumenti: Alcuni linguaggi funzionali potrebbero non avere la stessa ampiezza di librerie e strumenti disponibili rispetto ai linguaggi imperativi più diffusi.

### Esempio in Haskell

Di seguito due funzioni, la prima `sumToN` è pura e somma i primi `n` numeri. `(*2)` è una funzione che prende un argomento e lo moltiplica per 2 e ciò rende la seconda funzione `applyFunction` una vera funzione di ordine superiore, poiché accetta `(*2)` come argomento oltre ad una lista, producendo come risultato il raddoppio di tutti i suoi elementi:

```haskell
-- Definizione di una funzione pura che calcola la somma dei numeri da 1 a n
sumToN :: Integer -> Integer
sumToN n = sum [1..n]

-- Funzione di ordine superiore che accetta una funzione e una lista
applyFunction :: (a -> b) -> [a] -> [b]
applyFunction f lst = map f lst

-- Utilizzo delle funzioni
main = do
    print (sumToN 10) -- Stampa 55
    print (applyFunction (*2) [1, 2, 3, 4]) -- Stampa [2, 4, 6, 8]
```

### Linguaggi

Oltre a Haskell, ci sono molti altri linguaggi funzionali, tra cui:

- Erlang: Utilizzato per sistemi concorrenti e distribuiti.

- Elixir: Costruito a partire da Erlang, è utilizzato per applicazioni web scalabili.

- F#: Parte della piattaforma .NET, combina la programmazione funzionale con lo OOP.

- Scala: Anch'esso combina programmazione funzionale e orientata agli oggetti ed è interoperabile con Java.

- OCaml: Conosciuto per le sue prestazioni e sintassi espressiva.

- Lisp: Uno dei linguaggi più antichi, multi-paradigma con forti influenze funzionali.

- Clojure: Dialetto di Lisp per la JVM, adatto alla concorrenza.

- Scheme: Dialetto di Lisp spesso usato nell'educazione.

- ML: Linguaggio influente che ha portato allo sviluppo di OCaml e F#.

- Racket: Derivato da Scheme, usato nella ricerca accademica.