---
reference-location: margin
citation-location: margin
tbl-cap-location: margin
---

# Istruzioni

In Python, un programma è composto da una sequenza di istruzioni che l'interprete esegue una dopo l'altra. Le istruzioni sono i comandi fondamentali che dicono al computer cosa fare. Ogni istruzione rappresenta un'azione, come la creazione di una variabile, l'esecuzione di un ciclo, la definizione di una funzione o la stampa di un messaggio sullo schermo. 

Le istruzioni si distinguono in **semplici** e **composte**:

- Le istruzioni semplici sono quelle che non contengono altre istruzioni al loro interno. Sono eseguite dall'interprete come un singolo blocco di codice.

- Le istruzioni composte contengono altre istruzioni al loro interno. Queste istruzioni definiscono blocchi di codice che possono includere altre istruzioni semplici o composte.

## Istruzioni semplici

Un'istruzione semplice è sempre contenuta in una riga logica, che può presentare più istruzioni semplici separate da `;`. È permesso ma sconsigliato, perché in pochi casi porta a codice leggibile.

### Assegnamenti

Le istruzioni di assegnamento sono utilizzate per assegnare un valore a una variabile. Esempi: 

```python
x = 10 # <1>

nome = "Alice" # <2>
```
1. Assegnazione di un letterale di numero intero ad una variabile `x`.
2. Assegnazione di un letterale stringa ad una variabile `nome`.

L'assegnamento aumentato consente di combinare un'operazione aritmetica con l'assegnamento. Esempi: 

```python
x += 5  # <1>
x -= 2  # <2>
x *= 3  # <3>
x /= 4  # <4>
x %= 2  # <5>
```
1. Equivalente a `x = x + 5`.
2. Equivalente a `x = x - 2`.
3. Equivalente a `x = x * 3`.
4. Equivalente a `x = x / 4`.
5. Equivalente a `x = x % 2`.

### Controllo di flusso

Le istruzioni di controllo del flusso di esecuzione, sono utilizzate nei cicli.

- `break`: Interrompe il ciclo corrente. Esempio:

  ```python
  for i in [1, 2, 3, 4, 5, 6, 7, 8]: # <1>

    if i == 5:
      break # <2>
      
    print(i)

  print('Ciclo terminato')
  ```
  1. Ciclo a priori con 8 iterazioni, dove `i` assume a priori i valori `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`.
  2. Quando `i` diventi pari a `5`, il ciclo si interrompe e si esce dal blocco dell'istruzione composta `for` e l'interprete esegue `print('Ciclo terminato')`.

- `continue`: Salta l'iterazione corrente del ciclo e passa alla successiva. Esempio:

  ```python
  for i in [1, 2, 3, 4, 5, 6, 7, 8]:
    if i % 2 == 0:
      continue # <1>

    print(i)
  ```
  1. Alla seconda iterazione `i` assume valore `2` e il resto della divisione per `2` è `0`, cioè `i % 2 == 0` è vera. Pertanto, viene eseguita l'istruzione `continue`, che fa saltare l'interprete alla riga `if i % 2 == 0:` e non alla seguente `print(i)`.

- `pass`: L'istruzione `pass` non fa nulla e viene utilizzata come segnaposto. È utile in situazioni in cui la sintassi richiede un'istruzione, ma non si vuole eseguire alcuna azione. Può essere utilizzata, ad esempio, in blocchi di codice non ancora implementati o in definizioni di classi e funzioni vuote. Esempi di utilizzo:

- In un blocco condizionale:

  ```python
  if True: # <1>
    pass  # <2>
  ```
  1. Istruzione composta che richiede obbligatoriamente l'implementazione del blocco di codice che segue il delimitatore `:`.
  2. Segnaposto per future implementazioni.

- In una funzione non ancora implementata:

  ```python
  def funzione_non_implementata(): # <1>
    pass  # TODO
  ```
  1. Il blocco di codice di una funzione non può essere vuoto.

- In una classe vuota:

  ```python
  class ClasseVuota: # <1>
    pass
  ```
  1. Il blocco di codice della classe deve contenere almeno un'istruzione, come un membro o `pass`.

### Lancio di eccezioni

L'istruzione `raise` viene utilizzata per sollevare un'**eccezione**. È utile quando si desidera segnalare che si è verificato un errore e interrompere il flusso normale del programma.

Un'eccezione è un evento che si verifica durante l'esecuzione di un programma e interrompe il normale flusso di istruzioni. Le eccezioni sono utilizzate per gestire errori e situazioni inattese in modo strutturato e controllato. Quando si verifica un'eccezione, l'interprete Python interrompe l'esecuzione del programma e cerca un gestore di eccezioni, che vedremo nelle istruzioni composte, che possa trattare l'errore.

La sintassi dell'istruzione è `raise [eccezione[, valore[, traceback]]]`, ove `eccezione` è il tipo di oggetto che contiene le informazioni dell'anomalia, `valore` è un valore opzionale associato all'anomalia, generalmente una stringa di messaggio caratterizzante l'errore ed, infine, opzionalmente, un oggetto `traceback` che rappresenta lo stato dello _stack_ al momento idella generazione dell'eccezione.

Esempi:

- Sollevare un'eccezione predefinita:

  ```python
  raise ValueError("Valore non valido") # <1>
  ```
  1.L'istruzione solleva un'eccezione `ValueError` con il messaggio "Valore non valido".

- Sollevare un'eccezione definita dall'utente:

  ```python
  class MioErrore(Exception): # <1>
      pass

  raise MioErrore("Questo è un errore personalizzato") # <2>
  ```
  1. Viene definita una nuova eccezione `MioErrore` che estende la classe `Exception`.
  2. L'istruzione genera un'istanza di `MioErrore` con un messaggio personalizzato.

- Risollevare un'eccezione catturata (esempio completo di istruzione composta di gestione eccezioni):

  ```python
  try:
    x = 1 / 0 # <1>

  except ZeroDivisionError as e: # <2>
    print("Eccezione catturata: ", e)

    raise  # <3>
  ```
  1. L'interprete eseguendo `ZeroDivisionError`, genera un salto di esecuzione e istanzia un oggetto di tipo `ZeroDivisionError` per documentare l'accaduto.
  2. Segue blocco di codice che gestisce le eccezioni di tipo `ZeroDivisionError`.
  3. `raise` rlancia l'eccezione catturata.

- Specificare un traceback (riportato per completezza):

  ```python
  import traceback

  try:
    raise ValueError("Errore iniziale") # <1>

  except ValueError as e:
    tb = e.__traceback__

    raise RuntimeError("Errore successivo").with_traceback(tb) # <2>
  ```
  1. Viene sollevata una eccezione di tipo `RuntimeError`.
  2. Viene sollevata una seconda eccezione ma con lo stato dello stack della eccezione precedente, in pratica nascondendo la cattura effettuata e cambiando il tipo di eccezione.

Le eccezioni permettono di gestire gli errori in modo strutturato, separando il codice normale dalle operazioni di gestione degli errori. Quando si verifica un errore, invece di terminare il programma, è possibile intercettare l'eccezione e gestirla adeguatamente, fornendo messaggi di errore più chiari e permettendo al programma di continuare l'esecuzione se possibile.

### Controllo condizioni anomale

L'istruzione `assert condizione, messaggio` viene utilizzata per eseguire controlli durante l'esecuzione del programma. Se la `condizione` è falsa, viene sollevata un'eccezione `AssertionError` che include il `messaggio`. Può essere usata per il debugging e per verificare condizioni che dovrebbero essere sempre vere in un punto specifico del codice.

Esempi di utilizzo:

```python
x = 5

assert x > 0, "x deve essere maggiore di zero"  # <1>
assert x < 0, "x deve essere minore di zero"  # <2>
```
1. Non genera errore perché `x > 0` è vero.
2. Genera `AssertionError` con il messaggio `"x deve essere minore di zero"` perché `x < 0` è falso.

È importante notare che le asserzioni possono essere disabilitate a livello di runtime utilizzando l'opzione `-O` (ottimizzazione) quando si esegue lo script Python. Questo rimuoverà tutte le istruzioni `assert` dal bytecode generato.

```bash
python -O script.py
```

### Eliminazione di identificatori e elementi in contenitori

L'istruzione `del` viene utilizzata per eliminare identificatori come variabili o di funzione e oggetti da contenitori, come elementi singoli o in sezioni (slice) di liste oppure chiavi di dizionari. `del` rimuovendo i riferimenti agli oggetti, segnala al garbage collector la possibilità di liberazione delle risorse associate.

Esempi di utilizzo:

- Eliminazione di una variabile:

  ```python
  x = 10

  del x  # <1>

  print(x) # <2>
  ```
  1. Elimina la variabile `x`.
  2. Dà errore perché `x` non esiste. 

- Eliminazione di un elemento da un contenitore di oggetti di tipo lista per indice:

  ```python
  lista = [1, 2, 3, 4]

  del lista[0]  # <1>

  print(lista)  # <2>
  ```
  1. Elimina il primo elemento dalla lista.
  2. Output: `[2, 3, 4]`.

- Eliminare di elementi contigui da una lista:

  ```python
  lista = [1, 2, 3, 4, 5, 6]

  del lista[1:4]  # <1>

  print(lista)  # <2>
  ```
  1. Elimina gli elementi dal secondo al quarto.
  2. Output: `[1, 5, 6]`.

- Eliminazione di una chiave da un dizionario:

  ```python
  dizionario = {'a': 1, 'b': 2, 'c': 3}

  del dizionario['a']  # <1>

  print(dizionario)  # <2> 
  ```
  1. Elimina la chiave `'a'` dal dizionario.
  2. Output: `{'b': 2, 'c': 3}`. 

- Eliminazione di un attributo da un oggetto:

  ```python
  class ClasseSemplice:
    def __init__(self):
      self.attr = 42

  oggetto_semplice = ClasseSemplice()

  del oggetto_semplice.attr  # <1>
  ```
  1. Elimina l'attributo `'attr'` dall'oggetto `'oggetto_semplice'`.

- Eliminazione dell'identificatore di una funzione:

  ```python
  def somma_semplice(a, b):
      return a + b

  del somma_semplice  # <1>

  somma_semplice(a, b) # <2>
  ```
  1. Elimina il riferimento `somma_semplice` alla funzione.
  2. Errore. Output: `NameError: name 'somma_semplice' is not defined`.

- Eliminazione dell'identificatore di un modulo:

  ```python
  import math

  print(math.sqrt(4))  # <1>

  del math

  print(math)  # <2>
  ```
  1. Output: `2.0`.
  2. Errore. Output: `NameError: name 'math' is not defined. Did you forget to import 'math'?`.

### Importazione di moduli

L'istruzione `import` viene utilizzata per importare moduli in un programma Python, permettendo l'accesso alle funzioni, classi e variabili definite al loro interno. 

Tutti gli identificatori definiti nel modulo `nome_modulo` si importano colla sintassi `import nome_modulo` e dal quel punto fino alla fine del modulo importatore, sono accessibili colla notazione data dal nome del modulo seguito dal punto e l'identificatore di interesse, cioè `nome_modulo.nome_variabile` dove `nome_variabile` è l'identificatore importato. 

Una sintassi alternativa è `from nome_modulo import *`, per cui gli identificatori sono utilizzabili senza preporre `nome_modulo.`.

Infine, si possono importare identificatori particolari usando `from nome_modulo import` seguito dall'elenco degli identificatori necessari, separati da virgole.

Esempi:

- Importazione di tutti gli identificatori di un modulo:

  ```python
  import math # <1>

  print(math.sqrt(4))  # <2>
  ```
  1. Si importa il modulo `math`.
  2. Output: `2.0`.

- Importazione di identificatori particolari:

  ```python
  from math import sqrt, pi

  print(sqrt(4))  # <1>

  print(pi)       # <2>
  ```
  1. Output: `2.0`.
  2. Output: `3.141592653589793`.

- Importazione di un modulo con un alias:

  ```python
  import numpy as np # <1>

  array = np.array([1, 2, 3])

  print(array)  # <2>
  ```
  1. `numpy` è una librarie non facente parte dello standard Python, importata solitamente con un identificatore abbreviato in `np`.
  2. Output: `[1 2 3]`.

- Importazione di tutti gli identificatori di un modulo con accesso semplificato:

  ```python
  from math import *

  print(sqrt(4))  # <1>

  print(pi)       # <2>
  ```
  1. Output: `2.0`.
  2. Output: `3.141592653589793`.

È importante notare che l'istruzione `import` carica e inizializza il modulo solo una volta per sessione del programma. Se il modulo è già stato importato in precedenza, Python utilizza la versione già caricata, riducendo così il tempo di esecuzione e il consumo di memoria.

Quando si importa un modulo, Python cerca il modulo nelle directory specificate nella variabile `sys.path`. Questa variabile include la directory corrente, le directory specificate nella variabile d'ambiente `PYTHONPATH`, e le directory di installazione predefinite.

Esempio:

```python
import sys

print(sys.path)  # <1>
```
1. Elenco delle directory del computer dove Python cerca i moduli.

### Istruzioni di ritorno

L'istruzione `return` viene utilizzata per uscire da una funzione e opzionalmente restituire un valore al chiamante. Quando l'interprete Python incontra un'istruzione `return`, interrompe l'esecuzione della funzione e restituisce il valore specificato. Se non viene specificato alcun valore, la funzione restituisce `None`.

Esempi di utilizzo di `return`:

- Restituizione di un valore:

  ```python
  def somma(a, b):
    return a + b

  risultato = somma(3, 4)

  print(risultato)  # <1>
  ```
  1. Output: `7`.

- Assenza di valore restituito:

  ```python
  def senza_valore():
    return

  risultato = senza_valore()
  print(risultato)  # <1>
  ```
  1. Output: `None`.

L'istruzione `yield` viene utilizzata nelle funzioni per restituire un generatore, un tipo speciale di iteratore che produce una sequenza di valori nel tempo. Quando una funzione contiene un'istruzione `yield`, diventa automaticamente un generatore. Invece di restituire un singolo valore e terminare, il generatore può sospendere la sua esecuzione e riprenderla successivamente, mantenendo il suo stato tra le invocazioni.

Esempi di utilizzo di `yield`:

- Generatore semplice:

  ```python
  def contatore():
    yield 1
    yield 2
    yield 3

  for numero in contatore():
    print(numero) # <1>
  ```
  1. Output successivi: `1`, `2`, `3`.

- **Generatore con ciclo:**

  ```python
  def sequenza(n):
    for i in range(n):
      yield i

  for numero in sequenza(5):
    print(numero)
  ```
  1. Output successivi: `0`, `1`, `2`, `3`, `4`.

### Modificatori di ambito

Le istruzioni `global` e `nonlocal` sono utilizzate per modificare la visibilità delle variabili all'interno delle funzioni.

L'istruzione `global` viene utilizzata per dichiarare che una variabile all'interno di una funzione fa riferimento a una variabile globale, cioè una variabile definita al di fuori di qualsiasi funzione. Senza `global`, tutte le assegnazioni di variabili all'interno di una funzione sono considerate locali alla funzione stessa.

Esempio di utilizzo di `global`:

```python
x = 10 # <1>

def modifica_global():
  global x # <2>

  x = 20

modifica_global()

print(x)  # <3>
```
1. `x` è una variabile globale.
2. L'istruzione `global` dichiara che `x` fa riferimento alla variabile globale `x`, permettendo alla funzione di modificarla.
3. Output: `20`.

L'istruzione `nonlocal` viene utilizzata per dichiarare che una variabile all'interno di una funzione fa riferimento a una variabile non locale, cioè una variabile definita in un contesto esterno ma non globale (ad esempio, all'interno di una funzione contenente). Senza `nonlocal`, tutte le assegnazioni di variabili all'interno di una funzione sono considerate locali alla funzione stessa.

Esempio di utilizzo di `nonlocal`:

  ```python
  def esterna():
    x = 10 # <1>

    def interna():
      nonlocal x # <2>
      
      x = 20

    interna()

    print(x)

  esterna()  # <3>
  ```
  1. `x` è una variabile locale alla funzione `esterna`. 
  2. L'istruzione `nonlocal` dichiara che `x` fa riferimento alla variabile non locale `x`, permettendo alla funzione `interna` di modificarla.
  3. Output: `20`.

### Alias di tipo

L'istruzione `type` viene utilizzata per creare alias di tipo. Questo consente di assegnare nomi significativi ai tipi di dati complessi, migliorando la leggibilità del codice. Si possono definire anche alias di tipi generici, cioè tipi parametrizzati da altri tipi. 

È importante sottolineare che gli alias non sono da intendere come utili al controllo statico dei tipi durante l'esecuzione, ma come annotazione utile per strumenti di analisi del codice e miglioramento della leggibilità. 

Esempi:

- Definizione di alias di tipo:

  ```python
  type lista_coppie = list[tuple[str, int]] # <1>
  ```
  1. `lista_coppie` è un alias di `list[tuple[str, int]]`.

- Definizione di alias di tipo generico:

  ```python
  type contenitore_ordinato[T] = list[t] | tuple[T, ...] # <1>
  ```
  1. `contenitore_ordinato` può essere o una lista o una tupla con zero o più elementi.

### Istruzioni composte

Una istruzione composta è costituita da altre istruzioni (semplici o composte). Il controllo dell'esecuzione delle istruzioni componenti avviene per mezzo di una o più clausole che iniziano tutte con una parola chiave, sono terminate da `:` e seguite da un blocco di codice. Ogni blocco deve avere almeno una istruzione semplice, ma può non avere una propria riga logica, cioè stare sulla stessa riga fisica e logica del `:`.

Alcuni esempi del rapporto tra istruzioni e righe:

- Blocco di istruzioni separato su più righe con medesima indentazione:

  ``` python
  if x > 0: 
    print("x è positivo") # <1> 

    x += 1

    print(f"x ora è {x}") # <2>
  ```
  1. Prima riga fisica del blocco di codice del ramo eseguito quanto la condizione `x > 0` assume valore `True`.
  2. Ultima riga fisica del medesimo blocco.

- Blocco come singola istruzione sulla stessa riga logica:

  ``` python
  if x > 0: print("x è positivo")
  ```

- Diverse istruzioni semplici sulla stessa riga logica (non consigliato):

  ``` python
  if x > 0: print("x è positivo"); x += 1; print(f"x ora è {x}")
  ```

Ed ecco le principali istruzioni composte:

- `if`, controlla l'esecuzione di un blocco di codice in base a una espressione condizionale (tra parentesi angolari è presente dello pseudocodice, quindi non eseguire!):

  ``` python
  if <espressione condizionale>:
    # blocco di codice
  ```

- `for`, itera sugli elementi (oggetti) presenti in un oggetto di tipo sequenza (come una lista, una tupla o una stringa):

  ``` python
  for <elemento> in <sequenza>:
    # blocco di codice
  ```

- `while`, esegue un blocco di codice finché una espressione condizionale è vera:

  ``` python
  while <espressione condizionale>:
    # blocco di codice
  ```

- `try`, gestisce gli errori che possono verificarsi durante l'esecuzione di un blocco di codice:

  ``` python
  try:
    # blocco di codice
  except <eccezione>:
    # blocco di codice per gestire l'eccezione
  ```

- `with`, gestisce le risorse come file, connessioni di rete, ecc., assicurandosi che siano aperte e chiuse correttamente, anche se si verifica un errore:

  ``` python
  with open('file.txt', 'r') as file:
    # blocco di codice
  ```

- `def`, definisce una funzione fatta da una testata (nome funzione ed elenco parametri) e il blocco di istruzioni tra cui, opzionalmente, la restituzione di output:

  ``` python
  def nome_funzione(<parametro, parametro, ...>):
    # blocco di codice
  ```

- `class`, definisce una classe:

  ``` python
  class NomeClasse:
    # blocco di codice
  ```

- `match`, confronta un valore con diversi modelli (_pattern_) per trovare una corrispondenza ed esegue un blocco di istruzioni:

  ``` python
  match valore:
    case <pattern>:
      # blocco di codice
  ```