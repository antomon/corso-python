---
reference-location: margin
citation-location: margin
tbl-cap-location: margin
---

# Il modello dati

Per comprendere il **modello dati** di Python, dobbiamo conoscere i tipi di dati del linguaggio e le relative operazioni, con ciò intendendo che dobbiamo sia elencare quelli predefiniti, che apprendere le modalità di definizione di nuovi tipi. 

## Oggetti

Gli oggetti sono l'astrazione dei dati definita in Python. Ogni oggetto è caratterizzato da un'**identità**, un **tipo** e un **valore**. L'identità di un oggetto non cambia una volta creato e possiamo pensarlo come l'indirizzo dell'oggetto in memoria[^1]. Python permette di ricavarlo per mezzo della funzione predefinita (_built in_) `id()`:

```python
s = "Hello"

print(id(s)) # <1>
```
1. Output: un numero come `4467381744`.

Il tipo di un oggetto determina le operazioni che l'oggetto supporta per la manipolazione del proprio stato o di quello di altri oggetti, e definisce anche i possibili valori per gli oggetti di quel tipo (_dominio_ dei valori, per prendere in prestito un termine dalla matematica). Il linguaggio fornisce una funzione per conoscere il tipo dell'oggetto:

```python
s = "Hello"

print(type(s)) # <1>
```
1. Output: `<class 'str'>`.

[^1]: In CPython è effettivamente implementato così.

## Tipi e classi

In Python, i tipi di dati sono implementati come **classi**. Una classe è la definizione di un tipo di oggetto che specifica gli attributi (complessivamente il valore dell'oggetto) e i metodi (le operazioni) che determinano lo stato e il comportamento degli oggetti. Gli oggetti creati da una classe possono essere manipolati attraverso i metodi della classe, permettendo di interagire e modificarne il valore o quello di altri oggetti passati come argomenti. Inoltre, una classe può definire **metodi di istanza**, che operano su istanze specifiche della classe, **metodi di classe**, che operano a livello della classe stessa e possono accedere e modificare lo stato della classe tramite attributi di classe, e **metodi statici**, che sono funzioni associate alla classe ma non dipendono né dalla classe né dalle sue istanze.

Ad esempio, per una stringa:

```python
s = "Hello" # <1>

print(type(s))  # <2>
```
1. L'oggetto stringa il cui valore è `"Hello"` ha come nome `s`.
2. Output: `<class 'str'>`. `type` conferma che l'oggetto è una istanza di `str` che è il tipo delle stringhe in Python.

### Gerarchie di classi

Le classi possono essere organizzate in una gerarchia. In cima alla gerarchia delle classi di Python c'è la classe `object`, un po' infelice come nome, da cui derivano tutte le altre classi. Questo significa che ogni classe in Python eredita gli attributi e i metodi della classe `object`. La funzione `isinstance` è utile per investigare questa gerarchia, poiché permette di verificare se un oggetto è un'istanza di una determinata classe o di una sua classe derivata. `isinstance`, pertanto, ha due parametri, l'identificatore dell'oggetto e l'identificatore della classe e resistuisce un valore logico, `True` o `False`.

Ad esempio:

```python
s = "Hello" 

print(isinstance(s, str))  # <1>

print(isinstance(s, object))  # <2>
```
1. Output: `True`. `isinstance` conferma che `s` è un'istanza della classe `str`.
2. Output: `True`. `isinstance` conferma che `s` è un'istanza anche della classe `object`, da cui deriva `str`.

La funzione `issubclass` è altrettanto utile per esplorare le gerarchie delle classi, in quanto permette di verificare se una classe è una sottoclasse di un'altra.

Ad esempio:

```python
print(issubclass(str, object))  # <1>
```
1. Output: `True`. `issubclass` conferma che `str` è una sottoclasse di `object`.

### Creazione dell'oggetto

Una volta definita una classe, si possono creare nuove istanze o oggetti di quella classe, il che rappresenta un modo efficiente per riutilizzare funzionalità nel proprio codice. Questo passaggio è spesso chiamato costruzione o **istanziazione** degli oggetti. Lo strumento responsabile per la specializzazione di questo processo, è comunemente noto come **costruttore** della classe.

In Python, il costruttore è il metodo speciale `__init__` e può avere un numero arbitrario di parametri. Questo metodo viene eseguito automaticamente dall'interprete quando un nuovo oggetto della classe viene creato ed è il luogo possiamo scrivere delle istruzioni utili all'inizializzazione dell'oggetto, anche usando gli argomenti passati. La sintassi per l'istanziazione è data dall'identificatore della classe, seguita da una coppia di parentesi tonde, con all'interno l'elenco degli argomenti.

Esempio:

```python
s = str(4) # <1>
```
1. L'identificatore della classe delle stringhe `str` è seguito da un unico argomento, `4` , dato da un letterale intero, passato al costruttore per l'inizializzazione.

Il metodo `__init__` è sempre presente: se non è definito esplicitamente nella classe, viene ereditato dalla classe base `object`.

La creazione di un oggetto avviene in diversi contesti:

1. Uso di letterali. Ad esempio, per creare un oggetto stringa, si usano i letterali stringa e analogamente per gli altri:

  ```python
  s = "Hello" # <1>

  n = 42 # <2>

  f = 3.14 # <3>
  ```
  1. Creazione di un oggetto di tipo `str`.
  2. Creazione di un oggetto di tipo `int`.
  3. Creazione di un oggetto di tipo `float`.

2. Chiamata del costruttore della classe, ad esempio a quello della classe `list` passiamo una sequenza di interi:

  ```python
  lista = list([1, 2, 3])
  ```

3. Utilizzo di funzioni e metodi che restituiscono oggetti. Ad esempio, il metodo `upper` della classe `str` restituisce un nuovo oggetto ottenuto a partire da quello su cui è eseguito:
  
  ```python
  s1 = "Hello, World!"

  su_1 = s1.upper() # <1>

  s = "Hello, World!".upper() # <2>
  ```

4. Clonazione o copia utilizzando la funzione `copy` del modulo `copy`:

  ```python
  import copy

  lista_originale = [1, 2, 3]

  lista_copiata = copy.copy(lista_originale)
  ```

### Accesso a attributi e metodi

In Python, si utilizza la notazione con il punto `.` per accedere agli attributi e ai metodi di un oggetto o di una classe, semplicemente accodando all'identificatore della variabile (che rappresenta un'istanza della classe) o a quello della classe, il punto e l'identificatore del membro (attributo o metodo).  

Le stringhe in Python sono oggetti della classe `str` e hanno sia attributi che metodi. Ad esempio, il metodo `upper()` converte una stringa in maiuscolo: 

```python
s = "hello world"  # <1>

s_upper = s.upper()  # <2>

print(s_upper)  # <3>
```
1. Creazione di un oggetto stringa.
2. Chiamata del metodo `upper()` usando l'identificatore `s`.
3. Output: `HELLO WORLD`. 

### Mutabilità e immutabilità

Gli oggetti il cui valore può cambiare sono detti **mutabili**, mentre gli oggetti il cui valore non lo può una volta creati, sono chiamati **immutabili**. L'immutabilità di un oggetto è determinata dalla progettazione del suo tipo, ad esempio, per i tipi definiti nel linguaggio, numeri interi e in virgola mobile, stringhe e tuple sono immutabili, mentre dizionari e liste sono mutabili.

Gli oggetti non vengono mai distrutti esplicitamente dall'utente, ma, quando diventano inaccessibili, possono essere raccolti dal garbage collector, che è eseguito contemporaneamente al codice del programma, come parte dell'interprete. L'implementazione specifica quando e come gli oggetti debbano essere distrutti.

Alcuni oggetti contengono riferimenti a risorse _esterne_ rispetto al programma, come file aperti, connessioni di rete, finestre (_graphical user interface_, GUI) o dispositivi hardware. Queste risorse generalmente non vengono liberate dal garbage collector, perché le azioni corrispondenti sono particolari della risorsa stessa, pertanto, i loro oggetti forniscono anche un metodo esplicito di rilascio, solitamente chiamato `close()`. È molto importante tener conto di ciò per evitare effetti indesiderati. 

Alcuni oggetti, chiamati **contenitori**, contengono riferimenti ad altri oggetti. Esempi di contenitori sono _tuple_, _liste_ e _dizionari_, strutture dati di base, definite in molti linguaggi di programmazione. I riferimenti ad altri oggetti fanno parte del valore di un contenitore e, nella maggior parte dei casi, quando parliamo del valore di un contenitore, intendiamo proprio i valori degli oggetti contenuti, non le loro identità. Ad esempio:

```python
t = (1, 2, 3) # <1>

l = ["Qui", "Quo", "Qua"] # <2>
```
1. Tupla con tre oggetti al suo interno: `1`, `2`, `3`. Diciamo che la tupla contiene i tre valori interi. 
2. Lista com tre oggetti all'interno: `"Qui"`, `"Quo"`, `"Qua"`. Diciamo che la lista contiene le tre stringhe. 

La mutabilità di un contenitore si riferisce alla identità degli oggetti referenziati e non al loro valore, quindi, ad esempio, se una tupla contiene un riferimento ad un oggetto mutabile, il valore della tupla cambia se quell'oggetto mutabile viene modificato:

```python
s = ([1, 2, 3], ["Qui", "Quo", "Qua"])

print(s) # <1>

print(id(s[0])) # <2>
print(id(s[1])) # <3>

s[1][0] = "Huey" # <4>
s[1][1] = "Dewey" 
s[1][2] = "Louie"

print(s) # <5>

print(id(s[0])) # <6>
print(id(s[1])) # <7>
```
1. Output: `([1, 2, 3], ['Qui', 'Quo', 'Qua'])`.
2. Modifico gli elementi della lista, traducendoli in inglese.
3. Output dell'identità del primo oggetto contenuto (su ogni computer e sessione sarà diverso): `4361472384`.
4. Output dell'identità del secondo oggetto contenuto: `4361474176`.
5. Output: `([1, 2, 3], ['Huey', 'Dewey', 'Louie'])`. La tupla è cambiata!
6. Output: `4361472384`, l'identità del primo oggetto contenuto non è cambiata!
7. Output: `4361474176`, l'identità del secondo oggetto contenuto non è cambiata!

Ciò è un po' più generale, perché per gli oggetti di tipo immutabile, quando sono assegnati ad una variaible o risultato di un'espressione, a parità di valore, potrebbero avere la stessa identità, cioè essere lo stesso oggetto. Il condizionale è dovuto alla presenza e applicazione logiche di ottimizzazione, ad esempio della memoria, implementate nell'interprete.

Ad esempio, dopo:

```python
s1 = "Qui, Quo, Qua"

print(id(s1)) # <1>

s2 = "Qui, Quo, Qua"

print(id(s2)) # <2>
```
1. Output dell'identità di `s1`: `4432491760`.
2. Output dell'identità di `s2`: `4432491760`, cioè è la medesima identità dell'oggetto il cui nome è `s1`.

Per gli oggetti mutabili, questo non accade anche in casi su cui potrebbe essere ottimizzante:

```python
l1 = []

print(id(l1)) # <1>

l2 = []

print(id(l2)) # <2>
```
1. Output dell'identità di `l1`: `4454287744`.
2. Output dell'identità di `l2`: `4454289536`, cioè le identità sono diverse.

Attenzione però ad alcune _scorciatoie_ di Python:

```python
c = d = []
```

è equivalente a:

```python
c = []
d = c
```

cioè l'oggetto lista ha due nomi nel programma. 

## Tipi predefiniti

Python mette a disposizione molti tipi _generali_, cioè utili alla gestione di dati comunemente presenti in algoritmi. Esistono, inoltre, sia meccanismi di estensione della distribuzione Python che modificano l'installazione sul proprio computer, sia la possibilità conferita al programmatore di creare i propri tipi o di importarli da librerie prodotte da terze parti.

I tipi predefiniti sono immediatamente disponibili, cioè non necessitano di alcuna azione da parte del programmatore, come, ad esempio, l'importazione di moduli. 

Per ragioni di esposizione, distingueremo tra tipi predefiniti fondamentali, cioè che possono essere introdotti con un insieme limitato di concetti, tipi legati alla astrazione del paradigma di orientamento agli oggetti e, infine, costruzioni del linguaggio legate all'esecuzione asincrona.

### Tipi predefiniti fondamentali

Prima di entrare nel dettaglio per ognuno, di seguito un elenco dei tipi predefiniti fondamentali:

- Numeri: sia interi relativi che reali, cioè in virgola mobile, sia complessi.

- Sequenze, cioè contenitori caratterizzati da un ordinamento degli oggetti al loro interno, sia mutabili che immutabili. 

- Insiemi, cioè contenitori non caratterizzati da un ordinamento degli oggetti.

- Dizionari, cioè contenitori di coppie di oggetti chiave e valore.

- Altri: `None`, `NotImplemented`, `Ellipsis`.

### Numeri

I tipi predefiniti numerici corrispondono agli interi, i numeri a virgola mobile e quelli complessi. Sono immutabili, il che significa che effettuando una operazione su un oggetto numerico si produrrà sempre un nuovo oggetto e non una modifica del precedente.

Esistono anche altri tipi numerici nelle librerie fornite coll'interprete, per i numeri decimali a precisione arbitraria e i numeri razionali come frazioni.  

I letterali numerici non hanno segno, cioè `+` e `-` sono operatori unari che precedono la rappresentazione di un numero, quindi `-3` è una espressione che diventa il valore di un oggetto intero di valore `-3`. Nei letterali numerici si può inserire un trattino basso (_underscore_) tra le cifre o dopo gli specificatori della base per gli interi.

#### Interi

Esistono due tipi di interi. Il primo è `int`, per gli usuali numeri interi, a cui corrispondono diverse rappresentazioni sintattiche in basi diverse, come i letterali decimali, binari, ottali o esadecimali:

- Un letterale decimale inizia sempre con una cifra diversa da zero, esempi: `10`, `1_0`.
  
- Quello binario inizia con `0b` o `0B` seguito da una sequenza di cifre binarie (0 o 1), esempi: `0b1010`, `0B1010`, `0b_10_10`, `0b1_0_10`. 

- L'ottale inizia con `0o` o `0O` seguito da una sequenza di cifre ottali (da 0 a 7), esempi: `0o12`, `0O12`. 

- L'esadecimale inizia con `0x` o `0X` seguito da una sequenza di cifre esadecimali (da 0 a 9 e da A a F, in maiuscolo o minuscolo), esempi: `0xA`, `0XA`.

Gli interi in Python sono illimitati, al netto della finitezza della memoria del computer disponibile per la loro rappresentazione.

```python
large_int = 10**100

print(f"Un intero molto grande: {large_int}") # <1>
```
1. Output: `10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`.

L'altro tipo è `bool`, che ha solo due oggetti possibili, che si comportano come quelli corrispondenti agli interi `1` e `0` per rappresentare i valori logici, rispettivamente, di vero e falso. `bool` come classe deriva da `int` che, a sua volta, deriva da `object`:

```python
print(issubclass(bool, int)) # <1>
print(issubclass(int, object)) # <2>
```
1. Output: `True`.
2. Output: `True`.

#### Numeri in virgola mobile 

I numeri in virgola mobile in Python sono istanze della classe `float` e sono utilizzati per rappresentare numeri reali con una parte decimale. I letterali corrispondenti sono una sequenza di cifre in base 10, e solo in base 10, che include un punto (`.`), un suffisso di notazione scientifica (`e` o `E`, opzionalmente seguito da `+` o `-` e da una o più cifre), o entrambi. Il carattere iniziale di un letterale in virgola mobile non può essere `e` o `E`, ma può essere qualsiasi cifra (anche zeri a differenza degli interi) o un punto (`.`) seguito da una cifra.

Esempi di literali in virgola mobile: `0.`, `0.1`, `.0`, `1.`, `1.0`, `1e0`, `1.e0`, `1.0E0`, `1_0_0.0_1`. Attenzione: `1` è un intero, `1.` non lo è.

Per conoscere l'intervallo esatto e la precisione dei valori in virgola mobile sulla piattaforma in uso, e molti altri dettagli, è possibile usare `sys.float_info` nel modo seguente:

```python
import sys

float_info = sys.float_info  # <1>

print(f"Massimo valore rappresentabile (max): {float_info.max}")  # <2>
print(f"Minimo valore rappresentabile positivo (min): {float_info.min}")  # <3>
print(f"Massimo esponente base 2 (max_exp): {float_info.max_exp}")  # <4>
print(f"Minimo esponente base 2 (min_exp): {float_info.min_exp}")  # <5>
print(f"Massimo esponente base 10 (max_10_exp): {float_info.max_10_exp}")  # <6>
print(f"Minimo esponente base 10 (min_10_exp): {float_info.min_10_exp}")  # <7>
print(f"Precisione in bit (dig): {float_info.dig}")  # <8>
print(f"Numero di bit di mantissa (mant_dig): {float_info.mant_dig}")  # <9>
print(f"Epsilon macchina (epsilon): {float_info.epsilon}")  # <10>
```
1. Oggetto con all'interno le informazioni relative alla gestione dei numeri in virgola mobile della macchina.
2. Output: `Massimo valore rappresentabile (max): 1.7976931348623157e+308`. Il massimo valore rappresentabile per un numero in virgola mobile.
3. Output: `Minimo valore rappresentabile positivo (min): 2.2250738585072014e-308`. Il minimo valore positivo rappresentabile per un numero in virgola mobile.
4. Output: `Massimo esponente base 2 (max_exp): 1024`. Il massimo esponente base 2.
5. Output: `Minimo esponente base 2 (min_exp): -1021`. Il minimo esponente base 2.
6. Output: `Massimo esponente base 10 (max_10_exp): 308`. Il massimo esponente base 10.
7. Output: `Minimo esponente base 10 (min_10_exp): -307`. Il minimo esponente base 10.
8. Output: `Precisione in bit (dig): 15`. La precisione in bit, cioè il numero di cifre decimali che possono essere rappresentate senza perdita di precisione.
9. Output: `Numero di bit di mantissa (mant_dig): 53`. Il numero di bit nella mantissa.
10. Output: `Epsilon macchina (epsilon): 2.220446049250313e-16`. La differenza tra 1 e il numero più piccolo maggiore di 1 che può essere rappresentato.

#### Numeri complessi

Un numero complesso è composto da due valori in virgola mobile, uno per la parte reale e uno per la parte immaginaria. In Python, i numeri complessi sono istanze della classe `complex`, che presenta due attributi di sola lettura `real` e `imag`, rispettivamente per la parte reale e immaginaria, di tipo `float`. 

Un letterale immaginario può essere specificato come qualsiasi letterale decimale in virgola mobile o intero seguito da una `j` o `J`: `0j`, `0.j`, `0.0j`, `.0j`, `1j`, `1.j`, `1.0j`, `1e0j`, `1.e0j`, `1.0e0j`. La `j` alla fine del letterale immaginario indica la radice quadrata di `-1`. Per denotare un qualsiasi numero complesso costante, si potrà sommare o sottrarre un letterale in virgola mobile (o letterale intero) e uno immaginario. 

```python
z = 42+3.14j # <1>

print(z) # <2>

print(z.real) # <3>
print(z.imag) # <4>

print(type(z.real)) # <5>
print(type(z.imag)) # <6>
print(type(z)) # <7>
```
1. Assegnamento di un numero complesso alla variabile `z`.
2. Output: `(42+3.14j)`.
3. Output: `42.0`.
4. Output: `3.14`.
5. Output: `<class 'float'>`.
6. Output: `<class 'float'>`.
7. Output: `<class 'complex'>`.

### Sequenze

Una sequenza è un contenitore ordinato di oggetti, il cui indice è un intero che parte da `0`. Se la sequenza è referenziata da una variabile `c`, per ottenere il numero totale di oggetti contenuti si userà la funzione predefinita `len()`, cioè `len(c)`, e per l'oggetto i-esimo le parentesi quadre e l'indice, `c[i]`. È possibile usare indici negativi che sono interpretati come la somma di quello col numero totale di oggetti contenuti, quindi `-i` è trattato come `len(c)-i` e l'indice risultante dovrà sempre essere compreso tra `0` e `len(c)-1`.

Si può _sezionare_ (_slicing_) la sequenza per ottenere una sottosequenza, dello stesso tipo, di oggetti originariamente contigui tra gli indici `i` e `j`, cioè con indici `x` tali che `i≤x<j`, usando `c[i:j]`. Aggiungendo un terzo parametro di _passo_, `k`, si possono selezionare solo gli oggetti con indici `i+l*k` e `l≥0`, che siano compresi tra i due indici, cioè `i≤i+l*k<j`, con `c[i:j:k]`.

Le sequenze sono categorizzate in base alla mutabilità:

- Immutabili: stringhe, tuple, bytes.

- Mutabili: liste e array di bytes.

#### Iterabilità

Le sequenze sono iterabili cioè possono essere scorse in tutte per mezzo di un oggetto ad hoc detto **iteratore**. Un iteratore è un oggetto separato dalla sequenza stessa, che mantiene uno stato interno per tenere traccia dell'elemento successivo da restituire. Questo permette di iterare sulla sequenza senza modificarla direttamente. 
L'iteratore prende in input un oggetto iterabile e ne restituisce i valori uno alla volta secondo un certo protocollo. Per le sequenze, questo protocollo consiste nel partire dal primo elemento e procedere fino all'ultimo.

#### Stringhe

Una stringa in Python è un oggetto che si può creare a partire da un letterale composto di un numero non negativo di caratteri Unicode racchiusi o tra apici singoli `'`, oppure doppi `"`. Per inserire un a capo nella stringa dovrà essere usato `\n`, mentre per spezzarla su due righe fisiche dovrà essere usato un singolo backslash alla fine della prima riga fisica per indicare la continuazione nella riga fisica successiva.

Esempi:

```python
s1 = "Hello " \
    "World!" # <1>

print(s1)  # <2>

s2 = "Hello \n" \
    "World!" # <3>

print(s2)  # <4>
```
1. Stringa su due righe fisiche ma senza a capo all'interno.
2. Output: `Hello World!`.
3. Stringa su due righe fisiche con un a capo all'interno.
4. Output: 
  `Hello `
  `World!`.

Alternativamente, si possono usare letterali con coppie di tripli apici singoli `'''` o doppi  `"""`, dove la differenza è che è possibile inserire un a capo nell'editor e sarà mantenuto nella stringa. Un singolo backslash non può essere presente.

```python
s1 = """Hello 
World!""" # <1>

print(s1) # <2>

s2 = """Hello \n
        World!""" # <3>

print(s2) # <4>
```
1. Stringa su due righe fisiche ma senza a capo all'interno.
2. Output: 
  `Hello `
  `World!`.
3. Stringa su due righe fisiche con un a capo all'interno.
4. Output: 
  `Hello `

  `      World!`.

Nei letterali stringa si possono inserire caratteri non stampabili o caratteri che non sono disponibili a tastiera, usando le cosiddette sequenze di escape, come da tabella seguente:

| Sequenza      | Significato                                             | Codice ASCII/ISO | Esempio di stringa Python  |
|---------------|---------------------------------------------------------|------------------|----------------------------|
| `\<newline>`    | Ignora fine linea                                       | -          | `"Questo è un testo\ con una linea continuata"` |
| `\\`            | Backslash                                               | `0x5c`             | `"C:\\percorso\\al\\file"` |
| `\'`            | Apice singolo                                           | `0x27`             | `"L'apice singolo: \' esempio"` |
| `\"`            | Apice doppio                                            | `0x22`             | `"L'apice doppio: \" esempio"` |
| `\a`            | Campanello                                              | `0x07`             | `"Suono del campanello\a"` |
| `\b`            | Backspace                                               | `0x08`             | `"Carattere di backspace\b"` |
| `\f`            | Form feed                                               | `0x0c`             | `"Form feed\f esempio"` |
| `\n`            | Nuova linea                                             | `0x0a`             | `"Nuova linea\n esempio"` |
| `\r`            | Ritorno carrello                                        | `0x0d`             | `"Ritorno carrello\r esempio"` |
| `\t`            | Tabulazione                                             | `0x09`             | `"Tabulazione\tesempio"` |
| `\v`            | Tabulazione verticale                                   | `0x0b`             | `"Tabulazione verticale\v esempio"` |
| `\DDD`          | Valore ottale DDD del codice Unicode del carattere (solo per caratteri ASCII) | `DDD` (in ottale)        | `"Valore ottale: \101 esempio"` (`\101` rappresenta `'A'` che in ASCII è `65`) |
| `\xXX`          | Valore esadecimale XX del codice Unicode del carattere  | `XX` (in esadecimale)       | `"Valore esadecimale: \x41 esempio"` (`\x41` rappresenta 'A') |
| `\uXXXX`        | Carattere Unicode con valore esadecimale a 4 cifre      | `XXXX` (in esadecimale)        | `"Carattere cinese: \u4e2d"` (`\u4e2d` rappresenta '中') |
| `\UXXXXXXXX`    | Carattere Unicode con valore esadecimale a 8 cifre      | `XXXXXXXX` (in esadecinale)        | `"Carattere: \U0001f600"` (`\U0001f600` rappresenta '😀') |
| `\N{name}`      | Carattere Unicode                                       | -       | `"Carattere Unicode: \N{LATIN CAPITAL LETTER A} esempio"` |
: Sequenze di escape {.hover}

Esistono anche i letterali di stringhe _grezze_ (_raw_), sintatticamente identiche alle altre a meno di un suffisso  `r` o  `R`, comportante che le sequenze di escape non siano interpretate. Si usano comunemente per esprimere pattern di espressioni regolari o percorsi di file in Windows. 

```python
stringa = "C:\\Users\\username\\Documents\\file.txt" # <1>

print(stringa) # <2>

stringa_raw = r"C:\Users\username\Documents\file.txt" # <3>

print(stringa_raw) # <4>
```
1. Perché un path sia corretto in Windows è necessario usare il backslash per escape del backslash come separatore di path. 
2. Output: `C:\Users\username\Documents\file.txt`.
3. Definendo la stringa come grezza allora il backslash è intepretato come tale, quindi separatore di path.
4. Output: `C:\Users\username\Documents\file.txt`.

Dopo aver identificato il letterale stringa, l'inteprete crea l'oggetto stringa in memoria con tipo `str`. Alternativamente, si può crearla in altri modi:

1. Sebbene non sia comune usare il costruttore per creare una stringa da un letterale stringa, è comunque possibile:

  ```python
  s = str("Hello, World!") # <1>

  print(s)  # <2>
  ```
  1. Passo 
  2. Output: `Hello, World!`.

2. Possiamo creare una stringa a partire da un numero (intero o in virgola mobile):
  
  ```python
  s = str(42)

  print(s)  # <1>

  s = str(3.14)

  print(s)  # <2>
  ```
  1. Output: `3.14`.
  2. Output: `42`.

3. Si può creare una stringa concatenando i caratteri di una lista:

  ```python
  cl = ['H', 'e', 'l', 'l', 'o']

  s = ''.join(cl)

  print(s)  # <1>
  ```
  1. Output: `Hello`.

4. Se un oggetto definisce il metodo speciale `__str__` che restituisce una stringa, il costruttore di `str` lo chiama per ottenerla: 

  ```python
  l = ["Hello", " ", "World!"]

  s = str(l)

  print(s)
  ```
  1. Output: `['Hello', ' ', 'World!']`.

5. Si può creare una nuova stringa da qualsiasi oggetto iterabile, come liste o tuple, utilizzando il metodo `join` che inserisce tra gli elementi della sequenza la stringa dell'oggetto di cui è membro:

  ```python
  lista = ['Python', 'è', 'fantastico']

  s = ' '.join(lista)

  print(s)  # <1>

  tupla = ('Hello', 'World!')

  s = ' '.join(tupla)

  print(s)  # <2>
  ```
  1. Output: `Python è fantastico`. Lo spazio tra le parole è stato inserito perché `join` è stato chiamato su un oggetto la cui stringa era data dal solo carattere di spazio.
  2. Output: `Hello World!`.

6. È possibile creare una stringa a partire da un oggetto di bytes specificando la codifica:

   ```python
   b = b'Hello, World!'

   s = str(b, 'utf-8')

   print(s)  # Output: Hello, World!
   ```
   1. Output: `Hello World!`.

#### Tuple

Le tuple in Python sono sequenze ordinate immutabili, in cui gli oggetti contenuti possono essere di tipi diversi. La classe è `tuple` che deriva da `object`.

Per creare una tupla, si può utilizzare una serie di espressioni separate da virgole (`,`), come elementi della tupla. Si può opzionalmente mettere una virgola ridondante dopo l'ultimo elemento, che è necessaria se si ha un solo elemento. Si possono raggruppare gli elementi della tupla tra parentesi, ma le parentesi sono necessarie solo quando le virgole avrebbero altrimenti un altro significato (ad esempio, nelle chiamate di funzione), o per denotare tuple vuote o annidate.

Esempi di tuple costruite con letterali e espressioni:

```python
t1 = 42., "Hello", 0x42 # <1>
t2 = (42,) # <2>
t3 = 21+21, # <3>
t4 = () # <4>
```
1. Tupla con tre oggetti contenuti da letterale numerico, letterale stringa e ancora letterale numerico.
2. Tupla con un solo oggetto da letterale numerico.
3. Tupla con un solo oggetto da espressione.
4. Tupla vuota.

Possiamo creare le tuple usando la classe `tuple` che accetta come argomento un iterabile:

```python
t1 = tuple() # <1>

t2 = tuple("Hello") # <2>

t3 = tuple([1, 2, 3]) # <2>
```
1. Crea una tupla vuota.
2. Crea una tupla con 5 stringhe, una per ogni carattere.
3. Crea una tupla con 3 interi.

Operazioni sulle tuple:

```python
t1 = 42., "Hello", 0x42
print(t1[1])  # <1>

print(len(t1))  # <2>

t2 = (42,)

t3 = t1 + t2
print(t3) # <3>

print(t3[1:3])  # <4>

print(42. in t3) # <5>
```
1. Output: `"Hello"`.
2. Output: `3`.
3. Output: `(42.0, 'Hello', 66, 42)`. Concatenazione di tuple che produce una nuova tupla con 4 oggetti contenuti.
4. Output: `('Hello', 66)`. Slicing di tupla che produce una nuova tupla con 2 oggetti.
5. Output: `True`. Test di appartenenza di `42.` nella tupla `(42.0, 'Hello', 66, 42)`.

#### Liste

Le liste in Python sono sequenze ordinate mutabili, in cui gli oggetti contenuti possono essere di tipi diversi. La classe è `list` che deriva da `object`.

Per creare una lista, si utilizza una serie di espressioni, separate da virgole (`,`) all'interno di parentesi quadre, per indicare gli elementi della lista. Se ogni elemento è un letterale, l'intera costruzione è un letterale di lista. Si può opzionalmente mettere una virgola ridondante dopo l'ultimo elemento. Per denotare una lista vuota, si utilizza una coppia di parentesi quadre vuote.

Esempi di letterali di lista:

Esempi di liste costruite con letterali e espressioni:

```python
l1 = [42., "Hello", 0x42] # <1>
l2 = [21+21] # <2>
l3 = [] # <3>
```
1. Lista con tre oggetti contenuti da letterale numerico, letterale stringa e ancora letterale numerico.
2. Lista con un solo oggetto da espressione.
3. Lista vuota.

Possiamo creare le tuple usando la classe `tuple` oltre che i letterali:

```python
l1 = list() # <1>
l2 = list("Hello") # <2>
```
1. Crea una lista vuota.
2. Crea una lista con 5 stringhe, una per ogni carattere. 

Operazioni sulle liste:

```python
l1 = [42., "Hello", 0x42]
print(l1[1])  # <1>

print(len(l1))  # <2>

l2 = [42]

l3 = l1 + l2 
print(l3) # <3>

l2 += l1 
print(l2) # <4>

l4 = []

l4.extend(l1) 
print(l4) # <5>

l5 = []

l5.append(l1) 
print(l5) # <6>

print(l2[1:3])   # <7>

l1[1] = "Ciao"
print(l1)  # <8>

l1.remove("Ciao")
print(l1)  # <9>

l1.pop(0)
print(l1)  # <10>

del l4[1:2] # <11>
```
1. Output: `"Hello"`.
2. Output: `3`.
3. Output: `[42.0, 'Hello', 66, 42]`. Concatenazione di liste che produce una nuova lista.
4. Output: `[42, 42.0, 'Hello', 66]`. Concatenazione sul posto modificando `l2`.
5. Output: `[42.0, 'Hello', 66]`. Concatenazione sul posto modificando `l4`.
6. Output: `[[42.0, 'Hello', 66]]`. Inserimento in fondo alla lista di un elemento.
7. Output: `[42.0, 'Hello']`. Slicing di lista che produce una nuova lista.
8. Output: `[42.0, 'Ciao', 66]`. Modifica della lista per assegnazione di un nuovo oggetto ad un indice.
9. Output: `[42.0, 66]`. Rimozione di un elemento dalla lista usando un test di uguaglianza per stabilire che l'oggetto nella lista è uguale a quello passato come argomento.
10. Output: `[66]`. Rimozione di un elemento della lista usando uno slicing.

