---
reference-location: margin
citation-location: margin
---

# Il modello dati

Per comprendere il **modello dati** di Python, dobbiamo conoscere i tipi di dati del linguaggio e le relative operazioni, con ciò intendendo che dobbiamo sia elencare quelli predefiniti, che apprendere le modalità di definizione di nuovi tipi. 

## Oggetti

Gli oggetti sono l'astrazione dei dati definita in Python. Ogni oggetto è caratterizzato da un'**identità**, un **tipo** e un **valore**. L'identità di un oggetto non cambia una volta creato e possiamo pensarlo come l'indirizzo dell'oggetto in memoria[^1]. Python permette di ricavarlo per mezzo della funzione predefinita (_built in_) `id()`:

```python
s = "Hello"

print(id(s)) # <1>
```
1. Output: un numero come `4467381744`.

Il tipo di un oggetto determina le operazioni che l'oggetto supporta per la manipolazione del proprio stato o di quello di altri oggetti, e definisce anche i possibili valori per gli oggetti di quel tipo (_dominio_ dei valori, per prendere in prestito un termine dalla matematica). Il linguaggio fornisce una funzione per conoscere il tipo dell'oggetto:

```python
s = "Hello"

print(type(s)) # <1>
```
1. Output: `<class 'str'>`.

[^1]: In CPython è effettivamente implementato così.

Gli oggetti il cui valore può cambiare sono detti **mutabili**, mentre gli oggetti il cui valore non lo può una volta creati, sono chiamati **immutabili**. L'immutabilità di un oggetto è determinata dalla progettazione del suo tipo, ad esempio, per i tipi definiti nel linguaggio, numeri interi e in virgola mobile, stringhe e tuple sono immutabili, mentre dizionari e liste sono mutabili.

Gli oggetti non vengono mai distrutti esplicitamente dall'utente, ma, quando diventano inaccessibili, possono essere raccolti dal garbage collector, che è eseguito contemporaneamente al codice del programma, come parte dell'interprete. L'implementazione specifica quando e come gli oggetti debbano essere distrutti.

Alcuni oggetti contengono riferimenti a risorse _esterne_ rispetto al programma, come file aperti, connessioni di rete, finestre (_graphical user interface_, GUI) o dispositivi hardware. Queste risorse generalmente non vengono liberate dal garbage collector, perché le azioni corrispondenti sono particolari della risorsa stessa, pertanto, i loro oggetti forniscono anche un metodo esplicito di rilascio, solitamente chiamato `close()`. È molto importante tener conto di ciò per evitare effetti indesiderati. 

Alcuni oggetti, chiamati **contenitori**, contengono riferimenti ad altri oggetti. Esempi di contenitori sono _tuple_, _liste_ e _dizionari_, strutture dati di base, definite in molti linguaggi di programmazione. I riferimenti ad altri oggetti fanno parte del valore di un contenitore e, nella maggior parte dei casi, quando parliamo del valore di un contenitore, intendiamo proprio i valori degli oggetti contenuti, non le loro identità. Ad esempio:

```python
t = (1, 2, 3) # <1>

l = ["Qui", "Quo", "Qua"] # <2>
```
1. Tupla con tre oggetti al suo interno: `1`, `2`, `3`. Diciamo che la tupla contiene i tre valori interi. 
2. lista com tre oggetti all'interno: `"Qui"`, `"Quo"`, `"Qua"`. Diciamoc he la lista contiene le tre stringhe. 

La mutabilità di un contenitore si riferisce alla identità degli oggetti referenziati e non al loro valore, quindi, ad esempio, se una tupla contiene un riferimento ad un oggetto mutabile, il valore della tupla cambia se quell'oggetto mutabile viene modificato:

```python
s = ([1, 2, 3], ["Qui", "Quo", "Qua"])

print(s) # <1>

print(id(s[0])) # <2>
print(id(s[1])) # <3>

s[1][0] = "Huey" # <4>
s[1][1] = "Dewey" 
s[1][2] = "Louie"

print(s) # <5>

print(id(s[0])) # <6>
print(id(s[1])) # <7>
```
1. Output: `([1, 2, 3], ['Qui', 'Quo', 'Qua'])`.
2. Modifico gli elementi della lista, traducendoli in inglese.
3. Output dell'identità del primo oggetto contenuto (su ogni computer e sessione sarà diverso): `4361472384`.
4. Output dell'identità del secondo oggetto contenuto: `4361474176`.
5. Output: `([1, 2, 3], ['Huey', 'Dewey', 'Louie'])`. La tupla è cambiata!
6. Output: `4361472384`, l'identità del primo oggetto contenuto non è cambiata!
7. Output: `4361474176`, l'identità del secondo oggetto contenuto non è cambiata!

Ciò è un po' più generale, perché per gli oggetti di tipo immutabile, quando sono assegnati ad una variaible o risultato di un'espressione, a parità di valore, potrebbero avere la stessa identità, cioè essere lo stesso oggetto. Il condizionale è dovuto alla presenza e applicazione logiche di ottimizzazione, ad esempio della memoria, implementate nell'interprete.

Ad esempio, dopo:

```python
s1 = "Qui, Quo, Qua"

print(id(s1)) # <1>

s2 = "Qui, Quo, Qua"

print(id(s2)) # <2>
```
1. Output dell'identità di `s1`: `4432491760`.
2. Output dell'identità di `s2`: `4432491760`, cioè è la medesima identità dell'oggetto il cui nome è `s1`.

Per gli oggetti mutabili, questo non accade anche in casi su cui potrebbe essere ottimizzante:

```python
l1 = []

print(id(l1)) # <1>

l2 = []

print(id(l2)) # <2>
```
1. Output dell'identità di `l1`: `4454287744`.
2. Output dell'identità di `l2`: `4454289536`, cioè le identità sono diverse.

Attenzione però ad alcune _scorciatoie_ di Python:

```python
c = d = []
```

è equivalente a:

```python
c = []
d = c
```

cioè l'oggetto lista ha due nomi nel programma. 

## Tipi e classi

In Python, i tipi di dati sono implementati come _classi_. Una classe è la definizione di un tipo di oggetto che specifica gli attributi (complessivamente il valore dell'oggetto) e i metodi (le operazioni) che determinano lo stato e il comportamento degli oggetti. Gli oggetti creati da una classe possono essere manipolati attraverso i metodi della classe, permettendo di interagire e modificare i loro attributi per ottenere risultati desiderati. Quando creiamo un oggetto di una determinata classe, stiamo creando un'istanza di quella classe. 

Ad esempio, per una stringa:

```python
s = "Hello" # <1>

print(type(s))  # <2>
```
1. L'oggetto stringa il cui valore è `"Hello"` ha come nome `s`.
2. Output: `<class 'str'>`. `type` conferma che l'oggetto è una istanza di `str` che è il tipo delle stringhe in Python.

Le classi possono essere organizzate in una gerarchia. In cima alla gerarchia delle classi di Python c'è la classe `object`, un po' infelice come nome, da cui derivano tutte le altre classi. Questo significa che ogni classe in Python eredita gli attributi e i metodi della classe `object`. La funzione `isinstance` è utile per investigare questa gerarchia, poiché permette di verificare se un oggetto è un'istanza di una determinata classe o di una sua classe derivata.

Ad esempio:

```python
s = "Hello" 

print(isinstance(s, str))  # <1>

print(isinstance(s, object))  # <2>
```
1. Output: `True`. `isinstance` conferma che `s` è un'istanza della classe `str`.
2. Output: `True`. `isinstance` conferma che `s` è un'istanza anche della classe `object`, da cui deriva `str`.

La funzione `issubclass` è altrettanto utile per esplorare le gerarchie delle classi, in quanto permette di verificare se una classe è una sottoclasse di un'altra.

Ad esempio:

```python
print(issubclass(str, object))  # <1>
```
1. Output: `True`. `issubclass` conferma che `str` è una sottoclasse di `object`.

## Tipi predefiniti

Python mette a disposizione molti tipi _generali_, cioè utili alla gestione di dati comunemente presenti in algoritmi. Esistono, inoltre, sia meccanismi di estensione della distribuzione Python che modificano l'installazione sul proprio computer, sia la possibilità conferita al programmatore di creare i propri tipi o di importarli da librerie prodotte da terze parti.

I tipi predefiniti sono immediatamente disponibili, cioè non necessitano di alcuna azione da parte del programmatore, come, ad esempio, l'importazione di moduli. 

Per ragioni di esposizione, distingueremo tra tipi predefiniti fondamentali, cioè che possono essere introdotti con un insieme limitato di concetti, tipi legati alla astrazione del paradigma di orientamento agli oggetti e, infine, costruzioni del linguaggio legate all'esecuzione asincrona.

## Tipi predefiniti fondamentali

Prima di entrare nel dettaglio per ognuno, di seguito un elenco dei tipi predefiniti fondamentali:

- Numeri: sia interi relativi che reali, cioè in virgola mobile, sia complessi.

- Sequenze, cioè contenitori caratterizzati da un ordinamento degli oggetti al loro interno, sia mutabili che immutabili. 

- Insiemi, cioè contenitori non caratterizzati da un ordinamento degli oggetti.

- Dizionari, cioè contenitori di coppie di oggetti chiave e valore.

- Altri: `None`, `NotImplemented`, `Ellipsis`.

### Numeri

I tipi predefiniti numerici corrispondono agli interi, i numeri a virgola mobile e quelli complessi. Sono immutabili, il che significa che effettuando una operazione su un oggetto numerico si produrrà sempre un nuovo oggetto e non una modifica del precedente.

Esistono anche altri tipi numerici nelle librerie fornite coll'interprete, per i numeri decimali a precisione arbitraria e i numeri razionali come frazioni.  

I letterali numerici non hanno segno, cioè `+` e `-` sono operatori unari che precedono la rappresentazione di un numero, quindi `-3` è una espressione che diventa il valore di un oggetto intero di valore -3.

#### Interi

Esistono due tipi di interi. Il primo è `int`, per gli usuali numeri interi, a cui corrispondono diverse rappresentazioni sintattiche in basi diverse, come i letterali decimali, binari, ottali o esadecimali:

- Un letterale decimale inizia sempre con una cifra diversa da zero. 
  
- Quello binario inizia con `0b` o `0B` seguito da una sequenza di cifre binarie (0 o 1). 

- L'ottale inizia con `0o` o `0O` seguito da una sequenza di cifre ottali (da 0 a 7). 

- L'esadecimale inizia con `0x` o `0X` seguito da una sequenza di cifre esadecimali (da 0 a 9 e da A a F, in maiuscolo o minuscolo).

Ad esempio:

```python
dec = 10         # <1>
bin = 0b1010     # <2>
oct = 0o12       # <3>
hex = 0xA        # <4>
```
1. Letterale decimale.
2. Letterale binario.
3. Letterale ottale.
4. Letterale esadecimale.

Gli interi in Python sono illimitati, al netto della finitezza della memoria del computer disponibile per la loro rappresentazione.

```python
large_int = 10**100

print(f"Un intero molto grande: {large_int}") # <1>
```
1. Output: `10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`.

L'altro tipo è `bool`, che ha solo due oggetti possibili, che si comportano come quelli corrispondenti agli interi `1` e `0` per rappresentare i valori logici, rispettivamente, di vero e falso. `bool` come classe deriva da `int` che, a sua volta, deriva da `object`:

```python
print(issubclass(bool, int)) # <1>
print(issubclass(int, object)) # <2>
```
1. Output: `True`.
2. Output: `True`.

#### Numeri in virgola mobile 

I numeri in virgola mobile in Python sono istanze della classe `float` e sono utilizzati per rappresentare numeri reali con una parte decimale. I letterali corrispondenti sono una sequenza di cifre in base 10, e solo in base 10, che include un punto (`.`), un suffisso di notazione scientifica (`e` o `E`, opzionalmente seguito da `+` o `-`, seguito da una o più cifre), o entrambi. Il carattere iniziale di un letterale in virgola mobile non può essere `e` o `E`, ma può essere qualsiasi cifra (anche zeri a differenza degli interi) o un punto (`.`) seguito da una cifra.

Esempi di literali in virgola mobile: `0.`, `0.1`, `.0`, `1.`, `1.0`, `1e0`, `1.e0`, `1.0E0`. Attenzione: `1` è un intero, `1.` non lo è.

Per conoscere l'intervallo esatto e la precisione dei valori in virgola mobile sulla piattaforma in uso, e molti altri dettagli, è possibile usare `sys.float_info` nel modo seguente:

```python
import sys

float_info = sys.float_info  # <1>

print(f"Massimo valore rappresentabile (max): {float_info.max}")  # <2>
print(f"Minimo valore rappresentabile positivo (min): {float_info.min}")  # <3>
print(f"Massimo esponente base 2 (max_exp): {float_info.max_exp}")  # <4>
print(f"Minimo esponente base 2 (min_exp): {float_info.min_exp}")  # <5>
print(f"Massimo esponente base 10 (max_10_exp): {float_info.max_10_exp}")  # <6>
print(f"Minimo esponente base 10 (min_10_exp): {float_info.min_10_exp}")  # <7>
print(f"Precisione in bit (dig): {float_info.dig}")  # <8>
print(f"Numero di bit di mantissa (mant_dig): {float_info.mant_dig}")  # <9>
print(f"Epsilon macchina (epsilon): {float_info.epsilon}")  # <10>
```
1. Oggetto con all'interno le informazioni relative alla gestione dei numeri in virgola mobile della macchina.
2. Output: `Massimo valore rappresentabile (max): 1.7976931348623157e+308`. Il massimo valore rappresentabile per un numero in virgola mobile.
3. Output: `Minimo valore rappresentabile positivo (min): 2.2250738585072014e-308`. Il minimo valore positivo rappresentabile per un numero in virgola mobile.
4. Output: `Massimo esponente base 2 (max_exp): 1024`. Il massimo esponente base 2.
5. Output: `Minimo esponente base 2 (min_exp): -1021`. Il minimo esponente base 2.
6. Output: `Massimo esponente base 10 (max_10_exp): 308`. Il massimo esponente base 10.
7. Output: `Minimo esponente base 10 (min_10_exp): -307`. Il minimo esponente base 10.
8. Output: `Precisione in bit (dig): 15`. La precisione in bit, cioè il numero di cifre decimali che possono essere rappresentate senza perdita di precisione.
9. Output: `Numero di bit di mantissa (mant_dig): 53`. Il numero di bit nella mantissa.
10. Output: `Epsilon macchina (epsilon): 2.220446049250313e-16`. La differenza tra 1 e il numero più piccolo maggiore di 1 che può essere rappresentato.

#### Numeri complessi

Un numero complesso è composto da due valori in virgola mobile, uno per la parte reale e uno per la parte immaginaria. In Python, i numeri complessi sono istanze della classe `complex`, che presenta due attributi di sola lettura `real` e `imag`, rispettivamente per la parte reale e immaginaria, di tipo `float`. 

Un letterale immaginario può essere specificato come qualsiasi letterale decimale in virgola mobile o intero seguito da una `j` o `J`: `0j`, `0.j`, `0.0j`, `.0j`, `1j`, `1.j`, `1.0j`, `1e0j`, `1.e0j`, `1.0e0j`. La `j` alla fine del letterale immaginario indica la radice quadrata di `-1`. Per denotare un qualsiasi numero complesso costante, si potrà sommare o sottrarre un letterale in virgola mobile (o letterale intero) e uno immaginario. 

```python
z = 42+3.14j # <1>

print(z) # <2>

print(z.real) # <3>
print(z.imag) # <4>

print(type(z.real)) # <5>
print(type(z.imag)) # <6>
print(type(z)) # <7>

zc = z.conjugate() # <8>

print(zc) # <9>
```
1. Assegnamento di un numero complesso alla variabile `z`.
2. Output: `(42+3.14j)`.
3. Output: `42.0`.
4. Output: `3.14`.
5. Output: `<class 'float'>`.
6. Output: `<class 'float'>`.
7. Otteniamo il complesso coniugato di `z`.
8. Output: `(42-3.14j)`.















### Sequenze

#### Stringhe (str)
Le stringhe sono sequenze di caratteri Unicode. In Python, le stringhe sono immutabili.

Esempio:
```python
a = "Hello, World!"
print(type(a))  # <class 'str'>
```

#### Liste (list)
Le liste sono sequenze mutabili di oggetti. Possono contenere oggetti di tipi diversi.

Esempio:
```python
a = [1, 2, 3, "apple", [4, 5]]
print(type(a))  # <class 'list'>
```

#### Tuple (tuple)
Le tuple sono sequenze immutabili di oggetti. Come le liste, possono contenere oggetti di tipi diversi.

Esempio:
```python
a = (1, 2, 3, "apple", [4, 5])
print(type(a))  # <class 'tuple'>
```

### Insiemi

#### Set (set)
Gli insiemi sono contenitori mutabili che contengono elementi unici non ordinati.

Esempio:
```python
a = {1, 2, 3, "apple"}
print(type(a))  # <class 'set'>
```

#### Frozen Set (frozenset)
I frozen set sono insiemi immutabili.

Esempio:
```python
a = frozenset([1, 2, 3, "apple"])
print(type(a))  # <class 'frozenset'>
```

### Dizionari (dict)
I dizionari sono contenitori mutabili di coppie chiave-valore. Le chiavi devono essere uniche e immutabili.

Esempio:
```python
a = {"name": "Alice", "age": 30}
print(type(a))  # <class 'dict'>
```

### Altri

#### None
Il tipo `None` ha un solo valore, `None`, che rappresenta l'assenza di un valore. È spesso utilizzato come valore predefinito per variabili o come valore di ritorno per funzioni che non restituiscono nulla.

Esempio:
```python
a = None
print(type(a))  # <class 'NoneType'>
```

#### NotImplemented
`NotImplemented` è un valore speciale che può essere restituito dai metodi aritmetici e di confronto quando l'operazione non è supportata per gli operandi forniti. Non dovrebbe essere valutato in un contesto booleano.

Esempio:
```python
class MyNumber:
    def __eq__(self, other):
        if isinstance(other, MyNumber):
            return True
        return NotImplemented

a = MyNumber()
b = MyNumber()
print(a == b)  # True
print(a == 42)  # NotImplemented
```

#### Ellipsis
`Ellipsis` ha un solo valore, rappresentato dal letterale `...` o dal nome predefinito `Ellipsis`. È utilizzato principalmente in contesti di slicing avanzati.

Esempio:
```python
a = ...
print(type(a))  # <class 'ellipsis'>
```




