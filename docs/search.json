[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Prefazione",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html",
    "href": "prima-parte-linguaggi-programmazione.html",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "",
    "text": "1.1 Definizioni\nLa programmazione è il processo di progettazione e scrittura di istruzioni, nella forma statica, ad esempio un file di testo, identificate come codice sorgente, che un computer può ricevere per eseguire compiti predefiniti. Queste istruzioni sono codificate in un linguaggio di programmazione, che traduce le idee e gli algoritmi del programmatore, in un formato comprensibile ed eseguibile dal computer.\nUn programma informatico è una sequenza di istruzioni scritte per eseguire una specifica operazione o un insieme di operazioni su un computer. Queste istruzioni sono codificate in un linguaggio che il computer può comprendere e utilizzare per eseguire attività come calcoli, manipolazione di dati, controllo di dispositivi e interazione con l’utente. Pensate a un programma come a una ricetta di cucina. La ricetta elenca gli ingredienti necessari (dati) e fornisce istruzioni passo-passo (algoritmo) per preparare un piatto. Allo stesso modo, un programma informatico specifica i dati da usare e le istruzioni da seguire per ottenere un risultato desiderato.\nUn linguaggio di programmazione è un linguaggio formale che fornisce un insieme di regole e sintassi per scrivere programmi informatici. Questi linguaggi permettono ai programmatori di comunicare con i computer e di creare software. Alcuni esempi di linguaggi di programmazione includono Python, Java, C++, SQL, Rust, Haskell, Prolog, C, Assembly, Fortran, JavaScript e altre centinaia (o forse migliaia).",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#linguaggi-naturali-e-di-programmazione",
    "href": "prima-parte-linguaggi-programmazione.html#linguaggi-naturali-e-di-programmazione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.2 Linguaggi naturali e di programmazione",
    "text": "1.2 Linguaggi naturali e di programmazione\nI linguaggi di programmazione hanno dei punti in comune e delle differenze coi linguaggi naturali (come l’italiano o l’inglese). Quest’ultime sono principalmente:\n\nPrecisione e rigidità: I linguaggi di programmazione sono estremamente precisi e rigidi. Ogni istruzione deve essere scritta in un modo specifico affinché il computer possa comprenderla ed eseguirla correttamente. Anche un piccolo errore di sintassi può impedire il funzionamento di un programma.\nAmbiguità: I linguaggi naturali sono spesso ambigui e aperti a interpretazioni. Le stesse parole possono avere significati diversi a seconda del contesto. I linguaggi di programmazione, invece, sono progettati per essere privi di ambiguità; ogni istruzione ha un significato preciso e univoco.\nVocabolario limitato: I linguaggi naturali hanno un vocabolario vastissimo e in continua espansione. I linguaggi di programmazione, al contrario, hanno un vocabolario limitato costituito da parole chiave e comandi definiti dal linguaggio stesso.\nForma di mediazione: I linguaggi naturali sono direttamente utilizzati per comunicare, quelli di programmazione non sono comprensibili immediatamente dai computer, ma devono essere tradotti in una forma opportuna per mezzo di programmi ad hoc.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#algoritmi",
    "href": "prima-parte-linguaggi-programmazione.html#algoritmi",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.3 Algoritmi",
    "text": "1.3 Algoritmi\nUn algoritmo è “un insieme di regole che definiscono con precisione una sequenza di operazioni” (Harold Stone, Introduction to Computer Organization and Data Structures, 1971 (Stone 1971)). Tale definizione, per quanto generica, coglie i due aspetti fondanti, cioè regole, intese come prescrizioni sintattiche o semantiche, che si traducono in operazioni richieste ad un agente, umano o informatico.\n\nStone, Harold S. 1971. Introduction to Computer Organization and Data Structures. USA: https://dl.acm.org/doi/10.5555/578826; McGraw-Hill, Inc.\nIn altre parole, un algoritmo è una sequenza ben definita di passi o operazioni ben codificata, che, a partire da un input, produce un output in un tempo finito e, quindi, presenta la seguente serie di caratteristiche:\n\nFinitudine: L’algoritmo deve terminare dopo un numero finito di passi.\nDeterminismo: Ogni passo dell’algoritmo deve essere definito in modo preciso e non ambiguo.\nInput: L’algoritmo riceve zero o più dati in ingresso.\nOutput: L’algoritmo produce uno o più risultati.\nEffettività: Ogni operazione dell’algoritmo deve essere fattibile ed eseguibile in un tempo finito.\n\nGli algoritmi sono tradotti in codice sorgente attraverso un linguaggio di programmazione per creare programmi. In altre parole, un programma è la realizzazione pratica e funzionante degli algoritmi ideati dal programmatore.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#dal-codice-sorgente-allesecuzione",
    "href": "prima-parte-linguaggi-programmazione.html#dal-codice-sorgente-allesecuzione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.4 Dal codice sorgente all’esecuzione",
    "text": "1.4 Dal codice sorgente all’esecuzione\nPer comprendere come un programma scritto in un linguaggio di programmazione passi dal file di testo contenente il codice sorgente all’esecuzione delle istruzioni da parte della CPU, è fondamentale capire che questo processo richiede un programma che interpreti il codice sorgente. Tale programma può essere un compilatore o un interprete, le due macrocategorie che definiscono come il codice sorgente viene tradotto ed eseguito.\nUn compilatore è un programma che traduce l’intero codice sorgente di un programma scritto in un linguaggio di alto livello (come C o C++) in codice macchina, che è il linguaggio comprensibile direttamente dalla CPU. Questa traduzione avviene una sola volta, generando un file eseguibile che può essere eseguito direttamente dalla CPU.\nUn interprete, invece, è un programma che esegue il codice sorgente direttamente, istruzione per istruzione, senza produrre un file eseguibile separato. L’interprete legge una riga di codice, la traduce in codice macchina e la esegue immediatamente. Questo processo viene ripetuto per ogni riga del codice sorgente.\nÈ importante notare che alcuni linguaggi di programmazione possono essere sia compilati che interpretati, a seconda dell’implementazione disponibile. Ad esempio, Java utilizza sia la compilazione (per generare bytecode) che l’interpretazione, e la Java Virtual Machine (JVM) spesso utilizza anche la compilazione just-in-time (JIT) per tradurre il bytecode in codice macchina nativo durante l’esecuzione.\nDetto ciò i passaggi macro perché un programma sia eseguito e possa produrre gli effetti pronosticati, sono:\n\nIl programmatore scrive il codice sorgente utilizzando un editor di testo o un ambiente di sviluppo integrato (integrated development environment, IDE). Questo codice contiene le istruzioni del programma, scritte secondo la sintassi del linguaggio di programmazione scelto.\nL’interpreto o il compilatore vengono eseguiti con input il programma e un componente, l’analizzatore lessicale, legge il codice sorgente e lo divide in lessemi, che sono sequenze di caratteri che corrispondono agli elementi atomici del linguaggio. Ogni lessema viene identificato come un token specifico, come una parola chiave, un operatore o un identificatore.\nA seguire un secondo compoenente, il parser, riceve la sequenza di token dall’analizzatore lessicale e costruisce un albero di sintassi, che rappresenta la struttura grammaticale del programma. Il parser verifica che il codice rispetti le regole sintattiche del linguaggio.\nUn altro componente effettua la verifica che il programma abbia un senso logico. Ad esempio, controlla che le variabili siano dichiarate prima di essere utilizzate e che i tipi di dati siano compatibili con le operazioni eseguite su di essi.\nIl compilatore, a questo punto, genera una rappresentazione intermedia del programma, che è più vicina al linguaggio macchina ma ancora indipendente dall’architettura specifica del computer. Ciò è tipico dei linguaggi compilati, anche se alcuni interpreti possono generare un bytecode intermedio.\nIl compilatore ottimizza codice intermedio al fine di migliorare le prestazioni del programma, riducendo il numero di istruzioni o migliorando l’efficienza delle operazioni.\nIl codice intermedio ottimizzato viene tradotto in codice macchina, che è specifico per l’architettura del computer su cui il programma verrà eseguito.\nLinking: Il codice macchina viene combinato con altre librerie e moduli necessari per formare un eseguibile completo.\nEsecuzione: L’eseguibile viene caricato nella memoria del computer e il processore esegue le istruzioni, portando a termine le operazioni definite nel programma.\n\nNel caso di un interprete, i passaggi di generazione del codice intermedio e macchina possono essere sostituiti da una valutazione diretta delle istruzioni del programma, eseguendole una per una. In pratica, l’interprete traduce ogni singola istruzione del codice sorgente in un formato conprensibile dalla CPU e passa questa istruzione alla CPU stessa per l’esecuzione. Questo processo continua fino a quando tutte le istruzioni del programma non sono state eseguite.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#ciclo-di-vita-del-software",
    "href": "prima-parte-linguaggi-programmazione.html#ciclo-di-vita-del-software",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.5 Ciclo di vita del software",
    "text": "1.5 Ciclo di vita del software\nUn software è composto da uno o più programmi e, quando eseguito, realizza un compito con un grado di utilità specifico. La gerarchia concetttuale, dal più generale all’elemento più granulare, è: software, programmi, istruzioni.\nCosì come il disegno dei programmi è quello computazionale degli algoritmi, il disegno del software è funzionale per determinare i suoi obiettivi e architetturale per la decomposizione nei programmi.\nPer creare il software, quindi, è necessario percorrere una sequenza di fasi ben definita che, concisamente, è:\n\nLa progettazione di un’applicazione inizia con la fase di analisi dei requisiti, in cui si identificano cosa deve fare il software, chi sono gli utenti e quali sono i requisiti funzionali e non funzionali che deve soddisfare.\nSegue il disegno funzionale che dettaglia come ogni componente del sistema possa rispondere alle funzionalità richieste. In questa fase si descrivono le operazioni specifiche che ogni componente deve eseguire, utilizzando diagrammi di processo per rappresentare il flusso di attività al fine di rispondere ai requisiti.\nIl disegno architetturale riguarda l’organizzazione ad alto livello del sistema software. In questa fase si definiscono i componenti principali del sistema e come essi interagiscono tra di loro per supportare le attività di processo. Questo include la suddivisione del sistema in moduli o componenti, la definizione delle interfacce tra di essi e l’uso di tecniche di modellazione per rappresentare l’architettura del sistema.\nUna volta che l’architettura è stata progettata, si passa alla fase di implementazione, in cui i programmatori scrivono il codice sorgente nei linguaggi di programmazione scelti.\nDopo l’implementazione, è essenziale verificare che il software funzioni correttamente:\n\nTesting: Scrivere ed eseguire test per verificare che il software soddisfi i requisiti specificati. I test sono di diversi generi in funzione dell’oggetto di verifica, come test unitari, per segmenti di codice, test di integrazione, per componenti, e test di sistema nella sua interezza.\nDebugging: Identificare e correggere gli errori (bug) nel codice. Questo può includere l’uso di strumenti di debugging per tracciare l’esecuzione del programma e trovare i punti in cui si verificano gli errori.\n\nUna volta che il software è stato testato e ritenuto pronto, si passa alla fasi di messa a disposizione delle funzionalità agli utenti (in inglese, deployment):\n\nDistribuzione: Rilasciare il software agli utenti finali, che può includere l’installazione su server, la distribuzione di applicazioni desktop o il rilascio di app mobile.\nManutenzione: Continuare a supportare il software dopo il rilascio. Questo include la correzione di bug scoperti dopo il rilascio, l’aggiornamento del software per miglioramenti e nuove funzionalità, e l’adattamento a nuovi requisiti o ambienti.\n\n\nLa complessità del processo induce la necessità di avere dei team con qualità indiivduali diverse e il programmatore, oltre alle competenze specifiche, deve saper interpretare i vari artifatti di disegno e saperli tramutare in algoritmi e codice sorgente.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione",
    "href": "prima-parte-linguaggi-programmazione.html#limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.6 L’Impatto dell’intelligenza artificiale generativa sulla programmazione",
    "text": "1.6 L’Impatto dell’intelligenza artificiale generativa sulla programmazione\nCon l’avvento dell’intelligenza artificiale generativa (IA generativa), la programmazione ha subito una trasformazione significativa. Prima dell’IA generativa, i programmatori dovevano tutti scrivere manualmente ogni riga di codice, seguendo rigorosamente la sintassi e le regole del linguaggio di programmazione scelto. Questo processo richiedeva una conoscenza approfondita degli algoritmi, delle strutture dati e delle migliori pratiche di programmazione.\nInoltre, i programmatori dovevano creare ogni funzione, classe e modulo a mano, assicurandosi che ogni dettaglio fosse corretto, identificavano e correggevano gli errori nel codice con un processo lungo e laborioso, che comportava anche la scrittura di casi di test e l’esecuzione di sessioni di esecuzione di tali casi. Infine, dovebano scrivere documentazione dettagliata per spiegare il funzionamento del codice e facilitare la manutenzione futura.\n\n1.6.1 Attività del programmatore con l’IA Generativa\nL’IA generativa ha introdotto nuovi strumenti e metodologie che stanno cambiando il modo in cui i programmatori lavorano:\n\nGenerazione automatica del codice: Gli strumenti di IA generativa possono creare porzioni di codice basate su descrizioni ad alto livello fornite dai programmatori. Questo permette di velocizzare notevolmente lo sviluppo iniziale e ridurre gli errori di sintassi.\nAssistenza nel debugging: L’IA può identificare potenziali bug e suggerire correzioni, rendendo il processo di debugging più efficiente e meno dispendioso in termini di tempo.\nOttimizzazione automatica: Gli algoritmi di IA possono analizzare il codice e suggerire o applicare automaticamente ottimizzazioni per migliorare le prestazioni.\nGenerazione di casi di test: L’IA può creare casi di test per verificare la correttezza del codice, coprendo una gamma più ampia di scenari di quanto un programmatore potrebbe fare manualmente.\nDocumentazione automatica: L’IA può generare documentazione leggendo e interpretando il codice, riducendo il carico di lavoro manuale e garantendo una documentazione coerente e aggiornata.\n\n\n\n1.6.2 L’Importanza di imparare a programmare nell’era dell’IA generativa\nNonostante l’avvento dell’IA generativa, imparare a programmare rimane fondamentale per diverse ragioni. La programmazione non è solo una competenza tecnica, ma anche un modo di pensare e risolvere problemi. Comprendere i fondamenti della programmazione è essenziale per utilizzare efficacemente gli strumenti di IA generativa. Senza una solida base, è difficile sfruttare appieno queste tecnologie. Inoltre, la programmazione insegna a scomporre problemi complessi in parti più gestibili e a trovare soluzioni logiche e sequenziali, una competenza preziosa in molti campi.\nAnche con l’IA generativa, esisteranno sempre situazioni in cui sarà necessario personalizzare o ottimizzare il codice per esigenze specifiche. La conoscenza della programmazione permette di fare queste modifiche con sicurezza. Inoltre, quando qualcosa va storto, è indispensabile sapere come leggere e comprendere il codice per identificare e risolvere i problemi. L’IA può assistere, ma la comprensione umana rimane cruciale per interventi mirati.\nImparare a programmare consente di sperimentare nuove idee e prototipare rapidamente soluzioni innovative. La creatività è potenziata dalla capacità di tradurre idee in codice funzionante. Sapere programmare aiuta anche a comprendere i limiti e le potenzialità degli strumenti di IA generativa, permettendo di usarli in modo più strategico ed efficace.\nLa tecnologia evolve rapidamente, e con una conoscenza della programmazione si è meglio preparati ad adattarsi alle nuove tecnologie e metodologie che emergeranno in futuro. Inoltre, la programmazione è una competenza trasversale applicabile in numerosi settori, dalla biologia computazionale alla finanza, dall’ingegneria all’arte digitale. Avere questa competenza amplia notevolmente le opportunità di carriera.\nInfine, la programmazione è una porta d’accesso a ruoli più avanzati e specializzati nel campo della tecnologia, come l’ingegneria del software, la scienza dei dati e la ricerca sull’IA. Conoscere i principi della programmazione aiuta a comprendere meglio come funzionano gli algoritmi di IA, permettendo di contribuire attivamente allo sviluppo di nuove tecnologie.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html",
    "href": "prima-parte-paradigmi-programmazione.html",
    "title": "2  I paradigmi di programmazione",
    "section": "",
    "text": "2.1 L’importanza dei paradigmi di programmazione\nComprendere i paradigmi di programmazione è fondamentale per diversi motivi:",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#limportanza-dei-paradigmi-di-programmazione",
    "href": "prima-parte-paradigmi-programmazione.html#limportanza-dei-paradigmi-di-programmazione",
    "title": "2  I paradigmi di programmazione",
    "section": "",
    "text": "Approccio alla risoluzione dei problemi: Ogni paradigma offre una visione diversa su come affrontare e risolvere problemi. Conoscere vari paradigmi permette ai programmatori di scegliere l’approccio più adatto in base al problema specifico. Ad esempio, per problemi che richiedono una manipolazione di stati, la programmazione imperativa può essere più intuitiva. Al contrario, per problemi che richiedono trasformazioni di dati senza effetti collaterali, la programmazione funzionale potrebbe essere più adatta.\nVersatilità e adattabilità: I linguaggi moderni che supportano più paradigmi permettono ai programmatori di essere più versatili e adattabili. Possono utilizzare il paradigma più efficiente per diverse parti del progetto, migliorando sia la leggibilità che le prestazioni del codice.\nManutenzione del codice: La comprensione dei paradigmi aiuta nella scrittura di codice più chiaro e manutenibile. Ad esempio, il paradigma orientato agli oggetti può essere utile per organizzare grandi basi di codice in moduli e componenti riutilizzabili, migliorando la gestione del progetto.\nEvoluzione professionale: La conoscenza dei vari paradigmi arricchisce le competenze di un programmatore, rendendolo più competitivo nel mercato del lavoro. Conoscere più paradigmi permette di comprendere e lavorare con una gamma più ampia di linguaggi di programmazione e tecnologie.\nOttimizzazione del codice: Alcuni paradigmi sono più efficienti in determinate situazioni. Ad esempio, la programmazione concorrente è essenziale per lo sviluppo di software che richiede alta prestazione e scalabilità, come nei sistemi distribuiti. Comprendere come implementare la concorrenza in vari paradigmi permette di scrivere codice più efficiente.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-imperativo",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-imperativo",
    "title": "2  I paradigmi di programmazione",
    "section": "2.2 Paradigma imperativo",
    "text": "2.2 Paradigma imperativo\nLa programmazione imperativa, a differenza della programmazione dichiarativa, è un paradigma di programmazione che descrive l’esecuzione di un programma come una serie di istruzioni che cambiano il suo stato. In modo simile al modo imperativo delle lingue naturali, che esprime comandi per compiere azioni, i programmi imperativi sono una sequenza di comandi che il computer deve eseguire in sequenza. Un caso particolare di programmazione imperativa è quella procedurale.\nI linguaggi di programmazione imperativa si contrappongono ad altri tipi di linguaggi, come quelli funzionali e logici. I linguaggi di programmazione funzionale, come Haskell, non producono sequenze di istruzioni e non hanno uno stato globale come i linguaggi imperativi. I linguaggi di programmazione logica, come Prolog, sono caratterizzati dalla definizione di cosa deve essere calcolato, piuttosto che come deve avvenire il calcolo, a differenza di un linguaggio di programmazione imperativo.\nL’implementazione hardware di quasi tutti i computer è imperativa perché è progettata per eseguire il codice macchina, che è scritto in stile imperativo. Da questa prospettiva a basso livello, lo stato del programma è definito dal contenuto della memoria e dalle istruzioni nel linguaggio macchina nativo del processore. Al contrario, i linguaggi imperativi di alto livello sono caratterizzati da un modello dati e istruzioni che risultano più facilmente usabili come strumenti di espressione di passi algoritmici.\n\n2.2.1 Esempio in assembly\nAssembly è una categoria di linguaggi di basso livello, cioè strettamente legati all’hardware del computer, tanto che ogni processore ha il suo dialetto. Un esempio di un semplice programma scritto per l’architettura x86, utilizzando la sintassi dell’assembler NASM (Netwide Assembler), è il seguente che effettua la somma di due numeri e stampa il risultato:\nsection .data\n    num1 db 5           ; Definisce il primo numero\n    num2 db 3           ; Definisce il secondo numero\n    result db 0         ; Variabile per memorizzare il risultato\n    msg db 'Result: ', 0 ; Messaggio di output\n\nsection .bss\n    result_str resb 4   ; Buffer per la stringa del risultato\n\nsection .text\n    global _start\n\n_start:\n    ; Somma num1 e num2\n    mov al, [num1]      ; Carica il primo numero in AL\n    add al, [num2]      ; Aggiunge il secondo numero a AL\n    mov [result], al    ; Memorizza il risultato in result\n\n    ; Converti il risultato in stringa ASCII\n    mov eax, [result]   ; Carica il risultato in EAX\n    add eax, '0'        ; Converti il valore numerico in carattere ASCII\n    mov [result_str], eax ; Memorizza il carattere ASCII in result_str\n\n    ; Stampa il messaggio\n    mov eax, 4          ; syscall numero per sys_write\n    mov ebx, 1          ; file descriptor 1 (stdout)\n    mov ecx, msg        ; puntatore al messaggio\n    mov edx, 8          ; lunghezza del messaggio\n    int 0x80            ; chiamata di sistema\n\n    ; Stampa il risultato\n    mov eax, 4          ; syscall numero per sys_write\n    mov ebx, 1          ; file descriptor 1 (stdout)\n    mov ecx, result_str ; puntatore alla stringa del risultato\n    mov edx, 1          ; lunghezza della stringa del risultato\n    int 0x80            ; chiamata di sistema\n\n    ; Terminazione del programma\n    mov eax, 1          ; codice di sistema per l'uscita\n    xor ebx, ebx        ; codice di ritorno 0\n    int 0x80            ; interruzione per chiamare il kernel\nLe sezioni del codice:\n\nLa sezione .data definisce i dati statici num1, num2, result e msg.\nSezione .bss alloca lo spazio per result_str, che conterrà la stringa del risultato.\nSezione .textdefinisce _start come punto di ingresso del programma e:\n\nImplementa la logica principale del programma.\nSomma i valori di num1 e num2.\nConverte il risultato numerico in una stringa ASCII.\nUtilizza chiamate al sistema operativo per scrivere il messaggio e il risultato su stdout.\nTermina il programma.\n\n\nL’assembly è usato nello sviluppo di:\n\nSistemi operativi, ad esempio il kernel, che ha il controllo del sistema e i driver, cioè i programmi utili alla comunicazione coll’hardware.\nApplicazioni embedded: Microcontrollori di dispositivi medici, sistemi di controllo di veicoli, dispositivi IoT, ecc., cioè)dove è necessaria un’ottimizzazione estrema delle risorse computazionali.\nApplicazioni HPC (high performance computing): Il focus qui è eseguire calcoli intensivi e complessi in tempi relativamente brevi. Queste applicazioni richiedono un numero di operazioni per unità di tempo elevato e sono ottimizzate per sfruttare al massimo le risorse hardware disponibili, come CPU, GPU e memoria.\n\n\n\n2.2.2 Esempio in Python\nAll’altro estremo della immediatezza di comprensione del testo del codice per un essere umano, troviamo Python, un linguaggio di alto livello noto per la leggibilità ed eleganza.\nEcco il medesimo esempio, visibilmente più conciso e certamente intuibile anche avendo basi limitate di programmazione:\n1num1 = 5\nnum2 = 3\n\n2result = num1 + num2\n\n3print(\"Il risultato è: \", result)\n\n1\n\nDefinizione delle variabili che identificano gli addendi.\n\n2\n\nSomma dei due numeri.\n\n3\n\nStampa del risultato della somma.\n\n\n\n\n2.2.3 Analisi comparativa\nAssembly:\n\nBasso livello di astrazione: Assembly lavora direttamente con i registri della CPU e la memoria, quindi non astrae granché della complessità dell’hardware.\nScarsa versatilità: Il linguaggio è progettato per una ben definita architettura e, quindi, ha una scarsa applicabilità ad altre, anche se alcuni dialetti di assembly presentano delle similitudini.\nElevata precisione: Il programmatore ha un controllo dettagliato su ogni singola operazione compiuta dal processore, perché c’è una corrispondenza col codice macchina.\nComplessità: Ogni operazione deve essere definita esplicitamente e in sequenza, il che rende il codice più lungo e difficile da leggere.\n\nPython:\n\nAlto livello di astrazione: Python fornisce un’astrazione più elevata sia dei dati che delle istruzioni, permettendo di ignorare i dettagli dei diversi hardware.\nElevata semplicità: Il codice è più breve e leggibile, facilitando la comprensione e la manutenzione.\nElevata versatilità: Il linguaggio è applicabile senza modifiche a un elevato numero di architetture hardware-software.\nProduttività: I programmatori possono concentrarsi sulla complessità intrinseca del problema, senza preoccuparsi di molti dettagli implementativi del processo di esecuzione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-procedurale",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-procedurale",
    "title": "2  I paradigmi di programmazione",
    "section": "2.3 Paradigma procedurale",
    "text": "2.3 Paradigma procedurale\nLa programmazione procedurale è un paradigma di programmazione, derivato da quella imperativa, che organizza il codice in unità chiamate procedure o funzioni. Ogni procedura o funzione è un blocco di codice che può essere richiamato da altre parti del programma, promuovendo la riutilizzabilità e la modularità del codice.\nLa programmazione procedurale è una naturale evoluzione della imperativa e uno dei paradigmi più antichi e ampiamente utilizzati. Ha avuto origine negli anni ’60 e ’70 con linguaggi come Fortan, COBOL e C, tutt’oggi rilevanti. Questi linguaggi hanno introdotto concetti fondamentali come funzioni, sottoprogrammi e la separazione tra codice e dati. Il C, in particolare, ha avuto un impatto duraturo sulla programmazione procedurale, diventando uno standard de facto per lo sviluppo di sistemi operativi e software di sistema.\nI vantaggi principali sono:\n\nModularità: La programmazione procedurale incoraggia la suddivisione del codice in funzioni o procedure più piccole e gestibili. Questo facilita la comprensione, la manutenzione e il riutilizzo del codice.\nRiutilizzabilità: Le funzioni possono essere riutilizzate in diverse parti del programma o in progetti diversi, riducendo la duplicazione del codice e migliorando l’efficienza dello sviluppo.\nStruttura e organizzazione: Il codice procedurale è generalmente più strutturato e organizzato, facilitando la lettura e la gestione del progetto software.\nFacilità di debug e testing: La suddivisione del programma in funzioni isolate rende più facile individuare e correggere errori, oltre a testare parti specifiche del codice.\n\nD’altro canto, presenta anche degli svantaggi che hanno spinto i ricercatori a continuare l’innovazione:\n\nScalabilità limitata: Nei progetti molto grandi, la programmazione procedurale può diventare difficile da gestire. La mancanza di meccanismi di astrazione avanzati, come quelli offerti dalla programmazione orientata agli oggetti, può complicare la gestione della complessità.\nGestione dello stato: La programmazione procedurale si basa spesso su variabili globali per condividere stato tra le funzioni, il che può portare a bug difficili da individuare e risolvere.\nDifficoltà nell’aggiornamento: Le modifiche a una funzione possono richiedere aggiornamenti in tutte le parti del programma che la utilizzano, aumentando il rischio di introdurre nuovi errori.\nMeno Adatta per Applicazioni Moderne: Per applicazioni complesse e moderne che richiedono la gestione di eventi, interfacce utente complesse e modellazione del dominio, la programmazione procedurale può essere meno efficace rispetto ad altri paradigmi come quello orientato agli oggetti.\n\n\n2.3.1 Funzioni e procedure\nNella programmazione procedurale, il codice è suddiviso in unità elementari chiamate funzioni e procedure. La differenza principale tra le due è la seguente:\n\nFunzione: Una funzione è un blocco di codice che esegue un compito specifico e restituisce un valore. Le funzioni sono utilizzate per calcoli o operazioni che producono un risultato. Ad esempio, una funzione che calcola la somma di due numeri in linguaggio C:\nint somma(int a, int b) {\n  return a + b;\n}\nProcedura: Una procedura è simile a una funzione, ma non restituisce un valore. È utilizzata per eseguire azioni o operazioni che non necessitano di un risultato. Ad esempio, una procedura che stampa un messaggio in Pascal:\nprocedure stampaMessaggio;\nbegin\n  writeln('Ciao, Mondo!');\nend;\n\n\n\n2.3.2 Creazione di librerie\nUn altro aspetto importante della programmazione procedurale è la possibilità di creare librerie, che sono collezioni di funzioni e procedure riutilizzabili. Le librerie permettono di organizzare e condividere codice comune tra diversi progetti, aumentando la produttività e riducendo la duplicazione del codice, nonché abilitando un modello commerciale che mette a disposizione del software prodotto da aziende o comunità specializzate.\nEsempio di una semplice libreria ipotetica di somme in C:\n\nFile header (mialibreria.h):\n#ifndef MIALIBRERIA_H\n#define MIALIBRERIA_H\n\nint somma_interi(int a, int b);\n\nchar* somma_stringhe(const char* a, const char* b);\n\nint somma_array(int arr[], int n);\n\nvoid stampa_messaggio(const char* messaggio, \n                      void* risultato, \n                      char tipo);\n\n#endif\nFile di implementazione (mialibreria.c):\n#include \"mialibreria.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint somma_interi(int a, int b) {\n  return a + b;\n}\n\nchar* somma_stringhe(const char* a, const char* b) {\n1  char* risultato = malloc(strlen(a) + strlen(b) + 1);\n\n2  if (risultato) {\n3    strcpy(risultato, a);\n4    strcat(risultato, b);\n  }\n\n  return risultato;\n}\n\nint somma_array_interi(int arr[], int n) {\n  int somma = 0;\n\n  for (int i = 0; i &lt; n; i++) {\n    somma += arr[i];\n  }\n\n  return somma;\n}\n\nvoid stampa_messaggio(const char* messaggio, \n                      void* risultato, \n                      char tipo) {\n  printf(\"%s\", messaggio);\n\n  if (tipo == 'i') {\n5    printf(\"%d\\n\", *(int*)risultato);\n  } else if (tipo == 's') {\n6    printf(\"%s\\n\", (char*)risultato);\n  }\n}\n\n1\n\nAllocazione della memoria per la somma delle due stringhe e +1 per il carattere di terminazione \\0.\n\n2\n\nControllo se la funzione malloc ha avuto successo nell’allocare la memoria richiesta. Se risultato è NULL, significa che malloc ha fallito e il blocco di codice all’interno dell’if viene saltato, evitando così di tentare di accedere a memoria non valida.\n\n3\n\nSe l’allocazione ha avuto successo, copia la prima stringa nel risultato.\n\n4\n\nConcatenazione della seconda stringa nel risultato.\n\n5\n\nStampa del risultato se il tipo è intero.\n\n6\n\nStampa del risultato se il tipo è una stringa.\n\n\nFile principale (main.c):\n#include \"mialibreria.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n1  int risultato = somma_interi(5, 3);\n  stampa_messaggio(\"Il risultato della somma di interi è: \", \n                   &risultato, 'i');\n\n2  char* risultato_stringhe = somma_stringhe(\"Ciao, \", \"mondo!\");\n  stampa_messaggio(\"Il risultato della somma di stringhe è: \", \n                   risultato_stringhe, 's');\n3  free(risultato_stringhe);\n\n  int array[] = {1, 2, 3, 4, 5}; \n4  int risultato_array = somma_array_interi(array, 5);\n  stampa_messaggio(\"Il risultato della somma dell'array di interi è: \", \n                   &risultato_array, 'i');\n\n  return 0;\n}\n\n1\n\nChiamata della funzione per la somma di due interi.\n\n2\n\nChiamata della funzione per la somma di due stringhe (implementata come una concatenazione).\n\n3\n\nLiberazione della memoria allocata per la stringa risultante.\n\n4\n\nChiamata della funzione per la somma di un array di interi.\n\n\n\nE il medesimo, ma in Python:\ndef somma_interi(a, b):\n  return a + b\n\n1def somma_stringhe(a, b):\n  return a + b\n\n2def somma_array(arr):\n3  return sum(arr)\n\nrisultato_interi = somma_interi(3, 5)\nprint(f\"Il risultato della somma di interi è: {risultato_interi}\")\n\nrisultato_stringhe = somma_stringhe(\"Ciao, \", \"mondo!\")\nprint(f\"Il risultato della somma di stringhe è: {risultato_stringhe}\")\n\narray_interi = [1, 2, 3, 4, 5]\nrisultato_array = somma_array(array_interi) \nprint(f\"Il risultato della somma dell'array è: {risultato_array}\")\n\n1\n\nIl codice di somma_interi e somma_stringhe è identico e questo ci suggerisce che una delle due è ridondante.\n\n2\n\nLa funzione ora prende in input solo l’array e non c’è bisogno di inserire anche la sua dimensione.\n\n3\n\nIn Python, per evitare errori quando si usa la funzione sum, l’array (o lista) deve contenere elementi che supportano l’operazione di addizione tra di loro. Tipicamente, si usano numeri (interi o a virgola mobile), ma è possibile anche sommare altri tipi di elementi se l’operazione di addizione è definita per quel tipo di dato.\n\n\nAnche qui Python appare più semplice e immediato, sicuramente vincente sul piano della comprensione del codice e della immediatezza di utilizzo. In realtà, Python e C hanno sia una forte complementarietà sulle applicazioni, sia una dipendenza perché molte librerie e l’interprete stesso di Python sono in C.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-di-orientamento-agli-oggetti",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-di-orientamento-agli-oggetti",
    "title": "2  I paradigmi di programmazione",
    "section": "2.4 Paradigma di orientamento agli oggetti",
    "text": "2.4 Paradigma di orientamento agli oggetti\nLa programmazione orientata agli oggetti (in inglese object-oriented programming, OOP) è un paradigma di programmazione che organizza il software in termini di oggetti, ciascuno dei quali rappresenta un’istanza di una matrice detta classe. Una classe definisce un tipo di dato che include attributi (dati) e metodi (funzionalità). Gli oggetti interagiscono tra loro attraverso messaggi, permettendo una struttura modulare e intuitiva.\nL’OOP è emersa negli anni ’60 e ’70 con il linguaggio Simula, il primo linguaggio di programmazione a supportare questo paradigma. Tuttavia, è stato con Smalltalk, sviluppato negli anni ’70 da Alan Kay e altri presso Xerox PARC, che l’OOP ha guadagnato popolarità. Il paradigma è stato ulteriormente consolidato con il linguaggio C++ negli anni ’80 e con Java negli anni ’90, rendendolo uno dei più utilizzati per lo sviluppo software moderno. Oggi numerosi sono i linguaggi a oggetti, ad esempio Python, C#, Ruby, Java, Swift, Javascript, ecc. ed altri lo supportano come PHP (dalla versione 5) e financo il Fortran nella versione 2003.\nRispetto ai paradigmi precedenti, l’OOP introduce diversi concetti chiave che ineriscono al disegno architetturale di software:\n\nClasse e oggetto: La classe è un modello o schema per creare oggetti. Contiene definizioni di attributi e metodi. L’oggetto è un’istanza di una classe e rappresenta un’entità concreta nel programma con stato e comportamento mutevoli.\nIncapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie agli altri oggetti. Migliora la modularità e protegge l’integrità dei dati.\nEreditarietà (relazione is-a): Permette a una classe di estenderne un’altra, ereditandone attributi e metodi. Favorisce il riuso del codice e facilita l’estensione delle funzionalità. Si usa quando una classe può essere considerata una specializzazione di un’altra. Ad esempio, un Gatto è un Animale, quindi la classe Gatto eredita dalla classe Animale.\nPolimorfismo: Consente a oggetti di classi diverse di essere trattati come oggetti di una classe comune. Facilita l’uso di un’interfaccia uniforme per operazioni diverse. Il polimorfismo è strettamente legato all’ereditarietà e permette di usare un metodo in modi diversi a seconda dell’oggetto che lo invoca. Ad esempio, un metodo muovi() può comportarsi diversamente se invocato su un oggetto di classe Gatto rispetto a un oggetto di classe Uccello, ma entrambi sono trattati come Animale.\nAstrazione: Permette di definire interfacce di alto livello per oggetti, senza esporre i dettagli implementativi. Facilita la comprensione e la gestione della complessità del sistema, perché, assieme a ereditarietà e polimorfismo, permette di pensare in modo più naturale, basando la decomposizione del problema anche su relazioni di tipo gerarchico e concettuale. Attraverso l’astrazione, si definiscono classi e interfacce che rappresentano concetti generici, come Forma o Veicolo, senza specificare i dettagli concreti delle implementazioni.\nComposizione (relazione has-a): Permette a una classe di contenere altre classi come parte dei suoi attributi. È una forma di relazione che indica che un oggetto è composto da uno o più oggetti di altre classi. Si usa quando una classe ha bisogno di utilizzare funzionalità di altre classi ma non rappresenta una specializzazione di quelle classi. Ad esempio, una classe Auto può avere un oggetto Motore come attributo, indicando che un’Auto ha un Motore.\n\nI vantaggi principali dell’OOP sono:\n\nModularità: Le classi e gli oggetti favoriscono la suddivisione del codice in moduli indipendenti, in una forma più granulare rispetto al paradigma procedurale. Non solo le istruzioni sono raggruppate per soddisfare una specifica operazione, ma possono essere viste come più operazioni su uno stato associato. La modularità è rafforzata dalle relazioni has-a e is-a, che aiutano a organizzare il codice in componenti logicamente separati e interconnessi.\nRiutilizzabilità: L’uso di classi e l’ereditarietà (relazione is-a) consentono di riutilizzare il codice in nuovi progetti senza riscriverlo, limitando gli effetti collaterali sul codice con cui interagiscono. Le classi base possono essere estese per creare nuove classi con funzionalità aggiuntive, mantenendo al contempo la compatibilità con il codice esistente.\nFacilità di manutenzione: L’incapsulamento e l’astrazione riducono la complessità perché permettono una migliore assegnazione logica dei principi usati nella progettazione dell’applicazione alle singole classi. Ciò facilita la manutenzione del codice, poiché nella modifica si possono individuare rapidamente le istruzioni impattate. La relazione has-a contribuisce ulteriormente alla manutenzione isolando le responsabilità all’interno delle classi.\nEstendibilità: Le classi possono essere estese (relazione is-a) per aggiungere nuove funzionalità senza modificare il codice già preesistente, riducendo così gli impatti per il codice che ne dipende. Questo approccio facilita l’integrazione di nuove caratteristiche e miglioramenti, mantenendo la stabilità del sistema.\n\nAnche se sussistono dei caveat:\n\nComplessità iniziale: L’OOP può essere complesso da apprendere e implementare correttamente per i nuovi programmatori.\nOverhead di prestazioni: L’uso intensivo di oggetti può introdurre un overhead di memoria e prestazioni rispetto alla programmazione procedurale.\nAbuso di ereditarietà: L’uso improprio dell’ereditarietà può portare a gerarchie di classi troppo complesse e difficili da gestire, quindi, producendo un effetto opposto ad una delle ragioni di esistenza del concetto, cioè la semplicità di comunicazione della progettazione del software.\n\n\n2.4.1 Esempio in Java\nIn questo esempio, la classe Animale rappresenta una tipo di dato generico con un attributo nome e un metodo faiVerso. La classe Cane specializza Animale, usando l’attributo nome e sovrascrivendo il metodo faiVerso, per fornire un’implementazione coerente colle sue caratteristiche. La classe Main crea un’istanza di Cane e chiama il suo metodo faiVerso (annotato con @Override1), dimostrando il polimorfismo e l’ereditarietà:\n1 In Java, l’annotazione @Override è opzionale, ma altamente consigliata. Non omettere l’annotazione @Override non causerà un errore di compilazione o di runtime. Tuttavia, l’uso di @Override offre dei vantaggi importanti perché, innanzitutto, il compilatore può verificare che il metodo stia effettivamente sovrascrivendo uno nella classe base e segnalare un errore in caso contrario. Inoltre, l’annotazione migliora la leggibilità del codice perché indica chiaramente al lettore come il metodo è inteso rispetto all’ereditarietà.1class Animale {\n  String nome;\n\n  Animale(String nome) {\n    this.nome = nome;\n  }\n\n  void faiVerso() {\n    System.out.println(\"L'animale fa un verso\");\n  }\n}\n\n2class Cane extends Animale {\n\n  Cane(String nome) {\n    super(nome);\n  }\n\n3  @Override\n  void faiVerso() {\n    System.out.println(\"Il cane abbaia\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Animale mioCane = new Cane(\"Fido\");\n\n4    mioCane.faiVerso();\n  }\n}\n\n1\n\nDefinizione della classe Animale che ha il doppio compito di provvedere all’implementazione per una caratteristica comune (nome e descrizione()) e una particolare (faiVerso()).\n\n2\n\nDefinizione della classe derivata Cane.\n\n3\n\n@Override indica in esplicito che il faiVerso() del Cane sovrascrive (non eredita) il faiVerso() di Animale.\n\n4\n\nOutput: Il cane abbaia.\n\n\nIn realtà, se gli oggetti devono rappresentare animali reali vorrà dire che non deve essere possibile crearne dalla matrice Animale. Vediamo, quindi, come implementare il medesimo esempio con una classe astratta, cioè una classe che non può essere usata per generare direttamente oggetti, sempre in Java.\nNel caso pratico, ogni animale ha il suo verso, quindi dobbiamo costringere il programmatore che vuole implementare classi corrispondenti ad animali reali, ad aggiungere tassativamente il metodo faiVerso() per comunicarne la caratteristica distintiva. Una modalità è marchiare Animale e il suo metodo da caratterizzare (faiVerso()), con costrutti ad hoc perché siano, rispettivamente, identificata come classe astratta (per mezzo della parola riservata abstract) e metodo da implementare. Al contempo, Cane non subisce specifiche modifiche sintattiche, ma deve rispettare il vincolo (implementare faiVerso()) perché, ereditando le caratteristiche di Animale, possa essere una classe concreta, cioè da cui si possono creare oggetti. Il codice risultate è:\n1abstract class Animale {\n  String nome;\n\n  Animale(String nome) {\n    this.nome = nome;\n  }\n\n2  abstract String faiVerso();\n\n3  String descrizione() {\n    return \"L'animale si chiama \" + nome;\n  }\n}\n\n4class Cane extends Animale {\n\n  Cane(String nome) {\n    super(nome);\n  }\n\n  @Override\n  String faiVerso() {\n    return \"Il cane abbaia\";\n  }\n}\n\n5class Coccodrillo extends Animale {\n\n  Coccodrillo(String nome) {\n    super(nome);\n  }\n\n  @Override\n6  String faiVerso() {\n    return \"\";  \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Animale mioCane = new Cane(\"Fido\");\n\n7    System.out.println(mioCane.descrizione());\n8    System.out.println(mioCane.faiVerso());\n\n    Animale mioCoccodrillo = new Coccodrillo(\"Crocky\");\n\n9    System.out.println(mioCoccodrillo.descrizione());\n10    System.out.println(mioCoccodrillo.faiVerso());\n  }\n}\n\n1\n\nDefinizione della classe astratta che ha il doppio compito di fornire una implementazione di default per una caratteristica comune (nome) e un vincolo di implementazione nelle classe derivate per una seconda caratteristica comune non implementabile nello stesso modo per tutte (faiVerso()).\n\n2\n\nMetodo astratto faiVerso() che le classi corrispondenti ad animali reali dovranno implementare e che dovrà resituire una stringa.\n\n3\n\nMetodo concreto faiVerso() che restituisce una stringa.\n\n4\n\nDefinizione della classe derivata Cane.\n\n5\n\nDefinizione della classe derivata Coccodrillo.\n\n6\n\nIl coccodrillo non emette versi!\n\n7\n\nStampa: L'animale si chiama Fido.\n\n8\n\nStampa: Il cane abbaia.\n\n9\n\nStampa: L'animale si chiama Crocky.\n\n10\n\nNon stampa nulla perché il coccodrillo non emette versi!\n\n\n\n\n2.4.2 Template\nI template, o generics, non sono specifici dell’OOP, anche se sono spesso associati a essa. I template permettono di scrivere funzioni, classi, e altri costrutti di codice in modo generico, cioè indipendente dal tipo dei dati che manipolano. Questo concetto è particolarmente utile per creare librerie e moduli riutilizzabili e flessibili.\nAd esempio, definiamo la classe Box nel modo seguente:\n1template &lt;typename T&gt;\n2class Box {\n3  T value;\n\npublic:\n4  void setValue(T val) { value = val; }\n\n5  T getValue() { return value; }\n};\n\n1\n\nLa keyword template definisce un template di classe che può lavorare con qualsiasi tipo T specificato al momento dell’uso.\n\n2\n\nDichiarazione della classe Box che utilizza il template di tipo T.\n\n3\n\nDichiarazione del membro dati value di tipo T, che rappresenta il valore contenuto nella scatola.\n\n4\n\nMetodo pubblico setValue che imposta il valore del membro dati value con il parametro val di tipo T.\n\n5\n\nMetodo pubblico getValue che restituisce il valore del membro dati value di tipo T.\n\n\nBox può contenere un valore di qualsiasi tipo specificato al momento della creazione dell’istanza per mezzo del template T:\n1Box&lt;int&gt; intBox;\n\n2intBox.setValue(123);\n3int x = intBox.getValue();\n\n4Box&lt;std::string&gt; stringBox;\n\n5stringBox.setValue(\"Hello, World!\");\n6std::string str = stringBox.getValue();\n\n1\n\nCreazione di un’istanza di Box con tipo int, chiamata intBox.\n\n2\n\nChiamata del metodo setValue per impostare il valore di intBox a 123.\n\n3\n\nChiamata del metodo getValue per ottenere il valore di intBox e assegnarlo alla variabile x di tipo int.\n\n4\n\nCreazione di un’istanza di Box con tipo std::string, chiamata stringBox.\n\n5\n\nChiamata del metodo setValue per impostare il valore di stringBox a \"Hello, World!\".\n\n6\n\nChiamata del metodo getValue per ottenere il valore di stringBox e assegnarlo alla variabile str di tipo std::string.\n\n\nAnche nei linguaggi non orientati agli oggetti, i template trovano applicazione. Ad esempio, in Rust, un linguaggio di programmazione sistemistica non puramente OOP, il codice seguente restituisce il valore più grande di una lista:\n1fn largest&lt;T: PartialOrd&gt;(list: &[T]) -&gt; &T {\n2    let mut largest = &list[0];\n\n3    for item in list {\n4        if item &gt; largest {\n5            largest = item;\n        }\n    }\n6    largest\n}\n\n7fn main() {\n8    let numbers = vec![34, 50, 25, 100, 65];\n9    let max = largest(&numbers);\n\n10    println!(\"The largest number is {}\", max);\n}\n\n1\n\nDefinizione della funzione generica largest che accetta una lista di riferimenti a un tipo T che implementa il tratto PartialOrd e restituisce un riferimento a un valore di tipo T.\n\n2\n\nInizializzazione della variabile largest con il primo elemento della lista.\n\n3\n\nIterazione attraverso ogni elemento della lista.\n\n4\n\nControllo se l’elemento corrente item è maggiore di largest.\n\n5\n\nSe item è maggiore, aggiornamento della variabile largest con item.\n\n6\n\nRestituzione di largest, che è il riferimento al più grande elemento trovato nella lista.\n\n7\n\nDefinizione della funzione main, punto di ingresso del programma.\n\n8\n\nCreazione di un vettore di numeri interi numbers.\n\n9\n\nChiamata della funzione largest con un riferimento a numbers e assegnazione del risultato a max.\n\n10\n\nStampa del valore più grande trovato nella lista usando la macro println!.\n\n\n\n\n2.4.3 Metaprogrammazione\nLa metaprogrammazione è un paradigma che consente al programma di trattare il codice come dati, permettendo al codice di generare, manipolare o eseguire altro codice. Anche questo concetto non è esclusivo dell’OOP. In C++, la metaprogrammazione è strettamente legata ai template. Un esempio classico è la template metaprogramming (TMP), che permette di eseguire calcoli a tempo di compilazione.\nUn esempio è il codice seguente di calcolo del fattoriale:\ntemplate&lt;int N&gt;\nstruct Factorial {\n1    static const int value = N * Factorial&lt;N - 1&gt;::value;\n};\n\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt; {\n2    static const int value = 1;\n};\n\n1\n\nQuesta riga definisce un membro statico value della struttura Factorial. Per un dato N, il valore viene calcolato come N moltiplicato per il valore del fattoriale di N - 1. Questo è un esempio di ricorsione a livello di metaprogrammazione template.\n\n2\n\nQuesta riga è una specializzazione del template Factorial per il caso base quando N è 0. In questo caso, value è definito come 1, terminando la ricorsione template.\n\n\nLa metaprogrammazione è presente anche in linguaggi non OOP come Lisp, che utilizza le macro per trasformare e generare codice. Un esempio è il codice proposto di seguito dove è definita la macro when, che prende due parametri in input, cioè test e body, ove test è un’espressione condizionale e body un insieme di istruzioni da eeseguire se la condizione è vera:\n(defmacro when (test &rest body)  \n  `(if ,test                      \n       (progn ,@body)))           \nCommento riga per riga:\n\nDefinizione di una macro chiamata when, che accetta un test e un numero variabile di espressioni (body).\nLa macro espande in un’espressione if che valuta test. Se test è vero, esegue le espressioni contenute in body.\nprogn è utilizzato per racchiudere ed eseguire tutte le espressioni in body in sequenza. L’operatore ,@ è usato per spalmare gli elementi di body nell’espressione progn.\n\nVediamo un esempio pratico di come si utilizza la macro when. Il test è valutare se x è maggiore di 10 e, nel caso, stampare \"x is greater than 10\" e poi assegnare x a 0. Chiamiamo la macro con i due parametri:\n(when (&gt; x 10)                      \n  (print \"x is greater than 10\")     \n  (setf x 0))                        \nCommento riga per riga:\n\nInvocazione della macro when con la condizione &gt; x 10.\nSe la condizione è vera, viene eseguita l’istruzione (print \"x is greater than 10\"), che stampa il messaggio.\nSuccessivamente, viene eseguita l’istruzione (setf x 0), che assegna il valore 0 a x.\n\nQuesto viene espanso in:\n(if (&gt; x 10)                        \n    (progn                        \n      (print \"x is greater than 10\") \n      (setf x 0)))                   \nCommento riga per riga:\n\nL’istruzione if valuta la condizione &gt; x 10.\nSe la condizione è vera, viene eseguito il blocco progn.\nAll’interno del blocco progn, viene eseguita l’istruzione (print \"x is greater than 10\").\nInfine, viene eseguita l’istruzione (setf x 0) all’interno del blocco progn.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-dichiarativo",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-dichiarativo",
    "title": "2  I paradigmi di programmazione",
    "section": "2.5 Paradigma dichiarativo",
    "text": "2.5 Paradigma dichiarativo\nLa programmazione dichiarativa è un paradigma di programmazione che si focalizza sul cosa deve essere calcolato piuttosto che sul come calcolarlo. In altre parole, i programmi dichiarativi descrivono il risultato desiderato senza specificare esplicitamente i passaggi per ottenerlo. Questo è in netto contrasto con la programmazione imperativa, dove si fornisce una sequenza dettagliata di istruzioni per modificare lo stato del programma.\nLa programmazione dichiarativa ha radici nella logica e nella matematica, ed è emersa come un importante paradigma negli anni ’70 e ’80 con l’avvento di linguaggi come Prolog (per la programmazione logica) e SQL (per la gestione dei database). La programmazione funzionale, con linguaggi come Haskell, è anch’essa una forma di programmazione dichiarativa.\nI concetti principali associati alla programazione dichiarativa sono:\n\nDescrizione del risultato: I programmi dichiarativi descrivono le proprietà del risultato desiderato senza specificare l’algoritmo per ottenerlo. Esempio: In SQL, per ottenere tutti i record di una tabella con un certo valore, si scrive una query che descrive la condizione, non un algoritmo che scorre i record uno per uno.\nAssenza di stato esplicito: La programmazione dichiarativa evita l’uso esplicito di variabili di stato e di aggiornamenti di stato. Ciò riduce i rischi di effetti collaterali e rende il codice più facile da comprendere e verificare.\nIdempotenza: Le espressioni dichiarative sono spesso idempotenti, cioè possono essere eseguite più volte senza cambiare il risultato. Questo è particolarmente utile per la concorrenza e la parallelizzazione.\n\nIl vantaggio principale è relativo alla sua chiarezza perché ci si concentra sul risultato desiderato piuttosto che sui dettagli di implementazione.\nLa programmazione imperativa specifica come ottenere un risultato mediante una sequenza di istruzioni, modificando lo stato del programma. La programmazione dichiarativa, al contrario, specifica cosa deve essere ottenuto senza descrivere i dettagli di implementazione. In termini di livello di astrazione, la programmazione dichiarativa si trova a un livello superiore rispetto a quella imperativa.\n\n2.5.1 Linguaggi\nEcco una lista di alcuni linguaggi di programmazione dichiarativi:\n\nSQL (Structured Query Language): Utilizzato per la gestione e l’interrogazione di database relazionali.\nProlog: Un linguaggio di programmazione logica usato principalmente per applicazioni di intelligenza artificiale e linguistica computazionale.\nHTML (HyperText Markup Language): Utilizzato per creare e strutturare pagine web.\nCSS (Cascading Style Sheets): Utilizzato per descrivere la presentazione delle pagine web scritte in HTML o XML.\nXSLT (Extensible Stylesheet Language Transformations): Un linguaggio per trasformare documenti XML in altri formati.\nHaskell: Un linguaggio funzionale che è anche dichiarativo, noto per la sua pura implementazione della programmazione funzionale.\nErlang: Un linguaggio utilizzato per sistemi concorrenti e distribuiti, con caratteristiche dichiarative.\nVHDL (VHSIC Hardware Description Language): Utilizzato per descrivere il comportamento e la struttura di sistemi digitali.\nVerilog: Un altro linguaggio di descrizione hardware usato per la modellazione di sistemi elettronici.\nXQuery: Un linguaggio di query per interrogare documenti XML.\n\nQuesti linguaggi rappresentano diversi ambiti di applicazione, dai database alla descrizione hardware, e sono accomunati dall’approccio dichiarativo nel quale si specifica cosa ottenere piuttosto che come ottenerlo.\n\n\n\n\n\n\nNota\n\n\n\nSQL è uno degli esempi più diffusi di linguaggio di programmazione dichiarativo. Le query SQL descrivono i risultati desiderati piuttosto che le procedure operative.\nUna stored procedure in PL/SQL (Procedural Language/SQL) combina SQL con elementi di linguaggi di programmazione procedurali come blocchi di codice, condizioni e cicli. PL/SQL è quindi un linguaggio procedurale, poiché consente di specificare “come” ottenere i risultati attraverso un flusso di controllo esplicito, rendendolo non puramente dichiarativo. PL/SQL è utilizzato principalmente con il database Oracle.\nUn’alternativa a PL/SQL è T-SQL (Transact-SQL), utilizzato con Microsoft SQL Server e Sybase ASE. Anche T-SQL estende SQL con funzionalità procedurali simili, consentendo la scrittura di istruzioni condizionali, cicli e la gestione delle transazioni. Come PL/SQL, T-SQL è un linguaggio procedurale e non puramente dichiarativo.\nEsistono anche estensioni ad oggetti come il PL/pgSQL (Procedural Language/PostgreSQL) per il database PostgreSQL.\n\n\n\n\n2.5.2 Esempi\nEsempio di una query SQL che estrae tutti i nomi degli utenti con età maggiore di 30:\nCertamente! Ecco il codice SQL con i commenti identificati da un ID progressivo e l’elenco esplicativo:\n1SELECT nome\n2FROM utenti\n3WHERE età &gt; 30;\n\n1\n\nSeleziona la colonna nome.\n\n2\n\nDalla tabella utenti.\n\n3\n\nPer le righe dove la colonna età è maggiore di 30.\n\n\nIn Prolog, si definiscono fatti e regole che descrivono relazioni logiche. Il motore di inferenza di Prolog utilizza queste definizioni per risolvere query, senza richiedere un algoritmo dettagliato. Di seguito, sono definiti due fatti (le prime due righe) e due regole (la terza e la quarta) e quindi si effettua una query che dà come risultato true:\ngenitore(padre, figlio). \ngenitore(madre, figlio).  \nantenato(X, Y) :- genitore(X, Y).  \nantenato(X, Y) :- genitore(X, Z), antenato(Z, Y).  \n\n?- antenato(padre, figlio). \nCommento riga per riga:\n\nQuesta regola dichiara che padre è genitore di figlio.\nQuesta regola dichiara che madre è genitore di figlio.\nQuesta regola stabilisce che X è antenato di Y se X è genitore di Y.\nQuesta regola stabilisce che X è antenato di Y se X è genitore di Z e Z è antenato di Y.\nRiga vuota.\nQuesta è una query che chiede se padre è un antenato di figlio.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-funzionale",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-funzionale",
    "title": "2  I paradigmi di programmazione",
    "section": "2.6 Paradigma funzionale",
    "text": "2.6 Paradigma funzionale\nLa programmazione funzionale è un paradigma di programmazione che tratta il calcolo come la valutazione di funzioni matematiche ed evita lo stato mutabile e i dati modificabili. I programmi funzionali sono costruiti applicando e componendo funzioni. Questo paradigma è stato ispirato dal calcolo lambda, una formalizzazione matematica del concetto di funzione. La programmazione funzionale è un paradigma alternativo alla programmazione imperativa, che descrive la computazione come una sequenza di istruzioni che modificano lo stato del programma.\nLa programmazione funzionale ha radici storiche che risalgono agli anni ’30, con il lavoro di Alonzo Church sul calcolo lambda. I linguaggi di programmazione funzionale hanno iniziato a svilupparsi negli anni ’50 e ’60 con Lisp, ma è stato negli anni ’70 e ’80 che linguaggi come ML e Haskell hanno consolidato questo paradigma. Haskell, in particolare, è stato progettato per esplorare nuove idee in programmazione funzionale e ha avuto un impatto significativo sulla ricerca e sulla pratica del software.\nLa programmazione funzionale è una forma di programmazione dichiarativa che si basa su funzioni pure e immutabilità. Entrambi i paradigmi evitano stati mutabili e si concentrano sul risultato finale, ma la programmazione funzionale utilizza funzioni matematiche come unità fondamentali di calcolo.\nConcetti fondamentali:\n\nImmutabilità: I dati sono immutabili, il che significa che una volta creati non possono essere modificati. Questo riduce il rischio di effetti collaterali e rende il codice più prevedibile.\nFunzioni di prima classe e di ordine superiore: Le funzioni possono essere passate come argomenti a altre funzioni, ritornate da funzioni, e assegnate a variabili. Le funzioni di ordine superiore accettano altre funzioni come argomenti o restituiscono funzioni.\nPurezza: Le funzioni pure sono funzioni che, dato lo stesso input, restituiscono sempre lo stesso output e non causano effetti collaterali. Questo rende il comportamento del programma più facile da comprendere e prevedere.\nTrasparenza referenziale: Un’espressione è trasparentemente referenziale se può essere sostituita dal suo valore senza cambiare il comportamento del programma. Questo facilita l’ottimizzazione e il reasonig sul codice.\nRicorsione: È spesso utilizzata al posto di loop iterativi per eseguire ripetizioni, poiché si adatta meglio alla natura immutabile dei dati e alla definizione di funzioni.\nComposizione di funzioni: Consente di costruire funzioni complesse combinando funzioni più semplici. Questo favorisce la modularità e la riusabilità del codice.\n\nIl paradigma funzionale ha diversi vantaggi:\n\nPrevedibilità e facilità di test: Le funzioni pure e l’immutabilità rendono il codice più prevedibile e più facile da testare, poiché non ci sono stati mutabili o effetti collaterali nascosti.\nConcorrenza: La programmazione funzionale è ben adatta alla programmazione concorrente e parallela, poiché l’assenza di stato mutabile riduce i problemi di sincronizzazione e competizione per le risorse.\nModularità e riutilizzabilità: La composizione di funzioni e la trasparenza referenziale facilitano la creazione di codice modulare e riutilizzabile.\n\nE qualche svantaggio:\n\nCurva di apprendimento: La programmazione funzionale può essere difficile da apprendere per chi proviene da paradigmi imperativi o orientati agli oggetti, a causa dei concetti matematici sottostanti e della diversa mentalità necessaria.\nPrestazioni: In alcuni casi, l’uso intensivo di funzioni ricorsive può portare a problemi di prestazioni, come il consumo di memoria per le chiamate ricorsive. Tuttavia, molte implementazioni moderne offrono ottimizzazioni come la ricorsione di coda (in inglese, tail recursion).\nDisponibilità di librerie e strumenti: Alcuni linguaggi funzionali potrebbero non avere la stessa ampiezza di librerie e strumenti disponibili rispetto ai linguaggi imperativi più diffusi.\n\n\n2.6.1 Linguaggi\nOltre a Haskell, ci sono molti altri linguaggi funzionali, tra cui:\n\nErlang: Utilizzato per sistemi concorrenti e distribuiti.\nElixir: Costruito a partire da Erlang, è utilizzato per applicazioni web scalabili.\nF#: Parte della piattaforma .NET, combina la programmazione funzionale con lo OOP.\nScala: Anch’esso combina programmazione funzionale e orientata agli oggetti ed è interoperabile con Java.\nOCaml: Conosciuto per le sue prestazioni e sintassi espressiva.\nLisp: Uno dei linguaggi più antichi, multi-paradigma con forti influenze funzionali.\nClojure: Dialetto di Lisp per la JVM, adatto alla concorrenza.\nScheme: Dialetto di Lisp spesso usato nell’educazione.\nML: Linguaggio influente che ha portato allo sviluppo di OCaml e F#.\nRacket: Derivato da Scheme, usato nella ricerca accademica.\n\n\n\n2.6.2 Esempio in Haskell\nDi seguito due funzioni, la prima sumToN è pura e somma i primi n numeri. (*2) è una funzione che prende un argomento e lo moltiplica per 2 e ciò rende la seconda funzione applyFunction una vera funzione di ordine superiore, poiché accetta (*2) come argomento oltre ad una lista, producendo come risultato il raddoppio di tutti i suoi elementi:\nCertamente! Ecco il codice con i commenti identificati da un ID progressivo e l’elenco esplicativo che include le descrizioni:\nsumToN :: Integer -&gt; Integer\n1sumToN n = sum [1..n]\n\napplyFunction :: (a -&gt; b) -&gt; [a] -&gt; [b]\n2applyFunction f lst = map f lst\n\nmain = do\n3    print (sumToN 10)\n4    print (applyFunction (*2) [1, 2, 3, 4])\n\n1\n\nDefinizione di una funzione pura che calcola la somma dei numeri da 1 a n.\n\n2\n\nFunzione di ordine superiore che accetta una funzione e una lista.\n\n3\n\nNel main, stampa il risultato di sumToN 10, che è 55.\n\n4\n\nNel main, stampa il risultato di applyFunction (*2) [1, 2, 3, 4], che è [2, 4, 6, 8].",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html",
    "href": "prima-parte-sintassi.html",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "",
    "text": "3.1 Token\nGli elementi atomici della sintassi sono i token. Essi compongono tutte le istruzioni e possono essere sia prodotti dal programmatore che generati dall’analisi del testo da parte dell’interprete o compilatore. La comprensione di quali token siano validi, ci permette sia di scrivere istruzioni corrette, sia di sfruttare appieno i costrutti del linguaggio:\nUn lessema è una sequenza di caratteri nel programma sorgente che corrisponde al pattern di un token ed è identificata dall’analizzatore lessicale come un’istanza di quel token. Un token è una coppia composta da un nome di token e un valore attributo opzionale. Il nome del token è un simbolo astratto che rappresenta un tipo di unità lessicale, come una particolare parola chiave o una sequenza di caratteri di input che denota un identificatore. Un pattern è una descrizione della forma che possono assumere i lessemi di un token. Ad esempio, nel caso di una parola chiave come token, il pattern è semplicemente la sequenza di caratteri che forma la parola chiave. Per gli identificatori e altri token, il pattern è una struttura più complessa che corrisponde a molte stringhe.\nUn esempio per visualizzare i concetti introdotti:",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#token",
    "href": "prima-parte-sintassi.html#token",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "",
    "text": "Parole chiave: Sono termini riservati del linguaggio che hanno significati specifici e non possono essere utilizzati per altri scopi, come if, else, while, for, ecc.\nOperatori: Simboli utilizzati per eseguire operazioni su identificatori e letterali, come +, -, *, /, =, ==, ecc.\nDelimitatori: Caratteri utilizzati per separare elementi del codice, come punto e virgola (;), parentesi tonde (()), parentesi quadre ([]), parentesi graffe ({}), ecc.\nIdentificatori: Nomi utilizzati per identificare variabili, funzioni, classi, e altri oggetti.\nLetterali: Rappresentazioni di valori costanti nel codice, come numeri (123), stringhe (\"hello\"), caratteri ('a'), ecc.\nCommento: Non fanno parte della logica del programma e sono ignorati nell’esecuzione.\nSpazi e tabulazioni: Sono gruppi di caratteri non visualizzabili e spesso ignorati.\n\n\n\nif x == 10:\n\nToken coinvolti:\n\nif: Parola chiave.\nNAME: Identificatore.\nEQEQUAL: Operatore.\nNUMBER: Letterale numerico.\nCOLON: Delimitatore.\n\nLessemi:\n\nIl lessema per il token if è la sequenza di caratteri “if”.\nIl lessema per il token NAME è “x”.\nIl lessema per il token EQEQUAL è “==”.\nIl lessema per il token NUMBER “10”.\nIl lessema per il token COLON “:”.\n\nPattern:\n\nIl pattern per il token if è la stringa esatta “if”.\nIl pattern per un identificatore è una sequenza di lettere e numeri che inizia con una lettera.\nIl pattern per l’operatore == è la stringa esatta “==”.\nIl pattern per un letterale numerico è una sequenza di cifre.\nIl pattern per il delimitatore : è la stringa esatta “:”.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#analizzatore-lessicale-e-parser",
    "href": "prima-parte-sintassi.html#analizzatore-lessicale-e-parser",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.2 Analizzatore lessicale e parser",
    "text": "3.2 Analizzatore lessicale e parser\nL’analizzatore lessicale (o lexer) è un componente del compilatore o interprete che prende in input il codice sorgente del programma e lo divide in lessemi. Esso confronta ciascun lessema con i pattern definiti per il linguaggio di programmazione e genera una sequenza di token. Questi token sono poi passati al parser.\nAd esempio, il codice if x == 10: viene trasformato in una sequenza di token: [IF, NAME(x), EQEQUAL, NUMBER(10), COLON].\nIl parser è un altro componente del compilatore o interprete che prende in input la sequenza di token generata dall’analizzatore lessicale e verifica che la sequenza rispetti le regole sintattiche del linguaggio di programmazione. Il parser analizza i token per formare una struttura gerarchica che rappresenti le relazioni grammaticali tra di essi. Questa struttura interna è spesso un albero di sintassi (parse tree o syntax tree), che riflette la struttura grammaticale del codice sorgente, solitamente descritta usando una forma standard di notazione come la BNF (Backus-Naur Form) o varianti di essa 1. L’albero di sintassi ottenuto viene utilizzato per le successive fasi di compilazione o interpretazione, come quella di analisi semantica e di generazione del codice eseguibile. Ad esempio, il parser può verificare che le espressioni aritmetiche siano ben formate, che le istruzioni siano correttamente annidate e che le dichiarazioni di variabili siano valide.\n1 La BNF (Backus-Naur form o Backus normal form) è una metasintassi, ovvero un formalismo attraverso cui è possibile descrivere la sintassi di linguaggi formali (il prefisso meta ha proprio a che vedere con la natura circolare di questa definizione). Si tratta di uno strumento molto usato per descrivere in modo preciso e non ambiguo la sintassi dei linguaggi di programmazione, dei protocolli di rete e così via, benché non manchino in letteratura esempi di sue applicazioni a contesti anche non informatici e addirittura non tecnologici. Un esempio è la grammatica di Python.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#espressioni",
    "href": "prima-parte-sintassi.html#espressioni",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.3 Espressioni",
    "text": "3.3 Espressioni\nUn’espressione è una combinazione di lessemi che viene valutata per produrre un risultato. Le espressioni sono fondamentali nei linguaggi di programmazione perché permettono di eseguire calcoli, prendere decisioni e manipolare dati.\nEcco alcune tipologie di espressioni (notazioni in Python, ma non molto dissimili da altri linguaggi):\n\nEspressioni aritmetiche: Combinano letterali numerici, identificatori valorizzabili in numeri e operatori aritmetici per eseguire calcoli matematici. Esempi: 5 + 3, y / 4.0, \"Hello, \" + \"world!\".\nEspressioni logiche: Applicano operatori logici per valutare condizioni e produrre valori booleani (vero o falso) a letterali e identificatori. Esempi: x or 5, not y, a and b.\nEspressioni di confronto: Confrontano due valori usando operatori di confronto e restituiscono valori booleani, sempre a partire da letterali e identificatori. Esempi: x &lt; y, x != 42, a &gt;= b.\nEspressioni di chiamata a funzione: Invocano identificatori particolari, funzioni e metodi di oggetti, spesso con parametri definiti da identificatori e letterali, per eseguire operazioni più complesse. Esempi: max(a, b), sin(theta), my_function(x, 42).\nEspressioni di manipolazione di contenitori di dati: Creano e manipolano strutture dati come liste, dizionari, tuple e insiemi contenenti identificatori e letterali. Esempi: [1, x, 3], { 'key': 'value' }, ( 'y', 42 )\nEspressioni condizionali (ternarie): Valutano espressioni e restituiscono un valore basato sul risultato. Esempi: x if x &gt; y else y, 'Even' if n % 2 == 0 else 'Odd'.\n\nLe espressioni si possono comporre in espressioni più complesse come accade per quelle matematiche pur che siano rispettate le regole di compatibilità tra operatori, identificatori e letterali; esempio (x &lt; y) and sin(theta).",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#istruzioni-semplici",
    "href": "prima-parte-sintassi.html#istruzioni-semplici",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.4 Istruzioni semplici",
    "text": "3.4 Istruzioni semplici\nLe istruzioni semplici sono operazioni atomiche secondo il linguaggio e sono costituite da tutti i tipi di lessemi per compiere operazioni di base. I linguaggi di programmazione presentano delle istruzioni condivise nel senso di fondamentali che hanno solo minime differenze ed altre più particolari, perché dipendenti da specificità dalla progettazione del linguaggio. Ciò potrebbe essere anche solo questione di sintassi più che rappresentanti nuovi concetti.\nDi seguito un elenco di istruzioni semplici, alcune standard cioè presenti in tutti o la gran parte dei linguaggi considerati, altre specifiche ma che mettono in evidenza aspetti rilevanti di progettazione:\n\nEspressioni: È eseguibile dal compilatore o interprete, quindi, è una delle istruzioni semplici più importanti quando a sé stante, ma sono presenti anche all’interno di istruzioni semplici e composte. Alcuni esempi in vari linguaggi di somma di due identificatori:\n\nIn Python: x + y.\nIn Java: x + y;.\nIn C: x + y;.\nIn C++: x + y;.\n\nDichiarazione di variabili: La dichiarazione di una variabile introduce una nuova variabile nel programma e specifica il suo tipo2. La dichiarazione non assegna necessariamente un valore iniziale alla variabile. Esempi:\n\nIn Python la dichiarazione avviene automaticamente con l’assegnazione, anche se è possibile annotare il tipo di una variabile, ad esempio x: int = 5, anche se ciò non costringe il programmatore a utilizzare x on interi.\nIn Java: int x;.\nIn C: int x;.\nIn C++: int x;.\n\nAssegnazione: Utilizza un operatore di assegnazione (ad esempio, =) per attribuire un valore rappresentato da un letterale, una espressione o un identificatore, ad un identificatore di variabile, che possiamo pensare come un nome simbolico rappresentante una posizione dove è memorizzato un valore. In alcuni linguaggi deve essere preceduta dalla dichiarazione. Esempio:\n\nIn Python:\nz = (x * 2) + (y / 2)\n\nz: Identificatore della variabile.\n=: Operatore di assegnazione.\n(x * 2): Espressione che moltiplica x per 2.\n(y / 2): Espressione che divide y per 2.\n+: Operatore aritmetico che somma i risultati delle due espressioni in una più complessa. L’esecuzione dell’istruzione produce un risultato valido solo se x e y sono associate a valori numerici e ciò perché non tutte le istruzioni sintatticamente corrette sono semanticamente corrette. D’altronde ciò non deve essere preso come regola, perché se * fosse un operatore che ripete quanto a sinistra un numero di volte definito dal valore di destra e / la divisione del valore di sinistra in parti di numero pari a quanto a destra, allora x e y potrebbero essere stringhe.\n\nIn Java: z = (x * 2) + (y / 2);.\nIn C: z = (x * 2) + (y / 2);.\nIn C++: z = (x * 2) + (y / 2);.\n\nAssegnazione aumentata: Combina un’operazione e un’assegnazione in un’unica istruzione. Esempi per una assegnazione di una variabile del valore ottenuto dalla somma di quello proprio con il numero intero 1:\n\nIn Python: x += 1 è come scrivere x = x + 1.\nIn Java: x += 1;.\nIn C: x += 1;.\nIn C++: x += 1;.\n\nIstruzioni di input/output: Sono espressioni particolari ma generalmente evidenziate perché permettono di interagire con l’utente o di produrre output, spesso con sintassi ad hoc. Esempi:\n\nIn Python: print(\"Hello, World!\").\nIn Java: System.out.println(\"Hello, World!\");.\nIn C: printf(\"Hello, World!\\n\");.\nIn C++: std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;.\n\nIstruzioni di controllo del flusso: Permettono di interrompere o continuare l’esecuzione di cicli o di saltare a una specifica etichetta nel codice. Esempi:\n\nIn Python: break, continue.\nIn Java: break;, continue;.\nIn C: break;, continue;, goto label;.\nIn C++: break;, continue;, goto label;.\n\nGestione della vita degli oggetti: Include la creazione, l’utilizzo e la distruzione dei dati presenti nella memoria del computer. In alcuni linguaggi ciò è parzialmente o totalmente a carico del programmatore, mentre, all’altro estremo, è completamente gestito dal linguaggio. Esempi:\n\nCreazione di oggetti:\n\nIn C++: int* ptr = new int;.\nIn Java: String str = new String(\"Hello, world!\");\nIn Python: Non è presente una istruzione specifica giacché l’espressione MyClass() crea un oggetto di tipo MyClass.\nIn C: La creazione di oggetti è spesso gestita manualmente attraverso l’allocazione di memoria dinamica con funzioni come malloc.\n\nDistruzione di oggetti:\n\nIn Python: La gestione della memoria è automatica tramite il garbage collector.\nIn Java: In Java, la gestione della memoria è affidata al garbage collector.\nIn C++: delete ptr;.\nIn C: free(ptr); (richiede #include &lt;stdlib.h&gt;).\n\nEliminazione di variabili:\n\nIn Python: del x.\n\n\nRitorno di valori: Utilizzata all’interno di funzioni per restituire un valore. Esempi:\n\nIn Python: return x.\nIn Java: return x;.\nIn C: return x;.\nIn C++: return x;.\n\nGenerazione di eccezioni: Utilizzata per generare e inviare un’eccezione, cioè una interruzione della sequenza ordinaria delle istruzione per segnalare una anomalia. Esempi:\n\nIn Python: raise ValueError(\"Invalid input\").\nIn Java: throw new IllegalArgumentException(\"Invalid input\");.\nIn C++: throw std::invalid_argument(\"Invalid input\");.\nIn C: Non esiste un equivalente diretto, ma si possono utilizzare meccanismi come setjmp e longjmp per la gestione degli errori.\n\nImportazione di moduli: Permettono di importare moduli o parti di essi, cioè di utilizzare funzioni, classi, variabili e altri identificatori definiti in altri file o librerie. Esempi:\n\nIn Python: import math, from math import sqrt\nIn Java: import java.util.List;\nIn C: #include &lt;stdio.h&gt;\nIn C++: #include &lt;iostream&gt;\n\nDichiarazioni globali e non locali: Permettono di dichiarare variabili che esistono nell’ambito globale o non locale. Esempi:\n\nIn Python: global x, nonlocal y.\nIn Java: Le variabili globali non sono supportate direttamente; si utilizzano campi statici delle classi.\nIn C: Le variabili globali sono dichiarate al di fuori di qualsiasi funzione.\nIn C++: Le variabili globali sono dichiarate al di fuori di qualsiasi funzione.\n\nAssert: Utilizzata per verificare se una condizione è vera e, in caso contrario, sollevare un’eccezione. Esempi:\n\nIn Python: assert x &gt; 0, \"x deve essere positivo\".\nIn Java: assert x &gt; 0 : \"x deve essere positivo\";.\nIn C: assert(x &gt; 0); (richiede #include &lt;assert.h&gt;).\nIn C++: assert(x &gt; 0); (richiede #include &lt;cassert&gt;).\n\n\n2 Spiegheremo il concetto di tipo a breve, per ora si può pensare ad esso come l’insieme dei possibili valori e operazioni che si possono effettuare su di essi.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#istruzioni-composte-e-blocchi-di-codice",
    "href": "prima-parte-sintassi.html#istruzioni-composte-e-blocchi-di-codice",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.5 Istruzioni composte e blocchi di codice",
    "text": "3.5 Istruzioni composte e blocchi di codice\nLe istruzioni composte sono costituite da più istruzioni semplici e possono includere strutture di controllo del flusso, come condizioni (if), cicli (for, while) ed eccezioni (try, catch). Queste istruzioni sono utilizzate per organizzare il flusso di esecuzione del programma e possono contenere altre istruzioni semplici o composte al loro interno.\nUn blocco di codice è una sezione del codice che raggruppa una serie di istruzioni che devono essere eseguite insieme. I blocchi di codice sono spesso utilizzati all’interno delle istruzioni composte per delimitare il gruppo di istruzioni che devono essere eseguite in determinate condizioni o iterazioni.\nIn molti linguaggi di programmazione, i blocchi di codice sono delimitati da parentesi graffe ({}), mentre in altri linguaggi, come Python, l’indentazione è utilizzata per indicare l’inizio e la fine di un blocco di codice.\nAlcuni esempi di istruzione e blocco di codice:\n\nEsempio in C:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n\n  y = x * 2;\n}\nIn questo esempio:\n\nif (x &gt; 0) e quanto nelle parentesi graffe è un’istruzione composta. if è una parola chiave seguita da una espressione tra delimitatori.\n{ printf(\"x è positivo\\n\"); y = x * 2; } è un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera. Sono presenti diversi delimitatori, una espressione e una istruzione di assegnamento.\n\nEsempio in Python:\nif x &gt; 0:\n  print(\"x è positivo\")\n\n  y = x * 2\nIn questo esempio:\n\nif x &gt; 0: è un’istruzione composta.\nLe righe indentate sotto l’istruzione if, cioè print(\"x è positivo\") e y = x * 2, costituiscono un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\n\nAlcuni esempi di istruzione e blocco di codice:\n\nEsempio in C:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n  y = x * 2;\n}\nIn questo esempio:\n\nif (x &gt; 0) e quanto nelle parentesi graffe è un’istruzione composta.\n{ printf(\"x è positivo\\n\"); y = x * 2; } è un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\nEsempio in Python:\nif x &gt; 0:\n  print(\"x è positivo\")\n  y = x * 2\nIn questo esempio:\n\nif x &gt; 0: è un’istruzione composta.\nLe righe indentate sotto l’istruzione if (print(\"x è positivo\") e y = x * 2) costituiscono un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\n\nDi seguito sono elencate le istruzioni composte principali, con spiegazioni e semplici esempi di sintassi per Python, Java, C e C++:\n\nCondizionali (if, else if, else): Le istruzioni condizionali permettono l’esecuzione di blocchi di codice basati su espressioni logiche.\n\nPython:\nif x &gt; 0:\n  print(\"x è positivo\")\n\nelif x == 0:\n  print(\"x è zero\")\n\nelse:\n  print(\"x è negativo\")\nJava:\nif (x &gt; 0) {\n  System.out.println(\"x è positivo\");\n} else if (x == 0) {\n  System.out.println(\"x è zero\");\n} else {\n  System.out.println(\"x è negativo\");\n}\nC:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n} else if (x == 0) {\n  printf(\"x è zero\\n\");\n} else {\n  printf(\"x è negativo\\n\");\n}\nC++:\nif (x &gt; 0) {\n  std::cout &lt;&lt; \"x è positivo\" &lt;&lt; std::endl;\n} else if (x == 0) {\n  std::cout &lt;&lt; \"x è zero\" &lt;&lt; std::endl;\n} else {\n  std::cout &lt;&lt; \"x è negativo\" &lt;&lt; std::endl;\n}\n\nCicli (for): I cicli for permettono di iterare su un insieme di valori o di ripetere l’esecuzione di un blocco di codice per un numero specificato di volte.\n\nPython:\nfor i in range(5):\n  print(i)\nJava:\nfor (int i = 0; i &lt; 5; i++) {\n  System.out.println(i);\n}\nC:\nfor (int i = 0; i &lt; 5; i++) {\n  printf(\"%d\\n\", i);\n}\nC++:\nfor (int i = 0; i &lt; 5; i++) {\n  std::cout &lt;&lt; i &lt;&lt; std::endl;\n}\n\n\nCicli (while): I cicli while ripetono l’esecuzione di un blocco di codice finché una condizione specificata rimane vera.\n\nPython:\nwhile x &gt; 0:\n  print(x)\n\n  x -= 1\nJava:\nwhile (x &gt; 0) {\n  System.out.println(x);\n\n  x--;\n}\nC:\nwhile (x &gt; 0) {\n  printf(\"%d\\n\", x);\n\n  x--;\n}\nC++:\nwhile (x &gt; 0) {\n  std::cout &lt;&lt; x &lt;&lt; std::endl;\n\n  x--;\n}\nGestione delle eccezioni (try, catch): Le istruzioni di gestione delle eccezioni permettono di gestire errori o condizioni anomale che possono verificarsi durante l’esecuzione del programma.\n\nPython:\ntry:\n  value = int(input(\"Inserisci un numero: \"))\n\nexcept ValueError:\n  print(\"Input non valido\")\nJava:\ntry {\n  int value = Integer.parseInt(input);\n\n} catch (NumberFormatException e) {\n  System.out.println(\"Input non valido\");\n}\nC++:\ntry {\n  int value = std::stoi(input);\n\n} catch (const std::invalid_argument& e) {\n  std::cout &lt;&lt; \"Input non valido\" &lt;&lt; std::endl;\n}\nC: C non ha un supporto nativo per la gestione delle eccezioni, ma si possono usare meccanismi come setjmp e longjmp.\n#include &lt;setjmp.h&gt;\n\n1jmp_buf buf;\n\nvoid error() {\n2  longjmp(buf, 1);\n}\n\nint main() {\n3  if (setjmp(buf)) {\n4    printf(\"Errore rilevato\\n\");\n\n  } else {\n5    error();\n  }\n  return 0;\n}\n\n1\n\nDichiarazione di una variabile di tipo jmp_buf.\n\n2\n\nSalta al punto salvato in buf con valore di ritorno 1.\n\n3\n\nSalva il contesto di esecuzione attuale in buf.\n\n4\n\nEsegue se longjmp viene chiamato.\n\n5\n\nChiama la funzione error, che salta indietro al punto setjmp.\n\n\n\nSelezione multipla (switch, case, default): Le istruzioni di selezione multipla permettono di eseguire uno tra diversi blocchi di codice basati sul valore di un’espressione.\n\nPython (a partire da Python 3.10 con match):\nmatch x:\n  case 0:\n    print(\"x è zero\")\n\n  case 1:\n    print(\"x è uno\")\n\n  case _:\n    print(\"x è un altro numero\")\nJava:\nswitch (x) {\n  case 0:\n    System.out.println(\"x è zero\");\n\n    break;\n\n  case 1:\n    System.out.println(\"x è uno\");\n\n    break;\n\n  default:\n    System.out.println(\"x è un altro numero\");\n\n    break;\n}\nC:\nswitch (x) {\n  case 0:\n    printf(\"x è zero\\n\");\n\n    break;\n\n  case 1:\n    printf(\"x è uno\\n\");\n\n    break;\n\n  default:\n    printf(\"x è un altro numero\\n\");\n\n    break;\n}\nC++:\nswitch (x) {\n  case 0:\n    std::cout &lt;&lt; \"x è zero\" &lt;&lt; std::endl;\n\n    break;\n\n  case 1:\n    std::cout &lt;&lt; \"x è uno\" &lt;&lt; std::endl;\n\n    break;\n\n  default:\n    std::cout &lt;&lt; \"x è un altro numero\" &lt;&lt; std::endl;\n\n    break;\n}",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#organizzazione-delle-istruzioni-in-un-programma",
    "href": "prima-parte-sintassi.html#organizzazione-delle-istruzioni-in-un-programma",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.6 Organizzazione delle istruzioni in un programma",
    "text": "3.6 Organizzazione delle istruzioni in un programma\nCertamente, ecco il paragrafo completato:",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#organizzazione-delle-istruzioni-in-un-programma-1",
    "href": "prima-parte-sintassi.html#organizzazione-delle-istruzioni-in-un-programma-1",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.7 Organizzazione delle istruzioni in un programma",
    "text": "3.7 Organizzazione delle istruzioni in un programma\nIl programma è solitamente salvato in un file di testo in righe. Queste righe possono essere classificate in righe fisiche e righe logiche.\nUna riga fisica è una linea di testo nel file sorgente del programma, terminata da un carattere di a capo.\nEsempio:\n1int x = 10;\n\n1\n\nQuesta è una riga fisica.\n\n\nUna riga logica è una singola istruzione, che può estendersi su una o più righe fisiche.\nEsempio di riga logica con più righe fisiche:\n1int y = (10 + 20 + 30 +\n2         40 + 50);\n\n1\n\nPrima riga fisica della riga logica.\n\n2\n\nSeconda riga fisica della riga logica.\n\n\nIl concetto di righe fisiche e logiche esiste perché le istruzioni (o righe logiche) possono essere lunghe e composte, richiedendo più righe fisiche per migliorare la leggibilità e la gestione del codice.\nIn molti linguaggi di programmazione, l’uso di righe fisiche e logiche facilita l’organizzazione e la formattazione del codice. Ad esempio:\n\nPython utilizza l’indentazione per definire i blocchi di codice, quindi una riga logica che si estende su più righe fisiche deve continuare con una corretta indentazione. Inoltre, è possibile usare il carattere di continuazione (\\) per indicare che una riga logica prosegue sulla riga successiva:\nresult = (10 + 20 + 30 + \\\n          40 + 50)\nJava e C utilizzano le parentesi graffe ({}) per delimitare i blocchi di codice, e le istruzioni possono estendersi su più righe fisiche senza il bisogno di un carattere di continuazione, grazie al punto e virgola (;) che termina le istruzioni:\nint y = (10 + 20 + 30 + \n         40 + 50);\nint y = (10 + 20 + 30 + \n         40 + 50);\n\nL’uso corretto di righe fisiche e logiche migliora la leggibilità del codice, rendendolo più facile da capire e mantenere. Inoltre, una buona formattazione del codice facilita il lavoro di squadra, poiché gli sviluppatori possono facilmente seguire e comprendere la logica implementata da altri.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html",
    "href": "prima-parte-variabili-funzioni.html",
    "title": "4  Le variabili e le funzioni",
    "section": "",
    "text": "4.1 Variabili\nLe variabili sono uno dei concetti fondamentali nella programmazione, essenziali per la manipolazione e la gestione dei dati. Una variabile è un nome simbolico associato a una locazione di memoria che può contenere uno o più valori di un certo tipo di dato. Questo concetto permette agli sviluppatori di astrarre dalla memoria fisica e concentrarsi sulla logica del programma.\nLa gestione delle variabili varia tra i diversi linguaggi di programmazione, quindi esploreremo le variabili con particolare attenzione a Python, Java, C e C++.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html#variabili",
    "href": "prima-parte-variabili-funzioni.html#variabili",
    "title": "4  Le variabili e le funzioni",
    "section": "",
    "text": "4.1.1 Dichiarazione e inizializzazione\nLa dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. Questo processo informa il compilatore o l’interprete che una certa variabile esiste e può essere utilizzata nel codice. Abbiamo visto che esiste una istruzione specifica in alcuni linguaggi, mentre in altri è implicita nella assegnazione.\nL’inizializzazione di una variabile è il processo di assegnazione di un valore iniziale alla variabile. Questo può avvenire contestualmente alla dichiarazione o in un’istruzione separata successiva, quella di assegnamento.\nEsempi:\n\nIn Python, le variabili sono dichiarate automaticamente al momento dell’assegnazione del valore. Non è necessario specificare il tipo di dato, poiché Python è dinamicamente tipizzato, cioè determina durante l’esecuzione il tipo di dato del valore associato alla variabile.\n1x = 10\n2x = \"Hello\"\n\n1\n\nDichiarazione e inizializzazione.\n\n2\n\nCambia il tipo di x dinamicamente a stringa.\n\n\nJava: In Java, le variabili devono essere dichiarate con un tipo di dato esplicito. La dichiarazione può avvenire contestualmente all’inizializzazione o separatamente.\nint x;\nx = 10;\nint y = 20;\n\n\nDichiarazione.\nInizializzazione.\nDichiarazione e inizializzazione.\n\n\nC: In C, la dichiarazione delle variabili richiede la specifica del tipo di dato. La dichiarazione e l’inizializzazione possono essere separate o combinate.\nint x;\nx = 10;\nint y = 20;\n\n\nDichiarazione.\nInizializzazione.\nDichiarazione e inizializzazione.\n\n\nC++: Simile al C, ma con funzionalità aggiuntive come l’inizializzazione a lista.\n1int x;\n2x = 10;\n3int y = 20;\n4int z{30};\n5int arr[5] = {1, 2, 3, 4, 5};\n\n1\n\nDichiarazione.\n\n2\n\nInizializzazione.\n\n3\n\nDichiarazione e inizializzazione.\n\n4\n\nDichiarazione e inizializzazione a lista di z con l’intero 30.\n\n5\n\nDichiarazione e inizializzazione a lista di un array con 5 valori predefiniti.\n\n\n\n\n\n4.1.2 Ambito delle variabili\nL’ambito di una variabile rappresenta la porzione del codice in cui l’identificatore della variabile è definito e, quindi, può essere utilizzato. Gli approcci dei diversi linguaggi sono diversi, infatti Java, C e C++ hanno una gestione dell’ambito delle variabili per cui quelle dichiarate all’interno di un blocco sono limitate a quel blocco e non sono visibili al di fuori di esso. In Python, invece, le variabili definite all’interno di un blocco di un’istruzione composta (come un ciclo for o una condizione if) rimangono accessibili anche al di fuori del blocco, purché siano ancora nel medesimo ambito di funzione o modulo e, soprattutto quel blocco sia stato eseguito.\n\nGlobale: Le variabili globali sono dichiarate al di fuori di qualsiasi blocco e sono accessibili ovunque nel programma.\n1int globalVar = 10;\n\n2void function() {\n3  printf(\"%d\\n\", globalVar);\n}\n\n1\n\nVariabile globale.\n\n2\n\nInizio del blocco.\n\n3\n\nAccesso alla variabile globale.\n\n\nLocale: Le variabili locali sono dichiarate all’interno di un blocco, come una funzione o un loop, e sono accessibili solo all’interno di quel blocco.\npublic class Main {\n  public static void main(String[] args) {\n    if (true) {\n1      int x = 10;\n    }\n\n2    System.out.println(x);\n\n    for (int i = 0; i &lt; 10; i++) {\n3      int y = i;\n    }\n\n4    System.out.println(y);\n  }\n}\n\n1\n\nVariabile locale al blocco if.\n\n2\n\nErrore: x non è visibile qui!\n\n3\n\nVariabile locale al blocco for.\n\n4\n\nErrore: y non è visibile qui.\n\n\nIn Python, una variabile definita all’interno di un blocco di un’istruzione composta, come all’interno di un ciclo for o di una condizione if, rimane accessibile anche dopo l’esecuzione del blocco:\nfor i in range(10):\n  loopVar = i  # \n\nprint(loopVar)  # \n\nVariabile locale al ciclo.\nloopVar è ancora accessibile qui.\n\n\n\n\n4.1.3 Visibilità delle variabili\nLa visibilità si riferisce alla possibilità che in una regione di codice una certa variabile possa essere vista e utilizzata. Anche se correlata all’ambito, la visibilità può essere influenzata da altri fattori come la modularità e gli spazi di nomi (namespace).\n\nConsideriamo un esempio in C++ per illustrare la differenza tra ambito e visibilità:\n#include &lt;iostream&gt;\n\n1int globalVar = 10;\n\nvoid function() {\n2  int localVar = 5;\n\n3  std::cout &lt;&lt; globalVar &lt;&lt; std::endl;\n4  std::cout &lt;&lt; localVar &lt;&lt; std::endl;\n}\n\nint main() {\n  function();\n\n5  std::cout &lt;&lt; globalVar &lt;&lt; std::endl;\n6  std::cout &lt;&lt; localVar &lt;&lt; std::endl;\n\n  return 0;\n}\n\n1\n\nVariabile globale (ambito globale).\n\n2\n\nVariabile locale (ambito locale alla funzione).\n\n3\n\nVisibilità globaleVar all’interno della funzione.\n\n4\n\nVisibilità localVar all’interno della funzione.\n\n5\n\nVisibilità globalVar all’interno di main.\n\n6\n\nErrore: localVar non è visibile qui (ambito locale alla funzione function).\n\n\nIn Python, le variabili definite all’interno di una funzione sono locali a quella funzione, ma le variabili definite all’interno di un blocco (come un ciclo for o un if) sono visibili all’interno della funzione o del modulo in cui si trovano:\n1globalVar = 10\n\ndef function():\n2  localVar = 5\n\n  if True:\n3    blockVar = 20\n\n4  print(localVar)\n5  print(blockVar)\n\nfunction()\n\n6print(globalVar)\n7print(localVar)\n8print(blockVar)\n\n1\n\nVariabile globale.\n\n2\n\nVariabile locale.\n\n3\n\nVisibile all’interno della funzione.\n\n4\n\nVisibile.\n\n5\n\nVisibile.\n\n6\n\nVisibile.\n\n7\n\nErrore: non visibile al di fuori della funzione.\n\n8\n\nErrore: non visibile al di fuori della funzione.\n\n\n\n\n\n4.1.4 Durata di vita degli oggetti referenziati\nLa durata di vita descrive per quanto tempo un oggetto rimane in memoria durante l’esecuzione del programma. Questo è distinto dalla variabile (o puntatore) che fa riferimento all’oggetto.\nIn alcuni linguaggi di programmazione è presente il garbage collector, cioè un processo avviato dal compilatore o interprete che si occupa di rendere nuovamente disponibili le aree di memoria precedentemente occupate da oggetti non più referenziati da variabili. Questo accade quando l’esecuzione del programma raggiunge regioni di codice dove quelle variabili non sono più visibili. In questo modo, la visibilità è legata alla durata di vita degli oggetti, rendendo la gestione della memoria non più una preoccupazione del programmatore.\n\nVariabile automatica: L’oggetto esiste solo durante l’esecuzione del blocco di codice in cui è stata dichiarata la variabile a cui è associato.\nvoid function() {\n1  int autoVar = 10;\n} \n\n2printf(\"autoVar cancellata!\");\n\n1\n\nDichiarazione di autoVar e creazione in memoria di un oggetto corrispondente all’intero 10.\n\n2\n\nPrima di questa istruzione l’oggetto 10 non è più presente in memoria.\n\n\nVariabile statica: La variabile esiste per tutta la durata del programma, ma è accessibile solo all’interno del blocco in cui è dichiarata.\nvoid function() {\n1  static int staticVar = 10;\n}\n\n1\n\nVariabile statica ottenuta con una parola chiave ad hoc in fase di dichiarazione.\n\n\nVariabile dinamica: Le variabili dinamiche sono utilizzate per riservare memoria che persiste oltre la durata del blocco di codice in cui sono state create. L’oggetto è creato in memoria e deve essere cancellato esplicitamente dall’utente, utilizzando funzioni di gestione della memoria come delete. La variabile che punta all’oggetto è separata dall’oggetto stesso, quindi se la variabile non è più visibile, l’oggetto continuerà a rimanere in memoria e non sarà più eliminabile, causando una perdita di memoria (memory leak).\n#include &lt;iostream&gt;\n\nvoid function() {\n1  int* dynamicVar = new int(10);\n2  std::cout &lt;&lt; \"dynamicVar: \" &lt;&lt; *dynamicVar &lt;&lt; std::endl;\n}\n\nint main() {\n3  function();\n\n4  int* safeDynamicVar = new int(20);\n\n5  std::cout &lt;&lt; \"safeDynamicVar: \" &lt;&lt; *safeDynamicVar &lt;&lt; std::endl;\n\n6  delete safeDynamicVar;\n\n  return 0;\n\n1\n\nAllocazione dinamica di un intero all’interno della funzione function().\n\n2\n\nStampa del valore puntato da dynamicVar. Prima della chiusura del blocco non viene deallocata dynamicVar per dimostrare il problema di perdita di memoria\n\n3\n\nChiamata alla funzione function(). Dopo l’uscita dalla funzione, dynamicVar non è più accessibile, causando una perdita di memoria poiché non è stata deallocata.\n\n4\n\nAllocazione dinamica di un intero.\n\n5\n\nStampa del valore puntato da safeDynamicVar.\n\n6\n\nDeallocazione dinamica dell’intero. Corretto uso di allocazione e deallocazione dinamica.\n\n\nIn Python, la gestione della memoria è automatica grazie al garbage collector. Quando non ci sono più riferimenti di variabili a un oggetto, il garbage collector lo rimuove dalla memoria.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html#funzioni",
    "href": "prima-parte-variabili-funzioni.html#funzioni",
    "title": "4  Le variabili e le funzioni",
    "section": "4.2 Funzioni",
    "text": "4.2 Funzioni\nLe funzioni sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Questi costrutti sono fondamentali per la strutturazione e la modularizzazione del codice, consentendo di definire operazioni che possono essere invocate più volte durante l’esecuzione di un programma. La distinzione tra funzioni e metodi è che le funzioni sono indipendenti, mentre i metodi sono associati a oggetti o classi.\n\n4.2.1 Parametri e argomenti\nI parametri e gli argomenti sono strumenti fondamentali per passare informazioni alle funzioni e influenzarne il comportamento.\n\nParametri o parametri formali: I parametri sono definiti nella dichiarazione della funzione e rappresentano i nomi delle variabili che la funzione utilizzerà per accedere ai dati passati.\nArgomenti o parametri attuali: Gli argomenti sono i valori effettivi passati alla funzione quando viene chiamata.\n\nEsempio in Python:\n1def add(a, b):\n  return a + b\n\n2result = add(3, 4)\n\n3print(result)\n\n1\n\na e b sono parametri della funzione add.\n\n2\n\n3 e 4 sono argomenti passati alla funzione add.\n\n3\n\nIl risultato della funzione add viene stampato.\n\n\n\n\n4.2.2 Valore di ritorno\nIl valore di ritorno è il risultato prodotto da una funzione, che può essere utilizzato nell’istruzione chiamante. Una funzione può restituire un valore utilizzando la parola chiave return.\nEsempio in Java:\npublic class Main {\n1  public static int add(int a, int b) {\n2    return a + b;\n  }\n\n  public static void main(String[] args) {\n3    int result = add(3, 4);\n\n4    System.out.println(result);\n  }\n}\n\n1\n\nDichiarazione della funzione add che accetta due parametri interi.\n\n2\n\nLa funzione add ritorna la somma di a e b.\n\n3\n\nChiamata della funzione add con argomenti 3 e 4.\n\n4\n\nIl risultato della funzione add viene stampato.\n\n\n\n\n4.2.3 Ricorsione\nLa ricorsione è la capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili. Ogni chiamata ricorsiva deve avvicinarsi a una condizione di terminazione per evitare loop infiniti.\nEsempio in C++ (calcolo del fattoriale):\n#include &lt;iostream&gt;\n\n1int factorial(int n) {\n2  if (n &lt;= 1) return 1;\n\n3  return n * factorial(n - 1);\n}\n\nint main() {\n4  int result = factorial(5);\n\n5  std::cout &lt;&lt; result &lt;&lt; std::endl;\n  \n  return 0;\n}\n\n1\n\nDichiarazione della funzione factorial.\n\n2\n\nCondizione di terminazione: se n è minore o uguale a 1, ritorna 1.\n\n3\n\nChiamata ricorsiva: factorial chiama se stessa con n - 1.\n\n4\n\nChiamata della funzione factorial con argomento 5.\n\n5\n\nIl risultato della funzione factorial viene stampato.\n\n\n\n\n4.2.4 Funzioni di prima classe\nLe funzioni di prima classe sono funzioni che possono essere trattate come qualsiasi altra variabile. Possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.\n\nEsempio in Python:\ndef greet(name):\n  return f\"Hello, {name}!\"\n\n1say_hello = greet\n\n2print(say_hello(\"World\"))\n\n1\n\nLa funzione greet viene assegnata alla variabile say_hello.\n\n2\n\nsay_hello viene chiamata con l’argomento \"World\".\n\n\nEsempio in C++:\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nvoid greet(const std::string& name) {\n  std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; std::endl;\n}\n\nint main() {\n  std::function&lt;void(const std::string&)&gt; say_hello = greet;\n\n  say_hello(\"World\");\n\n  return 0;\n\n\nLa funzione greet viene assegnata alla variabile say_hello utilizzando std::function.\nsay_hello viene chiamata con l’argomento \"World\".\n\n\n\n4.2.5 Funzioni di ordine superiore\nLe funzioni di ordine superiore sono funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati. Sono fondamentali per la programmazione funzionale.\n\nEsempio in Python:\ndef add(a):\n  def inner(b):\n    return a + b\n\n1  return inner\n\n2add_five = add(5)\n\n3print(add_five(3))\n\n1\n\nLa funzione add ritorna una nuova funzione inner che somma a al suo argomento b.\n\n2\n\nadd(5) ritorna una nuova funzione che somma 5 al suo argomento.\n\n3\n\nLa funzione risultante viene chiamata con l’argomento 3, restituendo 8.\n\n\nEsempio in C++:\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstd::function&lt;int(int)&gt; add(int a) {\n  return [a](int b) { return a + b; };\n}\n\nint main() {\n  auto add_five = add(5);\n\n  std::cout &lt;&lt; add_five(3) &lt;&lt; std::endl;\n\n  return 0;\n}\n\n\nDichiarazione della funzione add che ritorna un std::function&lt;int(int)&gt;.\nadd ritorna una funzione lambda che somma a al suo argomento b.\nadd(5) ritorna una nuova funzione che somma 5 al suo argomento.\nLa funzione risultante viene chiamata con l’argomento 3, restituendo 8.\n\n\n\n4.2.6 Ambito e visibilità\nL’ambito e la visibilità degli identificatori delle funzioni sono concetti sono simili a quelli delle variabili, ma presentano alcune differenze chiave che è importante comprendere.\n\n4.2.6.1 Ambito\nPer le funzioni distinguiamo sempre i seguenti:\n\nAmbito globale: Una funzione dichiarata a livello globale, cioè al di fuori di qualsiasi altra funzione o blocco di codice, ha un ambito globale. Questo significa che la funzione è visibile e può essere chiamata da qualsiasi punto del programma dopo la sua dichiarazione.\nEsempio in C++:\n#include &lt;iostream&gt;\n\n1void globalFunction() {\n  std::cout &lt;&lt; \"Funzione globale\" &lt;&lt; std::endl;\n}\n\nint main() {\n2  globalFunction();\n\n  return 0;\n\n1\n\nDichiarazione della funzione globalFunction a livello globale.\n\n2\n\nChiamata della funzione globalFunction all’interno di main.\n\n\nIl comportamento è identico in Java e C. In Python, le funzioni definite a livello globale hanno ambito globale.\nAmbito locale: Una funzione dichiarata all’interno di un blocco di codice (come all’interno di una funzione o di una classe) ha un ambito locale. La funzione è visibile e può essere chiamata solo all’interno di quel blocco.\nEsempio in Python:\ndef outerFunction():\n1  def localFunction():\n    print(\"Funzione locale\")\n\n2  localFunction()\n\nouterFunction()\n\n3localFunction()\n\n1\n\nDichiarazione della funzione localFunction all’interno di outerFunction.\n\n2\n\nChiamata della funzione localFunction all’interno di outerFunction.\n\n3\n\nChiamata a localFunction al di fuori di outerFunction, che genera un errore poiché localFunction non è visibile a questo livello.\n\n\nIn Java e C++, le funzioni dichiarate all’interno di un blocco (come metodi all’interno di una classe) sono accessibili solo all’interno di quel blocco, simile a Python.\nIn C, le funzioni locali non sono standard, ma è possibile ottenere un comportamento simile usando funzioni statiche o funzioni inline definite all’interno di un file sorgente specifico.\n\n\n\n4.2.6.2 Visibilità\nLa visibilità si riferisce a dove nel codice l’identificatore di una funzione può essere utilizzato. La visibilità è strettamente legata all’ambito, ma può essere influenzata anche da altre considerazioni come la modularità e le regole di accesso.\n\nVisibilità Globale: Le funzioni con ambito globale sono visibili ovunque nel programma come per le variabili.\nVisibilità Locale: Le funzioni con ambito locale sono visibili solo all’interno del blocco in cui sono dichiarate. Questo è utile per creare funzioni di supporto (helper) o interne che non devono essere accessibili dall’esterno.\nEsempio in Python:\ndef outerFunction():\n1  def helperFunction():\n    print(\"Funzione helper\")\n\n2  helperFunction()\n\n  print(\"Funzione esterna\")\n\nouterFunction()\n\n1\n\nDichiarazione della funzione helperFunction all’interno di outerFunction.\n\n2\n\nChiamata della funzione helperFunction all’interno di outerFunction.\n\n\n\n\n\n4.2.6.3 Differenze tra funzioni con variabili e oggetti\nSebbene l’ambito e la visibilità delle funzioni condividano concetti simili con le variabili e gli oggetti, ci sono alcune differenze chiave:\n\nDurata di vita: Le variabili locali (automatiche) hanno una durata di vita limitata al blocco di codice in cui sono dichiarate. Quando il controllo esce dal blocco, la memoria allocata per la variabile viene liberata. Le funzioni, tuttavia, non vengono “distrutte” quando il controllo esce dal loro ambito; semplicemente non sono più visibili e chiamabili. In Python, le variabili definite all’interno di un blocco di un’istruzione composta rimangono accessibili finché sono nello stesso ambito di funzione o modulo, mentre le funzioni definite all’interno di un’altra funzione (nested functions) sono visibili solo all’interno di quella funzione.\nAllocazione dinamica: In C++, le variabili e gli oggetti possono essere allocati dinamicamente usando new e deallocati usando delete. Le funzioni non richiedono un’allocazione esplicita di memoria; la loro dichiarazione è sufficiente per renderle utilizzabili nell’ambito definito.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html#spazi-di-nomi-moduli-e-file",
    "href": "prima-parte-variabili-funzioni.html#spazi-di-nomi-moduli-e-file",
    "title": "4  Le variabili e le funzioni",
    "section": "4.3 Spazi di nomi, moduli e file",
    "text": "4.3 Spazi di nomi, moduli e file\nIn molti linguaggi di programmazione, la gestione dell’ambito e della visibilità delle variabili e delle funzioni può essere ulteriormente organizzata utilizzando spazio di nomi (namespace), moduli, header e file separati. Questa organizzazione aiuta a evitare conflitti di nome e a mantenere il codice più modulare e manutenibile.\n\n4.3.1 Python\nIn Python, i moduli sono file che contengono definizioni di variabili, funzioni e classi. I moduli possono essere importati in altri moduli o script per riutilizzare il codice. Quando un modulo viene importato, gli identificatori definiti in quel modulo (come variabili, funzioni e classi) diventano accessibili attraverso il nome del modulo. Sebbene i moduli siano spesso implementati come file separati, è possibile definirli anche all’interno di un file di codice sorgente principale.\nEsempio di modulo (mymodule.py):\n# mymodule.py\n1my_var = 10\n\ndef my_function():\n2    print(\"Funzione del modulo\")\n\n1\n\nVariabile globale nel modulo.\n\n2\n\nFunzione nel modulo.\n\n\nImportazione di un modulo in un altro file sorgente (main.py):\n# main.py\n1import mymodule\n\n2print(mymodule.my_var)\n3mymodule.my_function()\n\n1\n\nImportazione del modulo mymodule.\n\n2\n\nAccesso alla variabile my_var dal modulo mymodule.\n\n3\n\nChiamata della funzione my_function dal modulo mymodule.\n\n\n\n\n4.3.2 Java\nIn Java, i pacchetti (package) sono utilizzati per organizzare le classi in namespace separati. Ogni classe deve dichiarare il pacchetto di appartenenza.\nEsempio di classe in un pacchetto (mypackage/MyClass.java):\n// mypackage/MyClass.java\n1package mypackage;\n\npublic class MyClass {\n2    public static int myVar = 10;\n\n    public static void myMethod() {\n3        System.out.println(\"Metodo del pacchetto\");\n    }\n}\n\n1\n\nDichiarazione del pacchetto mypackage.\n\n2\n\nVariabile globale di classe.\n\n3\n\nMetodo della classe.\n\n\nImportazione di una classe da un pacchetto in un’altra classe (Main.java):\n// Main.java\n1import mypackage.MyClass;\n\npublic class Main {\n    public static void main(String[] args) {\n2        System.out.println(MyClass.myVar);\n3        MyClass.myMethod();\n    }\n}\n\n1\n\nImportazione della classe MyClass dal pacchetto mypackage.\n\n2\n\nAccesso alla variabile myVar dalla classe MyClass.\n\n3\n\nChiamata del metodo myMethod dalla classe MyClass.\n\n\n\n\n4.3.3 C\nIn C, i file di intestazione (header file) sono utilizzati per dichiarare funzioni e variabili che possono essere utilizzate in più file sorgente, a mo’ di libreria.\nEsempio di file di intestazione (mymodule.h):\n// mymodule.h\n#ifndef MYMODULE_H \n#define MYMODULE_H\n\n1extern int myVar;\n\n2void myFunction();\n\n#endif\n\n1\n\nDichiarazione della variabile globale myVar.\n\n2\n\nDichiarazione della funzione myFunction.\n\n\nEsempio di file sorgente (mymodule.c):\n#include \"mymodule.h\"\n\n1int myVar = 10;\n\nvoid myFunction() {\n2    printf(\"Funzione del modulo\\n\");\n}\n\n1\n\nDefinizione della variabile globale myVar.\n\n2\n\nDefinizione della funzione myFunction.\n\n\nUtilizzo del file di intestazione in un altro file sorgente (main.c):\n#include &lt;stdio.h&gt;\n1#include \"mymodule.h\"\n\nint main() {\n2    printf(\"%d\\n\", myVar);\n\n3    myFunction();\n\n    return 0;\n}\n\n1\n\nInclusione del file di intestazione mymodule.h.\n\n2\n\nAccesso alla variabile myVar dichiarata in mymodule.h.\n\n3\n\nChiamata della funzione myFunction dichiarata in mymodule.h.\n\n\n\n\n4.3.4 C++\nIn C++, la parola chiave namespace è utilizzata per organizzare le classi, le funzioni e le variabili in spazi di nomi separati, simili ai pacchetti in Java.\nEsempio di dichiarazione di uno spazio di nomi (mymodule.h):\n#ifndef MYMODULE_H \n#define MYMODULE_H\n\n1namespace mynamespace {\n2    extern int myVar;\n\n3    void myFunction();\n}\n\n#endif\n\n1\n\nDichiarazione dello spazio di nomi mynamespace.\n\n2\n\nDichiarazione della variabile globale myVar all’interno dello spazio di nomi.\n\n3\n\nDichiarazione della funzione myFunction all’interno dello spazio di nomi.\n\n\nEsempio di definizione dello spazio di nomi (mymodule.cpp):\n#include \"mymodule.h\"\n#include &lt;iostream&gt;\n\nnamespace mynamespace {\n1    int myVar = 10;\n\n    void myFunction() {\n2        std::cout &lt;&lt; \"Funzione del namespace\" &lt;&lt; std::endl;\n    }\n}\n\n1\n\nDefinizione della variabile globale myVar all’interno dello spazio di nomi.\n\n2\n\nDefinizione della funzione myFunction all’interno dello spazio di nomi.\n\n\nUtilizzo dello spazio di nomi in un altro file sorgente (main.cpp):\n#include \"mymodule.h\"\n#include &lt;iostream&gt;\n\nint main() {\n1    std::cout &lt;&lt; mynamespace::myVar &lt;&lt; std::endl;\n2    mynamespace::myFunction();\n    return 0;\n}\n\n1\n\nAccesso alla variabile myVar all’interno dello spazio di nomi mynamespace.\n\n2\n\nChiamata della funzione myFunction all’interno dello spazio di nomi mynamespace.\n\n\n\n\n4.3.5 Impatti\nL’uso di spazio di nomi, moduli e file di intestazione influisce sull’ambito e sulla visibilità delle variabili e delle funzioni. In generale, questi meccanismi consentono una maggiore modularità e organizzazione del codice, facilitando la gestione di grandi progetti.\n\nAmbito: L’ambito delle variabili e delle funzioni può essere limitato a uno spazio di nomi o a un modulo, riducendo il rischio di conflitti di nome.\nVisibilità: Le variabili e le funzioni dichiarate in namespace o moduli possono essere visibili solo all’interno di quel namespace o modulo, a meno che non vengano esplicitamente esportate.\nDurata di vita degli oggetti: La durata di vita degli oggetti non è direttamente influenzata dallo spazio di nomi o moduli, ma l’organizzazione del codice può rendere più chiaro quando e dove gli oggetti vengono creati e distrutti.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-modello-dati.html",
    "href": "prima-parte-modello-dati.html",
    "title": "5  Il modello dati dei linguaggi di programmazione",
    "section": "",
    "text": "5.1 Linguaggi procedurali\nNei linguaggi di programmazione procedurali, il modello dati è incentrato su tipi di dati semplici e compositi che supportano lo stile di programmazione orientato alle funzioni e procedure. Alcune caratteristiche tipiche includono:\nEsempio in C:\nL’esempio mostra come nel modello dati del linguaggio C possono essere definiti dei tipi compositi (Dato, Valore) e delle operazioni su quelli (stampa_dato, confronta_dato, inserisci_dato, cancella_dato). Il codice, pur realizzante una semplice libreria, appare slegato, cioè con funzioni che si applicano a tipi di dati specifici solo dall’interpretazione degli identificatori della funzione stessa e dei suoi parametri, cioè senza un legame esplicito e non ambiguo, tra tipo e funzione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Il modello dati dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-modello-dati.html#linguaggi-procedurali",
    "href": "prima-parte-modello-dati.html#linguaggi-procedurali",
    "title": "5  Il modello dati dei linguaggi di programmazione",
    "section": "",
    "text": "Tipi primitivi: Numeri interi, numeri a virgola mobile, caratteri e booleani.\nStrutture composite: Array, strutture (struct) e unioni (union). Gli array permettono di gestire collezioni di elementi dello stesso tipo, mentre le strutture permettono di combinare vari tipi di dati sotto un unico nome. Le unioni consentono di memorizzare diversi tipi di dati nello stesso spazio di memoria, ma solo uno di essi può essere attivo alla volta.\nOperazioni basate su funzioni: Le operazioni sui dati vengono eseguite attraverso funzioni che manipolano i valori passati come argomenti.\n\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_DATI 100\n\n1union Valore {\n  int intero;\n  float decimale;\n  char carattere;\n};\n\n2struct Dato {\n  char tipo;  \n  // 'i' per int, 'f' per float, 'c' per char\n  union Valore valore;\n};\n\n3void stampa_dato(struct Dato d) {\n  switch (d.tipo) {\n    case 'i':\n      printf(\"Intero: %d\\n\", d.valore.intero);\n      break;\n\n    case 'f':\n      printf(\"Float: %f\\n\", d.valore.decimale);\n      break;\n\n    case 'c':\n      printf(\"Carattere: %c\\n\", d.valore.carattere);\n      break;\n\n    default:\n      printf(\"Tipo sconosciuto\\n\");\n      break;\n  }\n}\n\nint confronta_dato(struct Dato d1, struct Dato d2) {\n  if (d1.tipo != d2.tipo) return 0;\n\n  switch (d1.tipo) {\n    case 'i': return d1.valore.intero == d2.valore.intero;\n\n    case 'f': return d1.valore.decimale == d2.valore.decimale;\n\n    case 'c': return d1.valore.carattere == d2.valore.carattere;\n\n    default: return 0;\n  }\n}\n\n4void inserisci_dato(struct Dato dati[], int *count, struct Dato nuovo_dato) {\n  if (*count &lt; MAX_DATI) {\n    dati[*count] = nuovo_dato;\n\n    (*count)++;\n\n  } else {\n    printf(\"Array pieno, impossibile inserire nuovo dato.\\n\");\n  }\n}\n\n5void cancella_dato(struct Dato dati[], int *count, struct Dato dato_da_cancellare) {\n  for (int i = 0; i &lt; *count; i++) {\n    if (confronta_dato(dati[i], dato_da_cancellare)) {\n      for (int j = i; j &lt; *count - 1; j++) {\n        dati[j] = dati[j + 1];\n      }\n\n      (*count)--;\n\n      i--; \n    }\n  }\n}\n\nint main() {\n6  struct Dato dati[MAX_DATI];\n  int count = 0;\n\n  struct Dato dato1 = {'i', .valore.intero = 42};\n  struct Dato dato2 = {'f', .valore.decimale = 3.14};\n  struct Dato dato3 = {'c', .valore.carattere = 'A'};\n  \n7  inserisci_dato(dati, &count, dato1);\n  inserisci_dato(dati, &count, dato2);\n  inserisci_dato(dati, &count, dato3);\n\n8  for (int i = 0; i &lt; count; i++) {\n    stampa_dato(dati[i]);\n  }\n\n9  cancella_dato(dati, &count, dato1);\n\n  printf(\"Dopo cancellazione:\\n\");\n\n  for (int i = 0; i &lt; count; i++) {\n    stampa_dato(dati[i]);\n  }\n\n  return 0;\n}\n\n1\n\nDefinizione di una union.\n\n2\n\nDefinizione di una struct che include la union.\n\n3\n\nFunzione per stampare i valori in base al tipo.\n\n4\n\nFunzione per inserire un nuovo dato alla fine dell’array.\n\n5\n\nFunzione per cancellare tutte le occorrenze di un dato dall’array.\n\n6\n\nDefinizione di un array di struct Dato.\n\n7\n\nInserimento di dati nell’array.\n\n8\n\nStampa dei dati nell’array.\n\n9\n\nCancellazione di un dato specifico e ristampa dell’array.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Il modello dati dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-modello-dati.html#linguaggi-orientati-agli-oggetti",
    "href": "prima-parte-modello-dati.html#linguaggi-orientati-agli-oggetti",
    "title": "5  Il modello dati dei linguaggi di programmazione",
    "section": "5.2 Linguaggi orientati agli oggetti",
    "text": "5.2 Linguaggi orientati agli oggetti\nLa programmazione orientata agli oggetti è un paradigma che utilizza oggetti per rappresentare concetti ed entità del mondo reale o astratto. Questo approccio si basa su un processo mentale fondamentale per risolvere problemi complessi: la decomposizione. Un problema complesso è più facilmente risolvibile se diviso in parti più piccole, ciascuna delle quali possiede uno stato e la possibilità di interagire con le altre parti. Questa divisione può essere effettuata per gradi, come se si osservasse sempre più da vicino il problema, effettivamente continunandone la specificazione, fino a raggiungere un livello sufficientemente di dettaglio da poter essere realizzato come istruzioni, codificate in costrutti permessi dalla sintassi del linguaggio, dell’oggetto.\n\n5.2.1 Oggetti\nLo stato di un oggetto è definito dai suoi attributi, i cui valori possono essere altri oggetti già disponibili, sia definiti dall’utente che dal linguaggio. L’interazione tra diversi oggetti avviene attraverso i metodi, che sono funzioni associate agli oggetti che possono modificare lo stato dell’oggetto o invocare metodi su altri oggetti.\nI membri di un oggetto (attributi e metodi) possono avere diverse limitazioni di accesso, definite dal concetto di visibilità:\n\nPubblica: Gli attributi e i metodi pubblici sono accessibili da qualsiasi parte del programma. Questa visibilità permette a qualsiasi altro oggetto o funzione di interagire con questi membri.\nPrivata: Gli attributi e i metodi privati sono accessibili solo da altri membri dell’oggetto e rispondono alla esigenza di separare il codice di interfaccia da quello utile al funzionamento interno.\nProtetta: Gli attributi e i metodi protetti sono accessibili da tutti i membri del medesimo oggetto ma, a differenza dei privati, anche da quelli degli oggetti derivati. Questo fornisce un livello intermedio di accesso, utile per la gestione dell’ereditarietà.\n\nL’incapsulamento è il principio su cui si basa la gestione della visibilità e guida la separazione del codice realizzante le specificità di un oggetto, da come è fruito dagli altri oggetti. Questo protegge l’integrità del suo stato e ne facilita la manutenzione del codice stesso, permettendo modifiche di implementazione, senza impatti sul codice esterno fintantoché non si cambiano i membri pubblici. Inoltre, se ben sfruttata nella progettazione, rende il codice più comprensibile e riduce la superficie d’attacco.\n\n\n5.2.2 Classi\nUn oggetto può essere generato da una struttura statica che ne definisce tutte le caratteristiche, la classe, oppure può essere creato a partire da un altro oggetto esistente, noto come prototipo.\nNella programmazione ad oggetti basata su classi, ogni oggetto è un’istanza vivente di una classe predefinita, che ne rappresenta il progetto o l’archetipo. La classe definisce i membri e la visibilità, quindi, in definitiva tutte le proprietà comuni agli oggetti dello stesso tipo o matrice. Gli oggetti vengono creati chiamando un metodo speciale della classe, noto come costruttore e, all’atto della loro vita, un secondo metodo, il distruttore, che si occupa di effettuare le azioni di terminazione.\nLa classe può inoltre definire metodi e attributi particolari, che possono essere ereditati da altre classi, cioè possono essere utilizzati da quest’ultime al pari dei propri membri. In tal modo, il linguaggio permette la costruzioni di gerarchie di classi che modellano relazioni di specializzazione, dalla più generale alla più particolare.\nCiò, oltre ad essere uno strumento di progettazione utile di per sé, facilita il riuso del codice per mezzo dell’estensione, al posto della modifica, di funzionalità. La classe che eredita da un’altra classe si definisce derivata dalla classe che, a sua volta, è detta base.\n\n\n5.2.3 Prototipi\nAlternativamente, alcuni linguaggi usano il concetto di prototipo, in cui gli oggetti sono le entità principali e non esiste una matrice separata come la classe. In questo paradigma, ogni oggetto può servire da prototipo per altri e ciò significa che, invece di creare nuove istanze di una classe, si creano nuovi oggetti clonando o estendendo quelli esistenti. È possibile aggiungere o modificare proprietà e metodi di un oggetto prototipo e, in tal caso, queste modifiche si propagheranno in tutti gli oggetti che derivano da esso.\nIl paradigma basato su prototipi offre maggiore flessibilità e dinamismo rispetto a quello basato su classi, poiché la struttura degli oggetti può essere modificata in modo dinamico. D’altronde, questo approccio può anche introdurre complessità e rendere più difficile la gestione delle gerarchie di oggetti e la comprensione del codice, poiché non esistono strutture fisse come le classi.\n\n\n5.2.4 Esempi di gerarchie di classi e prototipi\nVediamo le differenze tra classi e prototipi, riprendendo l’esempio in Java nella versione semplificata (senza astrazione):\nclass Animale { \n    String nome;\n\n    Animale(String nome) {\n        this.nome = nome;\n    }\n\n    void faiVerso() {\n        System.out.println(\"L'animale fa un verso\");\n    }\n}\n\nclass Cane extends Animale { \n\n    Cane(String nome) {\n        super(nome);\n    }\n\n    @Override\n    void faiVerso() {\n        System.out.println(\"Il cane abbaia\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animale mioCane = new Cane(\"Fido\");\n\n        mioCane.faiVerso(); \n    }\n}\nImplementiamo il medesimo programma in Javascript1, linguaggio che usa il concetto di prototipo:\n1 In JavaScript, le classi come sintassi sono state introdotte in ECMAScript 6 (ES6), per semplificare la creazione di oggetti e la gestione dell’ereditarietà prototipale. Tuttavia, è importante capire che sotto il cofano, JavaScript non utilizza classi nel senso tradizionale come in linguaggi come Java o C++ e non esiste un meccanismo nativo per creare classi astratte, anche se è possibile simulare il comportamento delle classi astratte utilizzando varie tecniche. Una comune è quella di lanciare un’eccezione se un metodo funzionalmente astratto non viene sovrascritto nella classe derivata.1let Animale = {\n    nome: \"Generic\",\n\n    init: function(nome) {\n        this.nome = nome;\n    },\n\n    faiVerso: function() {\n        console.log(\"L'animale fa un verso\");\n    }\n};\n\n2let Cane = Object.create(Animale);\n\n3Cane.faiVerso = function() {\n    console.log(\"Il cane abbaia\");\n};\n\n4let mioCane = Object.create(Cane);\n5mioCane.init(\"Fido\");\n\n6mioCane.faiVerso();\n\n1\n\nDefinizione dell’oggetto prototipo Animale.\n\n2\n\nCreazione di un nuovo oggetto basato sul prototipo Animale.\n\n3\n\nViene creato un nuovo oggetto Cane basato sul prototipo Animale, usando Object.create(Animale). Questo permette a Cane di ereditare proprietà e metodi da Animale. Il metodo faiVerso viene sovrascritto nell’oggetto Cane per specificare il comportamento da cane.\n\n4\n\nUn nuovo oggetto mioCane viene creato basandosi sul prototipo Cane usando Object.create(Cane).\n\n5\n\nIl metodo init viene chiamato per inizializzare il nome dell’oggetto mioCane.\n\n6\n\nQuando viene chiamato mioCane.faiVerso(), il metodo sovrascritto nell’oggetto Cane viene eseguito, mostrando Il cane abbaia.\n\n\n\n\n5.2.5 Ereditarietà\nCome abbiamo visto, l’ereditarietà è un meccanismo che permette a una classe di ereditare membri da un’altra classe. Essa si può presentare singola o multipla, ove la prima consente a una classe derivata di estendere solo una classe base. Questo è il modello di ereditarietà più comune e supportato da molti linguaggi di programmazione orientati agli oggetti, come Java e C#.\nL’ereditarietà multipla è tale da permettere a una classe di ricevere attributi e metodi contemporaneamente da più classi base. Questo meccanismo risponde all’esigenza di specializzare più concetti allo stesso tempo. Va sottolineato che è uno strumento potente prono, però, ad abusi, perché può introdurre complessità nella gestione delle gerarchie di classi e causare conflitti quando lo stesso metodo è ereditato da più classi, situazione nota come problema del diamante. Pertanto, alcuni linguaggi ne limitano l’applicazione, come Java che consente solo l’ereditarietà multipla di interfacce, ma non di classi. Altri, come Go, non supportano l’ereditarietà per scelta di progettazione. Go enfatizza la composizione rispetto all’ereditarietà per promuovere uno stile di programmazione più essenziale e flessibile. La composizione consente di costruire comportamenti complessi aggregando oggetti più semplici, evitando le complicazioni delle gerarchie di classi multilivello. Il C++, invece, supporta completamente l’ereditarietà multipla.\n\n\n5.2.6 Interfacce e classi astratte\nLe interfacce e le classi astratte sono due concetti fondamentali nella programmazione orientata agli oggetti, che consentono di definire contratti che le classi concrete devono rispettare.\nUn’interfaccia è un contratto che specifica un insieme di metodi che una classe deve implementare, senza fornire l’implementazione effettiva di questi metodi. Sono utilizzate per definire comportamenti comuni che possono essere condivisi da classi diverse, indipendentemente dalla loro posizione nella gerarchia delle classi. Le classi che implementano un’interfaccia devono fornire una definizione concreta per tutti i metodi dichiarati nell’interfaccia. In Java, ad esempio, le interfacce sono definite con la parola chiave interface.\nUna classe astratta è una classe che non può essere istanziata direttamente. Può contenere sia metodi astratti (senza codice al loro interno, che devono essere implementati dalle classi derivate) sia metodi concreti (con codice allinterno, che possono essere utilizzati dalle classi derivate). Le classi astratte sono utilizzate per fornire una base comune con alcune implementazioni di default e lasciare ad altre classi il compito di completare l’implementazione. In Java, le classi astratte sono definite con la parola chiave abstract.\nEsempio di interfaccia, classa astratta e ereditarietà multipla in Java:\n1interface Domesticazione {\n2  void assegnaAddomesticato(boolean addomesticato);\n3  boolean ottieniAddomesticato();\n}\n\n4abstract class Animale {\n  String nome;\n\n  Animale(String nome) {\n    this.nome = nome;\n  }\n\n5  abstract String faiVerso();\n\n6  String descrizione() {\n    return \"L'animale si chiama \" + nome;\n  }\n}\n\n7class Cane extends Animale implements Domesticazione {\n8  private boolean addomesticato;\n\n  Cane(String nome) {\n    super(nome);\n  }\n\n  @Override\n9  String faiVerso() {\n    return \"Il cane abbaia\";\n  }\n\n  @Override\n10  public void assegnaAddomesticato(boolean addomesticato) {\n    this.addomesticato = addomesticato; \n  }\n\n  @Override\n11  public boolean ottieniAddomesticato() {\n    return addomesticato; \n  }\n}\n\n12class Coccodrillo extends Animale {\n\n  Coccodrillo(String nome) {\n    super(nome);\n  }\n\n  @Override\n  String faiVerso() {\n    return \"\";  \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n13    Cane mioCane = new Cane(\"Fido\");\n\n    System.out.println(mioCane.descrizione()); \n    System.out.println(mioCane.faiVerso());    \n\n    mioCane.assegnaAddomesticato(true); \n    System.out.println(\"Cane addomesticato: \" + \n                       mioCane.ottieniAddomesticato());\n\n14    Coccodrillo mioCoccodrillo = new Coccodrillo(\"Crocky\");\n\n    System.out.println(mioCoccodrillo.descrizione()); \n    System.out.println(mioCoccodrillo.faiVerso());   \n  }\n}\n\n1\n\nInterfaccia che definisce una proprietà che gli animali possono possedere, la domesticazione. Da notare che la domesticazione è una proprietà complementare alle altre caratterizzanti l’animale, addirittura non aprioristica.\n\n2\n\nMetodo per impostare lo stato di addomesticamento dell’animale.\n\n3\n\nMetodo per verificare se è addomesticato.\n\n4\n\nClasse astratta che ha l’implementazione di una caratteristica condivisa dalle classi derivate, descrizione(), e un metodo astratto per una seconda, faiVerso(), che, deve essere sempre presente negli oggetti di tipo base animale, ma non ne è comume l’implementazione.\n\n5\n\nMetodo astratto.\n\n6\n\nMetodo concreto.\n\n7\n\nIl cane è un animale che può essere addomesticato, quindi la classe Cane deriva Animale (cioè deve implementare necessariamente faiVerso()) e implementa Domesticazione (cioè deve implementare assegnaAddomesticato() e ottieniAddomesticato()). descrizione() viene ereditato colla implementazione di Animale.\n\n8\n\nVariabile utile a registrare se il cane è stato addomesticato.\n\n9\n\nCane implementa faiVerso() di Animale.\n\n10\n\nCane implementa assegnaAddomesticato() di Domesticazione.\n\n11\n\nCane implementa ottieniAddomesticato() di Domesticazione.\n\n12\n\nIl coccodrillo non è addomesticabile, quindi, Coccodrillo non implementa l’interfaccia Domesticazione, ma è comunque un animale quindi deriva Animale e ne implementa l’unico metodo astratto faiVerso(). Non essendo addomesticabile, non ha neanche l’attributo addomesticato.\n\n13\n\nCreazione dell’oggetto Cane.\n\n14\n\nCreazione dell’oggetto Coccodrillo.\n\n\nLe interfacce e le classi astratte sono strumenti potenti per promuovere la riusabilità del codice e l’estensibilità dei sistemi software, poiché permettono di definire contratti chiari e di implementare diverse versioni di una funzionalità senza modificare il codice preesistente.\n\n\n5.2.7 Polimorfismo\nIl polimorfismo è un concetto chiave della programmazione orientata agli oggetti che permette a oggetti di classi diverse di essere trattati come oggetti di una classe comune. È uno strumento complementare all’ereditarietà, nelle mani del programmatore, utile a modellare comportamenti comuni per oggetti di tipi diversi, permettendo al codice di interagire con questi oggetti senza conoscere esattamente il loro tipo specifico. In termini pratici, il polimorfismo permette di chiamare metodi su oggetti di tipi diversi e ottenere comportamenti specifici a seconda del tipo di oggetto su cui viene chiamato il medesimo metodo.\nIl concetto di polimorfismo è strettamente legato all’idea di contratto tra oggetti. Questo contratto è definito dalle interfacce o dalle classi base e specifica quali metodi devono essere implementati dalle classi derivate. Quando un oggetto di una classe derivata è trattato come un oggetto della classe base o di un’interfaccia, si garantisce che esso rispetti il contratto definito dalla classe base o dall’interfaccia.\nEsistono due tipi principali di polimorfismo:\n\nPolimorfismo statico: Conosciuto soprattutto come overloading, si verifica quando più metodi nella stessa classe hanno lo stesso nome ma firme diverse (diverso numero o tipo di parametri). Il compilatore decide quale metodo chiamare in base alla firma del metodo.\n\nEsempio in Java che supporta l’overloading:\nclass Esempio {\n  void stampa(int a) {\n    System.out.println(\"Intero: \" + a);\n  }\n\n  void stampa(String a) {\n    System.out.println(\"Stringa: \" + a);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Esempio es = new Esempio();\n\n1    es.stampa(5);\n2    es.stampa(\"ciao\");\n  }\n}\n\n1\n\nChiama il metodo stampa(int a).\n\n2\n\nChiama il metodo stampa(String a).\n\n\n\nPolimorfismo dinamico: Noto come overriding, si verifica quando una classe derivata fornisce una specifica implementazione di un metodo già definito nella sua classe base. L’implementazione da chiamare è determinata a runtime, cioè a tempo di esecuzione e non compilazione, in base al tipo dell’oggetto.\n\nEsempio in Java riprendendo l’esempio con gli animali:\nclass Animale {\n  void faiVerso() {\n    System.out.println(\"L'animale fa un verso\");\n  }\n}\n\nclass Cane extends Animale {\n  @Override\n  void faiVerso() {\n    System.out.println(\"Il cane abbaia\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n1    Animale mioAnimale = new Cane();\n\n2    mioAnimale.faiVerso();\n  }\n}\n\n1\n\nL’oggetto mioAnimale è dichiarato come tipo Animale ma istanziato come Cane. Questo è un esempio di polimorfismo.\n\n2\n\nIl metodo faiVerso() viene chiamato sull’oggetto mioAnimale, ma viene eseguita la versione del metodo faiVerso() definita nella classe Cane, grazie al polimorfismo.\n\n\nIl polimorfismo è strettamente legato all’ereditarietà, poiché l’ereditarietà è spesso il meccanismo che permette al polimorfismo di funzionare. Quando una classe derivata estende una classe base e sovrascrive i suoi metodi, permette agli oggetti della classe derivata di essere trattati come oggetti della classe base ma di comportarsi in modo specifico alla classe derivata.\nI linguaggi di programmazione hanno delle differenze in relazione al supporto del polimorfismo:\n\nJava: Supporta sia l’overloading che l’overriding.\nC++: Supporta sia l’overloading che l’overriding. Fornisce meccanismi per specificare il tipo di legame (statico o dinamico) usando parole chiave come virtual.\nPython: Supporta l’overriding, ma non l’overloading nello stesso senso di Java o C++. Python permette la definizione di metodi con argomenti predefiniti o argomenti variabili per ottenere un effetto simile all’overloading.\n\nEsempio in Java da confrontare con quello seguente in Python:\nclass Animale {\n1  void faiVerso() {\n    System.out.println(\"L'animale fa un verso\"); \n  }\n}\n\nclass Cane extends Animale {\n  @Override\n2  void faiVerso() {\n    System.out.println(\"Il cane abbaia\"); \n  }\n\n3  void faiVerso(String suono) {\n    System.out.println(\"Il cane fa: \" + suono); \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n4    Animale mioAnimale = new Cane();\n5    mioAnimale.faiVerso();\n\n    Cane mioCane = new Cane();\n6    mioCane.faiVerso(\"bau\");\n  }\n}\n\n1\n\nMetodo faiVerso() definito nella classe base Animale.\n\n2\n\nOverriding del metodo faiVerso() nella classe derivata Cane.\n\n3\n\nOverloading del metodo faiVerso() nella classe derivata Cane.\n\n4\n\nDichiarazione di un oggetto di tipo Animale, ma istanziato come Cane.\n\n5\n\nChiamata al metodo faiVerso(), che esegue la versione del metodo nella classe Cane grazie al polimorfismo.\n\n6\n\nChiamata al metodo faiVerso(String suono), che dimostra l’overloading del metodo nella classe Cane.\n\n\nE in Python diventa:\nclass Animale:\n1  def fai_verso(self):\n    print(\"L'animale fa un verso\")  \n\nclass Cane(Animale):\n2  def fai_verso(self):\n    print(\"Il cane abbaia\")  \n\n3  def fai_verso_con_suono(self, suono):\n    print(f\"Il cane fa: {suono}\")  \n\n4mio_animale = Cane()\n5mio_animale.fai_verso()\n\nmio_cane = Cane()\n6mio_cane.fai_verso_con_suono(\"bau\")\n\n1\n\nMetodo fai_verso() definito nella classe base Animale.\n\n2\n\nOverriding del metodo fai_verso() nella classe derivata Cane.\n\n3\n\nDefinizione di un metodo aggiuntivo fai_verso_con_suono nella classe derivata Cane (Python non supporta l’overloading nello stesso senso di Java).\n\n4\n\nDichiarazione e istanziazione di un oggetto mio_animale come Cane.\n\n5\n\nChiamata al metodo fai_verso(), che esegue la versione del metodo nella classe Cane grazie al polimorfismo.\n\n6\n\nChiamata al metodo fai_verso_con_suono(suono), che dimostra una forma di polimorfismo simile all’overloading in Python.\n\n\nL’overriding è possibile grazie al dynamic dispatch, un meccanismo che consente di selezionare a runtime il metodo corretto da invocare in base al tipo effettivo dell’oggetto. Lo static disptach, al contrario, avviene al tempo di compilazione.\nMa il dispatch, cioè l’individuazione del metodo da eseguire, può essere singolo (single dispatch), così come presente nella maggior parte dei linguaggi orientati agli oggetti come Java e C++, e dove la scelta del metodo dipende solo dal tipo dell’oggetto sul quale il metodo stesso viene chiamato. Questo tipo di dispatch è sufficiente per supportare il polimorfismo detto di sottotipo, dove le classi derivate possono sovrascrivere i metodi della classe base e il metodo corretto viene selezionato a runtime in base al tipo effettivo dell’oggetto.\nIl multiple dispatch, invece, estende ulteriormente le capacità del polimorfismo permettendo la selezione del metodo da invocare basandosi sui tipi runtime di più di un argomento. Questo è particolarmente utile in scenari dove il comportamento dipende da combinazioni di tipi di oggetti, e non solo dal tipo dell’oggetto su cui il metodo è chiamato. Linguaggi come Julia e CLOS (Common Lisp Object System)supportano nativamente il multiple dispatch, mentre linguaggi come Java e C++ non lo supportano direttamente ma possono emularlo attraverso pattern come il visitor.\n\n\n5.2.8 Altri concetti\nDopo aver compreso i concetti fondamentali della programmazione orientata agli oggetti (OOP), come oggetti, classi, prototipi, ereditarietà e polimorfismo, è importante esplorare altri aspetti avanzati che contribuiscono alla potenza e alla flessibilità di questo paradigma.\n\n5.2.8.1 Mixin e trait\nI mixin e i trait sono concetti che permettono di aggiungere funzionalità a una classe senza utilizzare l’ereditarietà classica.\nI mixin sono classi che offrono metodi che possono essere utilizzati da altre classi senza essere una classe base di queste ultime. Permettono di combinare comportamenti comuni tra diverse classi.\nEsempio:\nclass MixinA:\n    def metodo_a(self):\n        print(\"Metodo A\")\n\nclass MixinB:\n    def metodo_b(self):\n        print(\"Metodo B\")\n\nclass ClasseConMixin(MixinA, MixinB):\n    pass\n\nobj = ClasseConMixin()\nobj.metodo_a()\nobj.metodo_b()\nI trait sono simili ai mixin e permettono di definire metodi che possono essere riutilizzati in diverse classi. Sono supportati nativamente in linguaggi come Scala e Rust.\ntrait TraitA {\n    def metodoA(): Unit = println(\"Metodo A\")\n}\n\ntrait TraitB {\n    def metodoB(): Unit = println(\"Metodo B\")\n}\n\nclass ClasseConTrait extends TraitA with TraitB\n\nval obj = new ClasseConTrait()\nobj.metodoA()\nobj.metodoB()\n\n\n5.2.8.2 Duck Typing\nIl duck typing è un concetto che si applica principalmente nei linguaggi dinamici, dove l’importanza è data al comportamento degli oggetti piuttosto che alla loro appartenenza a una specifica classe. Se un oggetto implementa i metodi richiesti da una certa operazione, allora può essere utilizzato per quella operazione, indipendentemente dal suo tipo.\nEsempio:\nclass Anatra:\n    def quack(self):\n        print(\"Quack!\")\n\nclass Persona:\n    def quack(self):\n        print(\"Sono una persona che imita un'anatra\")\n\ndef fai_quack(oggetto):\n    oggetto.quack()\n\nanatra = Anatra()\npersona = Persona()\n\nfai_quack(anatra)\nfai_quack(persona)",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Il modello dati dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html",
    "href": "prima-parte-altri-concetti-semantici.html",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "",
    "text": "6.1 Concorrenza\nLa concorrenza è la capacità di un programma di eseguire più sequenze di istruzioni in parallelo, migliorando le prestazioni e la reattività. La concorrenza è particolarmente utile in applicazioni che richiedono l’elaborazione simultanea di compiti indipendenti, come server web, sistemi di gestione di basi di dati e applicazioni interattive.\nUn concetto fondamentale della concorrenza è il thread, che rappresenta la più piccola unità di elaborazione eseguibile in modo indipendente. I thread permettono l’esecuzione parallela di codice all’interno di un programma, ma introducono la necessità di gestire l’accesso concorrente alle risorse condivise.\nLa sincronizzazione è essenziale per evitare condizioni di gara, che si verificano quando il risultato dell’esecuzione dipende dalla sequenza temporale in cui i thread accedono alle risorse. Meccanismi come i lock e i mutex garantiscono che solo un thread alla volta possa accedere a una risorsa condivisa, prevenendo conflitti e garantendo la consistenza dei dati.\nIn linguaggi moderni, come Python e JavaScript, la gestione delle operazioni asincrone è facilitata da costrutti come async/await. Questi costrutti migliorano l’efficienza e la reattività delle applicazioni, permettendo di eseguire operazioni di I/O senza bloccare il thread principale.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html#inputoutput-io",
    "href": "prima-parte-altri-concetti-semantici.html#inputoutput-io",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "6.2 Input/Output (I/O)",
    "text": "6.2 Input/Output (I/O)\nL’input/output (I/O) gestisce la comunicazione tra un programma e il suo ambiente esterno. Il File I/O permette la lettura e la scrittura su file, consentendo di memorizzare e recuperare dati persistenti. In molti linguaggi, come C e Python, le operazioni di file I/O sono supportate da funzioni o metodi che aprono, leggono, scrivono e chiudono file.\nIl Network I/O facilita la comunicazione tra sistemi diversi attraverso reti, consentendo di inviare e ricevere dati tra computer. Linguaggi come Java e Python offrono librerie per la gestione delle connessioni di rete, il trasferimento di dati e la comunicazione tra client e server.\nLo Standard I/O comprende l’interazione con l’utente tramite input da tastiera e output su schermo. In C, funzioni come scanf e printf gestiscono lo standard I/O, mentre in Python si utilizzano input e print.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html#annotazioni-e-metadati",
    "href": "prima-parte-altri-concetti-semantici.html#annotazioni-e-metadati",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "6.3 Annotazioni e Metadati",
    "text": "6.3 Annotazioni e Metadati\nLe annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l’analisi del codice.\nLe annotazioni sono utilizzate per specificare comportamenti speciali o configurazioni. In Java, le annotazioni come @Deprecated indicano che un metodo è obsoleto, @Override segnala che un metodo sovrascrive un metodo della superclasse, e @Entity e @Table in JPA (Jakarta Persistence) definiscono la relazione tra entità e tabelle nel contesto di un database. In Python, le annotazioni dei tipi (type hint) indicano i tipi delle variabili, dei parametri di funzione e dei valori di ritorno, migliorando la leggibilità e facilitando il type checking automatico.\nLe docstring in Python sono commenti strutturati che documentano il codice. Utilizzate per descrivere moduli, classi, metodi e funzioni, le docstring rendono il codice più leggibile e comprensibile e possono essere utilizzate per generare documentazione automatica.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html#macro-e-metaprogrammazione",
    "href": "prima-parte-altri-concetti-semantici.html#macro-e-metaprogrammazione",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "6.4 Macro e Metaprogrammazione",
    "text": "6.4 Macro e Metaprogrammazione\nLe macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice, migliorando la flessibilità e il riutilizzo.\nLe macro sono sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, le macro sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale. Le macro permettono di evitare la duplicazione di codice, ma possono anche introdurre complessità e difficoltà di debug.\nLa metaprogrammazione consiste nello scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time. In Python, la metaprogrammazione include l’uso di decoratori, che sono funzioni che modificano il comportamento di altre funzioni, e metaclassi, che permettono di controllare la creazione e il comportamento delle classi. L’introspezione, che consente di esaminare gli oggetti durante l’esecuzione del programma, è un’altra potente tecnica di metaprogrammazione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html",
    "href": "seconda-parte-python-introduzione.html",
    "title": "7  Introduzione a Python",
    "section": "",
    "text": "7.1 Perché Python è un linguaggio di alto livello?\nPython è considerato un linguaggio di programmazione di alto livello, cioè utilizza un livello di astrazione elevato rispetto alla complessità dell’ambiente in cui i suoi programmi sono eseguiti. Il programmatore ha a disposizione una sintassi che è più intuitiva rispetto ad altri linguaggi come Java, C++, PHP tradizionalmente anch’essi definiti di alto livello.\nInfatti, consente ai programmatori di scrivere codice in modo più concettuale e indipendente dalle caratteristiche degli hardware, anche molto diversi, su cui è disponibile. Ad esempio, invece di preoccuparsi di allocare e deallocare memoria manualmente, Python gestisce queste operazioni automaticamente. Questo libera il programmatore dai dettagli del sistema operativo e dell’elettronica, permettendogli di concentrarsi sulla logica del problema da risolvere.\nCiò ha un effetto importante sulla versatilità perché spesso è utilizzato come interfaccia utente per linguaggi di livello più basso come C, C++ o Fortran. Questo permette a Python di sfruttare le prestazioni dei linguaggi compilati per le parti critiche e computazionalmente intensive del codice, mantenendo al contempo una sintassi semplice e leggibile per la maggior parte del programma. Buoni compilatori per i linguaggi compilati classici possono sì generare codice binario che gira più velocemente di Python, tuttavia, nella maggior parte dei casi, le prestazioni delle applicazioni codificate in Python sono sufficienti.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#python-come-linguaggio-multiparadigma",
    "href": "seconda-parte-python-introduzione.html#python-come-linguaggio-multiparadigma",
    "title": "7  Introduzione a Python",
    "section": "7.2 Python come linguaggio multiparadigma",
    "text": "7.2 Python come linguaggio multiparadigma\nPython è un linguaggio di programmazione multiparadigma, il che significa che supporta diversi paradigmi di programmazione, permettendo di mescolare e combinare gli stili a seconda delle necessità dell’applicazione. Ecco alcuni dei paradigmi supportati da Python:\n\nProgrammazione imperativa: Puoi scrivere ed eseguire script Python direttamente dalla linea di comando, permettendo un approccio interattivo e immediato alla programmazione, come se fosse una calcolatrice.\nProgrammazione procedurale: In Python, è possibile organizzare il codice in funzioni e moduli, rendendo più semplice la gestione e la riutilizzabilità del codice. Puoi raccogliere il codice in file separati e importarli come moduli, migliorando la struttura e la leggibilità del programma.\nProgrammazione orientata agli oggetti: Python supporta pienamente la programmazione orientata agli oggetti, consentendo la definizione di classi e oggetti. Questo paradigma è utile per modellare dati complessi e relazioni tra essi. Le caratteristiche orientate agli oggetti di Python sono concettualmente simili a quelle del C++, ma più semplici da usare.\nProgrammazione funzionale: Python include funzionalità di programmazione funzionale, come funzioni di prima classe e di ordine superiore, lambda e strumenti come map, filter e reduce.\n\nQuesta flessibilità rende Python adatto a una vasta gamma di applicazioni e consente ai programmatori di scegliere l’approccio più adatto al problema da risolvere.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#regole-formali-e-esperienziali",
    "href": "seconda-parte-python-introduzione.html#regole-formali-e-esperienziali",
    "title": "7  Introduzione a Python",
    "section": "7.3 Regole formali e esperienziali",
    "text": "7.3 Regole formali e esperienziali\nPython non è solo un linguaggio con regole sintattiche precise e ben progettate, ma possiede anche una propria filosofia, un insieme di regole di buon senso esperienziali che sono complementari alla sintassi formale. Questa filosofia è spesso riassunta nel zen di Python, una raccolta di aforismi che catturano i principi fondamentali del design di Python. Tali principi aiutano i programmatori a comprendere e utilizzare al meglio le potenzialità del linguaggio e dell’ecosistema Python.\nEcco alcuni dei principi dello zen di Python1:\n1 PEP 20 – The Zen of Python\nLa leggibilità conta: Il codice dovrebbe essere scritto in modo che sia facile da leggere e comprendere.\nEsplicito è meglio di implicito: È preferibile scrivere codice chiaro e diretto piuttosto che utilizzare scorciatoie criptiche.\nSemplice è meglio di complesso: Il codice dovrebbe essere il più semplice possibile per risolvere il problema.\nComplesso è meglio di complicato: Quando la semplicità non è sufficiente, la complessità è accettabile, ma il codice non dovrebbe mai essere complicato.\nPratico batte puro: Le soluzioni pragmatiche sono preferibili alle soluzioni eleganti ma poco pratiche.\n\nQuesti principi, insieme alle regole sintattiche, guidano il programmatore nell’adottare buone pratiche di sviluppo e nel creare codice che sia non solo funzionale ma anche mantenibile e comprensibile da altri.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#lecosistema",
    "href": "seconda-parte-python-introduzione.html#lecosistema",
    "title": "7  Introduzione a Python",
    "section": "7.4 L’ecosistema",
    "text": "7.4 L’ecosistema\nFino ad ora abbiamo visto Python come linguaggio, ma è molto di più: Python è anche una vasta collezione di strumenti e risorse a disposizione degli sviluppatori, strutturata in un ecosistema completo, di cui il linguaggio ne rappresenta la parte formale. Questo ecosistema è disponibile completamente, anche come sorgente, sul sito ufficiale python.org.\n\n7.4.1 L’interprete\nL’interprete Python è lo strumento di esecuzione dei programmi. È il software che legge ed esegue il codice Python. Python è un linguaggio interpretato, il che significa che il codice viene eseguito direttamente dall’interprete, senza bisogno di essere compilato in un linguaggio macchina. Esistono diverse implementazioni dell’interprete Python:\n\nCPython: L’implementazione di riferimento dell’interprete Python, scritta in C. È la versione più utilizzata e quella ufficiale.\nPyPy: Un interprete alternativo che utilizza tecniche di compilazione just-in-time (JIT) per migliorare le prestazioni.\nJython: Un’implementazione di Python che gira sulla JVM (Java Virtual Machine).\nIronPython: Un’implementazione di Python integrata col .NET Framework della Microsoft.\n\n\n\n7.4.2 L’ambiente di sviluppo\nIDLE (integrated development and learning environment) è l’ambiente di sviluppo integrato ufficiale per Python. È incluso nell’installazione standard di Python ed è progettato per essere semplice e facile da usare, ideale per i principianti. Offre diverse funzionalità utili:\n\nEditor di codice: Con evidenziazione della sintassi, indentazione automatica e controllo degli errori.\nShell interattiva: Permette di eseguire codice Python in modo interattivo.\nStrumenti di debug: Include un debugger integrato con punti di interruzione e stepping.\n\n\n\n7.4.3 Le librerie standard\nUna delle caratteristiche più potenti di Python è il vasto insieme di librerie2 utilizzabili in CPython e IDLE, che fornisce moduli e pacchetti per quasi ogni necessità di programmazione. Alcuni esempi, tra le decine e al solo allo scopo di illustrarne la varietà, includono:\n2 Documentazione delle librerie standard di Python\nos: Fornisce funzioni per interagire con il sistema operativo.\nsys: Offre accesso a funzioni e oggetti del runtime di Python.\ndatetime: Consente di lavorare con date e orari.\njson: Permette di leggere e scrivere dati in formato JSON.\nre: Supporta la manipolazione di stringhe tramite espressioni regolari.\nhttp: Include moduli per l’implementazione di client e server HTTP.\nunittest: Fornisce un framework per il testing del codice.\nmath e cmath: Contengono funzioni matematiche di base e complesse.\nitertools, functools, operator: Offrono supporto per il paradigma di programmazione funzionale.\ncsv: Gestisce la lettura e scrittura di file CSV.\ntyping: Fornisce supporto per l’annotazione dei tipi di variabili, funzioni e classi.\nemail: Permette di creare, gestire e inviare email, facilitando la manipolazione di messaggi email MIME.\nhashlib: Implementa algoritmi di hash sicuri come SHA-256 e MD5.\nasyncio: Supporta la programmazione asincrona per la scrittura di codice concorrente e a bassa latenza.\nwave: Fornisce strumenti per leggere e scrivere file audio WAV.\n\n\n\n7.4.4 Moduli di estensione\nPython supporta l’estensione del suo core tramite moduli scritti in C, C++ o altri linguaggi. Questi moduli permettono di ottimizzare parti critiche del codice o di interfacciarsi con librerie e API esterne:\n\nCython: Permette di scrivere moduli C estesi utilizzando una sintassi simile a Python. Cython è ampiamente utilizzato per migliorare le prestazioni di parti critiche del codice, specialmente in applicazioni scientifiche e di calcolo numerico. Ad esempio, molte librerie scientifiche popolari come SciPy e scikit-learn utilizzano Cython per accelerare le operazioni computazionalmente intensive.\nctypes: Permette di chiamare funzioni in librerie dinamiche C direttamente da Python. È utile per interfacciarsi con librerie esistenti scritte in C, rendendo Python estremamente versatile per l’integrazione con altre tecnologie. Ciò è utile in applicazioni che devono interfacciarsi con hardware specifico o utilizzare librerie legacy.\nCFFI (C Foreign Function Interface): Un’altra interfaccia per chiamare librerie C da Python. È progettata per essere facile da usare e per supportare l’uso di librerie C complesse con Python. CFFI è utilizzato in progetti come PyPy e gevent, permettendo di scrivere codice ad alte prestazioni e di gestire le chiamate a funzioni C in modo efficiente.\n\n\n\n7.4.5 Le utility e gli strumenti aggiuntivi\nPython include anche una serie di strumenti e utility che facilitano lo sviluppo e la gestione dei progetti:\n\npip: Il gestore dei pacchetti di Python. Permette di installare e gestire moduli aggiuntivi, cioè non inclusi nello standard.\nvenv: Uno strumento per creare ambienti virtuali isolati, che permettono di gestire separatamente le dipendenze di diversi progetti.\nDocumentazione: Python include una documentazione dettagliata, accessibile tramite il comando pydoc o attraverso il sito ufficiale.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#un-esempio-di-algorimo-in-python-il-bubble-sort",
    "href": "seconda-parte-python-introduzione.html#un-esempio-di-algorimo-in-python-il-bubble-sort",
    "title": "7  Introduzione a Python",
    "section": "7.5 Un esempio di algorimo in Python: il bubble sort",
    "text": "7.5 Un esempio di algorimo in Python: il bubble sort\nPer chiudere il capitolo sul primo approccio a Python, possiamo confrontare un algoritmo, di bassa complessità ma non triviale, in diversi linguaggi di programmazione. Un buon esempio potrebbe essere l’implementazione dell’algoritmo di ordinamento bubble sort di una lista di valori. Vediamo come viene scritto in Python, C, C++, Java, Rust e Scala:\n\nPython in versione procedurale:\ndef bubble_sort(arr):\n  n = len(arr)\n\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] &gt; arr[j+1]:\n        arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sort(arr)\n\nprint(\"Array ordinato con bubble sort: \", arr)\nPython in versione sintatticamente orientata agli oggetti, ma praticamente procedurale:\nclass BubbleSort:\n  @staticmethod\n  def bubble_sort(arr):\n    n = len(arr)\n\n    for i in range(n):\n      for j in range(0, n-i-1):\n        if arr[j] &gt; arr[j+1]:\n          arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nBubbleSort.bubble_sort(arr)\n\nprint(\"Array ordinato con bubble sort: \", arr)\nPython in versione orientata agli oggetti, con una interfaccia di ordinamento implementata con due algoritmi (bubble e insertion sort):\n1from abc import ABC, abstractmethod\n\n# Classe astratta per algoritmi di ordinamento\n2class SortAlgorithm(ABC):\n  def __init__(self, arr):\n    self._arr = arr\n\n  @abstractmethod\n3  def sort(self):\n    # Metodo astratto che deve essere implementato dalle sottoclassi\n    pass\n\n  def get_array(self):\n    # Metodo per ottenere l'array corrente\n    return self._arr\n\n  def set_array(self, arr):\n    # Metodo per impostare un nuovo array\n    self._arr = arr\n\n# Implementazione dell'algoritmo di bubble sort\n4class BubbleSort(SortAlgorithm):\n  def sort(self):\n    n = len(self._arr)\n\n    for i in range(n):\n      for j in range(0, n-i-1):\n        if self._arr[j] &gt; self._arr[j+1]:\n          self._arr[j], self._arr[j+1] = self._arr[j+1], self._arr[j]\n\n# Implementazione dell'algoritmo di insertion sort\nclass InsertionSort(SortAlgorithm):\n  def sort(self):\n    for i in range(1, len(self._arr)):\n      key = self._arr[i]\n\n      j = i - 1\n\n      while j &gt;= 0 and key &lt; self._arr[j]:\n        self._arr[j + 1] = self._arr[j]\n\n        j -= 1\n\n      self._arr[j + 1] = key\n\n# Esempio di utilizzo con bubble sort\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sorter = BubbleSort(arr)\n\nbubble_sorter.sort()\n\nprint(\"Array ordinato con bubble sort: \", bubble_sorter.get_array())\n\n# Esempio di utilizzo con insertion sort\narr = [64, 34, 25, 12, 22, 11, 90]\n\ninsertion_sorter = InsertionSort(arr)\n\ninsertion_sorter.sort()\n\nprint(\"Array ordinato con insertion sort: \", insertion_sorter.get_array())\n\n1\n\nImportiamo ABC e abstractmethod dal modulo abc per definire la classe astratta.\n\n2\n\nSortAlgorithm è una classe astratta che rappresenta l’interfaccia di algoritmi di ordinamento.\n\n3\n\nsort è un metodo astratto che deve essere implementato nelle sottoclassi.\n\n4\n\nBubbleSort è una sottoclasse di SortAlgorithm che implementa l’algoritmo di ordinamento a bolle. Idem per InsertionSort.\n\n\nPython in versione funzionale:\ndef bubble_sort(arr):\n1  def sort_pass(arr, n):\n    if n == 1:\n      return arr\n\n2    new_arr = arr[:]\n\n    for i in range(n - 1):\n      if new_arr[i] &gt; new_arr[i + 1]:\n        new_arr[i], new_arr[i + 1] = new_arr[i + 1], new_arr[i]\n\n3    return sort_pass(new_arr, n - 1)\n\n4  return sort_pass(arr, len(arr))\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nsorted_arr = bubble_sort(arr)\n\nprint(\"Sorted array is:\", sorted_arr)\n\n1\n\nAll’interno di bubble_sort, è definita una funzione interna sort_pass che esegue un singolo passaggio dell’algoritmo di ordinamento a bolle.\n\n2\n\nViene creata una copia dell’array arr chiamata new_arr. Poi, per ogni coppia di elementi (new_arr[i], new_arr[i + 1]), se new_arr[i] è maggiore di new_arr[i + 1], vengono scambiati.\n\n3\n\nLa funzione sort_pass viene chiamata ricorsivamente con new_arr e decrementando n di 1.\n\n4\n\nLa funzione bubble_sort avvia il processo chiamando sort_pass con l’array completo e la sua lunghezza.\n\n\nC:\n#include &lt;stdio.h&gt;\n\nvoid bubble_sort(int arr[], int n) {\n  int i, j, temp;\n\n  for (i = 0; i &lt; n-1; i++) {\n    for (j = 0; j &lt; n-i-1; j++) {\n      if (arr[j] &gt; arr[j+1]) {\n        temp = arr[j];\n\n        arr[j] = arr[j+1];\n\n        arr[j+1] = temp;\n      }\n    }\n  }\n}\n\nint main() {\n  int arr[] = {64, 34, 25, 12, 22, 11, 90};\n  int n = sizeof(arr)/sizeof(arr[0]);\n\n  bubble_sort(arr, n);\n\n  printf(\"Array ordinato con bubble sort: \");\n\n  for (int i = 0; i &lt; n; i++) {\n    printf(\"%d \", arr[i]);\n  }\n\n  return 0;\n}\nC++:\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass BubbleSort {\npublic:\n  void sort(int arr[], int n) {\n    for (int i = 0; i &lt; n-1; i++) {\n      for (int j = 0; j &lt; n-i-1; j++) {\n        if (arr[j] &gt; arr[j+1]) {\n          int temp = arr[j];\n\n          arr[j] = arr[j+1];\n\n          arr[j+1] = temp;\n        }\n      }\n    }\n  }\n\n  void printArray(int arr[], int n) {\n    for (int i = 0; i &lt; n; i++) {\n      cout &lt;&lt; arr[i] &lt;&lt; \" \";\n    }\n\n    cout &lt;&lt; endl;\n  }\n};\n\nint main() {\n  int arr[] = {64, 34, 25, 12, 22, 11, 90};\n  int n = sizeof(arr)/sizeof(arr[0]);\n\n  BubbleSort bs;\n  bs.sort(arr, n);\n\n  cout &lt;&lt; \"Array ordinato con bubble sort: \";\n  bs.printArray(arr, n);\n\n  return 0;\n}\nJava:\npublic class BubbleSort {\n\n  public static void bubbleSort(int arr[]) {\n    int n = arr.length;\n\n    for (int i = 0; i &lt; n-1; i++) {\n      for (int j = 0; j &lt; n-i-1; j++) {\n        if (arr[j] &gt; arr[j+1]) {\n\n          int temp = arr[j];\n\n          arr[j] = arr[j+1];\n\n          arr[j+1] = temp;\n        }\n      }\n    }\n  }\n\n  public static void main(String args[]) {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n\n    bubbleSort(arr);\n\n    System.out.println(\"Array ordinato con bubble sort: \");\n\n    for (int i = 0; i &lt; arr.length; i++) {\n      System.out.print(arr[i] + \" \");\n    }\n  }\n}\nRust:\nfn bubble_sort(arr: &mut [i32]) {\n  let n = arr.len();\n\n  for i in 0..n {\n    for j in 0..n-i-1 {\n      if arr[j] &gt; arr[j+1] {\n        arr.swap(j, j+1);\n      }\n    }\n  }\n}\n\nfn main() {\n  let mut arr = [64, 34, 25, 12, 22, 11, 90];\n\n  bubble_sort(&mut arr);\n\n  println!(\"Array ordinato con bubble sort: {:?}\", arr);\n}\nScala:\nobject BubbleSort {\n  def bubbleSort(arr: Array[Int]): Unit = {\n    val n = arr.length\n\n    for (i &lt;- 0 until n) {\n      for (j &lt;- 0 until n - i - 1) {\n        if (arr(j) &gt; arr(j + 1)) {\n          val temp = arr(j)\n\n          arr(j) = arr(j + 1)\n\n          arr(j + 1) = temp\n        }\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val arr = Array(64, 34, 25, 12, 22, 11, 90)\n\n    bubbleSort(arr)\n\n    println(\"Array ordinato con bubble sort: \" + arr.mkString(\", \"))\n  }\n}\n\nConfrontando questi esempi, possiamo osservare le differenze sintattiche e di stile tra Python ed altri, importanti, linguaggi. Python si distingue per la sua sintassi concisa e espressiva soprattutto nella versione procedurale. L’implementazione colla gerarchia di oggetti ha un piccolo incremento di complessità che è ripagato dalla possibilità di creare gerarchie di algoritmi di ordinamento, con impatti nulli sul codice preesistente.\nLa versione procedurale in Python e l’implementazione C, già a primo acchito, presentano un evidente diverso grado di chiarezza del codice. Inoltre, la riga int n = sizeof(arr)/sizeof(arr[0]); in C si rende necessaria per calcolare il numero di valori a partire dalle dimensioni totale della lista e del singolo elemento, rispetto a n = len(arr) di Python, dove chiediamo direttamente il numero di valori.\nIl C++ e Java aggiungono caratteristiche relative agli oggetti e funzionalità di alto livello rispetto a C, al prezzo di una sintassi più complessa e verbosa. Rust e Scala sono linguaggi più moderni e si pongono nel mezzo tra C, C++ e Java e Python.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html",
    "href": "seconda-parte-python-installazione.html",
    "title": "8  Scaricare e installare Python",
    "section": "",
    "text": "8.1 Scaricamento",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#scaricamento",
    "href": "seconda-parte-python-installazione.html#scaricamento",
    "title": "8  Scaricare e installare Python",
    "section": "",
    "text": "Visita il sito ufficiale di Python: Vai su python.org.\nNaviga alla pagina di download: Clicca su Downloads nel menu principale.\nScarica il pacchetto di installazione:\n\nPer Windows: Cerca Python 3.12.x e fai partire il download (assicurati di scaricare la versione più recente).\nPer macOS: Come per Windows.\nPer Linux: Python è spesso preinstallato. Se non lo è, usa il gestore di pacchetti della tua distribuzione (ad esempio apt per Ubuntu: sudo apt-get install python3).",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#installazione",
    "href": "seconda-parte-python-installazione.html#installazione",
    "title": "8  Scaricare e installare Python",
    "section": "8.2 Installazione",
    "text": "8.2 Installazione\n\nEsegui il file di installazione:\n\nSu Windows: Esegui il file .exe scaricato. Assicurati di selezionare l’opzione Add Python to PATH durante l’installazione.\nSu macOS: Apri il file .pkg scaricato e segui le istruzioni.\nSu Linux: Usa il gestore di pacchetti per installare Python.\n\nVerifica l’installazione:\n\nApri il terminale (Command Prompt su Windows, Terminal su macOS e Linux).\nDigita python --version o python3 --version e premi Invio. Dovresti vedere la versione di Python installata.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#esecuzione-del-primo-programma-hello-world",
    "href": "seconda-parte-python-installazione.html#esecuzione-del-primo-programma-hello-world",
    "title": "8  Scaricare e installare Python",
    "section": "8.3 Esecuzione del primo programma: “Hello, World!”",
    "text": "8.3 Esecuzione del primo programma: “Hello, World!”\nÈ consuetudine eseguire come primo programma la visualizzazione della stringa “Hello, World!”1. Possiamo farlo in diversi modi e ciò è una delle caratteristiche più apprezzate di Python.\n1 La tradizione del programma “Hello, World!” ha una lunga storia che risale ai primi giorni della programmazione. Questo semplice programma è generalmente il primo esempio utilizzato per introdurre i nuovi programmatori alla sintassi e alla struttura di un linguaggio di programmazione. Il programma “Hello, World!” è diventato famoso grazie a Brian Kernighan, che lo ha incluso nel suo libro (Kernighan e Ritchie 1988) pubblicato nel 1978. Tuttavia, il suo utilizzo risale a un testo precedente di Kernighan, (Kernighan 1973), pubblicato nel 1973, dove veniva utilizzato un esempio simile.\nKernighan, Brian W., e Dennis M. Ritchie. 1988. The C Programming Language. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.\n\nKernighan, Brian W. 1973. «A Tutorial Introduction to the Programming Language B». Murray Hill, NJ: Bell Laboratories.\n\n8.3.1 REPL\nIl primo modo prevede l’utilizzo del REPL di Python. Il REPL (read-eval-print loop) è un ambiente interattivo di esecuzione di comandi Python generato dall’interprete, secondo il ciclo:\n\nRead: Legge un input dell’utente.\nEval: Valuta l’input.\nPrint: Visualizza il risultato dell’esecuzione.\nLoop: Ripete il ciclo.\n\nEseguiamo il nostro primo “Hello, World!”:\n\nApri il terminale ed esegui l’interprete Python digitando python o python3 e premi il tasto di invio della tastiera.\nScrivi ed esegui il programma:\n\nprint(\"Hello, World!\")\nPremi il tasto di invio per vedere il risultato immediatamente.\n\n\n\n\n\n\nAttenzione\n\n\n\nIl REPL e l’interprete Python sono strettamente collegati, ma non sono esattamente la stessa cosa. Quando avvii l’interprete Python senza specificare un file di script da eseguire (digitando semplicemente python o python3 nel terminale), entri in modalità REPL. Nel REPL, l’interprete Python legge l’input direttamente dall’utente, lo esegue, stampa il risultato e poi attende il prossimo input. In sintesi, l’interprete può eseguire programmi Python completi salvati in file, il REPL è progettato per un’esecuzione interattiva e immediata di singole istruzioni.\n\n\n\n\n8.3.2 Interprete\nUn altro modo per eseguire il nostro programma “Hello, World!” è utilizzare l’interprete Python per eseguire un file di codice sorgente. Questo metodo è utile per scrivere programmi più complessi e per mantenere il codice per usi futuri.\nEcco come fare sui diversi sistemi operativi.\n\nWindowsmacOSLinux\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Notepad.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dall’Esplora file.\nEsegui il file Python:\n\nApri il prompt dei comandi.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd %HOMEPATH%\\Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython hello.txt\n\noppure, se il tuo sistema utilizza python3:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come TextEdit.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dal Finder.\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documents\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Gedit o Nano.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello utilizzando il comando mv nel terminale:\n\nmv hello.txt hello\n\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCon queste istruzioni, dovresti essere in grado di eseguire il programma “Hello, World!” utilizzando un file Python su Windows, macOS e Linux.\n\n\n8.3.3 IDE\nUtilizzo di un IDE (integrated development environment) installato sul computer. Ecco alcuni dei più comuni e gratuiti.\n\nIDLEPyCharmVisual Studio Code\n\n\nÈ incluso con l’installazione di Python.\n\nAvvia IDLE.\nCrea un nuovo file (File -&gt; New File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file (File -&gt; Salva).\nEsegui il programma (Run -&gt; Run Module).\n\n\n\nProprietario ma con una versione liberamente fruibile.\n\nScarica e installa PyCharm da jetbrains.com/pycharm/download.\nCrea un nuovo progetto associando l’interprete Python.\nCrea un nuovo file Python (File -&gt; New -&gt; Python File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nEsegui il programma (Run -&gt; Run...).\n\n\n\nProprietario ma liberamente fruibile.\n\nScarica e installa VS Code da code.visualstudio.com.\nInstalla l’estensione Python.\nApri o crea una nuova cartella di progetto.\nCrea un nuovo file Python (File -&gt; Nuovo file).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file con estensione .py, ad esempio hello_world.py.\nEsegui il programma utilizzando il terminale integrato (Visualizza -&gt; Terminale) e digitando python hello_world.py.\n\n\n\n\n\n\n8.3.4 Esecuzione nel browser\nPuoi eseguire Python direttamente nel browser, senza installare nulla. Anche qui abbiamo diverse alternative, sia eseguendo il codice localmente, che utilizzando piattaforme online.\n\nRepl.itGoogle ColabPyScript\n\n\n\nVisita repl.it.\nCrea un nuovo progetto selezionando Python.\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nClicca su “Run” per eseguire il programma.\n\n\n\n\nVisita colab.research.google.com.\nCrea un nuovo notebook.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi il pulsante di esecuzione accanto alla cella.\n\n\n\n\nVisita il sito ufficiale di PyScript per ulteriori informazioni su come iniziare.\nCrea un file HTML con il seguente contenuto:\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Hello, World with PyScript&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/latest/pyscript.css\"&gt;\n    &lt;script defer src=\"https://pyscript.net/latest/pyscript.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;py-script&gt;\n        print(\"Hello, World!\")\n    &lt;/py-script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nSalva il file con estensione .html (ad esempio, hello.html).\nApri il file salvato in un browser web. Vedrai l’output Hello, World! direttamente nella pagina.\n\n\n\n\n\n\n8.3.5 Jupyter Notebook\nJupyter Notebook è un ambiente di sviluppo interattivo per la programmazione che permette di creare e condividere documenti contenenti codice eseguibile, visualizzazioni, testo formattato e altro ancora. Originariamente sviluppato come parte del progetto IPython, Jupyter supporta non solo Python, ma anche numerosi altri linguaggi di programmazione attraverso i cosiddetti kernel tra cui R, Julia e Scala.\n\nUso localeJupyterHubBinder\n\n\n\nAssicurati di avere Python e Jupyter installati sul tuo computer. Se non li hai, puoi installarli utilizzando Anaconda o pip:\n\npip install notebook\n\nAvvia Jupyter Notebook dal terminale:\n\njupyter notebook\n\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita l’istanza di JupyterHub della tua istituzione o azienda (maggiori informazioni).\nAccedi con le tue credenziali.\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita mybinder.org.\nInserisci l’URL del repository GitHub che contiene il tuo notebook o il tuo progetto Python.\nClicca su “Launch”.\nUna volta avviato l’ambiente, crea un nuovo notebook o apri uno esistente.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\nBinder è un servizio simile a Colab, anche se quest’ultimo offre strumenti generalmente più avanzati in termini di risorse computazionali e collaborazione. Binder di contro è basato su GitHub e ciò può essere utile in alcuni contesti.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html",
    "href": "seconda-parte-python-sintassi.html",
    "title": "9  La sintassi",
    "section": "",
    "text": "9.1 Elementi semantici\nPer dare un senso, anche intuitivo, ai concetti sintattici che saranno introdotti nel seguito, è opportuno definire, informalmente, alcuni elementi semantici, a partire da nozioni di base:",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#elementi-semantici",
    "href": "seconda-parte-python-sintassi.html#elementi-semantici",
    "title": "9  La sintassi",
    "section": "",
    "text": "Variabile: È un nome dato ad un valore presente in memoria.\nFunzione: È un insieme di istruzioni che può essere parametrizzato da una serie di input predefiniti e può avere una serie di output, a cui è associato un nome.\nClasse: È una definizione che raggruppa un insieme di attributi e operazioni che agiscono sugli atttributi della propria o di altre classi.\nOggetto: È un’istanza di una classe, cioè un particolare valore di una classe che è stato creato in memoria.\nModulo: È un file contenente definizioni di variabili, funzioni e classi che possono essere importate e utilizzate in altri programmi o moduli.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#righe",
    "href": "seconda-parte-python-sintassi.html#righe",
    "title": "9  La sintassi",
    "section": "9.2 Righe",
    "text": "9.2 Righe\nLe righe sono di due tipi: logiche e fisiche. Le seconde sono le più facilmente individuabili nel testo di un programma, perché sono terminate da un carattere di a capo. Una o più righe fisiche costituiscono una riga logica che corrisponde ad una istruzione. Esiste una eccezione, poco usata e consigliata in Python, per cui una riga fisica contiene più istruzioni separate da ;.\nVi sono due modi per dividere una riga logica in righe fisiche. Il primo è terminare con il backslash (\\, poco usata la traduzione barra rovesciata o simili) tutte le righe fisiche meno l’ultima (intendendo con ciò che il backslash precede l’a capo):\n1x = 1 + 2 + \\\n     3\n\n2if x &gt; 5 and \\\n3   x &lt; 9:\n  print(\"5 &lt; x &lt; 9\") \n\n1\n\nL’istruzione di assegnamento è spezzata su due righe fisiche.\n\n2\n\nL’istruzione condizionale ha due espressioni che devono essere entrambe vere, ognuna su una riga fisica.\n\n3\n\nNon importa quanto sono indentate le righe fisiche successive alla prima e ciò può essere sfruttato per incrementare la leggibilità, ad esempio, allineando le espressioni x &gt; 5 e x &lt; 9 in colonna.\n\n\nIl secondo è per mezzo di parentesi, giacché tutte le righe fisiche che seguono una con parentesi tonda (, quadra [ o graffa { aperta, fino a quella con l’analoga parentesi chiusa, sono unite in una logica. Le regole di indentazione, che vedremo nel seguito, si applicano solo alla prima riga fisica.\nEsempi sintatticamente corretti ma sconsigliabili, per l’inerente illeggibilità:\n1x = (1 + 2\n     + 3 + 4)\n\ny = [1, 2, \n2           3, 4 +\n      5] \n\n3z = [1, 2\n     , 3, 4]   \n\n1\n\nL’espressione è spezzata su due righe fisiche e le parentesi tonde rappresentano un’alternativa all’uso del backslash.\n\n2\n\nLe righe fisiche della lista non hanno la stessa indentazione e una espressione è spezzata su due righe.\n\n3\n\nLa lista è spezzata su due righe fisiche e un delimitatore inizia la riga anziché terminare la precedente.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#commenti",
    "href": "seconda-parte-python-sintassi.html#commenti",
    "title": "9  La sintassi",
    "section": "9.3 Commenti",
    "text": "9.3 Commenti\nUn commento inizia con un carattere cancelletto (#) e termina alla fine della riga fisica. I commenti non possono coesistere con il backslash come separatore di riga logica, giacché entrambi devono chiudere la riga fisica.\nEsempi non sintatticamente corretti:\n1x = 1 + 2 + \\ # Commento\n     3\n\n2if x &gt; 5 and # Commento \\\n   x &lt; 9: \n  print(\"5 &lt; x &lt; 9\") \n\n1\n\nIl backslash deve terminare la riga fisica, quindi non può essere seguito da un commento. Se necessario può andare o alla riga successiva, scelta consigliata, o alla precedente. L’interprete segnalerà l’errore SyntaxError.\n\n2\n\nIl commento rende il backslash parte di esso quindi non segnala più la fine della riga fisica e, all’esecuzione, si avrà anche qui un errore di tipo SyntaxError, perché and deve essere seguito da un’espressione.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#indentazione",
    "href": "seconda-parte-python-sintassi.html#indentazione",
    "title": "9  La sintassi",
    "section": "9.4 Indentazione",
    "text": "9.4 Indentazione\nIndentazione significa che spazi o, in alternativa, tabulazioni precedono un carattere che non sia nessuno dei due. Il numero di spazi, ottenuto dopo la trasformazione delle tabulazioni in spazi, si definisce livello di indentazione. L’indentazione del codice è il modo che Python utilizza per raggruppare le istruzioni in un blocco, ove tutte devono presentare la medesima indentazione. La prima riga logica che ha una indentazione minore della precedente, segnala che il blocco è stato chiuso proprio da quest’ultima. Anche le clausole di un’istruzione composta devono avere la stessa indentazione.\nLa prima istruzione di un file o la prima inserita al prompt &gt;&gt;&gt; del REPL non deve presentare spazi o tabulazioni, cioè ha un livello di indentazione pari a 0.\nAlcuni esempi:\n\nDefinizione di una funzione:\n1def somma(a, b):\n2  risultato = a + b\n\n  return risultato \n\n1\n\nPrima riga senza indentazione.\n\n2\n\nQuesta riga e la successiva appartengono allo stesso blocco e, pertanto, hanno la medesima indentazione.\n\n\nTest di condizione:\nx = 10\n\n1if x &lt; 0:\n2    print(\"x è negativo\")\n\nelif x == 0: \n      print(\"x è zero\") \n\nelse: \n        print(\"x è positivo\") \n\n1\n\nLe tre clausole if , then e else hanno identica indentazione.\n\n2\n\nI tre blocchi hanno come unico vincolo quello di avere un livello maggiore della riga precedente. I blocchi corrispondenti alle diverse clausole non devono avere lo stesso livello di indentazione, anche se è buona prassi farlo.\n\n\n\n\n\n\n\n\n\nAttenzione\n\n\n\nNon si possono avere sia spazi che tabulazioni per definire il livello di indentazione nello stesso file. Ciò perché renderebbe ambiguo il numero di spazi che si ottiene dopo la trasformazione delle tabulazioni in spazi. Quindi, o si usano spazi, scelta raccomandata, o tabulazioni.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#token",
    "href": "seconda-parte-python-sintassi.html#token",
    "title": "9  La sintassi",
    "section": "9.5 Token",
    "text": "9.5 Token\nLe righe logiche sono composte da token che si categorizzano in parole chiave, identificatori, operatori, delimitatori e letterali. I token sono separati da un numero arbitrario di spazi e tabulazioni. Ad esempio:\nx = 1  +  2  +  3\n\nif    x &gt; 5    and    x &lt; 9: \n  print(\"5 &lt; x &lt; 9\") \n\n9.5.1 Identificatori\nUn identificatore è un nome assegnato ad un oggetto, cioè una variabile, una funzione, una classe, un modulo e altro. Esso è case sensitive cioè python e Python sono due identificatori diversi.\nAlcuni esempi:\n1intero = 42\n2decimale = 3.14\n3testo = \"Ciao, mondo!\"\n4lista = [1, 2, 3]\n5dizionario = {\"chiave\": \"valore\"}\n\n6def mia_funzione():\n  print(\"Questa è una funzione\")\n\n7class MiaClasse:\n8  def __init__(self, valore):\n9    self.valore = valore\n    \n10  def metodo(self):\n    print(\"Questo è un metodo della classe\")\n\n11import math\n\n12def mio_generatore():\n  yield 1\n  yield 2\n  yield 3\n\n13mio_oggetto = MiaClasse(10)\n\n1\n\nIdentificatore di numero intero: intero.\n\n2\n\nIdentificatore di numero decimale: decimale.\n\n3\n\nIdentificatore di stringa: testo.\n\n4\n\nIdentificatore di lista: lista.\n\n5\n\nIdentificatore di dizionario: dizionario.\n\n6\n\nIdentificatore di funzione: mia_funzione.\n\n7\n\nIdentificatore di classe: MiaClasse.\n\n8\n\nIdentificatore di metodo e parametro: __init__ e valore.\n\n9\n\nIdentificatore di attributo: valore.\n\n10\n\nIdentificatore di metodo: metodo.\n\n11\n\nIdentificatore di modulo: math.\n\n12\n\nIdentificatore di generatore: mio_generatore.\n\n13\n\nIdentificatore di oggetto: mio_oggetto.\n\n\n\n\n9.5.2 Parole chiave\nLe parole chiave sono parole che non possono essere usate per scopi diversi da quelli predefiniti nel linguaggio e, quindi, non possono essere usate come identificatori. Ad esempio, True che rappresenta il valore logico di verità, non può essere usato per definire ad esempio una variabile.\nEsistono anche delle parole chiave contestuali, cioè che sono tali solo in alcuni contesti ed altrove possono essee usate come identificatori. Usiamo il codice seguente per ottenere una lista di parole chiave e parole chiave contestuali:\n1import keyword\n\n2parole_chiave = keyword.kwlist\n\n3parole_chiave_contestuale = keyword.softkwlist\n\n4print(parole_chiave)\n\n5print(parole_chiave_contestuale)\n\n1\n\nImporta il modulo keyword.\n\n2\n\nOttiene la lista delle parole chiave.\n\n3\n\nOttiene la lista delle parole chiave contestuali.\n\n4\n\nStampa la lista delle parole chiave.\n\n5\n\nStampa la lista delle parole chiave contestuali.\n\n\nNella tabella seguente invece un elenco completo con breve descrizione:\n\nParole chiave di Python\n\n\n\n\n\n\nParola chiave\nDescrizione\n\n\n\n\nValori booleani\n\n\n\nFalse\nValore booleano falso\n\n\nTrue\nValore booleano vero\n\n\nOperatori logici\n\n\n\nand\nOperatore logico AND\n\n\nor\nOperatore logico OR\n\n\nnot\nOperatore logico NOT\n\n\nOperatori di controllo di flusso\n\n\n\nif\nUtilizzato per creare un’istruzione condizionale\n\n\nelif\nUtilizzato per aggiungere condizioni in un blocco if\n\n\nelse\nUtilizzato per specificare il blocco di codice da eseguire se le condizioni precedenti sono false\n\n\nfor\nUtilizzato per creare un ciclo for\n\n\nwhile\nUtilizzato per creare un ciclo while\n\n\nbreak\nInterrompe il ciclo in corso\n\n\ncontinue\nSalta l’iterazione corrente del ciclo e passa alla successiva\n\n\npass\nIndica un blocco di codice vuoto\n\n\nreturn\nUtilizzato per restituire un valore da una funzione\n\n\nGestione delle eccezioni\n\n\n\ntry\nUtilizzato per definire un blocco di codice da eseguire e gestire le eccezioni\n\n\nexcept\nUtilizzato per catturare le eccezioni in un blocco try-except\n\n\nfinally\nBlocco di codice che viene eseguito alla fine di un blocco try, indipendentemente dal fatto che si sia verificata un’eccezione\n\n\nraise\nUtilizzato per sollevare un’eccezione\n\n\nDefinizione delle funzioni e classi\n\n\n\ndef\nUtilizzato per definire una funzione\n\n\nclass\nUtilizzato per definire una classe\n\n\nlambda\nUtilizzato per creare funzioni anonime\n\n\nGestione contesto di dichiarazione di variabili\n\n\n\nglobal\nUtilizzato per dichiarare variabili globali\n\n\nnonlocal\nUtilizzato per dichiarare variabili non locali\n\n\nOperazioni su moduli\n\n\n\nimport\nUtilizzato per importare moduli\n\n\nfrom\nUtilizzato per importare specifici elementi da un modulo\n\n\nas\nUtilizzato per creare alias, ad esempio negli import\n\n\nOperatori di identità e appartenenza\n\n\n\nin\nUtilizzato per verificare se un valore esiste in una sequenza\n\n\nis\nOperatore di confronto di identità\n\n\nGestione delle risorse\n\n\n\nwith\nUtilizzato per garantire un’azione di pulizia come il rilascio delle risorse\n\n\nProgrammazione asincrona\n\n\n\nasync\nUtilizzato per definire funzioni asincrone\n\n\nawait\nUtilizzato per attendere un risultato in una funzione asincrona\n\n\nVarie\n\n\n\ndel\nUtilizzato per eliminare oggetti\n\n\nassert\nUtilizzato per le asserzioni, verifica che un’espressione sia vera\n\n\nyield\nUtilizzato per restituire un generatore da una funzione\n\n\nNone\nRappresenta l’assenza di valore o un valore nullo\n\n\nParole chiave contestuali\n\n\n\nmatch\nUtilizzato nell’istruzione match per il pattern matching\n\n\ncase\nUtilizzato nell’istruzione match per definire un ramo\n\n\n_\nUtilizzato come identificatore speciale nell’istruzione match per indicare un pattern di default o ignorare valori\n\n\ntype\nUtilizzato in specifici contesti per dichiarazioni di tipo\n\n\n\nEsempi di uso di parole chiave contestuali:\n\nmatch, case e _:\n1def process_value(value):\n2  match value:\n3    case 1:\n      print(\"Uno\")\n\n    case 2:\n      print(\"Due\")\n\n4    case _:\n      print(\"Altro\")\n\n5match = \"Questo è un identificatore valido\"\n\nprocess_value(1)  # Output: Uno\nprocess_value(2)  # Output: Due\nprocess_value(3)  # Output: Altro\n\n6print(match)\n\n1\n\nDefiniamo una funzione che utilizza il pattern matching.\n\n2\n\nUso di match come parola chiave.\n\n3\n\nUso di case come parola chiave.\n\n4\n\nUso di _ come parola chiave.\n\n5\n\nUtilizzo di match come identificatore per una variabile.\n\n6\n\nOutput: Questo è un identificatore valido.\n\n\ntype:\nfrom typing import TypeAlias\n\n1type Point = tuple[float, float]\n\n2def distanza(p1: Point, p2: Point) -&gt; float:\n  return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\npunto1: Point = (1.0, 2.0) \npunto2: Point = (4.0, 6.0)\n\n3print(distanza(punto1, punto2))\n\n4print(type(punto1))\n\n1\n\nUso di type come parola chiave.\n\n2\n\nUtilizzo dell’alias di tipo Point per i parametri della funzione.\n\n3\n\nOutput: 5.0.\n\n4\n\nUso di type identificatore di una funzione. Output: &lt;class 'tuple'&gt;.\n\n\n\n\n\n9.5.3 Classi riservate di identificatori\nAlcune classi di identificatori (oltre alle parole chiave) hanno significati speciali in Python. Queste classi sono identificate dai pattern di caratteri di sottolineatura (underscore) all’inizio e alla fine dei nomi. Tuttavia, l’uso di questi identificatori non impone limitazioni rigide al programmatore, ma è importante seguire le convenzioni per evitare ambiguità e problemi di compatibilità.\nIdentificatori speciali:\n\n_:\n\nNon importato da from module import *: Gli identificatori che iniziano con un singolo underscore non vengono importati con un’istruzione di importazione globale. Questo è un meccanismo per indicare che tali variabili o funzioni sono destinate ad essere private al modulo e non dovrebbero essere usate direttamente da altri moduli. Esempio:\n\nIn un file example.py:\n1_private_variable = \"Variabile da non esportare'\"\n\n1\n\nNel modulo example.py viene definita la variabile come privata.\n\n\nIn altro modulo diverso da example.py:\n1from example import *\n\n2print(_private_variable)\n\n1\n\nDal modulo example vengono importatati tutti gli identificatori pubblici.\n\n2\n\nGenera un errore: NameError: name '_private_variable' is not defined.\n\n\n\nPattern nei match: Nel contesto di un pattern di corrispondenza all’interno di un’istruzione match, _ è una parola chiave contestuale che denota un wildcard (carattere jolly), coem indicato sopra.\nInterprete interattivo: L’interprete interattivo rende disponibile il risultato dell’ultima valutazione nella variabile _. Il valore di _ è memorizzato nel modulo builtins, insieme ad altre funzioni e variabili predefinite come print(), permettendo l’accesso globale a _ durante una sessione interattiva. Esempio:\n# Eseguire nel REPL\nresult = 5 + 3\n\n1print(_)\n\n1\n\nOutput: 8 (nell’interprete interattivo).\n\n\nAltro uso: Altrove, _ è un identificatore regolare. Viene spesso usato per nominare elementi speciali per l’utente, ma non speciali per Python stesso. Il nome _ è comunemente usato in congiunzione con l’internazionalizzazione (vedi la documentazione del modulo gettext per ulteriori informazioni su questa convenzione) ed è anche comunemente utilizzato per variabili non usate. Esempio:\n1_ = \"Valore non usato\"\n\nimport gettext\n\ngettext.install('myapplication')\n\n2print(_('Hello, world'))\n\n1\n\nUso di _ come variabile regolare.\n\n2\n\nUso di _ per internazionalizzazione.\n\n\n\n__*__: Questi nomi, informalmente noti come nomi dunder1, sono definiti dall’interprete e dalla sua implementazione (inclusa la libreria standard). Altri potrebbero essere definiti nelle versioni future di Python. Qualsiasi uso di nomi __*__, in qualsiasi contesto, che non segua l’uso esplicitamente documentato, è soggetto a discontinuazione senza preavviso. Esempio:\nclass MyClass:\n1  def __init__(self, value):\n    self.__value = value\n\n  def __str__(self):\n2    return f\"MyClass con valore {self.__value}\"\n\nobj = MyClass(10)\n\n3print(obj)\n\n1\n\nDunder per metodo chiamato alla creazione dell’oggetto.\n\n2\n\nDunder chiamato da print con parametro l’oggetto.\n\n3\n\nOutput: MyClass con valore 10.\n\n\n__*: I nomi in questa categoria, quando utilizzati all’interno di una definizione di classe, vengono riscritti dal compilatore (processo noto come name mangling) per evitare conflitti di nome tra attributi “privati” delle classi base e delle classi derivate. Questo aiuta a garantire che gli attributi destinati ad essere privati non vengano accidentalmente sovrascritti nelle sottoclassi. Esempio:\nclass BaseClass:\n  def __init__(self):\n    self.__private_attr = \"Base\"\n\nclass DerivedClass(BaseClass):\n  def __init__(self):\n    super().__init__()\n\n    self.__private_attr = \"Derived\"\n\nbase_obj = BaseClass()\nderived_obj = DerivedClass()\n\n1print(base_obj._BaseClass__private_attr)\n2print(derived_obj._DerivedClass__private_attr)\n\n1\n\nAccesso al nome di BaseClass.\n\n2\n\nAccesso al nome di DerivedClass.\n\n\n\n1 I nomi con doppio underscore (__) sono chiamati dunder come abbreviazione di double underscore.\n\n9.5.4 Operatori\nGli operatori sono rappresentati da simboli non alfanumerici e, quando applicati a uno o più identificatori, letterali o espressioni (definiti genericamente operandi), producono un risultato. Attenzione a non confondere la definizione di operatore come token, come considerata qui, con quella di operatore come funzionalità algoritmica, poiché alcune parole chiave sono operatori algoritmici e anche le funzioni possono agire come operatori.\nEsempi:\nx = 5\ny = 10\n\n1z = x + y\n\n2sum = 3 + 4\n\n3result = (x * y) + (z / 2)\n\n1\n\nUtilizza l’operatore + sugli identificatori x e y.\n\n2\n\nUtilizza l’operatore + su letterali.\n\n3\n\nUtilizza vari operatori su espressioni.\n\n\nIn tabella l’elenco degli operatori:\n\nOperatori di Python\n\n\n\n\n\n\nOperatore\nDescrizione\n\n\n\n\nAritmetici\n\n\n\n+\nAddizione\n\n\n-\nSottrazione\n\n\n*\nMoltiplicazione\n\n\n/\nDivisione\n\n\n//\nDivisione intera\n\n\n%\nModulo\n\n\n**\nEsponenziazione\n\n\n@\nMatrice (operatore di moltiplicazione)\n\n\nConfronto\n\n\n\n&lt;\nMinore\n\n\n&gt;\nMaggiore\n\n\n&lt;=\nMinore o uguale\n\n\n&gt;=\nMaggiore o uguale\n\n\n==\nUguale\n\n\n!=\nDiverso\n\n\nBitwise\n\n\n\n&\nAND bit a bit\n\n\n|\nOR bit a bit\n\n\n^\nXOR bit a bit\n\n\n~\nNOT bit a bit\n\n\n&lt;&lt;\nShift a sinistra\n\n\n&gt;&gt;\nShift a destra\n\n\nAssegnazione\n\n\n\n:=\nOperatore di assegnazione in espressione (walrus o tricheco)\n\n\n\nEsempio su @ che illustra un aspetto importante: il comportamento degli operatori può (o meglio, deve) essere definito quando si creano dei tipi di oggetto. Infatti, nel codice seguente, è definita una matrice assieme a una delle operazioni matematiche più comuni che è la moltiplicazione, implementata per mezzo di __matmul__:\nclass Matrice:\n  def __init__(self, righe):\n    self.righe = righe\n    self.num_righe = len(righe)\n    self.num_colonne = len(righe[0]) if righe else 0\n\n  def __matmul__(self, altra):\n1    if self.num_colonne != altra.num_righe:\n      raise ValueError(\"Non è possibile moltiplicare le matrici: \"\n                       \"dimensioni incompatibili.\")\n    \n2    risultato = [[0 for _ in range(altra.num_colonne)]\n           for _ in range(self.num_righe)]\n    \n3    for i in range(self.num_righe):\n      for j in range(altra.num_colonne):\n        for k in range(self.num_colonne):\n          risultato[i][j] += (self.righe[i][k] *\n                              altra.righe[k][j])\n    \n    return Matrice(risultato)\n\n4  def __repr__(self):\n    return '\\n'.join([' '.join(map(str, riga)) for riga in self.righe])\n\n# Definizione di due matrici\nA = Matrice([[1, 2], \n             [3, 4]])\nB = Matrice([[5, 6], \n             [7, 8]])\n\n5C = A @ B\n\nprint(\"Matrice A:\")\nprint(A)\n\nprint(\"Matrice B:\")\nprint(B)\n\nprint(\"Risultato di A @ B:\")\n6print(C)\n\n1\n\nControlla se le dimensioni sono compatibili per la moltiplicazione.\n\n2\n\nInizializza la matrice risultato con zeri.\n\n3\n\nEsegue la moltiplicazione delle matrici.\n\n4\n\nRappresentazione leggibile della matrice.\n\n5\n\nMoltiplicazione di matrici utilizzando l’operatore @.\n\n6\n\nChiama __matmul__ per ottenere la stringa su due righe: 19 22 e 43 50.\n\n\nInfine, @ è anche un delimitatore.\n\n\n9.5.5 Delimitatori\nIn Python, alcuni token servono come delimitatori nella grammatica del linguaggio. I delimitatori sono caratteri che separano le varie componenti del codice, come espressioni, blocchi di codice, parametri di funzioni e istruzioni.\nLa seguente tabella include tutti i delimitatori e i principali utilizzi:\n\nDelimitatori di Python\n\n\n\n\n\n\nDelimitatore\nDescrizione\n\n\n\n\n(\nUtilizzata per raggruppare espressioni, chiamate di funzione e definizioni di tupla\n\n\n)\nUtilizzata per chiudere le parentesi tonde aperte\n\n\n[\nUtilizzate per definire liste e accedere agli elementi delle liste, tuple, o stringhe\n\n\n]\nUtilizzate per chiudere le parentesi quadre aperte\n\n\n{\nUtilizzate per definire dizionari e set\n\n\n}\nUtilizzate per chiudere le parentesi graffe aperte\n\n\n,\nUtilizzata per separare elementi in liste, tuple, e argomenti nelle chiamate di funzione\n\n\n:\nUtilizzato per definire blocchi di codice (come in if, for, while, def, class) e per gli slice\n\n\n.\nUtilizzato per accedere agli attributi di un oggetto. Può apparire in letterali decimnali e immaginari\n\n\n;\nUtilizzato per separare istruzioni multiple sulla stessa riga\n\n\n@\nUtilizzato per dichiarare decoratori per funzioni e metodi\n\n\n=\nOperatore utilizzato per assegnare valori a variabili\n\n\n-&gt;\nAnnotazione del tipo di ritorno delle funzioni\n\n\n+=\nAssegnazione aumentata con addizione. Aggiunge il valore a destra a quello a sinistra e assegna il risultato alla variabile a sinistra. Come i successivi, è sia un delimitatore che un operatore\n\n\n-=\nAssegnazione aumentata con sottrazione\n\n\n*=\nAssegnazione aumentata con moltiplicazione\n\n\n/=\nAssegnazione aumentata con divisione\n\n\n//=\nAssegnazione aumentata con divisione intera\n\n\n%=\nAssegnazione aumentata con modulo\n\n\n@=\nAssegnazione aumentata con moltiplicazione di matrici\n\n\n&=\nAssegnazione aumentata con AND bit a bit\n\n\n|=\nAssegnazione aumentata con OR bit a bit\n\n\n^=\nAssegnazione aumentata con XOR bit a bit\n\n\n&gt;&gt;=\nAssegnazione aumentata con shift a destra\n\n\n&lt;&lt;=\nAssegnazione aumentata con shift a sinistra\n\n\n**=\nAssegnazione aumentata con esponenziazione\n\n\n\nUna sequenza di tre punti, comunemente indicata come ellissi anche al difuori dei linguaggi di programmazione,2 è trattata come un token a sé e corrisponde ad un oggetto predefinito chiamato Ellipsis, con applicazioni in diversi contesti:\n2 L’ellissi è usata, ad esempio, in C per dichiarare funzioni che accettano un numero variaible di parametri e i Javascript come operatore per espandere gli array o le proprietà di un oggetto.1print(type(...))\n\ndef funzione_da_completare():\n2  ...\n\nclass ClasseEsempio:\n  def metodo_da_completare(self):\n    ...\n\nfrom typing import Callable\n\n3def funzione_variadica(func: Callable[..., int]):\n  pass\n\nimport numpy as np\n\narray = np.array([[[1, 2, 3],    [4, 5, 6]], \n                  [[7, 8, 9], [10, 11, 12]]]) \n\n4print(array[..., 1])\n\n1\n\nOtteniamo il tipo dell’oggetto ellissi. L’output è &lt;class 'ellipsis'&gt;.\n\n2\n\nUtilizzo come segnaposto per indicare che la funzione è da completare. Da notare che chiamare la funzione funzione_da_completare() non dà errore.\n\n3\n\nL’uso di Callable[..., int] indica una funzione che può accettare un numero variabile di argomenti di qualsiasi tipo e restituire un valore di tipo int.\n\n4\n\nnumpy è una libreria di calcolo matriciale molto diffusa. L’ellissi è utilizzata per effettuare uno sezione complessa della matrice secondo tutte le dimensioni precedenti all’ultima. In altre parole, l’ellissi permette di selezionare interamente tutte le dimensioni tranne l’ultima specificata. Il risultato stampato in console è su due righe: [[ 2  5] e [ 8 11]].\n\n\nAlcuni caratteri ASCII hanno un significato speciale come parte di altri token o sono significativi per l’analizzatore lessicale:\n\nCaratteri speciali di Python\n\n\n\n\n\n\nCarattere\nDescrizione\n\n\n\n\n'\nUtilizzato per definire stringhe di caratteri.\n\n\n\"\nUtilizzato per definire stringhe di caratteri.\n\n\n#\nSimbolo di commento. Utilizzato per indicare un commento, che viene ignorato dall’interprete Python.\n\n\n\\\nBackslash. Utilizzato per caratteri di escape nelle stringhe e per continuare le righe di codice su più righe fisiche.\n\n\n\nAlcuni caratteri ASCII non sono utilizzati in Python e la loro presenza al difuori dei letterali di stringa e dei commenti genera un errore: $, ?, `.\n\n\n9.5.6 Letterali\nI letterali sono notazioni per valori costanti di alcuni tipi predefiniti nel linguaggio. Esistono diversi tipi di letterali, ognuno rappresenta un tipo di dato specifico e ha una sintassi particolare.\n\n9.5.6.1 Numerici\nI letterali numerici includono interi, numeri a virgola mobile e numeri immaginari:\n\nInteri, possono essere scritti in base decimale, ottale, esadecimale o binaria:\n\nDecimale: 42.\nOttale: 0o12, 0O7.\nEsadecimale: 0xA, 0X1F.\nBinario: 0b1010, 0B11.\n\nVirgola mobile, possono essere rappresentati con una parte intera e una decimale, oppure con notazione scientifica:\n\nVirgola mobile: 3.14, 0.001.\nNotazione scientifica: 1e10, 2.5E-3.\n\nNumeri immaginari, ottenuti da un letterale intero o a virgola mobile con un suffisso j o J: 4j, 4.j, 3.14e-10j.\n\n\n\n9.5.6.2 Stringhe\nI letterali di stringa possono essere racchiusi tra virgolette singole o doppie. Possono anche essere multi-linea se racchiusi tra triple virgolette singole o doppie:\n\nStringhe racchiuse tra virgolette singole o doppie:\n\nSingole: 'ciao'.\nDoppie: \"mondo\".\n\nStringhe multi-linea racchiuse tra triple virgolette singole o doppie:\n\nTriple singole: '''testo multi-linea'''.\nTriple doppie: \"\"\"testo multi-linea\"\"\".\n\n\nLe stringhe tra tripli apici possono avere degli a capo e degli apici (non tripli) all’interno.\nEsempio:\nstringa_multilinea = \"\"\"Questa è una stringa\nmolto \"importante\".\"\"\"\n\nprint(stringa_multilinea)\nTutte le stringhe sono codificate in Unicode, con il prefisso b la stringa è di tipo byte ed è limitata ai 128 caratteri dell’ASCII. Se si prepone r, che sta per raw cioè grezzo, allora la codifica è sempre Unicode ma i caratteri di escape3 non sono intepretati.\n3 In Python, il carattere di escape \\ è utilizzato nelle stringhe per inserire caratteri speciali che non possono essere facilmente digitati sulla tastiera o che hanno significati speciali.Alcuni esempi comuni includono:\n\n\\n per una nuova linea (linefeed).\n\\t per una tabulazione.\n\\\\ per inserire un backslash.\n\\' per il singolo apice.\n\\\" per i doppi apici.\n\n\n\n9.5.6.3 F-stringhe\nLe f-stringhe (stringhe formattate) sono racchiuse tra virgolette singole, doppie o triple e sono precedute dal prefisso f o F. Permettono di includere espressioni Python all’interno.\nSi possono avere stringhe formattate grezze ma non byte.\nEsempio:\nnome = \"Python\"\n\n1f_stringa = f'Ciao, {nome.upper()}!'\n\ndefinizione = \"Linguaggio\"\n\nf_stringa_multi_linea = f'''Questo è un esempio\ndi f-stringa multi-linea\n2in {definizione.lower() + ' ' + nome}'''\n\n3print(f_stringa)\n\n4print(f_stringa_multi_linea)\n\n1\n\nViene chiamato il metodo della stringa lower() per avere il maiuscolo.\n\n2\n\nUsiamo un’espressione di concatenazione di stringhe.\n\n3\n\nOutput: Output: Ciao, python!.\n\n4\n\nOutput composto dalle tre righe Questo è un esempio, di f-stringa multi-linea e in linguaggio Python.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#istruzioni",
    "href": "seconda-parte-python-sintassi.html#istruzioni",
    "title": "9  La sintassi",
    "section": "9.6 Istruzioni",
    "text": "9.6 Istruzioni\nUn programma Python è una sequenza di istruzioni che si distinguono in semplici e composte.\n\n9.6.1 Istruzioni semplici\nUn’istruzione semplice è sempre contenuta in una riga logica, che può presentare più istruzioni semplici separate da ;. È permesso ma sconsigliato, perché in pochi casi porta a codice leggibile.\nIn Python, le istruzioni semplici sono:\n\nAssegnazione, attribuisce un valore a una variabile:\nx = 10\nIstruzioni di importazione, permettono di utilizzare gli identificatori definiti in altri moduli:\nimport math\nfrom math import sqrt\nIstruzioni di controllo del flusso nei cicli:\n\nbreak: Interrompe un ciclo.\ncontinue: Salta all’iterazione successiva di un ciclo.\npass: Non esegue alcuna operazione.\n\nfor i in range(10):\n    if i == 5:\n        break\nIstruzioni di gestione dell’uscita da una funzione, della generazione di valori o del sollevamento di eccezioni:\n\nreturn: Restituisce un valore da una funzione.\nyield: Restituisce un generatore.\nraise: Solleva un’eccezione per segnalare uan condizione di errore.\n\ndef func():\n    return x\nIstruzioni di asserzione in cui si verifica una condizione e viene generata un’eccezione se la condizione è falsa:\nassert x &gt; 0, \"x deve essere positivo\"\nIstruzioni di diichiarazione di modifica dell’ambito di variabili:\nglobal x\nnonlocal y\nUn’espressione è una istruzione semplice ed, infatti, inserita nel REPL, ne viene prodotto il risultato della valutazione. D’altronde, una espressione è spesso utilizzata per chiamare funzioni che hanno effetti collaterali, come, ad esempio, produrre un output in console. Espressioni più importanti:\n\nProduzione di output:\n1def stampa_messaggio(messaggio):\n  print(messaggio)\n\n2stampa_messaggio(\"Ciao, mondo!\")\n\n1\n\nFunzione che stampa un messaggio.\n\n2\n\nIstruzione di espressione che chiama la funzione con un effetto collaterale (stampa del messaggio).\n\n\nModifica di parametri:\n1def aggiungi_elemento(lista, elemento):\n  lista.append(elemento)\n\n2numeri = [1, 2, 3]\n\n3aggiungi_elemento(numeri, 4)\n\n4print(numeri)\n\n1\n\nFunzione che modifica un argomento mutabile (lista).\n\n2\n\nLista iniziale.\n\n3\n\nIstruzione di espressione che chiama la funzione con un effetto collaterale (modifica dell’argomento).\n\n4\n\nOutput: [1, 2, 3, 4].\n\n\nModifica di variabili globali:\n1contatore = 0\n\n2def incrementa_contatore():\n  global contatore\n\n  contatore += 1\n\n3incrementa_contatore()\n\n4print(contatore)\n\n1\n\nVariabile globale.\n\n2\n\nFunzione che modifica una variabile globale.\n\n3\n\nIstruzione di espressione che chiama la funzione con un effetto collaterale (modifica della variabile globale).\n\n4\n\nOutput: 1.\n\n\nLancio di eccezioni:\n1def solleva_eccezione(messaggio):\n  raise ValueError(messaggio) \n\ntry: \n2  solleva_eccezione(\"Qualcosa è andato storto!\")\n\nexcept ValueError as e:\n3  print(e)\n\n1\n\nFunzione che solleva un’eccezione.\n\n2\n\nIstruzione di espressione che chiama la funzione con un effetto collaterale (sollevamento di un’eccezione).\n\n3\n\nOutput: Qualcosa è andato storto!.\n\n\nUn assegnamento con = è anch’esso un’istruzione semplice e non può mai essere all’interno di una espressione, dove, invece, si può usare l’operatore tricheco :=:\nif (n := len(\"Python\")) &gt; 5:\n1  print(f\"La lunghezza della stringa è {n}\")\n\n1\n\nOutput: La lunghezza della stringa è 6.\n\n\n\n\n\n\n9.6.2 Istruzioni composte\nUna istruzione composta è costituita da altre istruzioni (semplici o composte). Il controllo dell’esecuzione delle istruzioni componenti avviene per mezzo di una o più clausole che iniziano tutte con una parola chiave, sono terminate da : e seguite da un blocco di codice. Ogni blocco deve avere almeno una istruzione semplice, ma può non avere una propria riga logica, cioè stare sulla stessa riga fisica e logica del :.\nAlcuni esempi del rapporto tra istruzioni e righe:\n\nBlocco di istruzioni separato su più righe con medesima indentazione:\nif x &gt; 0: \n1  print(\"x è positivo\")\n\n  x += 1\n\n2  print(f\"x ora è {x}\")\n\n1\n\nPrima riga fisica del blocco di codice del ramo eseguito quanto la condizione x &gt; 0 assume valore True.\n\n2\n\nUltima riga fisica del medesimo blocco.\n\n\nBlocco come singola istruzione sulla stessa riga logica:\nif x &gt; 0: print(\"x è positivo\")\nDiverse istruzioni semplici sulla stessa riga logica (non consigliato):\nif x &gt; 0: print(\"x è positivo\"); x += 1; print(f\"x ora è {x}\")\n\nEd ecco le principali istruzioni composte:\n\nif, controlla l’esecuzione di un blocco di codice in base a una espressione condizionale (tra parentesi angolari è presente dello pseudocodice, quindi non eseguire!):\nif &lt;espressione condizionale&gt;:\n  # blocco di codice\nfor, itera sugli elementi (oggetti) presenti in un oggetto di tipo sequenza (come una lista, una tupla o una stringa):\nfor &lt;elemento&gt; in &lt;sequenza&gt;:\n  # blocco di codice\nwhile, esegue un blocco di codice finché una espressione condizionale è vera:\nwhile &lt;espressione condizionale&gt;:\n  # blocco di codice\ntry, gestisce gli errori che possono verificarsi durante l’esecuzione di un blocco di codice:\ntry:\n  # blocco di codice\nexcept &lt;eccezione&gt;:\n  # blocco di codice per gestire l'eccezione\nwith, gestisce le risorse come file, connessioni di rete, ecc., assicurandosi che siano aperte e chiuse correttamente, anche se si verifica un errore:\nwith open('file.txt', 'r') as file:\n  # blocco di codice\ndef, definisce una funzione fatta da una testata (nome funzione ed elenco parametri) e il blocco di istruzioni tra cui, opzionalmente, la restituzione di output:\ndef nome_funzione(&lt;parametro, parametro, ...&gt;):\n  # blocco di codice\nclass, definisce una classe:\nclass NomeClasse:\n  # blocco di codice\nmatch, confronta un valore con diversi modelli (pattern) per trovare una corrispondenza ed esegue un blocco di istruzioni:\nmatch valore:\n    case &lt;pattern&gt;:\n        # blocco di codice",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html",
    "href": "seconda-parte-python-modello-dati.html",
    "title": "10  Il modello dati",
    "section": "",
    "text": "10.1 Oggetti\nGli oggetti sono l’astrazione dei dati definita in Python. Ogni oggetto è caratterizzato da un’identità, un tipo e un valore. L’identità di un oggetto non cambia una volta creato e possiamo pensarlo come l’indirizzo dell’oggetto in memoria1. Python permette di ricavarlo per mezzo della funzione predefinita (built in) id():\nIl tipo di un oggetto determina le operazioni che l’oggetto supporta per la manipolazione del proprio stato o di quello di altri oggetti, e definisce anche i possibili valori per gli oggetti di quel tipo (dominio dei valori, per prendere in prestito un termine dalla matematica). Il linguaggio fornisce una funzione per conoscere il tipo dell’oggetto:",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html#oggetti",
    "href": "seconda-parte-python-modello-dati.html#oggetti",
    "title": "10  Il modello dati",
    "section": "",
    "text": "1 In CPython è effettivamente implementato così.s = \"Hello\"\n\n1print(id(s))\n\n1\n\nOutput: un numero come 4467381744.\n\n\n\ns = \"Hello\"\n\n1print(type(s))\n\n1\n\nOutput: &lt;class 'str'&gt;.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html#tipi-e-classi",
    "href": "seconda-parte-python-modello-dati.html#tipi-e-classi",
    "title": "10  Il modello dati",
    "section": "10.2 Tipi e classi",
    "text": "10.2 Tipi e classi\nIn Python, i tipi di dati sono implementati come classi. Una classe è la definizione di un tipo di oggetto che specifica gli attributi (complessivamente il valore dell’oggetto) e i metodi (le operazioni) che determinano lo stato e il comportamento degli oggetti. Gli oggetti creati da una classe possono essere manipolati attraverso i metodi della classe, permettendo di interagire e modificarne il valore o quello di altri oggetti passati come argomenti. Inoltre, una classe può definire metodi di istanza, che operano su istanze specifiche della classe, metodi di classe, che operano a livello della classe stessa e possono accedere e modificare lo stato della classe tramite attributi di classe, e metodi statici, che sono funzioni associate alla classe ma non dipendono né dalla classe né dalle sue istanze.\nAd esempio, per una stringa:\n1s = \"Hello\"\n\n2print(type(s))\n\n1\n\nL’oggetto stringa il cui valore è \"Hello\" ha come nome s.\n\n2\n\nOutput: &lt;class 'str'&gt;. type conferma che l’oggetto è una istanza di str che è il tipo delle stringhe in Python.\n\n\n\n10.2.1 Gerarchie di classi\nLe classi possono essere organizzate in una gerarchia. In cima alla gerarchia delle classi di Python c’è la classe object, un po’ infelice come nome, da cui derivano tutte le altre classi. Questo significa che ogni classe in Python eredita gli attributi e i metodi della classe object. La funzione isinstance è utile per investigare questa gerarchia, poiché permette di verificare se un oggetto è un’istanza di una determinata classe o di una sua classe derivata. isinstance, pertanto, ha due parametri, l’identificatore dell’oggetto e l’identificatore della classe e resistuisce un valore logico, True o False.\nAd esempio:\ns = \"Hello\" \n\n1print(isinstance(s, str))\n\n2print(isinstance(s, object))\n\n1\n\nOutput: True. isinstance conferma che s è un’istanza della classe str.\n\n2\n\nOutput: True. isinstance conferma che s è un’istanza anche della classe object, da cui deriva str.\n\n\nLa funzione issubclass è altrettanto utile per esplorare le gerarchie delle classi, in quanto permette di verificare se una classe è una sottoclasse di un’altra.\nAd esempio:\n1print(issubclass(str, object))\n\n1\n\nOutput: True. issubclass conferma che str è una sottoclasse di object.\n\n\n\n\n10.2.2 Creazione dell’oggetto\nUna volta definita una classe, si possono creare nuove istanze o oggetti di quella classe, il che rappresenta un modo efficiente per riutilizzare funzionalità nel proprio codice. Questo passaggio è spesso chiamato costruzione o istanziazione degli oggetti. Lo strumento responsabile per la specializzazione di questo processo, è comunemente noto come costruttore della classe.\nIn Python, il costruttore è il metodo speciale __init__ e può avere un numero arbitrario di parametri. Questo metodo viene eseguito automaticamente dall’interprete quando un nuovo oggetto della classe viene creato ed è il luogo possiamo scrivere delle istruzioni utili all’inizializzazione dell’oggetto, anche usando gli argomenti passati. La sintassi per l’istanziazione è data dall’identificatore della classe, seguita da una coppia di parentesi tonde, con all’interno l’elenco degli argomenti.\nEsempio:\n1s = str(4)\n\n1\n\nL’identificatore della classe delle stringhe str è seguito da un unico argomento, 4 , dato da un letterale intero, passato al costruttore per l’inizializzazione.\n\n\nIl metodo __init__ è sempre presente: se non è definito esplicitamente nella classe, viene ereditato dalla classe base object.\nLa creazione di un oggetto avviene in diversi contesti:\n\nUso di letterali. Ad esempio, per creare un oggetto stringa, si usano i letterali stringa e analogamente per gli altri:\n\n1s = \"Hello\"\n\n2n = 42\n\n3f = 3.14\n\n1\n\nCreazione di un oggetto di tipo str.\n\n2\n\nCreazione di un oggetto di tipo int.\n\n3\n\nCreazione di un oggetto di tipo float.\n\n\nlista = list([1, 2, 3])\n\nUtilizzo di funzioni e metodi che restituiscono oggetti. Ad esempio, il metodo upper della classe str restituisce un nuovo oggetto ottenuto a partire da quello su cui è eseguito:\n\ns1 = \"Hello, World!\"\n\nsu_1 = s1.upper()\n\ns = \"Hello, World!\".upper()\n\n\nimport copy\n\nlista_originale = [1, 2, 3]\n\nlista_copiata = copy.copy(lista_originale)\n\n\n10.2.3 Accesso a attributi e metodi\nIn Python, si utilizza la notazione con il punto . per accedere agli attributi e ai metodi di un oggetto o di una classe, semplicemente accodando all’identificatore della variabile (che rappresenta un’istanza della classe) o a quello della classe, il punto e l’identificatore del membro (attributo o metodo).\nLe stringhe in Python sono oggetti della classe str e hanno sia attributi che metodi. Ad esempio, il metodo upper() converte una stringa in maiuscolo:\n1s = \"hello world\"\n\n2s_upper = s.upper()\n\n3print(s_upper)\n\n1\n\nCreazione di un oggetto stringa.\n\n2\n\nChiamata del metodo upper() usando l’identificatore s.\n\n3\n\nOutput: HELLO WORLD.\n\n\n\n\n10.2.4 Mutabilità e immutabilità\nGli oggetti il cui valore può cambiare sono detti mutabili, mentre gli oggetti il cui valore non lo può una volta creati, sono chiamati immutabili. L’immutabilità di un oggetto è determinata dalla progettazione del suo tipo, ad esempio, per i tipi definiti nel linguaggio, numeri interi e in virgola mobile, stringhe e tuple sono immutabili, mentre dizionari e liste sono mutabili.\nGli oggetti non vengono mai distrutti esplicitamente dall’utente, ma, quando diventano inaccessibili, possono essere raccolti dal garbage collector, che è eseguito contemporaneamente al codice del programma, come parte dell’interprete. L’implementazione specifica quando e come gli oggetti debbano essere distrutti.\nAlcuni oggetti contengono riferimenti a risorse esterne rispetto al programma, come file aperti, connessioni di rete, finestre (graphical user interface, GUI) o dispositivi hardware. Queste risorse generalmente non vengono liberate dal garbage collector, perché le azioni corrispondenti sono particolari della risorsa stessa, pertanto, i loro oggetti forniscono anche un metodo esplicito di rilascio, solitamente chiamato close(). È molto importante tener conto di ciò per evitare effetti indesiderati.\nAlcuni oggetti, chiamati contenitori, contengono riferimenti ad altri oggetti. Esempi di contenitori sono tuple, liste e dizionari, strutture dati di base, definite in molti linguaggi di programmazione. I riferimenti ad altri oggetti fanno parte del valore di un contenitore e, nella maggior parte dei casi, quando parliamo del valore di un contenitore, intendiamo proprio i valori degli oggetti contenuti, non le loro identità. Ad esempio:\n1t = (1, 2, 3)\n\n2l = [\"Qui\", \"Quo\", \"Qua\"]\n\n1\n\nTupla con tre oggetti al suo interno: 1, 2, 3. Diciamo che la tupla contiene i tre valori interi.\n\n2\n\nLista com tre oggetti all’interno: \"Qui\", \"Quo\", \"Qua\". Diciamo che la lista contiene le tre stringhe.\n\n\nLa mutabilità di un contenitore si riferisce alla identità degli oggetti referenziati e non al loro valore, quindi, ad esempio, se una tupla contiene un riferimento ad un oggetto mutabile, il valore della tupla cambia se quell’oggetto mutabile viene modificato:\ns = ([1, 2, 3], [\"Qui\", \"Quo\", \"Qua\"])\n\n1print(s)\n\n2print(id(s[0]))\n3print(id(s[1]))\n\n4s[1][0] = \"Huey\"\ns[1][1] = \"Dewey\" \ns[1][2] = \"Louie\"\n\n5print(s)\n\n6print(id(s[0]))\n7print(id(s[1]))\n\n1\n\nOutput: ([1, 2, 3], ['Qui', 'Quo', 'Qua']).\n\n2\n\nModifico gli elementi della lista, traducendoli in inglese.\n\n3\n\nOutput dell’identità del primo oggetto contenuto (su ogni computer e sessione sarà diverso): 4361472384.\n\n4\n\nOutput dell’identità del secondo oggetto contenuto: 4361474176.\n\n5\n\nOutput: ([1, 2, 3], ['Huey', 'Dewey', 'Louie']). La tupla è cambiata!\n\n6\n\nOutput: 4361472384, l’identità del primo oggetto contenuto non è cambiata!\n\n7\n\nOutput: 4361474176, l’identità del secondo oggetto contenuto non è cambiata!\n\n\nCiò è un po’ più generale, perché per gli oggetti di tipo immutabile, quando sono assegnati ad una variaible o risultato di un’espressione, a parità di valore, potrebbero avere la stessa identità, cioè essere lo stesso oggetto. Il condizionale è dovuto alla presenza e applicazione logiche di ottimizzazione, ad esempio della memoria, implementate nell’interprete.\nAd esempio, dopo:\ns1 = \"Qui, Quo, Qua\"\n\n1print(id(s1))\n\ns2 = \"Qui, Quo, Qua\"\n\n2print(id(s2))\n\n1\n\nOutput dell’identità di s1: 4432491760.\n\n2\n\nOutput dell’identità di s2: 4432491760, cioè è la medesima identità dell’oggetto il cui nome è s1.\n\n\nPer gli oggetti mutabili, questo non accade anche in casi su cui potrebbe essere ottimizzante:\nl1 = []\n\n1print(id(l1))\n\nl2 = []\n\n2print(id(l2))\n\n1\n\nOutput dell’identità di l1: 4454287744.\n\n2\n\nOutput dell’identità di l2: 4454289536, cioè le identità sono diverse.\n\n\nAttenzione però ad alcune scorciatoie di Python:\nc = d = []\nè equivalente a:\nc = []\nd = c\ncioè l’oggetto lista ha due nomi nel programma.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html#tipi-predefiniti",
    "href": "seconda-parte-python-modello-dati.html#tipi-predefiniti",
    "title": "10  Il modello dati",
    "section": "10.3 Tipi predefiniti",
    "text": "10.3 Tipi predefiniti\nPython mette a disposizione molti tipi generali, cioè utili alla gestione di dati comunemente presenti in algoritmi. Esistono, inoltre, sia meccanismi di estensione della distribuzione Python che modificano l’installazione sul proprio computer, sia la possibilità conferita al programmatore di creare i propri tipi o di importarli da librerie prodotte da terze parti.\nI tipi predefiniti sono immediatamente disponibili, cioè non necessitano di alcuna azione da parte del programmatore, come, ad esempio, l’importazione di moduli.\nPer ragioni di esposizione, distingueremo tra tipi predefiniti fondamentali, cioè che possono essere introdotti con un insieme limitato di concetti, tipi legati alla astrazione del paradigma di orientamento agli oggetti e, infine, costruzioni del linguaggio legate all’esecuzione asincrona.\n\n10.3.1 Tipi predefiniti fondamentali\nPrima di entrare nel dettaglio per ognuno, di seguito un elenco dei tipi predefiniti fondamentali:\n\nNumeri: sia interi relativi che reali, cioè in virgola mobile, sia complessi.\nSequenze, cioè contenitori caratterizzati da un ordinamento degli oggetti al loro interno, sia mutabili che immutabili.\nInsiemi, cioè contenitori non caratterizzati da un ordinamento degli oggetti.\nDizionari, cioè contenitori di coppie di oggetti chiave e valore.\nAltri: None, NotImplemented, Ellipsis.\n\n\n\n10.3.2 Numeri\nI tipi predefiniti numerici corrispondono agli interi, i numeri a virgola mobile e quelli complessi. Sono immutabili, il che significa che effettuando una operazione su un oggetto numerico si produrrà sempre un nuovo oggetto e non una modifica del precedente.\nEsistono anche altri tipi numerici nelle librerie fornite coll’interprete, per i numeri decimali a precisione arbitraria e i numeri razionali come frazioni.\nI letterali numerici non hanno segno, cioè + e - sono operatori unari che precedono la rappresentazione di un numero, quindi -3 è una espressione che diventa il valore di un oggetto intero di valore -3. Nei letterali numerici si può inserire un trattino basso (underscore) tra le cifre o dopo gli specificatori della base per gli interi.\n\n10.3.2.1 Interi\nEsistono due tipi di interi. Il primo è int, per gli usuali numeri interi, a cui corrispondono diverse rappresentazioni sintattiche in basi diverse, come i letterali decimali, binari, ottali o esadecimali:\n\nUn letterale decimale inizia sempre con una cifra diversa da zero, esempi: 10, 1_0.\nQuello binario inizia con 0b o 0B seguito da una sequenza di cifre binarie (0 o 1), esempi: 0b1010, 0B1010, 0b_10_10, 0b1_0_10.\nL’ottale inizia con 0o o 0O seguito da una sequenza di cifre ottali (da 0 a 7), esempi: 0o12, 0O12.\nL’esadecimale inizia con 0x o 0X seguito da una sequenza di cifre esadecimali (da 0 a 9 e da A a F, in maiuscolo o minuscolo), esempi: 0xA, 0XA.\n\nGli interi in Python sono illimitati, al netto della finitezza della memoria del computer disponibile per la loro rappresentazione.\nlarge_int = 10**100\n\n1print(f\"Un intero molto grande: {large_int}\")\n\n1\n\nOutput: 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n\nL’altro tipo è bool, che ha solo due oggetti possibili, che si comportano come quelli corrispondenti agli interi 1 e 0 per rappresentare i valori logici, rispettivamente, di vero e falso. bool come classe deriva da int che, a sua volta, deriva da object:\n1print(issubclass(bool, int))\n2print(issubclass(int, object))\n\n1\n\nOutput: True.\n\n2\n\nOutput: True.\n\n\n\n\n10.3.2.2 Numeri in virgola mobile\nI numeri in virgola mobile in Python sono istanze della classe float e sono utilizzati per rappresentare numeri reali con una parte decimale. I letterali corrispondenti sono una sequenza di cifre in base 10, e solo in base 10, che include un punto (.), un suffisso di notazione scientifica (e o E, opzionalmente seguito da + o - e da una o più cifre), o entrambi. Il carattere iniziale di un letterale in virgola mobile non può essere e o E, ma può essere qualsiasi cifra (anche zeri a differenza degli interi) o un punto (.) seguito da una cifra.\nEsempi di literali in virgola mobile: 0., 0.1, .0, 1., 1.0, 1e0, 1.e0, 1.0E0, 1_0_0.0_1. Attenzione: 1 è un intero, 1. non lo è.\nPer conoscere l’intervallo esatto e la precisione dei valori in virgola mobile sulla piattaforma in uso, e molti altri dettagli, è possibile usare sys.float_info nel modo seguente:\nimport sys\n\n1float_info = sys.float_info\n\n2print(f\"Massimo valore rappresentabile (max): {float_info.max}\")\n3print(f\"Minimo valore rappresentabile positivo (min): {float_info.min}\")\n4print(f\"Massimo esponente base 2 (max_exp): {float_info.max_exp}\")\n5print(f\"Minimo esponente base 2 (min_exp): {float_info.min_exp}\")\n6print(f\"Massimo esponente base 10 (max_10_exp): {float_info.max_10_exp}\")\n7print(f\"Minimo esponente base 10 (min_10_exp): {float_info.min_10_exp}\")\n8print(f\"Precisione in bit (dig): {float_info.dig}\")\n9print(f\"Numero di bit di mantissa (mant_dig): {float_info.mant_dig}\")\n10print(f\"Epsilon macchina (epsilon): {float_info.epsilon}\")\n\n1\n\nOggetto con all’interno le informazioni relative alla gestione dei numeri in virgola mobile della macchina.\n\n2\n\nOutput: Massimo valore rappresentabile (max): 1.7976931348623157e+308. Il massimo valore rappresentabile per un numero in virgola mobile.\n\n3\n\nOutput: Minimo valore rappresentabile positivo (min): 2.2250738585072014e-308. Il minimo valore positivo rappresentabile per un numero in virgola mobile.\n\n4\n\nOutput: Massimo esponente base 2 (max_exp): 1024. Il massimo esponente base 2.\n\n5\n\nOutput: Minimo esponente base 2 (min_exp): -1021. Il minimo esponente base 2.\n\n6\n\nOutput: Massimo esponente base 10 (max_10_exp): 308. Il massimo esponente base 10.\n\n7\n\nOutput: Minimo esponente base 10 (min_10_exp): -307. Il minimo esponente base 10.\n\n8\n\nOutput: Precisione in bit (dig): 15. La precisione in bit, cioè il numero di cifre decimali che possono essere rappresentate senza perdita di precisione.\n\n9\n\nOutput: Numero di bit di mantissa (mant_dig): 53. Il numero di bit nella mantissa.\n\n10\n\nOutput: Epsilon macchina (epsilon): 2.220446049250313e-16. La differenza tra 1 e il numero più piccolo maggiore di 1 che può essere rappresentato.\n\n\n\n\n10.3.2.3 Numeri complessi\nUn numero complesso è composto da due valori in virgola mobile, uno per la parte reale e uno per la parte immaginaria. In Python, i numeri complessi sono istanze della classe complex, che presenta due attributi di sola lettura real e imag, rispettivamente per la parte reale e immaginaria, di tipo float.\nUn letterale immaginario può essere specificato come qualsiasi letterale decimale in virgola mobile o intero seguito da una j o J: 0j, 0.j, 0.0j, .0j, 1j, 1.j, 1.0j, 1e0j, 1.e0j, 1.0e0j. La j alla fine del letterale immaginario indica la radice quadrata di -1. Per denotare un qualsiasi numero complesso costante, si potrà sommare o sottrarre un letterale in virgola mobile (o letterale intero) e uno immaginario.\n1z = 42+3.14j\n\n2print(z)\n\n3print(z.real)\n4print(z.imag)\n\n5print(type(z.real))\n6print(type(z.imag))\n7print(type(z))\n\n1\n\nAssegnamento di un numero complesso alla variabile z.\n\n2\n\nOutput: (42+3.14j).\n\n3\n\nOutput: 42.0.\n\n4\n\nOutput: 3.14.\n\n5\n\nOutput: &lt;class 'float'&gt;.\n\n6\n\nOutput: &lt;class 'float'&gt;.\n\n7\n\nOutput: &lt;class 'complex'&gt;.\n\n\n\n\n\n10.3.3 Sequenze\nUna sequenza è un contenitore ordinato di oggetti, il cui indice è un intero che parte da 0. Se la sequenza è referenziata da una variabile c, per ottenere il numero totale di oggetti contenuti si userà la funzione predefinita len(), cioè len(c), e per l’oggetto i-esimo le parentesi quadre e l’indice, c[i]. È possibile usare indici negativi che sono interpretati come la somma di quello col numero totale di oggetti contenuti, quindi -i è trattato come len(c)-i e l’indice risultante dovrà sempre essere compreso tra 0 e len(c)-1.\nSi può sezionare (slicing) la sequenza per ottenere una sottosequenza, dello stesso tipo, di oggetti originariamente contigui tra gli indici i e j, cioè con indici x tali che i≤x&lt;j, usando c[i:j]. Aggiungendo un terzo parametro di passo, k, si possono selezionare solo gli oggetti con indici i+l*k e l≥0, che siano compresi tra i due indici, cioè i≤i+l*k&lt;j, con c[i:j:k].\nLe sequenze sono categorizzate in base alla mutabilità:\n\nImmutabili: stringhe, tuple, bytes.\nMutabili: liste e array di bytes.\n\n\n10.3.3.1 Iterabilità\nLe sequenze sono iterabili cioè possono essere scorse in tutte per mezzo di un oggetto ad hoc detto iteratore. Un iteratore è un oggetto separato dalla sequenza stessa, che mantiene uno stato interno per tenere traccia dell’elemento successivo da restituire. Questo permette di iterare sulla sequenza senza modificarla direttamente. L’iteratore prende in input un oggetto iterabile e ne restituisce i valori uno alla volta secondo un certo protocollo. Per le sequenze, questo protocollo consiste nel partire dal primo elemento e procedere fino all’ultimo.\n\n\n10.3.3.2 Stringhe\nUna stringa in Python è un oggetto che si può creare a partire da un letterale composto di un numero non negativo di caratteri Unicode racchiusi o tra apici singoli ', oppure doppi \". Per inserire un a capo nella stringa dovrà essere usato \\n, mentre per spezzarla su due righe fisiche dovrà essere usato un singolo backslash alla fine della prima riga fisica per indicare la continuazione nella riga fisica successiva.\nEsempi:\ns1 = \"Hello \" \\\n1    \"World!\"\n\n2print(s1)\n\ns2 = \"Hello \\n\" \\\n3    \"World!\"\n\n4print(s2)\n\n1\n\nStringa su due righe fisiche ma senza a capo all’interno.\n\n2\n\nOutput: Hello World!.\n\n3\n\nStringa su due righe fisiche con un a capo all’interno.\n\n4\n\nOutput: Hello World!.\n\n\nAlternativamente, si possono usare letterali con coppie di tripli apici singoli ''' o doppi \"\"\", dove la differenza è che è possibile inserire un a capo nell’editor e sarà mantenuto nella stringa. Un singolo backslash non può essere presente.\ns1 = \"\"\"Hello \n1World!\"\"\"\n\n2print(s1)\n\ns2 = \"\"\"Hello \\n\n3        World!\"\"\"\n\n4print(s2)\n\n1\n\nStringa su due righe fisiche ma senza a capo all’interno.\n\n2\n\nOutput: Hello World!.\n\n3\n\nStringa su due righe fisiche con un a capo all’interno.\n\n4\n\nOutput: Hello\n\n\nWorld!.\nNei letterali stringa si possono inserire caratteri non stampabili o caratteri che non sono disponibili a tastiera, usando le cosiddette sequenze di escape, come da tabella seguente:\n\nSequenze di escape\n\n\n\n\n\n\n\n\nSequenza\nSignificato\nCodice ASCII/ISO\nEsempio di stringa Python\n\n\n\n\n\\&lt;newline&gt;\nIgnora fine linea\n-\n\"Questo è un testo\\ con una linea continuata\"\n\n\n\\\\\nBackslash\n0x5c\n\"C:\\\\percorso\\\\al\\\\file\"\n\n\n\\'\nApice singolo\n0x27\n\"L'apice singolo: \\' esempio\"\n\n\n\\\"\nApice doppio\n0x22\n\"L'apice doppio: \\\" esempio\"\n\n\n\\a\nCampanello\n0x07\n\"Suono del campanello\\a\"\n\n\n\\b\nBackspace\n0x08\n\"Carattere di backspace\\b\"\n\n\n\\f\nForm feed\n0x0c\n\"Form feed\\f esempio\"\n\n\n\\n\nNuova linea\n0x0a\n\"Nuova linea\\n esempio\"\n\n\n\\r\nRitorno carrello\n0x0d\n\"Ritorno carrello\\r esempio\"\n\n\n\\t\nTabulazione\n0x09\n\"Tabulazione\\tesempio\"\n\n\n\\v\nTabulazione verticale\n0x0b\n\"Tabulazione verticale\\v esempio\"\n\n\n\\DDD\nValore ottale DDD del codice Unicode del carattere (solo per caratteri ASCII)\nDDD (in ottale)\n\"Valore ottale: \\101 esempio\" (\\101 rappresenta 'A' che in ASCII è 65)\n\n\n\\xXX\nValore esadecimale XX del codice Unicode del carattere\nXX (in esadecimale)\n\"Valore esadecimale: \\x41 esempio\" (\\x41 rappresenta ‘A’)\n\n\n\\uXXXX\nCarattere Unicode con valore esadecimale a 4 cifre\nXXXX (in esadecimale)\n\"Carattere cinese: \\u4e2d\" (\\u4e2d rappresenta ‘中’)\n\n\n\\UXXXXXXXX\nCarattere Unicode con valore esadecimale a 8 cifre\nXXXXXXXX (in esadecinale)\n\"Carattere: \\U0001f600\" (\\U0001f600 rappresenta ‘😀’)\n\n\n\\N{name}\nCarattere Unicode\n-\n\"Carattere Unicode: \\N{LATIN CAPITAL LETTER A} esempio\"\n\n\n\nEsistono anche i letterali di stringhe grezze (raw), sintatticamente identiche alle altre a meno di un suffisso r o R, comportante che le sequenze di escape non siano interpretate. Si usano comunemente per esprimere pattern di espressioni regolari o percorsi di file in Windows.\n1url_regex = r\"https:\\/\\/(?:www\\.)?[a-zA-Z0-9\\-]+(\\.[a-zA-Z]{2,})+\"\n\nprint(url_regex)\n\n1\n\nurl_regex è l’espressione regolare utile a validare URL in HTTPS ben formati.\n\n\nDopo aver identificato il letterale stringa, l’inteprete crea l’oggetto stringa in memoria con tipo str. Alternativamente, si può crearla in altri modi:\n\nSebbene non sia comune usare il costruttore per creare una stringa da un letterale stringa, è comunque possibile:\n\n1s = str(\"Hello, World!\")\n\n2print(s)\n\n1\n\nPasso\n\n2\n\nOutput: Hello, World!.\n\n\ns = str(42)\n\n1print(s)\n\ns = str(3.14)\n\n2print(s)\n\n1\n\nOutput: 3.14.\n\n2\n\nOutput: 42.\n\n\ncl = ['H', 'e', 'l', 'l', 'o']\n\ns = ''.join(cl)\n\n1print(s)\n\n1\n\nOutput: Hello.\n\n\nl = [\"Hello\", \" \", \"World!\"]\n\ns = str(l)\n\nprint(s)\n\nOutput: ['Hello', ' ', 'World!'].\nSi può creare una nuova stringa da qualsiasi oggetto iterabile, come liste o tuple, utilizzando il metodo join che inserisce tra gli elementi della sequenza la stringa dell’oggetto di cui è membro:\n\nlista = ['Python', 'è', 'fantastico']\n\ns = ' '.join(lista)\n\n1print(s)\n\ntupla = ('Hello', 'World!')\n\ns = ' '.join(tupla)\n\n2print(s)\n\n1\n\nOutput: Python è fantastico. Lo spazio tra le parole è stato inserito perché join è stato chiamato su un oggetto la cui stringa era data dal solo carattere di spazio.\n\n2\n\nOutput: Hello World!.\n\n\n\n\n10.3.3.3 Tuple\nLe tuple in Python sono sequenze ordinate immutabili, in cui gli oggetti contenuti possono essere di tipi diversi. La classe è tuple che deriva da object.\nPer creare una tupla, si può utilizzare una serie di espressioni separate da virgole (,), come elementi della tupla. Si può opzionalmente mettere una virgola ridondante dopo l’ultimo elemento, che è necessaria se si ha un solo elemento. Si possono raggruppare gli elementi della tupla tra parentesi, ma le parentesi sono necessarie solo quando le virgole avrebbero altrimenti un altro significato (ad esempio, nelle chiamate di funzione), o per denotare tuple vuote o annidate.\nEsempi di tuple costruite con letterali e espressioni:\n1t1 = 42., \"Hello\", 0x42\n2t2 = (42,)\n3t3 = 21+21,\n4t4 = ()\n\n1\n\nTupla con tre oggetti contenuti da letterale numerico, letterale stringa e ancora letterale numerico.\n\n2\n\nTupla con un solo oggetto da letterale numerico.\n\n3\n\nTupla con un solo oggetto da espressione.\n\n4\n\nTupla vuota.\n\n\nPossiamo creare le tuple usando la classe tuple che accetta come argomento un iterabile:\n1t1 = tuple()\n\n2t2 = tuple(\"Hello\")\n\nt3 = tuple([1, 2, 3])\n\n1\n\nCrea una tupla vuota.\n\n2\n\nCrea una tupla con 5 stringhe, una per ogni carattere.\n\n\nOperazioni sulle tuple:\nt1 = 42., \"Hello\", 0x42\n1print(t1[1])\n\n2print(len(t1))\n\nt2 = (42,)\n\nt3 = t1 + t2\n3print(t3)\n\n4print(t3[1:3])\n\n5print(42. in t3)\n\n1\n\nOutput: \"Hello\".\n\n2\n\nOutput: 3.\n\n3\n\nOutput: (42.0, 'Hello', 66, 42). Concatenazione di tuple che produce una nuova tupla con 4 oggetti contenuti.\n\n4\n\nOutput: ('Hello', 66). Slicing di tupla che produce una nuova tupla con 2 oggetti.\n\n5\n\nOutput: True. Test di appartenenza di 42. nella tupla (42.0, 'Hello', 66, 42).\n\n\n\n\n10.3.3.4 Liste\nLe liste in Python sono sequenze ordinate mutabili, in cui gli oggetti contenuti possono essere di tipi diversi. La classe è list che deriva da object.\nPer creare una lista, si utilizza una serie di espressioni, separate da virgole (,) all’interno di parentesi quadre, per indicare gli elementi della lista. Se ogni elemento è un letterale, l’intera costruzione è un letterale di lista. Si può opzionalmente mettere una virgola ridondante dopo l’ultimo elemento. Per denotare una lista vuota, si utilizza una coppia di parentesi quadre vuote.\nEsempi di letterali di lista:\nEsempi di liste costruite con letterali e espressioni:\n1l1 = [42., \"Hello\", 0x42]\n2l2 = [21+21]\n3l3 = []\n\n1\n\nLista con tre oggetti contenuti da letterale numerico, letterale stringa e ancora letterale numerico.\n\n2\n\nLista con un solo oggetto da espressione.\n\n3\n\nLista vuota.\n\n\nPossiamo creare le tuple usando la classe tuple oltre che i letterali:\n1l1 = list()\n2l2 = list(\"Hello\")\n\n1\n\nCrea una lista vuota.\n\n2\n\nCrea una lista con 5 stringhe, una per ogni carattere.\n\n\nOperazioni sulle liste:\nl1 = [42., \"Hello\", 0x42]\n1print(l1[1])\n\n2print(len(l1))\n\nl2 = [42]\n\nl3 = l1 + l2 \n3print(l3)\n\nl2 += l1 \n4print(l2)\n\nl4 = []\n\nl4.extend(l1) \n5print(l4)\n\nl5 = []\n\nl5.append(l1) \n6print(l5)\n\n7print(l2[1:3])\n\nl1[1] = \"Ciao\"\n8print(l1)\n\nl1.remove(\"Ciao\")\n9print(l1)\n\nl1.pop(0)\n10print(l1)\n\ndel l4[1:2]\n\n1\n\nOutput: \"Hello\".\n\n2\n\nOutput: 3.\n\n3\n\nOutput: [42.0, 'Hello', 66, 42]. Concatenazione di liste che produce una nuova lista.\n\n4\n\nOutput: [42, 42.0, 'Hello', 66]. Concatenazione sul posto modificando l2.\n\n5\n\nOutput: [42.0, 'Hello', 66]. Concatenazione sul posto modificando l4.\n\n6\n\nOutput: [[42.0, 'Hello', 66]]. Inserimento in fondo alla lista di un elemento.\n\n7\n\nOutput: [42.0, 'Hello']. Slicing di lista che produce una nuova lista.\n\n8\n\nOutput: [42.0, 'Ciao', 66]. Modifica della lista per assegnazione di un nuovo oggetto ad un indice.\n\n9\n\nOutput: [42.0, 66]. Rimozione di un elemento dalla lista usando un test di uguaglianza per stabilire che l’oggetto nella lista è uguale a quello passato come argomento.\n\n10\n\nOutput: [66]. Rimozione di un elemento della lista usando uno slicing.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html",
    "href": "seconda-parte-esercizi.html",
    "title": "11  Esercizi",
    "section": "",
    "text": "11.1 ➀ Python come calcolatrice\nPrimi esperimenti con Python.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#python-come-calcolatrice",
    "href": "seconda-parte-esercizi.html#python-come-calcolatrice",
    "title": "11  Esercizi",
    "section": "",
    "text": "11.1.1 Numeri interi e in virgola mobile\n\nProblemaSoluzione\n\n\nUsare gli operatori matematici su costanti numeriche e osservare i risultati e gli errori nel REPL, perché è più immediato rispetto all’esecuzione completa del programma e permette di prendere dimistichezza velocemente con dei costrutti di base del linguaggio.\n\n\nIl codice seguente può essere eseguito sia nel REPL, riga per riga, sia come programma.\n\n\n\n\n\n\nSuggerimento\n\n\n\nUsando il REPL, basterà digitare l’espressione senza assegnamento per ottenere il risultato.\n\n\n# Moltiplicazione\nx = 5 * 2\nprint(x)\n\nx = 5 * 2.\nprint(x) # Cosa notiamo?\n\n# Divisione in virgola mobile\nx = 5 / 2\nprint(x)\n\nx = 4 / 2\nprint(x) # Cosa notiamo?\n\nx = 4 / 2.\nprint(x)\n\n# Confronto\nx = 5 &gt; 2\nprint(x)\n\nx = 5 &gt; 2.\nprint(x) # Cosa notiamo?\n\n# Diversità\nx = 4 != 4.\nprint(x) # Cosa notiamo?\n\nx = 0 != (1 - 1)\nprint(x) # Cosa notiamo?\n\n\n\n\n\n11.1.2 Stringhe\n\nProblemaSoluzione\n\n\nUsare gli operatori su stringhe, sempre nel REPL.\n\n\ns = \"Hello\" + ' ' + 'World!'\nprint(s)\n\nss = s\n\nss *= 2\nprint(ss)\nprint(s) # Cosa notiamo per s e ss?\n\n# Appartenenza\nb = 'el' in s\nprint(b) \n\nb = 'oo' not in s\nprint(b)\n\n# Confronto\nb = \"Ciao Mondo!\" &lt; s \nprint(b) # È rispettato l'ordine lessicografico?\n\nl_s= len(s)\nprint(l_s)\n\n# Slicing della stringa come contenitore di caratteri\ns_ = ss[:l_s] \nprint(s_) \n\nl_ss = len(ss) \nprint(l_ss)\n\n# Modo alternativo di ottenere la stringa originale solo usando ss\ns_ = ss[:int(l_ss / 2)] \nprint(s_) \n\n# Metodo per rendere la stringa in maiuscolo\nsu = s.upper()\nprint(su)\n\n# Uguaglianza\nb = s == su\nprint(b) # Cosa notiamo?\n\n\n\n\n\n11.1.3 Espressioni\n\nProblemaSoluzione\n\n\nCostruire delle espressioni per comprendere come mischiare numeri e stringhe, la precedenza degli operatori e le conversioni di tipo, sempre nel REPL.\n\n\nn = 42\ns = \"42\"\n\n# Congiunzione\nb = n and s\nprint(b) # Cosa notiamo?\n\n# Disgiunzione\nb = n or s\nprint(b) \n\n# Negazione e congiunzione\nb = n and not s\nprint(b) # Cosa notiamo?\n\n# Conversione di tipo in stringa e appartenenza\nb = str(2) in s\nprint(b)\n\n# Conversione di tipo in intero e divisione\nb = int(s) / 2\nprint(b)\n\n# Espressione con precedenza data dall'ordine degli operatori \ne = 2 + n * 3\nprint(e)\n\n# Espressione con precedenza modificata colle parentesi \ne = (2 + n) * 3\nprint(e) # Cosa notiamo?",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#numeri-pari-o-dispari",
    "href": "seconda-parte-esercizi.html#numeri-pari-o-dispari",
    "title": "11  Esercizi",
    "section": "11.2 ➁ Numeri pari o dispari",
    "text": "11.2 ➁ Numeri pari o dispari\nDefinire una funzione che prende in input un numero intero e restituisce una stringa di Pari o Dispari.\n\n11.2.1 Riscaldamento\n\nProblemaSoluzione\n\n\nSperimentiamo l’operatore modulo %, che restituisce il resto della divisione di due interi, con diversi input sia pari che dispari usando un test condizionale.\n\n\nn = 42\n\nif n % 2 == 0:\n  print(\"Pari\")\n\nelse:\n  print(\"Dispari\")\n\n\n\n\n\n11.2.2 Svolgimento\n\nProblemaSoluzione 1Soluzione 2Soluzione 3Soluzione 4\n\n\nInserire le istruzioni in una funzione che prende in input un parametro, il numero intero, e restituisce una stringa, Pari o Dispari. Sperimentare soluzioni diverse.\n\n\nUsiamo l’operatore modulo % che restituisce il resto della divisione di due interi all’interno di una funzione. Questa prende in input un numero intero e restituisce la stringa richiesta.\ndef pari_o_dispari(n):\n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)\n\n\nUsiamo l’operatore modulo % per il test di parità sul numero intero e la funzione isinstance per verificare il tipo in input.\ndef pari_o_dispari(n):\n  if not isinstance(n, int):\n    return \"Errore: l'input deve essere un numero intero!\"\n    \n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)\n\n\nUsiamo l’operatore modulo %, la funzione isinstance per verificare il tipo in input e assert in caso di input non corretto.\ndef pari_o_dispari(n):\n  assert isinstance(n, int), \\\n    \"Errore: l'input deve essere un numero intero!\"\n    \n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)\n\n'''\nrisultato = pari_o_dispari(\"42\")\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73.)\n\nprint(risultato)\n'''\n\n\nUsiamo la funzione divmod che restituisce il quoziente e il resto della divisione di due interi. Per ottenere documentazione su essa basterà digitare help(divmod) nel REPL.\ndef pari_o_dispari(n):\n  _, remainder = divmod(n, 2)\n\n  return \"Pari\" if remainder == 0 else \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#rimozione-di-duplicati-da-una-lista-preservando-lordinamento",
    "href": "seconda-parte-esercizi.html#rimozione-di-duplicati-da-una-lista-preservando-lordinamento",
    "title": "11  Esercizi",
    "section": "11.3 ➁ Rimozione di duplicati da una lista preservando l’ordinamento",
    "text": "11.3 ➁ Rimozione di duplicati da una lista preservando l’ordinamento\n\nProblemaSoluzione 1Soluzione 2Soluzione 3➂ Soluzione 4\n\n\nScrivere una funzione che prende in input una lista e ne rimuove i duplicati, preservando l’ordinamento.\n\n\nUsiamo un ciclo for per iterare attraverso la lista originale e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti in essa, preservando così l’ordine originale.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n\n  for elemento in lista:\n    if elemento not in lista_senza_duplicati:\n      lista_senza_duplicati.append(elemento)\n\n  return lista_senza_duplicati\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un ciclo while per iterare attraverso la lista originale. Un set viene utilizzato per memorizzare gli elementi già visti e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti nel set.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n\n  visti = set()\n\n  i = 0\n  while i &lt; len(lista):\n    if lista[i] not in visti:\n      lista_senza_duplicati.append(lista[i])\n\n      visti.add(lista[i])\n\n    i += 1\n\n  return lista_senza_duplicati\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un dizionario per memorizzare gli elementi unici, sfruttando il fatto che i dizionari preservano l’ordine di inserimento a partire da Python 3.7. Gli elementi vengono aggiunti al dizionario come chiavi, e infine si restituisce la lista delle chiavi del dizionario.\ndef rimuovi_duplicati(lista):\n  return list(dict.fromkeys(lista))\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUtilizziamo una list comprehension per creare una nuova lista. Un set viene usato per tenere traccia degli elementi già visti, e gli elementi vengono aggiunti alla lista finale solo se non sono già presenti nel set.\ndef rimuovi_duplicati(lista):\n  return list(dict.fromkeys(lista))\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#rimozione-di-duplicati-da-una-lista-e-ordinamento",
    "href": "seconda-parte-esercizi.html#rimozione-di-duplicati-da-una-lista-e-ordinamento",
    "title": "11  Esercizi",
    "section": "11.4 ➁ Rimozione di duplicati da una lista e ordinamento",
    "text": "11.4 ➁ Rimozione di duplicati da una lista e ordinamento\n\nProblemaSoluzione 1Soluzione 2Soluzione 3➂ Soluzione 4\n\n\nScrivere una funzione che prende in input una lista e ne rimuove i duplicati, ordinando il risultato.\n\n\nUsiamo un ciclo for per iterare attraverso la lista originale e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti in essa. Dopo aver rimosso i duplicati, ordiniamo la lista risultante.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n\n  for elemento in lista:\n    if elemento not in lista_senza_duplicati:\n      lista_senza_duplicati.append(elemento)\n\n  return sorted(lista_senza_duplicati)\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un ciclo while per iterare attraverso la lista originale. Un set viene utilizzato per memorizzare gli elementi già visti e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti nel set. Dopo aver rimosso i duplicati, ordiniamo la lista risultante.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n  visti = set()\n\n  i = 0\n  while i &lt; len(lista):\n    if lista[i] not in visti:\n      lista_senza_duplicati.append(lista[i])\n\n      visti.add(lista[i])\n\n    i += 1\n\n  return sorted(lista_senza_duplicati)\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un dizionario per memorizzare gli elementi unici, sfruttando il fatto che i dizionari preservano l’ordine di inserimento a partire da Python 3.7. Gli elementi vengono aggiunti al dizionario come chiavi. Dopo aver rimosso i duplicati, ordiniamo la lista delle chiavi del dizionario.\ndef rimuovi_duplicati(lista):\n  return sorted(dict.fromkeys(lista))\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUtilizziamo una list comprehension per creare una nuova lista. Un set viene usato per tenere traccia degli elementi già visti, e gli elementi vengono aggiunti alla lista finale solo se non sono già presenti nel set. Dopo aver rimosso i duplicati, ordiniamo la lista risultante.\ndef rimuovi_duplicati(lista):\n  visti = set()\n\n  lista_senza_duplicati = [x for x in lista if not (x in visti or visti.add(x))]\n\n  return sorted(lista_senza_duplicati)\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#calcolo-del-fattoriale-di-un-numero",
    "href": "seconda-parte-esercizi.html#calcolo-del-fattoriale-di-un-numero",
    "title": "11  Esercizi",
    "section": "11.5 ➁ Calcolo del fattoriale di un numero",
    "text": "11.5 ➁ Calcolo del fattoriale di un numero\n\nProblemaSoluzione 1Soluzione 2➂ Soluzione 3➃ Soluzione 4\n\n\nScrivere una funzione che prende in input un numero intero positivo e restituisce il suo fattoriale.\n\n\n\n\n\n\nSuggerimento\n\n\n\nIl fattoriale di un numero n è il prodotto di tutti i numeri interi positivi minori o uguali a n ed è denotato come n!.\n\n\n\n\nUsiamo un ciclo for per calcolare il fattoriale. Partiamo da 1 e moltiplichiamo progressivamente tutti i numeri fino a n.\ndef fattoriale(n):\n  risultato = 1\n\n  for i in range(1, n + 1):\n    risultato *= i\n\n  return risultato\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\nUsiamo un ciclo while per calcolare il fattoriale. Partiamo da 1 e moltiplichiamo progressivamente tutti i numeri fino a n, utilizzando una variabile di iterazione.\ndef fattoriale(n):\n  risultato = 1\n  i = 1\n\n  while i &lt;= n:\n    risultato *= i\n\n    i += 1\n\n  return risultato\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\nUtilizziamo la ricorsione per calcolare il fattoriale. La funzione richiama se stessa riducendo il problema fino a raggiungere il caso base n = 1.\ndef fattoriale(n):\n  if n == 0 or n == 1:\n    return 1\n\n  else:\n    return n * fattoriale(n - 1)\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\nUsiamo la funzione reduce del modulo functools per calcolare il fattoriale. Questa soluzione utilizza un approccio funzionale per ridurre una sequenza di numeri a un singolo valore.\nfrom functools import reduce\n\ndef fattoriale(n):\n  return reduce(lambda x, y: x * y, range(1, n + 1), 1)\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\n\nEcco un esercizio divertente che coinvolge l’uso dei dizionari in Python:",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#contare-le-parole-in-una-frase-in-modo-semplificato",
    "href": "seconda-parte-esercizi.html#contare-le-parole-in-una-frase-in-modo-semplificato",
    "title": "11  Esercizi",
    "section": "11.6 ➁ Contare le parole in una frase in modo semplificato",
    "text": "11.6 ➁ Contare le parole in una frase in modo semplificato\n\nProblemaSoluzione 1Soluzione 2➂ Soluzione 3➂ Soluzione 4\n\n\nScrivere una funzione che prende in input una stringa contenente una frase e restituisce un dizionario con il conteggio di ciascuna parola nella frase. Le frasi non devono contenere punteggiatura e il confronto tiene conto della differenza tra lettere maiuscole e minuscole.\n\n\nUsiamo un ciclo for per iterare attraverso le parole della frase, aggiornando il conteggio di ciascuna parola in un dizionario.\ndef conta_parole(frase):\n  parole = frase.split()\n  conteggio = {}\n  \n  for parola in parole:\n    if parola in conteggio:\n      conteggio[parola] += 1\n\n    else:\n      conteggio[parola] = 1\n\n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))  # &lt;1&gt; # \n\nOutput: {'ciao': 3, 'come': 1, 'stai': 1}.\n\n\n\nUsiamo il metodo get del dizionario per aggiornare il conteggio delle parole in un dizionario.\ndef conta_parole(frase):\n  parole = frase.split()\n  conteggio = {}\n  \n  for parola in parole:\n    conteggio[parola] = conteggio.get(parola, 0) + 1\n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))  \n\n\nUsiamo il modulo collections e il defaultdict per semplificare il conteggio delle parole.\nfrom collections import defaultdict\n\ndef conta_parole(frase):\n  parole = frase.split()\n  conteggio = defaultdict(int)\n\n  for parola in parole:\n    conteggio[parola] += 1\n      \n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))  \n\n\nUsiamo il modulo collections e Counter per contare le parole nella frase in modo conciso.\nfrom collections import Counter\n\ndef conta_parole(frase):\n    parole = frase.split()\n\n    conteggio = Counter(parole)\n\n    return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#contare-le-parole-in-una-frase-con-esattezza",
    "href": "seconda-parte-esercizi.html#contare-le-parole-in-una-frase-con-esattezza",
    "title": "11  Esercizi",
    "section": "11.7 ➂ Contare le parole in una frase con esattezza",
    "text": "11.7 ➂ Contare le parole in una frase con esattezza\n\nProblema\n\n\nScrivere una funzione che prende in input una stringa contenente una frase e un flag maiuscolo_minuscolo che controlla se il conteggio delle parole debba tener conto del maiuscolo o minuscolo. Inoltre considera parole senza terner conto di eventuale punteggiatura nel calcolo. La funzione restituisce un dizionario con il conteggio di ciascuna parola nella frase.\n\n\n\n\n\n\nSuggerimento\n\n\n\nSi può usare string.punctuation del modulo string che contiene tutti i caratteri di punteggiatura disponibili in Python. Include caratteri come !\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_``{|}~.\n\n\n\nProblemaSoluzione 1Soluzione 2Soluzione 3Soluzione 4\n\n\nScrivere una funzione che prende in input una stringa contenente una frase e un flag maiuscolo_minuscolo che controlla se il conteggio delle parole deve essere case sensitive o case insensitive. La funzione restituisce un dizionario con il conteggio di ciascuna parola nella frase.\n\n\nUsiamo un ciclo for per iterare attraverso le parole della frase, aggiornando il conteggio di ciascuna parola in un dizionario. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = {}\n\n  for parola in parole:\n    if parola in conteggio:\n      conteggio[parola] += 1\n\n    else:\n      conteggio[parola] = 1\n\n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\n1print(conta_parole(frase, maiuscolo_minuscolo=False))\n2print(conta_parole(frase, maiuscolo_minuscolo=True))\n\n1\n\nOutput: {'ciao': 3, 'come': 1, 'stai': 1}.\n\n2\n\nOutput: {'Ciao': 2, 'ciao': 1, 'Come': 1, 'stai': 1}.\n\n\n\n\nUsiamo il metodo get del dizionario per aggiornare il conteggio delle parole in un dizionario. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = {}\n\n  for parola in parole:\n    conteggio[parola] = conteggio.get(parola, 0) + 1\n      \n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False))  \nprint(conta_parole(frase, maiuscolo_minuscolo=True))  \n\n\nUsiamo il modulo collections e il defaultdict per semplificare il conteggio delle parole. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\nfrom collections import defaultdict\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = defaultdict(int)\n\n  for parola in parole:\n    conteggio[parola] += 1\n\n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False)) \nprint(conta_parole(frase, maiuscolo_minuscolo=True))  \n\n\nUsiamo il modulo collections e Counter per contare le parole nella frase in modo conciso. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\nfrom collections import Counter\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n    \n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = Counter(parole)\n\n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False)) \nprint(conta_parole(frase, maiuscolo_minuscolo=True))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "appendice-riferimenti.html",
    "href": "appendice-riferimenti.html",
    "title": "Riferimenti",
    "section": "",
    "text": "Kernighan, Brian W. 1973. “A Tutorial Introduction to the\nProgramming Language b.” Murray Hill, NJ: Bell Laboratories.\n\n\nKernighan, Brian W., and Dennis M. Ritchie. 1988. The c Programming\nLanguage. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.\n\n\nStone, Harold S. 1971. Introduction to Computer Organization and\nData Structures. USA: https://dl.acm.org/doi/10.5555/578826; McGraw-Hill, Inc.\n\n\nStroustrup, Bjarne. 2013. The c++ Programming Language. 4th ed.\nhttps://dl.acm.org/doi/10.5555/2543987; Addison-Wesley\nProfessional.",
    "crumbs": [
      "Prefazione",
      "Appendici",
      "Riferimenti"
    ]
  }
]