[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Prefazione",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "fp-programming-languages.html",
    "href": "fp-programming-languages.html",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "",
    "text": "1.1 Definizioni\nLa programmazione è il processo di progettazione e scrittura di istruzioni, note come codice sorgente, che un computer può ricevere per eseguire compiti predefiniti. Queste istruzioni sono codificate in un linguaggio di programmazione, che traduce le idee e gli algoritmi del programmatore in un formato comprensibile ed eseguibile dal computer.\nUn programma informatico è una sequenza di istruzioni scritte per eseguire una specifica operazione o un insieme di operazioni su un computer. Queste istruzioni sono codificate in un linguaggio che il computer può comprendere e seguire per eseguire attività come calcoli, manipolazione di dati, controllo di dispositivi e interazione con l’utente. Pensate a un programma come a una ricetta di cucina. La ricetta elenca gli ingredienti necessari (dati) e fornisce istruzioni passo-passo (algoritmo) per preparare un piatto. Allo stesso modo, un programma informatico specifica i dati da usare e le istruzioni da seguire per ottenere un risultato desiderato.\nUn linguaggio di programmazione è un linguaggio formale che fornisce un insieme di regole e sintassi per scrivere programmi informatici. Questi linguaggi permettono ai programmatori di comunicare con i computer e di creare software. Alcuni esempi di linguaggi di programmazione includono Python, Java, C++ e JavaScript. I linguaggi di programmazione differiscono dai linguaggi naturali (come l’italiano o l’inglese) in diversi modi:\nQuando un programma viene scritto e salvato in un file di testo, il computer deve eseguirlo per produrre le azioni desiderate. Questo processo si svolge in diverse fasi:",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "fp-programming-languages.html#definizioni",
    "href": "fp-programming-languages.html#definizioni",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "",
    "text": "Precisione e rigidità: I linguaggi di programmazione sono estremamente precisi e rigidi. Ogni istruzione deve essere scritta in un modo specifico affinché il computer possa comprenderla ed eseguirla correttamente. Anche un piccolo errore di sintassi può impedire il funzionamento di un programma.\nAmbiguità: I linguaggi naturali sono spesso ambigui e aperti a interpretazioni. Le stesse parole possono avere significati diversi a seconda del contesto. I linguaggi di programmazione, invece, sono progettati per essere privi di ambiguità; ogni istruzione ha un significato preciso e univoco.\nVocabolario limitato: I linguaggi naturali hanno un vocabolario vastissimo e in continua espansione. I linguaggi di programmazione, al contrario, hanno un vocabolario limitato costituito da parole chiave e comandi definiti dal linguaggio stesso.\n\n\n\nCompilazione o interpretazione: Il codice sorgente, scritto in un linguaggio di alto livello leggibile dall’uomo, deve essere trasformato in un linguaggio macchina comprensibile dal computer. Questo avviene attraverso due possibili processi:\n\nCompilazione: In linguaggi come C++ o Java, un compilatore traduce tutto il codice sorgente in linguaggio macchina, creando un file eseguibile. Questo file può poi essere eseguito direttamente dalla CPU.\nInterpretazione: In linguaggi come Python o JavaScript, un interprete legge ed esegue il codice sorgente riga per riga, traducendolo in linguaggio macchina al momento dell’esecuzione.\n\nEsecuzione: Una volta che il programma è stato compilato (nel caso dei linguaggi compilati) o viene interpretato (nel caso dei linguaggi interpretati), il computer può iniziare ad eseguire le istruzioni. La CPU (central processing unit) legge queste istruzioni dal file eseguibile o dall’interprete e le esegue una per una. Durante questa fase, la CPU manipola i dati e produce i risultati desiderati.\nInterazione con i componenti hardware: Durante l’esecuzione, il programma può interagire con vari componenti hardware del computer. Ad esempio, può leggere e scrivere dati nella memoria, accedere ai dischi rigidi per salvare o recuperare informazioni, comunicare attraverso la rete, e interagire con dispositivi di input/output come tastiere e monitor. Questa interazione permette al programma di eseguire compiti complessi e di fornire output all’utente.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "fp-programming-languages.html#limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione",
    "href": "fp-programming-languages.html#limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.2 L’Impatto dell’intelligenza artificiale generativa sulla programmazione",
    "text": "1.2 L’Impatto dell’intelligenza artificiale generativa sulla programmazione\nCon l’avvento dell’intelligenza artificiale generativa (IA generativa), la programmazione ha subito una trasformazione significativa. Prima dell’IA generativa, i programmatori dovevano tutti scrivere manualmente ogni riga di codice, seguendo rigorosamente la sintassi e le regole del linguaggio di programmazione scelto. Questo processo richiedeva una conoscenza approfondita degli algoritmi, delle strutture dati e delle migliori pratiche di programmazione.\nInoltre, i programmatori dovevano creare ogni funzione, classe e modulo a mano, assicurandosi che ogni dettaglio fosse corretto, identificavano e correggevano gli errori nel codice con un processo lungo e laborioso, che comportava anche la scrittura di casi di test e l’esecuzione di sessioni di esecuzione di tali casi. Infine, dovebano scrivere documentazione dettagliata per spiegare il funzionamento del codice e facilitare la manutenzione futura.\n\n1.2.1 Attività del programmatore con l’IA Generativa\nL’IA generativa ha introdotto nuovi strumenti e metodologie che stanno cambiando il modo in cui i programmatori lavorano:\n\nGenerazione automatica del codice: Gli strumenti di IA generativa possono creare porzioni di codice basate su descrizioni ad alto livello fornite dai programmatori. Questo permette di velocizzare notevolmente lo sviluppo iniziale e ridurre gli errori di sintassi.\nAssistenza nel debugging: L’IA può identificare potenziali bug e suggerire correzioni, rendendo il processo di debugging più efficiente e meno dispendioso in termini di tempo.\nOttimizzazione automatica: Gli algoritmi di IA possono analizzare il codice e suggerire o applicare automaticamente ottimizzazioni per migliorare le prestazioni.\nGenerazione di casi di test: L’IA può creare casi di test per verificare la correttezza del codice, coprendo una gamma più ampia di scenari di quanto un programmatore potrebbe fare manualmente.\nDocumentazione automatica: L’IA può generare documentazione leggendo e interpretando il codice, riducendo il carico di lavoro manuale e garantendo una documentazione coerente e aggiornata.\n\n\n\n1.2.2 L’Importanza di imparare a programmare nell’era dell’IA generativa\nNonostante l’avvento dell’IA generativa, imparare a programmare rimane fondamentale per diverse ragioni. La programmazione non è solo una competenza tecnica, ma anche un modo di pensare e risolvere problemi. Comprendere i fondamenti della programmazione è essenziale per utilizzare efficacemente gli strumenti di IA generativa. Senza una solida base, è difficile sfruttare appieno queste tecnologie. Inoltre, la programmazione insegna a scomporre problemi complessi in parti più gestibili e a trovare soluzioni logiche e sequenziali, una competenza preziosa in molti campi.\nAnche con l’IA generativa, esisteranno sempre situazioni in cui sarà necessario personalizzare o ottimizzare il codice per esigenze specifiche. La conoscenza della programmazione permette di fare queste modifiche con sicurezza. Inoltre, quando qualcosa va storto, è indispensabile sapere come leggere e comprendere il codice per identificare e risolvere i problemi. L’IA può assistere, ma la comprensione umana rimane cruciale per interventi mirati.\nImparare a programmare consente di sperimentare nuove idee e prototipare rapidamente soluzioni innovative. La creatività è potenziata dalla capacità di tradurre idee in codice funzionante. Sapere programmare aiuta anche a comprendere i limiti e le potenzialità degli strumenti di IA generativa, permettendo di usarli in modo più strategico ed efficace.\nLa tecnologia evolve rapidamente, e con una conoscenza della programmazione si è meglio preparati ad adattarsi alle nuove tecnologie e metodologie che emergeranno in futuro. Inoltre, la programmazione è una competenza trasversale applicabile in numerosi settori, dalla biologia computazionale alla finanza, dall’ingegneria all’arte digitale. Avere questa competenza amplia notevolmente le opportunità di carriera.\nInfine, la programmazione è una porta d’accesso a ruoli più avanzati e specializzati nel campo della tecnologia, come l’ingegneria del software, la scienza dei dati e la ricerca sull’IA. Conoscere i principi della programmazione aiuta a comprendere meglio come funzionano gli algoritmi di IA, permettendo di contribuire attivamente allo sviluppo di nuove tecnologie.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html",
    "href": "fp-programming-paradigms.html",
    "title": "2  Paradigmi di programmazione",
    "section": "",
    "text": "2.1 Linguaggi di programmazione imperativa\nLa programmazione imperativa si concentra sull’esecuzione di istruzioni sequenziali che modificano lo stato del programma. Le istruzioni indicano al computer cosa fare passo dopo passo. Esempi di linguaggi che permettono il paradigma imperativo sono Assembly, C, Go, Python, per diversi casi d’uso:",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html#linguaggi-di-programmazione-imperativa",
    "href": "fp-programming-paradigms.html#linguaggi-di-programmazione-imperativa",
    "title": "2  Paradigmi di programmazione",
    "section": "",
    "text": "Assembly: Utilizzato nella programmazione a basso livello, come nello sviluppo di firmware e driver di dispositivi.\nC: Utilizzato per lo sviluppo di sistemi operativi e software di sistema, dove il controllo dettagliato delle operazioni è cruciale.\nGo: Sviluppato da Google, è utilizzato per costruire applicazioni di rete e sistemi scalabili, noto per la sua efficienza e facilità di utilizzo nelle applicazioni concorrenti.\nPython: Utilizzato in vari campi e noto per la sua semplicità e leggibilità, supporta la programmazione imperativa con l’uso di dichiarazioni di controllo e assegnazioni di variabili.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html#linguaggi-procedurali",
    "href": "fp-programming-paradigms.html#linguaggi-procedurali",
    "title": "2  Paradigmi di programmazione",
    "section": "2.2 Linguaggi procedurali",
    "text": "2.2 Linguaggi procedurali\nLa programmazione procedurale è un sottotipo di programmazione imperativa che organizza il codice in blocchi chiamati procedure o funzioni. Questi blocchi possono essere riutilizzati in diverse parti del programma per evitare ripetizioni e migliorare l’organizzazione del codice. Esempi sono Fortran, Pascal, C, Go, Python e i relativi casi d’uso:\n\nFortran: Molto utilizzato in applicazioni scientifiche e di ingegneria per calcoli numerici ad alta precisione.\nPascal: Storicamente utilizzato nei corsi di informativa per insegnare i fondamenti della programmazione.\nGo, Python: Supportano la programmazione procedurale grazie alla possibilità di definire funzioni e organizzare il codice in moduli.\nC: Anche se C non supporta i moduli nel senso moderno, utilizza file header (.h) e file sorgente (.c) per separare e organizzare il codice.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html#linguaggi-orientati-agli-oggetti",
    "href": "fp-programming-paradigms.html#linguaggi-orientati-agli-oggetti",
    "title": "2  Paradigmi di programmazione",
    "section": "2.3 Linguaggi orientati agli oggetti",
    "text": "2.3 Linguaggi orientati agli oggetti\nI linguaggi orientati agli oggetti modellano il problema come un insieme di oggetti che interagiscono tra loro per svolgere un compito. Gli oggetti sono istanze di classi, che possono contenere dati e metodi per manipolare quei dati. La programmazione orientata agli oggetti è estremamente utile per progettare architetture software complesse grazie ai suoi concetti di modularità, riutilizzabilità, astrazione, ereditarietà e polimorfismo. Alcuni linguaggi ad oggetti sono Java, Python, C++, Rust, Scala e i casi d’uso:\n\nJava: Ampiamente utilizzato per lo sviluppo di applicazioni aziendali, applicazioni Android e sistemi di backend.\nC++: Utilizzato in applicazioni ad alte prestazioni come videogiochi, motori grafici e software di simulazione. Il C++ supporta i template, che permettono la scrittura di codice generico e la metaprogrammazione, consentendo al codice di essere più flessibile e riutilizzabile.\nRust: Concepito per garantire la sicurezza della memoria e la concorrenza, offre anche supporto per la programmazione orientata agli oggetti.\nScala: Utilizzato per sviluppare applicazioni scalabili e sistemi distribuiti, spesso usato per l’elaborazione di grandi moli di dati. Scala supporta i generics, che sono simili ai template in C++, permettendo di scrivere codice generico e riutilizzabile.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html#linguaggi-funzionali",
    "href": "fp-programming-paradigms.html#linguaggi-funzionali",
    "title": "2  Paradigmi di programmazione",
    "section": "2.4 Linguaggi funzionali",
    "text": "2.4 Linguaggi funzionali\nI linguaggi funzionali si concentrano sulla valutazione di espressioni e funzioni, trattandole alla stregua di equazioni matematiche. La programmazione funzionale enfatizza l’uso di funzioni pure (cioè hanno come unico effetto quello di produrre un output) e l’immutabilità dei dati. Alcuni esempi: Haskell, Lisp, ML, Scala e i casi d’uso:\n\nHaskell: Utilizzato nella ricerca accademica, nello sviluppo di software finanziario e nei sistemi di calcolo parallelo.\nLisp: Storicamente utilizzato nell’intelligenza artificiale e nello sviluppo di software di simulazione. ELIZA, uno dei primi chatbot che potevano simulare una conversazione umana, era scritto in Lisp. John McCarthy nel 1959 introdusse la gestione automatica della memoria (garbage collection).\nMeta language (ML): Utilizzato nello sviluppo di compilatori, nell’analisi formale di programmi e in applicazioni finanziarie. ML ha diversi dialetti importanti, ognuno dei quali ha influenzato significativamente la programmazione funzionale e lo sviluppo di linguaggi di programmazione, come F# e OCaml.\nScala: Abilita sia la programmazione orientata agli oggetti che la programmazione funzionale, rendendolo un linguaggio versatile per vari tipi di applicazioni.\nPython: Sebbene Python non sia un linguaggio di programmazione funzionale puro come l’Haskell, offre comunque molte funzionalità che facilitano lo stile di programmazione funzionale, ad esempio la funzioni di prima classe, quelle anonime dette lambda e le funzioni di ordine superiore (map, filter, reduce).",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html#altri-paradigmi-di-programmazione",
    "href": "fp-programming-paradigms.html#altri-paradigmi-di-programmazione",
    "title": "2  Paradigmi di programmazione",
    "section": "2.5 Altri paradigmi di programmazione",
    "text": "2.5 Altri paradigmi di programmazione\nOltre ai paradigmi principali sopra menzionati, esistono altri paradigmi di programmazione meno comuni ma altrettanto importanti in certi contesti.\n\nLogico: Prolog, che sta per programming in logic, è stato sviluppato nei primi anni ’70 da Alain Colmerauer e Robert Kowalski. È uno dei linguaggi più noti per la programmazione logica e ha giocato un ruolo significativo nello sviluppo dell’intelligenza artificiale.\nConcorrente: Uno dei più diffusi linguaggi abilitanti la programmazione concirrente è l’Erlang, utilizzato nello sviluppo di sistemi distribuiti e applicazioni che richiedono alta disponibilità.\nDichiarativo: La programmazione dichiarativa si concentra sul “cosa” deve essere fatto piuttosto che sul “come” farlo. In altre parole, in un linguaggio dichiarativo, il programmatore specifica il risultato desiderato, lasciando al sistema il compito di determinare come ottenerlo. Questo approccio contrasta con la programmazione imperativa, dove il programmatore deve fornire una sequenza dettagliata di passi per raggiungere il risultato. Un esempio è lo structured query language (SQL), standard de facto per interrogare e manipolare database relazionali. Altri ben noti linguaggi dichiarativi sono: CSS, XQuery, VHDL, RegEx, Makefile.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-programming-paradigms.html#in-sintesi",
    "href": "fp-programming-paradigms.html#in-sintesi",
    "title": "2  Paradigmi di programmazione",
    "section": "2.6 In sintesi",
    "text": "2.6 In sintesi\nI paradigmi di programmazione offrono diversi approcci per risolvere problemi e progettare sistemi software. Ogni paradigma ha i suoi punti di forza e indirizza specifiche esigenze nel processo di sviluppo del software. La comprensione e l’utilizzo dei vari paradigmi permette ai programmatori di scegliere l’approccio più appropriato per il problema in questione e di scrivere codice più efficace, mantenibile e riutilizzabile:\n\nProgrammazione imperativa: Ottimale per problemi che richiedono una sequenza di istruzioni dettagliate e un controllo preciso sullo stato del programma.\nProgrammazione procedurale: Favorisce la modularità e la riusabilità del codice tramite la suddivisione in procedure o funzioni.\nProgrammazione orientata agli oggetti: Eccelle nella gestione di sistemi complessi grazie alla modularità, riusabilità, astrazione, ereditarietà e polimorfismo.\nProgrammazione funzionale: Promuove funzioni pure, immutabilità e composizionalità, facilitando il ragionamento e la verifica del comportamento del sistema.\nProgrammazione logica: Ideale per problemi che possono essere espressi in termini di relazioni logiche, come l’intelligenza artificiale e la risoluzione di vincoli.\nProgrammazione dichiarativa: Si concentra sul “cosa” piuttosto che sul “come”, rendendo il codice più leggibile e permettendo l’ottimizzazione automatica.\n\nAlcuni linguaggi di programmazione, come Python e C++, sono noti per il loro supporto a molteplici paradigmi, rendendoli strumenti versatili e potenti nel repertorio di un programmatore.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "fp-syntax-algorithm.html",
    "href": "fp-syntax-algorithm.html",
    "title": "3  Sintassi dei linguaggi di programmazione e algoritmi dei programmi",
    "section": "",
    "text": "3.1 Che cos’è un algoritmo?\nUna definizione informale di algoritmo è un insieme di istruzioni precise e finite che descrivono come eseguire un compito specifico o risolvere un problema. Pensate a un algoritmo come a una ricetta di cucina: la ricetta fornisce una serie di passaggi chiari da seguire per preparare un piatto.\nFormalmente, un algoritmo è una sequenza ben definita di passi o operazioni che, a partire da un input, produce un output in un tempo finito. Le proprietà principali di un algoritmo includono:",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi dei linguaggi di programmazione e algoritmi dei programmi</span>"
    ]
  },
  {
    "objectID": "fp-syntax-algorithm.html#che-cosè-un-algoritmo",
    "href": "fp-syntax-algorithm.html#che-cosè-un-algoritmo",
    "title": "3  Sintassi dei linguaggi di programmazione e algoritmi dei programmi",
    "section": "",
    "text": "Finitudine L’algoritmo deve terminare dopo un numero finito di passi.\nDeterminismo: Ogni passo dell’algoritmo deve essere definito in modo preciso e non ambiguo.\nInput L’algoritmo riceve zero o più dati in ingresso.\nOutput L’algoritmo produce uno o più risultati.\nEffettività: Ogni operazione dell’algoritmo deve essere fattibile ed eseguibile in un tempo finito.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi dei linguaggi di programmazione e algoritmi dei programmi</span>"
    ]
  },
  {
    "objectID": "fp-syntax-algorithm.html#sintassi-e-semantica-dei-linguaggi-di-programmazione",
    "href": "fp-syntax-algorithm.html#sintassi-e-semantica-dei-linguaggi-di-programmazione",
    "title": "3  Sintassi dei linguaggi di programmazione e algoritmi dei programmi",
    "section": "3.2 Sintassi e semantica dei linguaggi di programmazione",
    "text": "3.2 Sintassi e semantica dei linguaggi di programmazione\nI linguaggi di programmazione sono strumenti utilizzati per implementare algoritmi in modo che possano essere eseguiti da un computer. Un linguaggio di programmazione ha due componenti principali: la sintassi e la semantica.\n\n3.2.1 Sintassi\nLa sintassi di un linguaggio di programmazione è l’insieme di regole che definiscono come devono essere scritte le istruzioni, cioè le unità logiche di esecuzione del programma. È come la grammatica in una lingua naturale e stabilisce quali combinazioni di simboli sono considerate costrutti validi nel linguaggio.\nGli elementi principali della sintassi includono:\n\nParole chiave: Sono termini riservati del linguaggio che hanno significati specifici e non possono essere utilizzati per altri scopi, come if, else, while, for, ecc.\nOperatori: Simboli utilizzati per eseguire operazioni su variabili e valori, come +, -, *, /, =, ==, ecc.\nSeparatori e delimitatori: Caratteri utilizzati per separare elementi del codice, come punto e virgola (;), parentesi tonde (()), parentesi quadre ([]), parentesi graffe ({}), ecc.\nIdentificatori: Nomi utilizzati per identificare variabili, funzioni, classi, e altri oggetti definiti dall’utente.\nLetterali: Rappresentazioni di valori costanti nel codice, come numeri (123), stringhe (\"hello\"), caratteri ('a'), ecc.\nEspressioni: Combinazioni di variabili, operatori e funzioni che vengono valutate per produrre un valore.\n\nQuesti elementi sintattici sono utilizzati per comporre istruzioni semplici e istruzioni complesse.\n\n3.2.1.1 Istruzioni Semplici\nLe istruzioni semplici sono costituite da singole operazioni che possono essere eseguite direttamente. Queste istruzioni sono fondamentali e spesso coinvolgono i seguenti elementi:\n\nAssegnazione: Utilizza un operatore di assegnazione (=) per attribuire un valore a una variabile, che possiamo pensare come un nome simbolico rappresentante una posizione dove è memorizzato un valore. Esempio:\nx = 5\nx: Identificatore (nome) della variabile. =: Operatore di assegnazione. 5: Letterale numerico intero.\nInput/output: Utilizza parole chiave o funzioni di libreria per leggere valori dall’input o scrivere valori all’output. Esempio:\nprint(\"Hello, World!\")\nprint: Parola chiave o identificatore di funzione di libreria. \"Hello, World!\": Letterale stringa. L’esecuzione dell’istruzione produce \"Hello, World!\" in output.\nOperazioni aritmetiche: Utilizza operatori aritmetici per eseguire operazioni su variabili e valori. Esempio: plaintext     y = 7 + 2.3 y: Identificatore della variabile. =: Operatore di assegnazione del risultato della valutazione dell’operazione a destra. 7: Letterale numerico intero. +: Operatore aritmetico. 2.3: Letterale numerico decimale. L’esecuzione dell’istruzione fa in modo che la variabile y sia associato a 9.3.\nEspressioni: Combinazioni di variabili, operatori e valori che producono un risultato. Esempio: plaintext     z = (x * 2) + (y / 2) z: Identificatore della variabile. =: Operatore di assegnazione. (x * 2): Espressione che moltiplica x per 2. (y / 2): Espressione che divide y per 2. +: Operatore aritmetico che somma i risultati delle due espressioni. L’esecuzione dell’istruzione produce un risultato valido solo se x e y sono associate a valori numerici e ciò perché non tutte le istruzioni sintatticamente corrette sono semanticamente corrette. D’altronde ciò non deve essere preso come regola, perché se * fosse un operatore che ripete quanto a sinistra un numero di volte definito dal valore di destra e / la divisione del valore di sinistra in parti di numero pari a quanto a destra, allora x e y potrebbero essere stringhe.\n\n\n\n3.2.1.2 Istruzioni Complesse\nLe istruzioni complesse sono costituite da più istruzioni semplici e possono includere strutture di controllo del flusso. Esempi includono:\n\nCondizioni: Istruzioni che eseguono un blocco di codice solo se una condizione è vera. Esempio: plaintext     if (x &gt; 0) {         print(\"x è positivo\")     } if: Parola chiave che introduce la condizione. (x &gt; 0): Condizione composta da: x: Identificatore della variabile, &gt;: Operatore di confronto e 0: Letterale numerico intero. { ... }: Delimitatori che racchiudono il blocco di codice. print(\"x è positivo\"): Istruzione di output.\nCicli: Istruzioni che ripetono un blocco di codice. Esempio: plaintext     for (i = 0; i &lt; n; i++) {         somma = somma + i     } for: Parola chiave che introduce il ciclo. (i = 0; i &lt; n; i++): Espressione di controllo del ciclo composta da: - i = 0: Assegnazione iniziale, i &lt; n: Condizione del ciclo ei++: Incremento della variabile i. { ... }: Delimitatori che racchiudono il blocco di codice. somma = somma + i: Operazione aritmetica.\n\n\n\n\n3.2.2 Semantica\nLa semantica di un linguaggio di programmazione definisce il significato delle istruzioni sintatticamente corrette. In altre parole, la semantica specifica cosa fa un programma quando viene eseguito, descrivendo l’effetto delle istruzioni sullo stato del sistema. Gli elementi semantici sono numerosi, possono essere anche molto complessi e non tutti presenti in uno specifico linguaggio. Di seguito ne sono elencati alcuni tra i più diffusi:\n\nVariabile: È un nome simbolico associato a locazione di memoria che può contenere uno o più valori. È fondamentale per la manipolazione di dati perché sono un mezzo per astrarre dalla costante memorizzata. Le variabili possono essere associate a diversi tipi di dati e durate di vita. La semantica delle variabili include la loro dichiarazione, inizializzazione, uso e visibilità:\n\nDichiarazione: La dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. La dichiarazione informa il compilatore o l’interprete che una certa variabile esiste e può essere utilizzata nel codice.\nInizializzazione: L’inizializzazione di una variabile è il processo di assegnare un valore iniziale alla variabile. L’inizializzazione può avvenire contestualmente alla dichiarazione o in un’istruzione separata successiva.\nVisibilità: Indica dove la variabile può essere utilizzata all’interno del codice (ad esempio, variabili locali o globali).\nDurata di Vita: Descrive per quanto tempo la variabile rimane in memoria durante l’esecuzione del programma (ad esempio, automatica, statica, dinamica).\n\nTipi di dati: I tipi di dati definiscono il dominio dei valori che una variabile può assumere e le operazioni che possono essere eseguite su quei valori. Un tipo di dato determina la natura del valore (ad esempio, numero intero, carattere, booleano) e le operazioni che possono essere effettuate su di esso. Generalmente si distinguono in:\n\nTipi primitivi: I tipi di dati fondamentali forniti da un linguaggio, come integer, float, boolean e character.\nTipi complessi: Tipi di dati costituiti da più tipi primitivi, come array, struct e oggetti.\nTipi di dati utente: Tipi definiti dall’utente, come classi e tipi personalizzati, che permettono di creare strutture dati più complesse e specifiche per il problema da risolvere.\n\nAmbito (in inglese, scope): L’ambito rappresenta la porzione del codice in cui un identificatore (come una variabile o una funzione) è definito e, quindi, esiste. L’ambito determina dove un identificatore può essere dichiarato e utilizzato. Tipicamente gli ambiti sono:\n\nGlobale: Identificatori dichiarati a livello globale, accessibili ovunque nel programma.\nLocale: Identificatori dichiarati all’interno di un blocco, come una funzione o un loop, e accessibili solo all’interno di quel blocco.\nStatico e dinamico: L’ambito statico è determinato a tempo di compilazione, mentre l’ambito dinamico è determinato a runtime, influenzando come e dove gli identificatori possono essere utilizzati.\n\nVisibilità: La visibilità si riferisce a dove nel codice un identificatore può essere visto e utilizzato. Anche se correlata all’ambito, la visibilità può essere influenzata da altri fattori come la modularità e i namespace, che organizzano e separano gli identificatori per evitare conflitti di nome. La visibilità è generalmente:\n\nGlobale: Un identificatore dichiarato con visibilità globale può essere utilizzato in qualsiasi parte del programma.\nLocale: Un identificatore dichiarato con visibilità locale è visibile solo all’interno del blocco di codice in cui è stato dichiarato.\n\nDurata di vita delle variabili: La durata di vita delle variabili si riferisce a quanto tempo una variabile rimane in memoria durante l’esecuzione del programma. Alcune tipologie di durata:\n\nAutomatica: Variabili che esistono solo durante l’esecuzione del blocco in cui sono dichiarate.\nStatica: Variabili che esistono per tutta la durata del programma e mantengono il loro valore tra diverse chiamate di funzione.\nDinamica: Variabili allocate dinamicamente durante l’esecuzione del programma, solitamente gestite manualmente dall’utente (ad esempio, usando malloc/free in C) o automaticamente tramite garbage collection.\n\nDurata di vita di altri identificatori:\n\nFunzioni: Le funzioni stesse generalmente hanno una durata di vita che coincide con la durata del programma. Tuttavia, i puntatori a funzione e le chiusure (in inglese, closures) possono avere durate di vita diverse in alcuni linguaggi.\nClassi e oggetti: Le classi hanno una durata di vita che coincide con la durata del programma, mentre gli oggetti (istanze di classi) hanno durate di vita dinamiche, determinate dalla loro allocazione e deallocazione.\nModuli: In linguaggi come Python, i moduli hanno una durata di vita che coincide con la durata del programma o del processo di importazione.\n\nFunzioni e metodi: Le funzioni e i metodi sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Alcuni concetti collegati sono:\n\nParametri e argomenti: Valori passati alle funzioni per influenzarne il comportamento. I parametri sono definiti nella dichiarazione della funzione, mentre gli argomenti sono i valori effettivi passati quando la funzione è chiamata.\nValore di ritorno: Il risultato prodotto da una funzione, che può essere utilizzato nell’istruzione chiamante.\nOverloading: Definizione di più funzioni con lo stesso nome ma diversi parametri, consentendo diverse implementazioni basate sui tipi e il numero di argomenti.\nRicorsione: Capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili.\nFunzioni di prima classe: Le funzioni possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.\nFunzioni di ordine superiore: Funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati.\n\nControllo di flusso: Determina l’ordine in cui le istruzioni vengono eseguite e alcuni esempi sono:\n\nCondizionali: Strutture che permettono al programma di prendere decisioni (if, else, switch/case).\nCicli: Strutture che ripetono un blocco di codice (for, while, do-while).\nEccezioni: Meccanismi per gestire errori e condizioni anomale (try, catch, throw), permettendo al programma di continuare l’esecuzione in modo controllato.\n\nClassi e oggetti: Le classi sono trutture che definiscono proprietà (variabili) e comportamenti (metodi) comuni a tutti gli oggetti di quel tipo. Le classi rappresentano il modello o il blueprint da cui vengono creati gli oggetti. L’oggetto è l’istanza concreta di una classe. Gli oggetti sono entità che combinano dati e comportamenti secondo la struttura definita dalla loro classe. Si applicano i seguenti:\n\nEncapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie, migliorando la modularità e la manutenzione del codice.\nEreditarietà: Permette di creare nuove classi basate su classi esistenti, riutilizzando e estendendo il comportamento delle classi base.\nPolimorfismo: Consente a metodi di comportarsi diversamente a seconda dell’oggetto su cui vengono invocati, fornendo flessibilità e estendibilità.\n\nGestione della memoria utilizzata dal programma: La gestione della memoria è fondamentale per il funzionamento efficiente di un programma. Ne esistono diverse modalità:\n\nAllocazione dinamica: La memoria è allocata e deallocata a runtime, permettendo una gestione flessibile delle risorse.\nGarbage collection: Automatizza la deallocazione della memoria non utilizzata, riducendo il rischio di sfruttamento non ottimale (memory leak) e semplificando la gestione della memoria.\n\nSpazio di nomi (in inglese namespace): I namespace organizzano variabili, funzioni e altri identificatori per evitare conflitti di nome.\nModuli e librerie: I moduli e le librerie suddividono il codice in unità riutilizzabili e organizzate, da importare in programmi. I moduli possono definire degli spazi di nomi.\nConcorrenza: La concorrenza permette l’esecuzione parallela di più sequenze di istruzioni, migliorando le prestazioni e la reattività. Alcuni concetti relativi sono:\n\nThread: Un thread è la più piccola unità di elaborazione che può essere eseguita in modo indipendente. I thread consentono l’esecuzione parallela di codice all’interno di un programma.\nSincronizzazione: Meccanismi per gestire l’accesso concorrente alle risorse condivise, prevenendo condizioni di gara e garantendo la consistenza dei dati.\nLock e mutex: Meccanismi per prevenire condizioni di corsa (in inglese race condition), cioè un fenomeno che si presenta nei sistemi concorrenti quando, in presenza di una sequenza di processi multipli, il risultato finale dell’esecuzione dei processi dipende dalla temporizzazione o dalla sequenza con cui vengono eseguiti. Garantiscono, pertanto, l’accesso sicuro alle risorse condivise.\nAsync/await: Gestione di operazioni asincrone, migliorando l’efficienza e la reattività delle applicazioni.\n\nInput/output (I/O): L’input/output gestisce la comunicazione tra il programma e l’ambiente esterno.\n\nFile I/O: Lettura e scrittura su file per memorizzare e recuperare dati persistenti.\nNetwork I/O: Comunicazione attraverso reti per inviare e ricevere dati tra sistemi diversi.\nStandard I/O: Interazione con l’utente tramite input da tastiera e output su schermo.\n\nAnnotazioni e metadati: Le annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l’analisi del codice.\n\nAnnotazioni: Informazioni extra utilizzate per specificare comportamenti speciali o configurazioni. Ad esempio, in Java, le annotazioni possono essere utilizzate per indicare che un metodo è obsoleto (@Deprecated), per sovrascrivere un metodo della superclasse (@Override), o per specificare la relazione tra entità nel contesto di framework come JPA (@Entity, @Table). In Python, le annotazioni sono utilizzate principalmente per indicare i tipi di variabili, parametri di funzione e valori di ritorno (type hint). Non influenzano direttamente il comportamento del programma, ma sono utili per la documentazione e il type checking anche automatico.\nDocstring: Commenti strutturati che documentano il codice, spesso utilizzati per generare documentazione automatica. In Python, ad esempio, le docstring possono essere utilizzate per descrivere il funzionamento di moduli, classi, metodi e funzioni, rendendo il codice più leggibile e comprensibile.\n\nMacro e metaprogrammazione: Le macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice.\n\nMacro: Sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale.\nMetaprogrammazione: Tecniche per scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time, migliorando la flessibilità e il riutilizzo del codice. In Python include l’uso di decoratori, metaclassi e introspezione.\n\n\nQuesti elementi semantici combinati determinano il comportamento e la logica di un programma, influenzando il modo in cui il codice viene scritto, eseguito e mantenuto.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi dei linguaggi di programmazione e algoritmi dei programmi</span>"
    ]
  },
  {
    "objectID": "fp-syntax-algorithm.html#esempio-di-algoritmo",
    "href": "fp-syntax-algorithm.html#esempio-di-algoritmo",
    "title": "3  Sintassi dei linguaggi di programmazione e algoritmi dei programmi",
    "section": "3.3 Esempio di Algoritmo",
    "text": "3.3 Esempio di Algoritmo\nConsideriamo un esempio semplice di algoritmo per calcolare la somma dei numeri da 1 a n:\n\nInput: Un numero intero n.\nOutput: La somma dei numeri da 1 a n.\n\nAlgoritmo (in pseudocodice):\n1. Inizializza somma a 0\n2. Per ogni numero i da 1 a n:\n    3. Aggiungi i a somma\n4. Restituisci somma\n\n## Implementazione di un Algoritmo in un Linguaggio di Programmazione\n\nVediamo come un algoritmo per calcolare la somma dei numeri da 1 a n può essere implementato in un linguaggio di programmazione generico. Esamineremo come gli elementi sintattici si collegano alle componenti semantiche.\n\n### Algoritmo (in pseudocodice)\n\n1. Inizializza `somma` a 0\n2. Per ogni numero `i` da 1 a `n`:\n    - Aggiungi `i` a `somma`\n3. Restituisci `somma`\n\n### Implementazione\n\n```plaintext\nfunzione somma(n):\n    somma = 0\n    per i da 1 a n:\n        somma = somma + i\n    ritorna somma\n\n3.3.1 Analisi degli Elementi Sintattici e Semantici\n\n3.3.1.1 Dichiarazione della Funzione\nfunzione somma(n):\n\nSintassi:\n\nfunzione: Parola chiave che introduce la definizione di una funzione.\nsomma: Identificatore che nomina la funzione.\n(n): Parentesi tonde che contengono l’argomento della funzione.\n\nSemantica:\n\nDefinisce una funzione chiamata somma che accetta un argomento n.\n\n\n\n\n3.3.1.2 Inizializzazione della Variabile\nsomma = 0\n\nSintassi:\n\nsomma: Identificatore della variabile.\n=: Operatore di assegnazione.\n0: Literal (valore costante).\n\nSemantica:\n\nInizializza la variabile somma a 0.\n\n\n\n\n3.3.1.3 Ciclo for\nper i da 1 a n:\n\nSintassi:\n\nper: Parola chiave che introduce il ciclo.\ni: Identificatore della variabile di controllo del ciclo.\nda 1 a n: Espressione di controllo del ciclo che indica l’intervallo.\n\nSemantica:\n\nItera la variabile i da 1 a n.\n\n\n\n\n3.3.1.4 Espressione Aritmetica\nsomma = somma + i\n\nSintassi:\n\nsomma: Identificatore della variabile.\n=: Operatore di assegnazione.\nsomma + i: Espressione aritmetica composta da:\n\nsomma: Identificatore della variabile.\n+: Operatore aritmetico.\ni: Identificatore della variabile.\n\n\nSemantica:\n\nAggiunge il valore di i alla variabile somma e assegna il risultato a somma.\n\n\n\n\n3.3.1.5 Restituzione del Risultato\nritorna somma\n\nSintassi:\n\nritorna: Parola chiave che indica la restituzione di un valore.\nsomma: Identificatore della variabile.\n\nSemantica:\n\nRestituisce il valore della variabile somma come risultato della funzione.\n\n\n\n\n\n3.3.2 Collegamento agli Elementi Sintattici\nOgni elemento dello pseudocodice è collegato a specifici componenti sintattici e semantici del linguaggio di programmazione:\n\nParole chiave: funzione, per, ritorna\nOperatori: =, +\nSeparatori: (), :\nIdentificatori: somma, n, i\nLiterals: 0, 1, n\nEspressioni: somma + i, da 1 a n\n\n\n\n3.3.3 Conclusione\nUn algoritmo è la base logica e metodica di un programma. La comprensione della sintassi e della semantica di un linguaggio di programmazione è essenziale per tradurre correttamente un algoritmo in un codice eseguibile. Gli elementi sintattici come parole chiave, operatori, separatori, identificatori, literals ed espressioni sono i mattoni fondamentali che definiscono come scrivere correttamente il codice. La semantica descrive cosa fa effettivamente il codice una volta eseguito, garantendo che l’algoritmo produca i risultati desiderati.",
    "crumbs": [
      "Prima parte: I fondamenti",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi dei linguaggi di programmazione e algoritmi dei programmi</span>"
    ]
  },
  {
    "objectID": "sp-python-intro.html",
    "href": "sp-python-intro.html",
    "title": "4  introduzione a Python",
    "section": "",
    "text": "4.1 Perché Python è un linguaggio di alto livello?\nPython è considerato un linguaggio di programmazione di alto livello, cioè utilizza un livello di astrazione elevato rispetto alla complessità dell’ambiente in cui i suoi programmi sono eseguiti. Il programmatore ha a disposizione una sintassi che è più intuitiva rispetto ad altri linguaggi come Java, C++, PHP tradizionalmente anch’essi definiti di alto livello.\nInfatti, consente ai programmatori di scrivere codice in modo più concettuale e indipendente dalle caratteristiche degli hardware, anche molto diversi, su cui è disponibile. Ad esempio, invece di preoccuparsi di allocare e deallocare memoria manualmente, Python gestisce queste operazioni automaticamente. Questo libera il programmatore dai dettagli del sistema operativo e dell’elettronica, permettendogli di concentrarsi sulla logica del problema da risolvere.\nCiò ha un effetto importante sulla versatilità perché spesso è utilizzato come “interfaccia utente” per linguaggi di livello più basso come C, C++ o Fortran. Questo permette a Python di sfruttare le prestazioni dei linguaggi compilati per le parti critiche e computazionalmente intensive del codice, mantenendo al contempo una sintassi semplice e leggibile per la maggior parte del programma. Buoni compilatori per i linguaggi compilati classici possono sì generare codice binario che gira più velocemente di Python, tuttavia, nella maggior parte dei casi, le prestazioni delle applicazioni codificate in Python sono sufficienti.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>introduzione a Python</span>"
    ]
  },
  {
    "objectID": "sp-python-intro.html#python-come-linguaggio-multiparadigma",
    "href": "sp-python-intro.html#python-come-linguaggio-multiparadigma",
    "title": "4  introduzione a Python",
    "section": "4.2 Python come linguaggio multiparadigma",
    "text": "4.2 Python come linguaggio multiparadigma\nPython è un linguaggio di programmazione multiparadigma, il che significa che supporta diversi paradigmi di programmazione, permettendo di mescolare e combinare gli stili a seconda delle necessità dell’applicazione. Ecco alcuni dei paradigmi supportati da Python:\n\nProgrammazione imperativa: Python supporta la programmazione imperativa, che si basa sull’esecuzione di istruzioni in una sequenza specifica. Puoi scrivere ed eseguire script Python direttamente dalla linea di comando, permettendo un approccio interattivo e immediato alla programmazione, come se fosse una calcolatrice.\nProgrammazione procedurale: In Python, è possibile organizzare il codice in funzioni e moduli, rendendo più semplice la gestione e la riutilizzabilità del codice. Puoi raccogliere il codice in file separati e importarli come moduli, migliorando la struttura e la leggibilità del programma.\nProgrammazione orientata agli oggetti: Python supporta pienamente la programmazione orientata agli oggetti, consentendo la definizione di classi e oggetti. Questo paradigma è utile per modellare dati complessi e relazioni tra essi. Le caratteristiche orientate agli oggetti di Python sono concettualmente simili a quelle di C++, ma più semplici da usare.\nProgrammazione funzionale: Python include funzionalità di programmazione funzionale, come funzioni di prima classe e di ordine superiore, lambda e strumenti come map, filter e reduce. Sfruttando la modularità, si possono creare collezioni di strumenti pronti all’uso.\n\nQuesta flessibilità rende Python adatto a una vasta gamma di applicazioni e consente ai programmatori di scegliere l’approccio più adatto al problema da risolvere.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>introduzione a Python</span>"
    ]
  },
  {
    "objectID": "sp-python-intro.html#regole-formali-e-esperienziali",
    "href": "sp-python-intro.html#regole-formali-e-esperienziali",
    "title": "4  introduzione a Python",
    "section": "4.3 Regole formali e esperienziali",
    "text": "4.3 Regole formali e esperienziali\nPython non è solo un linguaggio con regole sintattiche precise e ben progettate, ma possiede anche una propria “filosofia”, un insieme di regole di buon senso esperienziali che sono complementari alla sintassi formale. Questa filosofia è spesso riassunta nel “zen di Python”, una raccolta di aforismi che catturano i principi fondamentali del design di Python. Tali principi aiutano i programmatori a comprendere e utilizzare al meglio le potenzialità del linguaggio e dell’ecosistema Python.\nEcco alcuni dei principi dello “zen di Python”1:\n1 PEP 20 – The Zen of Python\nLa leggibilità conta: Il codice dovrebbe essere scritto in modo che sia facile da leggere e comprendere.\nEsplicito è meglio di implicito: È preferibile scrivere codice chiaro e diretto piuttosto che utilizzare scorciatoie criptiche.\nSemplice è meglio di complesso: Il codice dovrebbe essere il più semplice possibile per risolvere il problema.\nComplesso è meglio di complicato: Quando la semplicità non è sufficiente, la complessità è accettabile, ma il codice non dovrebbe mai essere complicato.\nPratico batte puro: Le soluzioni pragmatiche sono preferibili alle soluzioni eleganti ma poco pratiche.\n\nQuesti principi, insieme alle regole sintattiche, guidano il programmatore nell’adottare buone pratiche di sviluppo e nel creare codice che sia non solo funzionale ma anche mantenibile e comprensibile da altri.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>introduzione a Python</span>"
    ]
  },
  {
    "objectID": "sp-python-intro.html#lecosistema",
    "href": "sp-python-intro.html#lecosistema",
    "title": "4  introduzione a Python",
    "section": "4.4 L’ecosistema",
    "text": "4.4 L’ecosistema\nFino ad ora abbiamo visto Python come linguaggio, ma è molto di più: Python è anche una vasta collezione di strumenti e risorse a disposizione degli sviluppatori, strutturata in un ecosistema completo, di cui il linguaggio ne rappresenta la parte formale. Questo ecosistema è disponibile completamente e anche come sorgente sul sito ufficiale python.org.\n\n4.4.1 L’interprete\nL’interprete Python è lo strumento di esecuzione dei programmi. È il software che legge ed esegue il codice Python. Python è un linguaggio interpretato, il che significa che il codice viene eseguito direttamente dall’interprete, senza bisogno di essere compilato in un linguaggio macchina. Esistono diverse implementazioni dell’interprete Python:\n\nCPython: L’implementazione di riferimento dell’interprete Python, scritta in C. È la versione più utilizzata e quella ufficiale.\nPyPy: Un interprete alternativo che utilizza tecniche di compilazione just-in-time (JIT) per migliorare le prestazioni.\nJython: Un’implementazione di Python che gira sulla JVM (Java virtual machine).\nIronPython: Un’implementazione di Python integrata col .NET framework della Microsoft.\n\n\n\n4.4.2 L’ambiente di sviluppo\nIDLE (integrated development and learning environment) è l’ambiente di sviluppo integrato ufficiale per Python. È incluso nell’installazione standard di Python ed è progettato per essere semplice e facile da usare, ideale per i principianti. Offre diverse funzionalità utili:\n\nEditor di codice: Con evidenziazione della sintassi, indentazione automatica e controllo degli errori.\nShell interattiva: Permette di eseguire codice Python in modo interattivo.\nStrumenti di debug: Include un debugger integrato con punti di interruzione e stepping.\n\n\n\n4.4.3 Le librerie standard\nUna delle caratteristiche più potenti di Python è il vasto insieme di librerie2 utilizzabili in CPython e IDLE, che fornisce moduli e pacchetti per quasi ogni necessità di programmazione. Alcuni esempi, solo allo scopo di illustrarne la varietà, includono:\n2 Documentazione delle librerie standard di Python\nos: Fornisce funzioni per interagire con il sistema operativo.\nsys: Offre accesso a funzioni e oggetti del runtime di Python.\ndatetime: Consente di lavorare con date e orari.\njson: Permette di leggere e scrivere dati in formato JSON.\nre: Supporta la manipolazione di stringhe tramite espressioni regolari.\nhttp: Include moduli per l’implementazione di client e server HTTP.\nunittest: Fornisce un framework per il testing del codice.\nmath e cmath: Contengono funzioni matematiche di base e complesse.\nitertools, functools, operator: Offrono supporto per il paradigma di programmazione funzionale.\ncsv: Gestisce la lettura e scrittura di file CSV.\ntyping: Fornisce supporto per l’annotazione dei tipi di variabili, funzioni e classi.\nemail: Permette di creare, gestire e inviare email, facilitando la manipolazione di messaggi email MIME.\nhashlib: Implementa algoritmi di hash sicuri come SHA-256 e MD5.\nasyncio: Supporta la programmazione asincrona per la scrittura di codice concorrente e a bassa latenza.\nwave: Fornisce strumenti per leggere e scrivere file audio WAV.\n\n\n\n4.4.4 Moduli di estensione\nPython supporta l’estensione del suo core tramite moduli scritti in C, C++ o altri linguaggi. Questi moduli permettono di ottimizzare parti critiche del codice o di interfacciarsi con librerie e API esterne:\n\nCython: Permette di scrivere moduli C estesi utilizzando una sintassi simile a Python. Cython è ampiamente utilizzato per migliorare le prestazioni di parti critiche del codice, specialmente in applicazioni scientifiche e di calcolo numerico. Ad esempio, molte librerie scientifiche popolari come SciPy e scikit-learn utilizzano Cython per accelerare le operazioni computazionalmente intensive.\nctypes: Permette di chiamare funzioni in librerie dinamiche C direttamente da Python. È utile per interfacciarsi con librerie esistenti scritte in C, rendendo Python estremamente versatile per l’integrazione con altre tecnologie. Ciò è utile in applicazioni che devono interfacciarsi con hardware specifico o utilizzare librerie legacy.\nCFFI (C foreign function interface): Un’altra interfaccia per chiamare librerie C da Python. È progettata per essere facile da usare e per supportare l’uso di librerie C complesse con Python. CFFI è utilizzato in progetti come PyPy e gevent, permettendo di scrivere codice ad alte prestazioni e di gestire le chiamate a funzioni C in modo efficiente.\n\n\n\n4.4.5 Utility e strumenti aggiuntivi\nPython include anche una serie di strumenti e utility che facilitano lo sviluppo e la gestione dei progetti:\n\npip: Il gestore dei pacchetti di Python. Permette di installare e gestire moduli aggiuntivi, cioè non inclusi nello standard.\nvenv: Uno strumento per creare ambienti virtuali isolati, che permettono di gestire separatamente le dipendenze di diversi progetti.\nDocumentazione: Python include una documentazione dettagliata, accessibile tramite il comando pydoc o attraverso il sito ufficiale.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>introduzione a Python</span>"
    ]
  },
  {
    "objectID": "sp-python-intro.html#lalgoritmo-di-ordinamento-bubble-sort",
    "href": "sp-python-intro.html#lalgoritmo-di-ordinamento-bubble-sort",
    "title": "4  introduzione a Python",
    "section": "4.5 L’algoritmo di ordinamento bubble sort",
    "text": "4.5 L’algoritmo di ordinamento bubble sort\nPer chiudere il capitolo sul primo approccio a Python, possiamo confrontare un algoritmo di media complessità in diversi linguaggi di programmazione. Un buon esempio potrebbe essere l’implementazione dell’algoritmo di ordinamento “bubble sort” di una lista di valori. Vediamo come viene scritto in Python, C, C++, e Java.\n\n4.5.1 Python\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] &gt; arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sort(arr)\n\nprint(\"Sorted array is:\", arr)\n\n\n4.5.2 C\n#include &lt;stdio.h&gt;\n\nvoid bubble_sort(int arr[], int n) {\n    int i, j, temp;\n    for (i = 0; i &lt; n-1; i++) {\n        for (j = 0; j &lt; n-i-1; j++) {\n            if (arr[j] &gt; arr[j+1]) {\n                temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    bubble_sort(arr, n);\n\n    printf(\"Sorted array is: \");\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    return 0;\n}\n\n\n4.5.3 C++\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass BubbleSort {\npublic:\n    void sort(int arr[], int n) {\n        for (int i = 0; i &lt; n-1; i++) {\n            for (int j = 0; j &lt; n-i-1; j++) {\n                if (arr[j] &gt; arr[j+1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n\n    void printArray(int arr[], int n) {\n        for (int i = 0; i &lt; n; i++) {\n            cout &lt;&lt; arr[i] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n};\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    BubbleSort bs;\n    bs.sort(arr, n);\n\n    cout &lt;&lt; \"Sorted array is: \";\n    bs.printArray(arr, n);\n\n    return 0;\n}\n\n\n4.5.4 Java\npublic class BubbleSort {\n\n    public static void bubbleSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i &lt; n-1; i++) {\n            for (int j = 0; j &lt; n-i-1; j++) {\n                if (arr[j] &gt; arr[j+1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {64, 34, 25, 12, 22, 11, 90};\n\n        bubbleSort(arr);\n\n        System.out.println(\"Sorted array is:\");\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n\n\n4.5.5 Rust\nfn bubble_sort(arr: &mut [i32]) {\n    let n = arr.len();\n    for i in 0..n {\n        for j in 0..n-i-1 {\n            if arr[j] &gt; arr[j+1] {\n                arr.swap(j, j+1);\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut arr = [64, 34, 25, 12, 22, 11, 90];\n\n    bubble_sort(&mut arr);\n\n    println!(\"Sorted array is: {:?}\", arr);\n}\n\n\n4.5.6 Scala\nobject BubbleSort {\n  def bubbleSort(arr: Array[Int]): Unit = {\n    val n = arr.length\n    for (i &lt;- 0 until n) {\n      for (j &lt;- 0 until n - i - 1) {\n        if (arr(j) &gt; arr(j + 1)) {\n          val temp = arr(j)\n          arr(j) = arr(j + 1)\n          arr(j + 1) = temp\n        }\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val arr = Array(64, 34, 25, 12, 22, 11, 90)\n\n    bubbleSort(arr)\n\n    println(\"Sorted array is: \" + arr.mkString(\", \"))\n  }\n}\nConfrontando questi esempi, possiamo osservare le differenze sintattiche e di stile tra Python ed altri, importanti, linguaggi. Python si distingue per la sua sintassi concisa e leggibile, mentre C richiede una gestione manuale della memoria e una sintassi più dettagliata.\nIl C++ e Java aggiungono caratteristiche relative agli oggetti e funzionalità di alto livello rispetto a C, al prezzo di una sintassi più complessa e verbosa. Rust e Scala sono linguaggi più moderni e si pongono nel mezzo tra C, C++ e Java e Python.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>introduzione a Python</span>"
    ]
  },
  {
    "objectID": "sp-python-install.html",
    "href": "sp-python-install.html",
    "title": "5  Scaricare e installare Python",
    "section": "",
    "text": "5.1 Scaricamento",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "sp-python-install.html#scaricamento",
    "href": "sp-python-install.html#scaricamento",
    "title": "5  Scaricare e installare Python",
    "section": "",
    "text": "Visita il sito ufficiale di Python: Vai su python.org.\nNaviga alla pagina di download: Clicca su “Downloads” nel menu principale.\nScarica il pacchetto di installazione:\n\nPer Windows: Clicca su “Download Python 3.12.x” (assicurati di scaricare la versione più recente).\nPer macOS: Clicca su “Download Python 3.12.x”.\nPer Linux: Python è spesso preinstallato. Se non lo è, usa il gestore di pacchetti della tua distribuzione (ad esempio apt per Ubuntu: sudo apt-get install python3).",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "sp-python-install.html#installazione",
    "href": "sp-python-install.html#installazione",
    "title": "5  Scaricare e installare Python",
    "section": "5.2 Installazione",
    "text": "5.2 Installazione\n\nEsegui il file di installazione:\n\nSu Windows: Esegui il file .exe scaricato. Assicurati di selezionare l’opzione “Add Python to PATH” durante l’installazione.\nSu macOS: Apri il file .pkg scaricato e segui le istruzioni.\nSu Linux: Usa il gestore di pacchetti per installare Python.\n\nVerifica l’installazione:\n\nApri il terminale (Command Prompt su Windows, Terminal su macOS e Linux).\nDigita python --version o python3 --version e premi Invio. Dovresti vedere la versione di Python installata.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "sp-python-install.html#esecuzione-del-primo-programma-hello-world",
    "href": "sp-python-install.html#esecuzione-del-primo-programma-hello-world",
    "title": "5  Scaricare e installare Python",
    "section": "5.3 Esecuzione del primo programma: “Hello, World!”",
    "text": "5.3 Esecuzione del primo programma: “Hello, World!”\nÈ consuetudine eseguire come primo programma la visualizzazione della stringa “Hello, World!”1. Possiamo farlo in diversi modi e ciò è una delle caratteristiche più apprezzate di Python.\n1 La tradizione del programma “Hello, World!” ha una lunga storia che risale ai primi giorni della programmazione. Questo semplice programma è generalmente il primo esempio utilizzato per introdurre i nuovi programmatori alla sintassi e alla struttura di un linguaggio di programmazione. Il programma “Hello, World!” è diventato famoso grazie a Brian Kernighan, che lo ha incluso nel suo libro (Kernighan e Ritchie 1988) pubblicato nel 1978. Tuttavia, il suo utilizzo risale a un testo precedente di Kernighan, (Kernighan 1973), pubblicato nel 1973, dove veniva utilizzato un esempio simile.\nKernighan, Brian W., e Dennis M. Ritchie. 1988. The C Programming Language. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.\n\nKernighan, Brian W. 1973. «A Tutorial Introduction to the Programming Language B». Murray Hill, NJ: Bell Laboratories.\n\n5.3.1 REPL\nIl primo modo prevede l’utilizzo del REPL di Python. Il REPL (read-eval-print loop) è un ambiente interattivo di esecuzione di comandi Python generato dall’interprete, secondo il ciclo:\n\nRead: Legge un input dell’utente.\nEval: Valuta l’input.\nPrint: Visualizza il risultato dell’esecuzione.\nLoop: Ripete il ciclo.\n\nEseguiamo il nostro primo “Hello, World!”:\n\nApri il terminale ed esegui l’interprete Python digitando python o python3 e premi il tasto di invio della tastiera.\nScrivi ed esegui il programma:\n\nprint(\"Hello, World!\")\nPremi il tasto di invio per vedere il risultato immediatamente.\n\n\n\n\n\n\nAttenzione\n\n\n\nIl REPL e l’interprete Python sono strettamente collegati, ma non sono esattamente la stessa cosa. Quando avvii l’interprete Python senza specificare un file di script da eseguire (digitando semplicemente python o python3 nel terminale), entri in modalità REPL. Nel REPL, l’interprete Python legge l’input direttamente dall’utente, lo esegue, stampa il risultato e poi attende il prossimo input. In sintesi, l’interprete può eseguire programmi Python completi salvati in file, il REPL è progettato per un’esecuzione interattiva e immediata di singole istruzioni.\n\n\n\n\n5.3.2 Interprete\nUn altro modo per eseguire il nostro programma “Hello, World!” è utilizzare l’interprete Python per eseguire un file di codice sorgente. Questo metodo è utile per scrivere programmi più complessi e per mantenere il codice per usi futuri.\nEcco come fare sui diversi sistemi operativi.\n\nWindowsmacOSLinux\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Notepad.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dall’Esplora file.\nEsegui il file Python:\n\nApri il prompt dei comandi.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd %HOMEPATH%\\Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython hello.txt\noppure, se il tuo sistema utilizza python3: plaintext   python3 hello.txt\nVisualizza il risultato:\nHello, World!\n\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come TextEdit.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dal Finder.\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documents\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\nHello, World!\n\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Gedit o Nano.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello utilizzando il comando mv nel terminale: bash      mv hello.txt hello\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\nHello, World!\n\n\n\n\nCon queste istruzioni, dovresti essere in grado di eseguire il programma “Hello, World!” utilizzando un file Python su Windows, macOS e Linux.\n\n\n5.3.3 IDE\nUtilizzo di un IDE (integrated development environment) installato sul computer. Ecco alcuni dei più comuni e gratuiti.\n\nIDLEPyCharmVisual Studio Code\n\n\nIncluso con l’installazione di Python.\n\nAvvia IDLE.\nCrea un nuovo file (File -&gt; New File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file (File -&gt; Salva).\nEsegui il programma (Run -&gt; Run Module).\n\n\n\nProprietario ma con una versione liberamente fruibile.\n\nScarica e installa PyCharm da jetbrains.com/pycharm/download.\nCrea un nuovo progetto associando l’interprete Python.\nCrea un nuovo file Python (File -&gt; New -&gt; Python File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nEsegui il programma (Run -&gt; Run...).\n\n\n\nProprietario ma liberamente fruibile.\n\nScarica e installa VS Code da code.visualstudio.com.\nInstalla l’estensione Python.\nApri o crea una nuova cartella di progetto.\nCrea un nuovo file Python (File -&gt; Nuovo file).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file con estensione .py, ad esempio hello_world.py.\nEsegui il programma utilizzando il terminale integrato (Visualizza -&gt; Terminale) e digitando python hello_world.py.\n\n\n\n\n\n\n5.3.4 Esecuzione nel browser\nPuoi eseguire Python direttamente nel browser, senza installare nulla. Anche qui abbiamo diverse alternative, sia eseguendo il codice localmente, che utilizzando piattaforme online.\n\nRepl.itGoogle ColabPyScript\n\n\n\nVisita repl.it.\nCrea un nuovo progetto selezionando Python.\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nClicca su “Run” per eseguire il programma.\n\n\n\n\nVisita colab.research.google.com.\nCrea un nuovo notebook.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi il pulsante di esecuzione accanto alla cella.\n\n\n\n\nVisita il sito ufficiale di PyScript per ulteriori informazioni su come iniziare.\nCrea un file HTML con il seguente contenuto:\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Hello, World with PyScript&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/latest/pyscript.css\"&gt;\n    &lt;script defer src=\"https://pyscript.net/latest/pyscript.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;py-script&gt;\n        print(\"Hello, World!\")\n    &lt;/py-script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nSalva il file con estensione .html (ad esempio, hello.html).\nApri il file salvato in un browser web. Vedrai l’output Hello, World! direttamente nella pagina.\n\n\n\n\n\n\n5.3.5 Jupyter Notebook\nJupyter Notebook è un ambiente di sviluppo interattivo per la programmazione che permette di creare e condividere documenti contenenti codice eseguibile, visualizzazioni, testo formattato e altro ancora. Originariamente sviluppato come parte del progetto IPython, Jupyter supporta non solo Python, ma anche numerosi altri linguaggi di programmazione attraverso i cosiddetti kernel tra cui R, Julia e Scala.\n\nUso localeJupyterHubBinder\n\n\n\nAssicurati di avere Python e Jupyter installati sul tuo computer. Se non li hai, puoi installarli utilizzando Anaconda o pip:\n\npip install notebook\n\nAvvia Jupyter Notebook dal terminale:\n\njupyter notebook\n\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita l’istanza di JupyterHub della tua istituzione o azienda (maggiori informazioni).\nAccedi con le tue credenziali.\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita mybinder.org.\nInserisci l’URL del repository GitHub che contiene il tuo notebook o il tuo progetto Python.\nClicca su “Launch”.\nUna volta avviato l’ambiente, crea un nuovo notebook o apri uno esistente.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\nBinder è un servizio simile a Colab, anche se quest’ultimo offre strumenti generalmente più avanzati in termini di risorse computazionali e collaborazione. Binder di contro è basato su GitHub e ciò può essere utile in alcuni contesti.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Riferimenti",
    "section": "",
    "text": "Kernighan, Brian W. 1973. “A Tutorial Introduction to the\nProgramming Language b.” Murray Hill, NJ: Bell Laboratories.\n\n\nKernighan, Brian W., and Dennis M. Ritchie. 1988. The c Programming\nLanguage. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.\n\n\nStroustrup, Bjarne. 1997. The c++ Programming Language. 3rd ed.\nReading, MA, USA: Addison-Wesley.",
    "crumbs": [
      "Appendici",
      "Riferimenti"
    ]
  }
]