[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Prefazione",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html",
    "href": "prima-parte-linguaggi-programmazione.html",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "",
    "text": "1.1 Definizioni\nLa programmazione è il processo di progettazione e scrittura di istruzioni, nella forma statica identificate come codice sorgente, che un computer può ricevere per eseguire compiti predefiniti. Queste istruzioni sono codificate in un linguaggio di programmazione, che traduce le idee e gli algoritmi del programmatore, in un formato comprensibile ed eseguibile dal computer.\nUn programma informatico è una sequenza di istruzioni scritte per eseguire una specifica operazione o un insieme di operazioni su un computer. Queste istruzioni sono codificate in un linguaggio che il computer può comprendere e seguire per eseguire attività come calcoli, manipolazione di dati, controllo di dispositivi e interazione con l’utente. Pensate a un programma come a una ricetta di cucina. La ricetta elenca gli ingredienti necessari (dati) e fornisce istruzioni passo-passo (algoritmo) per preparare un piatto. Allo stesso modo, un programma informatico specifica i dati da usare e le istruzioni da seguire per ottenere un risultato desiderato.\nUn linguaggio di programmazione è un linguaggio formale che fornisce un insieme di regole e sintassi per scrivere programmi informatici. Questi linguaggi permettono ai programmatori di comunicare con i computer e di creare software. Alcuni esempi di linguaggi di programmazione includono Python, Java, C++, SQL, Rust, Haskell, Prolog, C, Assembly, Fortran, JavaScript e altre centinaia (o forse migliaia).",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#linguaggi-naturali-e-di-programmazione",
    "href": "prima-parte-linguaggi-programmazione.html#linguaggi-naturali-e-di-programmazione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.2 Linguaggi naturali e di programmazione",
    "text": "1.2 Linguaggi naturali e di programmazione\nI linguaggi di programmazione differiscono dai linguaggi naturali (come l’italiano o l’inglese) in diversi modi:\n\nPrecisione e rigidità: I linguaggi di programmazione sono estremamente precisi e rigidi. Ogni istruzione deve essere scritta in un modo specifico affinché il computer possa comprenderla ed eseguirla correttamente. Anche un piccolo errore di sintassi può impedire il funzionamento di un programma.\nAmbiguità: I linguaggi naturali sono spesso ambigui e aperti a interpretazioni. Le stesse parole possono avere significati diversi a seconda del contesto. I linguaggi di programmazione, invece, sono progettati per essere privi di ambiguità; ogni istruzione ha un significato preciso e univoco.\nVocabolario limitato: I linguaggi naturali hanno un vocabolario vastissimo e in continua espansione. I linguaggi di programmazione, al contrario, hanno un vocabolario limitato costituito da parole chiave e comandi definiti dal linguaggio stesso.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#algoritmi",
    "href": "prima-parte-linguaggi-programmazione.html#algoritmi",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.3 Algoritmi",
    "text": "1.3 Algoritmi\nUn algoritmo è “un insieme di regole che definiscono con precisione una sequenza di operazioni” (Harold Stone, Introduction to Computer Organization and Data Structures, 1971 (Stone 1971)). Gli algoritmi sono alla base della programmazione perché rappresentano il disegno teorico computazionale dei programmi.\n\nStone, Harold S. 1971. Introduction to Computer Organization and Data Structures. USA: https://dl.acm.org/doi/10.5555/578826; McGraw-Hill, Inc.\nPiù precisamente, un algoritmo è una sequenza ben definita di passi o operazioni che, a partire da un input, produce un output in un tempo finito. Le proprietà principali seguenti esprimono in modo più completo le caratteristiche che un algoritmo deve possedere:\n\nFinitudine L’algoritmo deve terminare dopo un numero finito di passi.\nDeterminismo: Ogni passo dell’algoritmo deve essere definito in modo preciso e non ambiguo.\nInput L’algoritmo riceve zero o più dati in ingresso.\nOutput L’algoritmo produce uno o più risultati.\nEffettività: Ogni operazione dell’algoritmo deve essere fattibile ed eseguibile in un tempo finito.\n\nGli algoritmi sono tradotti in codice sorgente attraverso un linguaggio di programmazione per creare programmi. In altre parole, un programma è la realizzazione pratica e funzionante degli algoritmi ideati dal programmatore.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#esecuzione-del-programma",
    "href": "prima-parte-linguaggi-programmazione.html#esecuzione-del-programma",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.4 Esecuzione del programma",
    "text": "1.4 Esecuzione del programma\nQuando un programma viene scritto e salvato in un file di testo, il computer deve eseguirlo per produrre le azioni desiderate. Questo processo si svolge in diverse fasi:\n\nCompilazione o interpretazione: Il codice sorgente, scritto in un linguaggio di alto livello leggibile dall’uomo, deve essere trasformato in un linguaggio macchina comprensibile dal computer. Questo avviene attraverso due possibili processi:\n\nCompilazione: In linguaggi come C++ o Java, un compilatore traduce tutto il codice sorgente in linguaggio macchina, creando un file eseguibile. Questo file può poi essere eseguito direttamente dalla CPU.\nInterpretazione: In linguaggi come Python o JavaScript, un interprete legge ed esegue il codice sorgente istruzione per istruzione, traducendolo in linguaggio macchina al momento dell’esecuzione.\n\nEsecuzione: Una volta che il programma è stato compilato (nel caso dei linguaggi compilati) o viene interpretato (nel caso dei linguaggi interpretati), il computer può iniziare ad eseguire le istruzioni. La CPU (central processing unit) legge queste istruzioni dal file eseguibile o dall’interprete e le esegue una per una. Durante questa fase, la CPU manipola i dati e produce i risultati desiderati.\nInterazione con i componenti hardware: Durante l’esecuzione, il programma può interagire con vari componenti hardware del computer. Ad esempio, può leggere e scrivere dati nella memoria, accedere ai dischi rigidi per salvare o recuperare informazioni, comunicare attraverso la rete, e interagire con dispositivi di input/output come tastiere e monitor. Questa interazione permette al programma di eseguire compiti complessi e di fornire output all’utente.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#ciclo-di-vita-del-software",
    "href": "prima-parte-linguaggi-programmazione.html#ciclo-di-vita-del-software",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.5 Ciclo di vita del software",
    "text": "1.5 Ciclo di vita del software\nUn software è composto da uno o più programmi e, quando eseguito, realizza un compito con un grado di utilità specifico. La gerarchia è quindi: software, programmi, istruzioni.\nCosì come il disegno dei programmi è quello computazionale degli algoritmi, il disegno del software è funzionale per determinare i suoi obiettivi e architetturale per la decomposizione nei programmi.\nPer creare il software è necessario percorrere una sequenza di fasi ben definita che, concisamente, è:\n\nLa progettazione di un’applicazione inizia con la fase di analisi dei requisiti, in cui si identificano cosa deve fare il software, chi sono gli utenti e quali sono i requisiti funzionali e non funzionali che deve soddisfare.\nSegue il disegno funzionale che dettaglia come ogni componente del sistema possa rispondere alle funzionalità richieste. In questa fase si descrivono le operazioni specifiche che ogni componente deve eseguire, utilizzando diagrammi di processo per rappresentare il flusso di attività al fine di rispondere ai requisiti.\nIl disegno architetturale riguarda l’organizzazione ad alto livello del sistema software. In questa fase si definiscono i componenti principali del sistema e come essi interagiscono tra di loro per supportare le attività di processo. Questo include la suddivisione del sistema in moduli o componenti, la definizione delle interfacce tra di essi e l’uso di tecniche di modellazione per rappresentare l’architettura del sistema.\nUna volta che l’architettura è stata progettata, si passa alla fase di implementazione, in cui i programmatori scrivono il codice sorgente nei linguaggi di programmazione scelti.\nDopo l’implementazione, è essenziale verificare che il software funzioni correttamente:\n\nTesting: Scrivere ed eseguire test per verificare che il software soddisfi i requisiti specificati. I test sono di diversi generi in funzione dell’oggetto di verifica, come test unitari, per segmenti di codice, test di integrazione, per componenti, e test di sistema nella sua interezza.\nDebugging: Identificare e correggere gli errori (bug) nel codice. Questo può includere l’uso di strumenti di debugging per tracciare l’esecuzione del programma e trovare i punti in cui si verificano gli errori.\n\nUna volta che il software è stato testato e ritenuto pronto, si passa alla fasi di messa a disposizione delle funzionalità agli utenti (in inglese, deployment):\n\nDistribuzione: Rilasciare il software agli utenti finali, che può includere l’installazione su server, la distribuzione di applicazioni desktop o il rilascio di app mobile.\nManutenzione: Continuare a supportare il software dopo il rilascio. Questo include la correzione di bug scoperti dopo il rilascio, l’aggiornamento del software per miglioramenti e nuove funzionalità, e l’adattamento a nuovi requisiti o ambienti.\n\n\nLa complessità del processo induce la necessità di avere dei team con qualità indiivduali diverse e il programmatore, oltre alle competenze specifiche, deve saper interpretare i vari artifatti di disegno e saperli tramutare in algoritmi e codice sorgente.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione",
    "href": "prima-parte-linguaggi-programmazione.html#limpatto-dellintelligenza-artificiale-generativa-sulla-programmazione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.6 L’Impatto dell’intelligenza artificiale generativa sulla programmazione",
    "text": "1.6 L’Impatto dell’intelligenza artificiale generativa sulla programmazione\nCon l’avvento dell’intelligenza artificiale generativa (IA generativa), la programmazione ha subito una trasformazione significativa. Prima dell’IA generativa, i programmatori dovevano tutti scrivere manualmente ogni riga di codice, seguendo rigorosamente la sintassi e le regole del linguaggio di programmazione scelto. Questo processo richiedeva una conoscenza approfondita degli algoritmi, delle strutture dati e delle migliori pratiche di programmazione.\nInoltre, i programmatori dovevano creare ogni funzione, classe e modulo a mano, assicurandosi che ogni dettaglio fosse corretto, identificavano e correggevano gli errori nel codice con un processo lungo e laborioso, che comportava anche la scrittura di casi di test e l’esecuzione di sessioni di esecuzione di tali casi. Infine, dovebano scrivere documentazione dettagliata per spiegare il funzionamento del codice e facilitare la manutenzione futura.\n\n1.6.1 Attività del programmatore con l’IA Generativa\nL’IA generativa ha introdotto nuovi strumenti e metodologie che stanno cambiando il modo in cui i programmatori lavorano:\n\nGenerazione automatica del codice: Gli strumenti di IA generativa possono creare porzioni di codice basate su descrizioni ad alto livello fornite dai programmatori. Questo permette di velocizzare notevolmente lo sviluppo iniziale e ridurre gli errori di sintassi.\nAssistenza nel debugging: L’IA può identificare potenziali bug e suggerire correzioni, rendendo il processo di debugging più efficiente e meno dispendioso in termini di tempo.\nOttimizzazione automatica: Gli algoritmi di IA possono analizzare il codice e suggerire o applicare automaticamente ottimizzazioni per migliorare le prestazioni.\nGenerazione di casi di test: L’IA può creare casi di test per verificare la correttezza del codice, coprendo una gamma più ampia di scenari di quanto un programmatore potrebbe fare manualmente.\nDocumentazione automatica: L’IA può generare documentazione leggendo e interpretando il codice, riducendo il carico di lavoro manuale e garantendo una documentazione coerente e aggiornata.\n\n\n\n1.6.2 L’Importanza di imparare a programmare nell’era dell’IA generativa\nNonostante l’avvento dell’IA generativa, imparare a programmare rimane fondamentale per diverse ragioni. La programmazione non è solo una competenza tecnica, ma anche un modo di pensare e risolvere problemi. Comprendere i fondamenti della programmazione è essenziale per utilizzare efficacemente gli strumenti di IA generativa. Senza una solida base, è difficile sfruttare appieno queste tecnologie. Inoltre, la programmazione insegna a scomporre problemi complessi in parti più gestibili e a trovare soluzioni logiche e sequenziali, una competenza preziosa in molti campi.\nAnche con l’IA generativa, esisteranno sempre situazioni in cui sarà necessario personalizzare o ottimizzare il codice per esigenze specifiche. La conoscenza della programmazione permette di fare queste modifiche con sicurezza. Inoltre, quando qualcosa va storto, è indispensabile sapere come leggere e comprendere il codice per identificare e risolvere i problemi. L’IA può assistere, ma la comprensione umana rimane cruciale per interventi mirati.\nImparare a programmare consente di sperimentare nuove idee e prototipare rapidamente soluzioni innovative. La creatività è potenziata dalla capacità di tradurre idee in codice funzionante. Sapere programmare aiuta anche a comprendere i limiti e le potenzialità degli strumenti di IA generativa, permettendo di usarli in modo più strategico ed efficace.\nLa tecnologia evolve rapidamente, e con una conoscenza della programmazione si è meglio preparati ad adattarsi alle nuove tecnologie e metodologie che emergeranno in futuro. Inoltre, la programmazione è una competenza trasversale applicabile in numerosi settori, dalla biologia computazionale alla finanza, dall’ingegneria all’arte digitale. Avere questa competenza amplia notevolmente le opportunità di carriera.\nInfine, la programmazione è una porta d’accesso a ruoli più avanzati e specializzati nel campo della tecnologia, come l’ingegneria del software, la scienza dei dati e la ricerca sull’IA. Conoscere i principi della programmazione aiuta a comprendere meglio come funzionano gli algoritmi di IA, permettendo di contribuire attivamente allo sviluppo di nuove tecnologie.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html",
    "href": "prima-parte-paradigmi-programmazione.html",
    "title": "2  Paradigmi di programmazione",
    "section": "",
    "text": "2.1 L’importanza dei paradigmi di programmazione\nComprendere i paradigmi di programmazione è fondamentale per diversi motivi:",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#limportanza-dei-paradigmi-di-programmazione",
    "href": "prima-parte-paradigmi-programmazione.html#limportanza-dei-paradigmi-di-programmazione",
    "title": "2  Paradigmi di programmazione",
    "section": "",
    "text": "Approccio alla risoluzione dei problemi: Ogni paradigma offre una visione diversa su come affrontare e risolvere problemi. Conoscere vari paradigmi permette ai programmatori di scegliere l’approccio più adatto in base al problema specifico. Ad esempio, per problemi che richiedono una manipolazione di stati, la programmazione imperativa può essere più intuitiva. Al contrario, per problemi che richiedono trasformazioni di dati senza effetti collaterali, la programmazione funzionale potrebbe essere più adatta.\nVersatilità e adattabilità: I linguaggi moderni che supportano più paradigmi permettono ai programmatori di essere più versatili e adattabili. Possono utilizzare il paradigma più efficiente per diverse parti del progetto, migliorando sia la leggibilità che le prestazioni del codice.\nManutenzione del codice: La comprensione dei paradigmi aiuta nella scrittura di codice più chiaro e manutenibile. Ad esempio, il paradigma orientato agli oggetti può essere utile per organizzare grandi basi di codice in moduli e componenti riutilizzabili, migliorando la gestione del progetto.\nEvoluzione professionale: La conoscenza dei vari paradigmi arricchisce le competenze di un programmatore, rendendolo più competitivo nel mercato del lavoro. Conoscere più paradigmi permette di comprendere e lavorare con una gamma più ampia di linguaggi di programmazione e tecnologie.\nOttimizzazione del codice: Alcuni paradigmi sono più efficienti in determinate situazioni. Ad esempio, la programmazione concorrente è essenziale per lo sviluppo di software che richiede alta prestazione e scalabilità, come nei sistemi distribuiti. Comprendere come implementare la concorrenza in vari paradigmi permette di scrivere codice più efficiente.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-imperativo",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-imperativo",
    "title": "2  Paradigmi di programmazione",
    "section": "2.2 Paradigma imperativo",
    "text": "2.2 Paradigma imperativo\nLa programmazione imperativa, a differenza della programmazione dichiarativa, è un paradigma di programmazione che descrive l’esecuzione di un programma come una serie di istruzioni che cambiano il suo stato. In modo simile al modo imperativo delle lingue naturali, che esprime comandi per compiere azioni, i programmi imperativi sono una sequenza di comandi che il computer deve eseguire in sequenza. Un caso particolare di programmazione imperativa è quella procedurale.\nI linguaggi di programmazione imperativa si contrappongono ad altri tipi di linguaggi, come quelli funzionali e logici. I linguaggi di programmazione funzionale, come Haskell, non producono sequenze di istruzioni e non hanno uno stato globale come i linguaggi imperativi. I linguaggi di programmazione logica, come Prolog, sono caratterizzati dalla definizione di cosa deve essere calcolato, piuttosto che come deve avvenire il calcolo, a differenza di un linguaggio di programmazione imperativo.\nL’implementazione hardware di quasi tutti i computer è imperativa perché è progettata per eseguire il codice macchina, che è scritto in stile imperativo. Da questa prospettiva a basso livello, lo stato del programma è definito dal contenuto della memoria e dalle istruzioni nel linguaggio macchina nativo del processore. Al contrario, i linguaggi imperativi di alto livello sono caratterizzati da un modello dati e istruzioni che risultano più facilmente usabili come strumenti di espressione di passi algoritmici.\n\n2.2.1 Esempio in assembly\nAssembly è una categoria di linguaggi di basso livello, cioè strettamente legati all’hardware del computer, tanto che ogni processore ha il suo dialetto. Un esempio di un semplice programma scritto per l’architettura x86, utilizzando la sintassi dell’assembler NASM (Netwide Assembler), è il seguente che effettua la somma di due numeri e stampa il risultato:\nsection .data\n    num1 db 5           ; Definisce il primo numero\n    num2 db 3           ; Definisce il secondo numero\n    result db 0         ; Variabile per memorizzare il risultato\n    msg db 'Result: ', 0 ; Messaggio di output\n\nsection .bss\n    result_str resb 4   ; Buffer per la stringa del risultato\n\nsection .text\n    global _start\n\n_start:\n    ; Somma num1 e num2\n    mov al, [num1]      ; Carica il primo numero in AL\n    add al, [num2]      ; Aggiunge il secondo numero a AL\n    mov [result], al    ; Memorizza il risultato in result\n\n    ; Converti il risultato in stringa ASCII\n    mov eax, [result]   ; Carica il risultato in EAX\n    add eax, '0'        ; Converti il valore numerico in carattere ASCII\n    mov [result_str], eax ; Memorizza il carattere ASCII in result_str\n\n    ; Stampa il messaggio\n    mov eax, 4          ; syscall numero per sys_write\n    mov ebx, 1          ; file descriptor 1 (stdout)\n    mov ecx, msg        ; puntatore al messaggio\n    mov edx, 8          ; lunghezza del messaggio\n    int 0x80            ; chiamata di sistema\n\n    ; Stampa il risultato\n    mov eax, 4          ; syscall numero per sys_write\n    mov ebx, 1          ; file descriptor 1 (stdout)\n    mov ecx, result_str ; puntatore alla stringa del risultato\n    mov edx, 1          ; lunghezza della stringa del risultato\n    int 0x80            ; chiamata di sistema\n\n    ; Terminazione del programma\n    mov eax, 1          ; codice di sistema per l'uscita\n    xor ebx, ebx        ; codice di ritorno 0\n    int 0x80            ; interruzione per chiamare il kernel\nLe sezioni del codice:\n\nLa sezione .data definisce i dati statici num1, num2, result e msg.\nSezione .bss alloca lo spazio per result_str, che conterrà la stringa del risultato.\nSezione .textdefinisce _start come punto di ingresso del programma e:\n\nImplementa la logica principale del programma.\nSomma i valori di num1 e num2.\nConverte il risultato numerico in una stringa ASCII.\nUtilizza chiamate al sistema operativo per scrivere il messaggio e il risultato su stdout.\nTermina il programma.\n\n\nL’assembly è usato nello sviluppo di:\n\nSistemi operativi, ad esempio il kernel, che ha il controllo del sistema e i driver, cioè i programmi utili alla comunicazione coll’hardware.\nApplicazioni embedded: Microcontrollori di dispositivi medici, sistemi di controllo di veicoli, dispositivi IoT, ecc., cioè)dove è necessaria un’ottimizzazione estrema delle risorse computazionali.\nApplicazioni HPC (high performance computing): Il focus qui è eseguire calcoli intensivi e complessi in tempi relativamente brevi. Queste applicazioni richiedono un numero di operazioni per unità di tempo elevato e sono ottimizzate per sfruttare al massimo le risorse hardware disponibili, come CPU, GPU e memoria.\n\n\n\n2.2.2 Esempio in Python\nAll’altro estremo della immediatezza di comprensione del testo del codice. per un essere umano, troviamo Python, un linguaggio di alto livello noto per la leggibilità ed eleganza.\nEcco il medesimo esempio:\n1num1 = 5\nnum2 = 3\n\n2result = num1 + num2\n\n3print(\"Il risultato è: \", result)\n\n1\n\nDefinizione delle variabili che identificano gli addendi.\n\n2\n\nSomma dei due numeri.\n\n3\n\nStampa del risultato della somma.\n\n\n\n\n2.2.3 Analisi comparativa\nAssembly:\n\nBasso livello di astrazione: Assembly lavora direttamente con i registri della CPU e la memoria, quindi non astrae granché della complessità dell’hardware.\nScarsa versatilità: Il linguaggio è progettato per una ben definita architettura e, quindi, ha una scarsa applicabilità ad altre, anche se alcuni dialetti di assembly presentano delle similitudini.\nElevata precisione: Il programmatore ha un controllo dettagliato su ogni singola operazione compiuta dal processore, perché c’è una corrispondenza col codice macchina.\nComplessità: Ogni operazione deve essere definita esplicitamente e in sequenza, il che rende il codice più lungo e difficile da leggere.\n\nPython:\n\nAlto livello di astrazione: Python fornisce un’astrazione più elevata sia dei dati che delle istruzioni, permettendo di ignorare i dettagli dei diversi hardware.\nElevata semplicità: Il codice è più breve e leggibile, facilitando la comprensione e la manutenzione.\nElevata versatilità: Il linguaggio è applicabile senza modifiche a un elevato numero di architetture hardware-software.\nProduttività: I programmatori possono concentrarsi sulla complessità intrinseca del problema, senza preoccuparsi di molti dettagli implementativi del processo di esecuzione.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-procedurale",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-procedurale",
    "title": "2  Paradigmi di programmazione",
    "section": "2.3 Paradigma procedurale",
    "text": "2.3 Paradigma procedurale\nLa programmazione procedurale è un paradigma di programmazione, derivato da quella imperativa, che organizza il codice in unità chiamate procedure o funzioni. Ogni procedura o funzione è un blocco di codice che può essere richiamato da altre parti del programma, promuovendo la riutilizzabilità e la modularità del codice.\nLa programmazione procedurale è una naturale evoluzione della imperativa e uno dei paradigmi più antichi e ampiamente utilizzati. Ha avuto origine negli anni ’60 e ’70 con linguaggi come Fortan, COBOL e C, tutt’oggi rilevanti. Questi linguaggi hanno introdotto concetti fondamentali come funzioni, sottoprogrammi e la separazione tra codice e dati. Il C, in particolare, ha avuto un impatto duraturo sulla programmazione procedurale, diventando uno standard de facto per lo sviluppo di sistemi operativi e software di sistema.\nI vantaggi principali sono:\n\nModularità: La programmazione procedurale incoraggia la suddivisione del codice in funzioni o procedure più piccole e gestibili. Questo facilita la comprensione, la manutenzione e il riutilizzo del codice.\nRiutilizzabilità: Le funzioni possono essere riutilizzate in diverse parti del programma o in progetti diversi, riducendo la duplicazione del codice e migliorando l’efficienza dello sviluppo.\nStruttura e organizzazione: Il codice procedurale è generalmente più strutturato e organizzato, facilitando la lettura e la gestione del progetto software.\nFacilità di debug e testing: La suddivisione del programma in funzioni isolate rende più facile individuare e correggere errori, oltre a testare parti specifiche del codice.\n\nD’altro canto, presenta anche degli svantaggi che hanno spinto i ricercatori a continuare l’innovazione:\n\nScalabilità limitata: Nei progetti molto grandi, la programmazione procedurale può diventare difficile da gestire. La mancanza di meccanismi di astrazione avanzati, come quelli offerti dalla programmazione orientata agli oggetti, può complicare la gestione della complessità.\nGestione dello stato: La programmazione procedurale si basa spesso su variabili globali per condividere stato tra le funzioni, il che può portare a bug difficili da individuare e risolvere.\nDifficoltà nell’aggiornamento: Le modifiche a una funzione possono richiedere aggiornamenti in tutte le parti del programma che la utilizzano, aumentando il rischio di introdurre nuovi errori.\nMeno Adatta per Applicazioni Moderne: Per applicazioni complesse e moderne che richiedono la gestione di eventi, interfacce utente complesse e modellazione del dominio, la programmazione procedurale può essere meno efficace rispetto ad altri paradigmi come quello orientato agli oggetti.\n\n\n2.3.1 Funzioni e procedure\nNella programmazione procedurale, il codice è suddiviso in unità elementari chiamate funzioni e procedure. La differenza principale tra le due è la seguente:\n\nFunzione: Una funzione è un blocco di codice che esegue un compito specifico e restituisce un valore. Le funzioni sono utilizzate per calcoli o operazioni che producono un risultato. Ad esempio, una funzione che calcola la somma di due numeri in linguaggio C:\nint somma(int a, int b) {\n    return a + b;\n}\nProcedura: Una procedura è simile a una funzione, ma non restituisce un valore. È utilizzata per eseguire azioni o operazioni che non necessitano di un risultato. Ad esempio, una procedura che stampa un messaggio in Pascal:\nprocedure stampaMessaggio;\nbegin\n    writeln('Ciao, Mondo!');\nend;\n\n\n\n2.3.2 Creazione di librerie\nUn altro aspetto importante della programmazione procedurale è la possibilità di creare librerie, che sono collezioni di funzioni e procedure riutilizzabili. Le librerie permettono di organizzare e condividere codice comune tra diversi progetti, aumentando la produttività e riducendo la duplicazione del codice.\nEsempio di una semplice libreria ipotetica di somme in C:\n\nFile header (mialibreria.h):\n#ifndef MIALIBRERIA_H\n#define MIALIBRERIA_H\n\nint somma_interi(int a, int b);\n\nchar* somma_stringhe(const char* a, const char* b);\n\nint somma_array(int arr[], int n);\n\nvoid stampa_messaggio(const char* messaggio);\n\n#endif\nFile di implementazione (mialibreria.c):\n#include \"mialibreria.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint somma_interi(int a, int b) {\n    return a + b;\n}\n\nchar* somma_stringhe(const char* a, const char* b) {\n1    char* risultato = malloc(strlen(a) + strlen(b) + 1);\n\n2    if (risultato) {\n3        strcpy(risultato, a);\n4        strcat(risultato, b);\n    }\n\n    return risultato;\n}\n\nint somma_array(int arr[], int n) {\n    int somma = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        somma += arr[i];\n    }\n\n    return somma;\n}\n\nvoid stampa_messaggio(const char* messaggio) {\n    printf(\"%s\\n\", messaggio);\n}\n\n1\n\nAllocazione della memoria e +1 per il carattere di terminazione ‘\\0’.\n\n2\n\nIl controllo è presente per verificare se la funzione malloc ha avuto successo nell’allocare la memoria richiesta. Se risultato è NULL, significa che malloc ha fallito e il blocco di codice all’interno dell’if viene saltato, evitando così di tentare di accedere a memoria non valida.\n\n3\n\nSe l’allocazione ha avuto successo, copia la prima stringa nel risultato.\n\n4\n\nIdem per la seconda.\n\n\nFile principale (main.c):\n#include \"mialibreria.h\"\n#include &lt;stdio.h&gt;\n\nint main() {\n1    int risultato = somma_interi(5, 3);\n\n    stampa_messaggio(\"Il risultato della somma di interi è:\");\n    printf(\"%d\\n\", risultato);\n\n2    char* risultato_stringhe = somma_stringhe(\"Ciao, \", \"mondo!\");\n\n    stampa_messaggio(\"Il risultato della somma di stringhe è:\");\n    printf(\"%s\\n\", risultato_stringhe);\n3    free(risultato_stringhe);\n\n4    int array[] = {1, 2, 3, 4, 5};\n    int risultato_array = somma_array(array, 5);\n\n    stampa_messaggio(\"Il risultato della somma dell'array è:\");\n    printf(\"%d\\n\", risultato_array);\n\n    return 0;\n}\n\n1\n\nChiamata della funzione di somma di due interi.\n\n2\n\nChiamata delal funzione di somma di due stringhe (implementato come una concatenazione).\n\n3\n\nLibera la memoria allocata.\n\n4\n\nSomma di un array di interi.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-di-orientamento-agli-oggetti",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-di-orientamento-agli-oggetti",
    "title": "2  Paradigmi di programmazione",
    "section": "2.4 Paradigma di orientamento agli oggetti",
    "text": "2.4 Paradigma di orientamento agli oggetti\nLa programmazione orientata agli oggetti (in inglese object-oriented programming, OOP) è un paradigma di programmazione che organizza il software in termini di oggetti, ciascuno dei quali rappresenta un’istanza di una matrice detta classe. Una classe definisce un tipo di dato che include attributi (dati) e metodi (funzionalità). Gli oggetti interagiscono tra loro attraverso messaggi, permettendo una struttura modulare e intuitiva.\nL’OOP è emersa negli anni ’60 e ’70 con il linguaggio Simula, il primo linguaggio di programmazione a supportare questo paradigma. Tuttavia, è stato con Smalltalk, sviluppato negli anni ’70 da Alan Kay e altri presso Xerox PARC, che l’OOP ha guadagnato popolarità. Il paradigma è stato ulteriormente consolidato con il linguaggio C++ negli anni ’80 e con Java negli anni ’90, rendendolo uno dei più utilizzati per lo sviluppo software moderno. Oggi numerosi sono i linguaggi a oggetti, ad esempio Python, C#, Ruby, Swift, Javascript, ecc. ed altri lo supportano come PHP (dalla versione 5) e financo il Fortran nella versione 2003.\nRispetto ai paradigmi precedenti, l’OOP introduce diversi concetti chiave che ineriscono al disegno architetturale di software:\n\nClasse e oggetto: La classe è un modello o schema per creare oggetti. Contiene definizioni di attributi e metodi. L’oggetto è un’istanza di una classe e rappresenta un’entità concreta nel programma con stato e comportamento mutevoli.\nIncapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie agli altri oggetti. Migliora la modularità e protegge l’integrità dei dati.\nEreditarietà: Permette a una classe di estenderne un’altra, ereditandone attributi e metodi. Favorisce il riuso del codice e facilita l’estensione delle funzionalità.\nPolimorfismo: Consente a oggetti di classi diverse di essere trattati come oggetti di una classe comune. Facilita l’uso di un’interfaccia uniforme per operazioni diverse.\nAstrazione: Permette di definire interfacce di alto livello per oggetti, senza esporre i dettagli implementativi. Facilita la comprensione e la gestione della complessità del sistema.\n\nI vantaggi principali dell’OOP sono:\n\nModularità: Le classi e gli oggetti favoriscono la suddivisione del codice in moduli indipendenti, migliorando la manutenibilità e la riusabilità del software.\nRiutilizzabilità: L’uso di classi e l’ereditarietà consentono di riutilizzare il codice in nuovi progetti senza riscriverlo.\nFacilità di manutenzione: L’incapsulamento e l’astrazione riducono la complessità e facilitano la manutenzione del codice.\nEstendibilità: Le classi possono essere estese per aggiungere nuove funzionalità senza modificare il codice esistente.\nAffidabilità: Il polimorfismo e l’ereditarietà migliorano l’affidabilità del codice, poiché le modifiche possono essere fatte in una classe base e propagate alle classi derivate.\n\nAnche se sussistono dei caveat:\n\nComplessità iniziale: L’OOP può essere complesso da apprendere e implementare correttamente per i nuovi programmatori.\nOverhead di prestazioni: L’uso intensivo di oggetti può introdurre un overhead di memoria e prestazioni rispetto alla programmazione procedurale.\nAbuso di ereditarietà: L’uso improprio dell’ereditarietà può portare a gerarchie di classi troppo complesse e difficili da gestire.\n\n\n2.4.1 Esempio in Java\nIn questo esempio, la classe Animale rappresenta una tipo di dato generico con un attributo nome e un metodo faiVerso. La classe Cane specializza Animale, usando l’attributo nome e sovrascrivendo il metodo faiVerso, per fornire un’implementazione coerente colle sue caratteristiche. La classe Main crea un’istanza di Cane e chiama il suo metodo faiVerso (annotato con @Override1), dimostrando il polimorfismo e l’ereditarietà:\n1 In Java, l’annotazione @Override è opzionale, ma altamente consigliata. Non omettere l’annotazione @Override non causerà un errore di compilazione o di runtime. Tuttavia, l’uso di @Override offre dei vantaggi importanti: 1. Verifica del compilatore: Il compilatore verifica che il metodo stia effettivamente sovrascrivendo un metodo nella superclasse. Se il metodo nella superclasse viene rinominato o rimosso, il compilatore segnalerà un errore. 2. Migliora la leggibilità del codice: Indica chiaramente al lettore del codice che il metodo è inteso per sovrascrivere un metodo nella superclasse.1class Animale {\n    String nome;\n\n    Animale(String nome) {\n        this.nome = nome;\n    }\n\n    void faiVerso() {\n        System.out.println(\"L'animale fa un verso\");\n    }\n}\n\n2class Cane extends Animale {\n\n    Cane(String nome) {\n        super(nome);\n    }\n\n3    @Override\n    void faiVerso() {\n        System.out.println(\"Il cane abbaia\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animale mioCane = new Cane(\"Fido\");\n\n4        mioCane.faiVerso();\n    }\n}\n\n1\n\nDefinizione della classe Animale che ha il doppio compito di provvedere all’implementazione per una caratteristica comune (nome e descrizione()) e una particolare (faiVerso()).\n\n2\n\nDefinizione della classe derivata Cane.\n\n3\n\n@Override indica in esplicito che il faiVerso() del Cane sovrascrive (non eredita) il faiVerso() di Animale.\n\n4\n\nOutput: Il cane abbaia.\n\n\nIn realtà, se gli oggetti devono rappresentare animali reali vorrà dire che non deve essere possibile crearne dalla matrice Animale. Vediamo, quindi, come implementare il medesimo esempio con una classe astratta, cioè una classe che non può essere usata per generare direttamente oggetti, sempre in Java.\nNel caso pratico, ogni animale ha il suo verso, quindi dobbiamo costringere il programmatore che vuole implementare classi corrispondenti ad animali reali, ad aggiungere tassativamente il metodo faiVerso() per comunicarne la caratteristica distintiva. Una modalità è marchiare Animale e il suo metodo da caratterizzare (faiVerso()), con costrutti ad hoc perché siano, rispettivamente, identificata come classe astratta (per mezzo della parola riservata abstract) e metodo da implementare. Al contempo, Cane non subisce specifiche modifiche sintattiche, ma deve rispettare il vincolo (implementare faiVerso()) perché, ereditando le caratteristiche di Animale, possa essere una classe concreta, cioè da cui si possono creare oggetti. Il codice risultate è:\n1abstract class Animale {\n    String nome;\n\n    Animale(String nome) {\n        this.nome = nome;\n    }\n\n2    abstract String faiVerso();\n\n3    String descrizione() {\n        return \"L'animale si chiama \" + nome;\n    }\n}\n\n4class Cane extends Animale {\n\n    Cane(String nome) {\n        super(nome);\n    }\n\n    @Override\n    String faiVerso() {\n        return \"Il cane abbaia\";\n    }\n}\n\n5class Coccodrillo extends Animale {\n\n    Coccodrillo(String nome) {\n        super(nome);\n    }\n\n    @Override\n6    String faiVerso() {\n        return \"\";  \n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animale mioCane = new Cane(\"Fido\");\n\n7        System.out.println(mioCane.descrizione());\n8        System.out.println(mioCane.faiVerso());\n\n        Animale mioCoccodrillo = new Coccodrillo(\"Crocky\");\n\n9        System.out.println(mioCoccodrillo.descrizione());\n10        System.out.println(mioCoccodrillo.faiVerso());\n    }\n}\n\n1\n\nDefinizione della classe astratta che ha il doppio compito di fornire una implementazione di default per una caratteristica comune (nome) e un vincolo di implementazione nelle classe derivate per una seconda caratteristica comune non implementabile nello stesso modo per tutte (faiVerso()).\n\n2\n\nMetodo astratto faiVerso() che le classi corrispondenti ad animali reali dovranno implementare e che dovrà resituire una stringa.\n\n3\n\nMetodo concreto faiVerso() che restituisce una stringa.\n\n4\n\nDefinizione della classe derivata Cane.\n\n5\n\nDefinizione della classe derivata Coccodrillo.\n\n6\n\nIl coccodrillo non emette versi!\n\n7\n\nStampa: L'animale si chiama Fido.\n\n8\n\nStampa: Il cane abbaia.\n\n9\n\nStampa: L'animale si chiama Crocky.\n\n10\n\nNon stampa nulla perché il coccodrillo non emette versi!\n\n\n\n\n2.4.2 Template\nI template, o generics, non sono specifici dell’OOP, anche se sono spesso associati a essa. I template permettono di scrivere funzioni, classi, e altri costrutti di codice in modo generico, cioè indipendente dal tipo dei dati che manipolano. Questo concetto è particolarmente utile per creare librerie e moduli riutilizzabili e flessibili.\nAd esempio, definiamo la classe Box nel modo seguente:\ntemplate &lt;typename T&gt;\nclass Box {\n    T value;\n\npublic:\n    void setValue(T val) { value = val; }\n\n    T getValue() { return value; }\n};\nEssa può contenere un valore di qualsiasi tipo specificato al momento della creazione dell’istanza per mezzo del template T:\n1Box&lt;int&gt; intBox;\n\nintBox.setValue(123);\nint x = intBox.getValue();\n\n2Box&lt;std::string&gt; stringBox;\n\nstringBox.setValue(\"Hello, World!\");\nstd::string str = stringBox.getValue();\n\n1\n\nBox contiene un intero.\n\n2\n\nBox contiene una stringa.\n\n\nAnche nei linguaggi non orientati agli oggetti, i template trovano applicazione. Ad esempio, in Rust, un linguaggio di programmazione sistemistica non puramente OOP, il codice seguente restituisce il valore più grande di una lista:\nfn largest&lt;T: PartialOrd&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let numbers = vec![34, 50, 25, 100, 65];\n    let max = largest(&numbers);\n\n    println!(\"The largest number is {}\", max);\n}\n\n\n2.4.3 Metaprogrammazione\nLa metaprogrammazione è un paradigma che consente al programma di trattare il codice come dati, permettendo al codice di generare, manipolare o eseguire altro codice. Anche questo concetto non è esclusivo dell’OOP. In C++, la metaprogrammazione è strettamente legata ai template. Un esempio classico è la template metaprogramming (TMP), che permette di eseguire calcoli a tempo di compilazione.\nUn esempio è il codice seguente di calcolo del fattoriale:\ntemplate&lt;int N&gt;\nstruct Factorial {\n1    static const int value = N * Factorial&lt;N - 1&gt;::value;\n};\n\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt; {\n2    static const int value = 1;\n};\n\n1\n\nQuesta riga definisce un membro statico value della struttura Factorial. Per un dato N, il valore viene calcolato come N moltiplicato per il valore del fattoriale di N - 1. Questo è un esempio di ricorsione a livello di metaprogrammazione template.\n\n2\n\nQuesta riga è una specializzazione del template Factorial per il caso base quando N è 0. In questo caso, value è definito come 1, terminando la ricorsione template.\n\n\nLa metaprogrammazione è presente anche in linguaggi non OOP come Lisp, che utilizza le macro per trasformare e generare codice. Un esempio è il codice proposto di seguito dove è definita la macro when, che prende due parametri in input, cioè test e body, ove test è un’espressione condizionale e body un insieme di istruzioni da eeseguire se la condizione è vera:\n(defmacro when (test &rest body)\n  `(if ,test\n       (progn ,@body)))\nVediamo un esempio pratico di come si utilizza la macro when. Il test è valutare se x è maggiore di 10 e, nel caso, stampare \"x is greater than 10\" e poi assegnare x a 0. Chiamiamo la macro con i due parametri:\n(when (&gt; x 10)\n  (print \"x is greater than 10\")\n  (setf x 0))\nQuesto viene espanso in:\n(if (&gt; x 10)\n    (progn\n      (print \"x is greater than 10\")\n      (setf x 0)))",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-dichiarativo",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-dichiarativo",
    "title": "2  Paradigmi di programmazione",
    "section": "2.5 Paradigma dichiarativo",
    "text": "2.5 Paradigma dichiarativo\nLa programmazione dichiarativa è un paradigma di programmazione che si focalizza sul cosa deve essere calcolato piuttosto che sul come calcolarlo. In altre parole, i programmi dichiarativi descrivono il risultato desiderato senza specificare esplicitamente i passaggi per ottenerlo. Questo è in netto contrasto con la programmazione imperativa, dove si fornisce una sequenza dettagliata di istruzioni per modificare lo stato del programma.\nLa programmazione dichiarativa ha radici nella logica e nella matematica, ed è emersa come un importante paradigma negli anni ’70 e ’80 con l’avvento di linguaggi come Prolog (per la programmazione logica) e SQL (per la gestione dei database). La programmazione funzionale, con linguaggi come Haskell, è anch’essa una forma di programmazione dichiarativa.\nI concetti principali associati alla programazione dichiarativa sono:\n\nDescrizione del risultato: I programmi dichiarativi descrivono le proprietà del risultato desiderato senza specificare l’algoritmo per ottenerlo. Esempio: In SQL, per ottenere tutti i record di una tabella con un certo valore, si scrive una query che descrive la condizione, non un algoritmo che scorre i record uno per uno.\nAssenza di stato esplicito: La programmazione dichiarativa evita l’uso esplicito di variabili di stato e di aggiornamenti di stato. Ciò riduce i rischi di effetti collaterali e rende il codice più facile da comprendere e verificare.\nIdempotenza: Le espressioni dichiarative sono spesso idempotenti, cioè possono essere eseguite più volte senza cambiare il risultato. Questo è particolarmente utile per la concorrenza e la parallelizzazione.\n\nIl vantaggio principale è relativo alla sua chiarezza perché ci si concentra sul risultato desiderato piuttosto che sui dettagli di implementazione.\nLa programmazione imperativa specifica come ottenere un risultato mediante una sequenza di istruzioni, modificando lo stato del programma. La programmazione dichiarativa, al contrario, specifica cosa deve essere ottenuto senza descrivere i dettagli di implementazione. In termini di livello di astrazione, la programmazione dichiarativa si trova a un livello superiore rispetto a quella imperativa.\n\n2.5.1 Linguaggi\nEcco una lista di alcuni linguaggi di programmazione dichiarativi:\n\nSQL (Structured Query Language): Utilizzato per la gestione e l’interrogazione di database relazionali.\nProlog: Un linguaggio di programmazione logica usato principalmente per applicazioni di intelligenza artificiale e linguistica computazionale.\nHTML (HyperText Markup Language): Utilizzato per creare e strutturare pagine web.\nCSS (Cascading Style Sheets): Utilizzato per descrivere la presentazione delle pagine web scritte in HTML o XML.\nXSLT (Extensible Stylesheet Language Transformations): Un linguaggio per trasformare documenti XML in altri formati.\nHaskell: Un linguaggio funzionale che è anche dichiarativo, noto per la sua pura implementazione della programmazione funzionale.\nErlang: Un linguaggio utilizzato per sistemi concorrenti e distribuiti, con caratteristiche dichiarative.\nVHDL (VHSIC Hardware Description Language): Utilizzato per descrivere il comportamento e la struttura di sistemi digitali.\nVerilog: Un altro linguaggio di descrizione hardware usato per la modellazione di sistemi elettronici.\nXQuery: Un linguaggio di query per interrogare documenti XML.\n\nQuesti linguaggi rappresentano diversi ambiti di applicazione, dai database alla descrizione hardware, e sono accomunati dall’approccio dichiarativo nel quale si specifica cosa ottenere piuttosto che come ottenerlo.\n\n\n\n\n\n\nNota\n\n\n\nSQL è uno degli esempi più diffusi di linguaggio di programmazione dichiarativo. Le query SQL descrivono i risultati desiderati piuttosto che le procedure operative.\nUna stored procedure in PL/SQL (Procedural Language/SQL) combina SQL con elementi di linguaggi di programmazione procedurali come blocchi di codice, condizioni e cicli. PL/SQL è quindi un linguaggio procedurale, poiché consente di specificare “come” ottenere i risultati attraverso un flusso di controllo esplicito, rendendolo non puramente dichiarativo. PL/SQL è utilizzato principalmente con il database Oracle.\nUn’alternativa a PL/SQL è T-SQL (Transact-SQL), utilizzato con Microsoft SQL Server e Sybase ASE. Anche T-SQL estende SQL con funzionalità procedurali simili, consentendo la scrittura di istruzioni condizionali, cicli e la gestione delle transazioni. Come PL/SQL, T-SQL è un linguaggio procedurale e non puramente dichiarativo.\nEsistono anche estensioni ad oggetti come il PL/pgSQL (Procedural Language/PostgreSQL) per il database PostgreSQL.\n\n\n\n\n2.5.2 Esempi\nEsempio di una query SQL che estrae tutti i nomi degli utenti con età maggiore di 30:\nCertamente! Ecco il codice SQL con i commenti identificati da un ID progressivo e l’elenco esplicativo:\n1SELECT nome\n2FROM utenti\n3WHERE età &gt; 30;\n\n1\n\nSeleziona la colonna nome.\n\n2\n\nDalla tabella utenti.\n\n3\n\nPer le righe dove la colonna età è maggiore di 30.\n\n\nIn Prolog, si definiscono fatti e regole che descrivono relazioni logiche. Il motore di inferenza di Prolog utilizza queste definizioni per risolvere query, senza richiedere un algoritmo dettagliato. Di seguito, sono definiti due fatti (le prime due righe) e due regole (la terza e la quarta) e quindi si effettua una query che dà come risultato true:\ngenitore(padre, figlio).\ngenitore(madre, figlio).\nantenato(X, Y) :- genitore(X, Y).\nantenato(X, Y) :- genitore(X, Z), antenato(Z, Y).\n\n?- antenato(padre, figlio).",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-funzionale",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-funzionale",
    "title": "2  Paradigmi di programmazione",
    "section": "2.6 Paradigma funzionale",
    "text": "2.6 Paradigma funzionale\nLa programmazione funzionale è un paradigma di programmazione che tratta il calcolo come la valutazione di funzioni matematiche ed evita lo stato mutabile e i dati modificabili. I programmi funzionali sono costruiti applicando e componendo funzioni. Questo paradigma è stato ispirato dal calcolo lambda, una formalizzazione matematica del concetto di funzione. La programmazione funzionale è un paradigma alternativo alla programmazione imperativa, che descrive la computazione come una sequenza di istruzioni che modificano lo stato del programma.\nLa programmazione funzionale ha radici storiche che risalgono agli anni ’30, con il lavoro di Alonzo Church sul calcolo lambda. I linguaggi di programmazione funzionale hanno iniziato a svilupparsi negli anni ’50 e ’60 con Lisp, ma è stato negli anni ’70 e ’80 che linguaggi come ML e Haskell hanno consolidato questo paradigma. Haskell, in particolare, è stato progettato per esplorare nuove idee in programmazione funzionale e ha avuto un impatto significativo sulla ricerca e sulla pratica del software.\nLa programmazione funzionale è una forma di programmazione dichiarativa che si basa su funzioni pure e immutabilità. Entrambi i paradigmi evitano stati mutabili e si concentrano sul risultato finale, ma la programmazione funzionale utilizza funzioni matematiche come unità fondamentali di calcolo.\nConcetti fondamentali:\n\nImmutabilità: I dati sono immutabili, il che significa che una volta creati non possono essere modificati. Questo riduce il rischio di effetti collaterali e rende il codice più prevedibile.\nFunzioni di prima classe e di ordine superiore: Le funzioni possono essere passate come argomenti a altre funzioni, ritornate da funzioni, e assegnate a variabili. Le funzioni di ordine superiore accettano altre funzioni come argomenti o restituiscono funzioni.\nPurezza: Le funzioni pure sono funzioni che, dato lo stesso input, restituiscono sempre lo stesso output e non causano effetti collaterali. Questo rende il comportamento del programma più facile da comprendere e prevedere.\nTrasparenza referenziale: Un’espressione è trasparentemente referenziale se può essere sostituita dal suo valore senza cambiare il comportamento del programma. Questo facilita l’ottimizzazione e il reasonig sul codice.\nRicorsione: È spesso utilizzata al posto di loop iterativi per eseguire ripetizioni, poiché si adatta meglio alla natura immutabile dei dati e alla definizione di funzioni.\nComposizione di funzioni: Consente di costruire funzioni complesse combinando funzioni più semplici. Questo favorisce la modularità e la riusabilità del codice.\n\nIl paradigma funzionale ha diversi vantaggi:\n\nPrevedibilità e facilità di test: Le funzioni pure e l’immutabilità rendono il codice più prevedibile e più facile da testare, poiché non ci sono stati mutabili o effetti collaterali nascosti.\nConcorrenza: La programmazione funzionale è ben adatta alla programmazione concorrente e parallela, poiché l’assenza di stato mutabile riduce i problemi di sincronizzazione e competizione per le risorse.\nModularità e riutilizzabilità: La composizione di funzioni e la trasparenza referenziale facilitano la creazione di codice modulare e riutilizzabile.\n\nE qualche svantaggio:\n\nCurva di apprendimento: La programmazione funzionale può essere difficile da apprendere per chi proviene da paradigmi imperativi o orientati agli oggetti, a causa dei concetti matematici sottostanti e della diversa mentalità necessaria.\nPrestazioni: In alcuni casi, l’uso intensivo di funzioni ricorsive può portare a problemi di prestazioni, come il consumo di memoria per le chiamate ricorsive. Tuttavia, molte implementazioni moderne offrono ottimizzazioni come la ricorsione di coda (in inglese, tail recursion).\nDisponibilità di librerie e strumenti: Alcuni linguaggi funzionali potrebbero non avere la stessa ampiezza di librerie e strumenti disponibili rispetto ai linguaggi imperativi più diffusi.\n\n\n2.6.1 Esempio in Haskell\nDi seguito due funzioni, la prima sumToN è pura e somma i primi n numeri. (*2) è una funzione che prende un argomento e lo moltiplica per 2 e ciò rende la seconda funzione applyFunction una vera funzione di ordine superiore, poiché accetta (*2) come argomento oltre ad una lista, producendo come risultato il raddoppio di tutti i suoi elementi:\nCertamente! Ecco il codice con i commenti identificati da un ID progressivo e l’elenco esplicativo che include le descrizioni:\nsumToN :: Integer -&gt; Integer\n1sumToN n = sum [1..n]\n\napplyFunction :: (a -&gt; b) -&gt; [a] -&gt; [b]\n2applyFunction f lst = map f lst\n\nmain = do\n3    print (sumToN 10)\n4    print (applyFunction (*2) [1, 2, 3, 4])\n\n1\n\nDefinizione di una funzione pura che calcola la somma dei numeri da 1 a n.\n\n2\n\nFunzione di ordine superiore che accetta una funzione e una lista.\n\n3\n\nNel main, stampa il risultato di sumToN 10, che è 55.\n\n4\n\nNel main, stampa il risultato di applyFunction (*2) [1, 2, 3, 4], che è [2, 4, 6, 8].\n\n\n\n\n2.6.2 Linguaggi\nOltre a Haskell, ci sono molti altri linguaggi funzionali, tra cui:\n\nErlang: Utilizzato per sistemi concorrenti e distribuiti.\nElixir: Costruito a partire da Erlang, è utilizzato per applicazioni web scalabili.\nF#: Parte della piattaforma .NET, combina la programmazione funzionale con lo OOP.\nScala: Anch’esso combina programmazione funzionale e orientata agli oggetti ed è interoperabile con Java.\nOCaml: Conosciuto per le sue prestazioni e sintassi espressiva.\nLisp: Uno dei linguaggi più antichi, multi-paradigma con forti influenze funzionali.\nClojure: Dialetto di Lisp per la JVM, adatto alla concorrenza.\nScheme: Dialetto di Lisp spesso usato nell’educazione.\nML: Linguaggio influente che ha portato allo sviluppo di OCaml e F#.\nRacket: Derivato da Scheme, usato nella ricerca accademica.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi-semantica.html",
    "href": "prima-parte-sintassi-semantica.html",
    "title": "3  Sintassi e semantica dei linguaggi di programmazione",
    "section": "",
    "text": "3.1 Sintassi\nLa sintassi di un linguaggio di programmazione è l’insieme di regole che definiscono come devono essere scritte le istruzioni, cioè le unità logiche di esecuzione del programma. È come la grammatica in una lingua naturale e stabilisce quali combinazioni di simboli sono considerate costrutti validi nel linguaggio.\nPartiamo dagli elementi atomici della sintassi, detti token, per poi risalire fino al programma:\nUn lessema è una sequenza di caratteri nel programma sorgente che corrisponde al pattern di un token ed è identificata dall’analizzatore lessicale come un’istanza di quel token. Un token è una coppia composta da un nome di token e un valore attributo opzionale. Il nome del token è un simbolo astratto che rappresenta un tipo di unità lessicale, come una particolare parola chiave o una sequenza di caratteri di input che denota un identificatore. Un pattern è una descrizione della forma che possono assumere i lessemi di un token. Ad esempio, nel caso di una parola chiave come token, il pattern è semplicemente la sequenza di caratteri che forma la parola chiave. Per gli identificatori e altri token, il pattern è una struttura più complessa che corrisponde a molte stringhe.\nUn esempio per visualizzare i concetti introdotti:",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi e semantica dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi-semantica.html#sintassi",
    "href": "prima-parte-sintassi-semantica.html#sintassi",
    "title": "3  Sintassi e semantica dei linguaggi di programmazione",
    "section": "",
    "text": "Parole chiave: Sono termini riservati del linguaggio che hanno significati specifici e non possono essere utilizzati per altri scopi, come if, else, while, for, ecc.\nOperatori: Simboli utilizzati per eseguire operazioni su identificatori e letterali, come +, -, *, /, =, ==, ecc.\nDelimitatori: Caratteri utilizzati per separare elementi del codice, come punto e virgola (;), parentesi tonde (()), parentesi quadre ([]), parentesi graffe ({}), ecc.\nIdentificatori: Nomi utilizzati per identificare variabili, funzioni, classi, e altri oggetti.\nLetterali: Rappresentazioni di valori costanti nel codice, come numeri (123), stringhe (\"hello\"), caratteri ('a'), ecc.\nCommento: Non fanno parte della logica del programma e sono ignorati nell’esecuzione.\nSpazi e tabulazioni: Sono gruppi di caratteri non visualizzabili spesso ignorati.\n\n\n\nif x == 10:\n\nToken coinvolti:\n\nif: Parola chiave.\nNAME: Identificatore.\nEQEQUAL: Operatore.\nNUMBER: Letterale numerico.\nCOLON: Delimitatore.\n\nLessemi:\n\nIl lessema per il token if è la sequenza di caratteri “if”.\nIl lessema per il token NAME è “x”.\nIl lessema per il token EQEQUAL è “==”.\nIl lessema per il token NUMBER “10”.\nIl lessema per il token COLON “:”.\n\nPattern:\n\nIl pattern per il token if è la stringa esatta “if”.\nIl pattern per un identificatore è una sequenza di lettere e numeri che inizia con una lettera.\nIl pattern per l’operatore == è la stringa esatta “==”.\nIl pattern per un letterale numerico è una sequenza di cifre.\nIl pattern per il delimitatore : è la stringa esatta “:”.\n\n\n\n3.1.1 Analizzatore lessicale e parser\nL’analizzatore lessicale (o lexer) è un componente del compilatore o interprete che prende in input il codice sorgente del programma e lo divide in lessemi. Esso confronta ciascun lessema con i pattern definiti per il linguaggio di programmazione e genera una sequenza di token. Questi token sono poi passati al parser.\nIl parser è un altro componente del compilatore o interprete che prende in input la sequenza di token generata dall’analizzatore lessicale e verifica che la sequenza rispetti le regole sintattiche del linguaggio di programmazione. Il parser analizza i token per formare una struttura gerarchica che rappresenti le relazioni grammaticali tra di essi. Questa struttura interna è spesso un albero di sintassi (parse tree o syntax tree), che riflette la struttura grammaticale del codice sorgente, solitamente descritta usando una forma standard di notazione come la BNF (Backus-Naur Form) o varianti di essa.1 L’albero di sintassi viene utilizzato per ulteriori fasi di compilazione o interpretazione, come l’analisi semantica e la generazione del codice. Ad esempio, il parser può verificare che le espressioni aritmetiche siano ben formate, che le istruzioni siano correttamente annidate e che le dichiarazioni di variabili siano valide.\n1 La BNF (Backus-Naur form o Backus normal form) è una metasintassi, ovvero un formalismo attraverso cui è possibile descrivere la sintassi di linguaggi formali (il prefisso meta ha proprio a che vedere con la natura circolare di questa definizione). Si tratta di uno strumento molto usato per descrivere in modo preciso e non ambiguo la sintassi dei linguaggi di programmazione, dei protocolli di rete e così via, benché non manchino in letteratura esempi di sue applicazioni a contesti anche non informatici e addirittura non tecnologici. Un esempio è la grammatica di Python\n\n3.1.2 Espressioni\nUn’espressione è una combinazione di lessemi che viene valutata per produrre un risultato.\nEsempi di espressioni includono:\n\n5 + 3.\nx * 2.\ny / 4.0.\nmax(a, b).\n\"Hello, \" + \"world!\".\n\n\n\n3.1.3 Istruzioni semplici\nLe istruzioni semplici sono operazioni atomiche secondo il linguaggio e sono costituite da lessemi ed espressioni per compiere operazioni di base. Gli esempi principali includono:\n\nAssegnazione: Utilizza un operatore di assegnazione (ad esempio, =) per attribuire un valore a una variabile, che possiamo pensare come un nome simbolico rappresentante una posizione dove è memorizzato un valore. Esempio:\nx = 5\n\nx: Identificatore della variabile.\n=: Operatore di assegnazione.\n5: Letterale numerico intero.\n\nInput/output: Utilizza parole chiave o funzioni di libreria per leggere valori dall’input o scrivere valori all’output. Esempio:\nprint(\"Hello, World!\")\n\nprint: Parola chiave o identificatore di funzione di libreria.\n\"Hello, World!\": Letterale stringa. L’esecuzione dell’istruzione produce \"Hello, World!\" in output.\n\nAssegnazione ad espressione: Combinazione di variabili, operatori e valori che producono un risultato assegnato ad una variabile. Esempio:\nz = (x * 2) + (y / 2)\n\nz: Identificatore della variabile.\n=: Operatore di assegnazione.\n(x * 2): Espressione che moltiplica x per 2.\n(y / 2): Espressione che divide y per 2.\n+: Operatore aritmetico che somma i risultati delle due espressioni in una più complessa. L’esecuzione dell’istruzione produce un risultato valido solo se x e y sono associate a valori numerici e ciò perché non tutte le istruzioni sintatticamente corrette sono semanticamente corrette. D’altronde ciò non deve essere preso come regola, perché se * fosse un operatore che ripete quanto a sinistra un numero di volte definito dal valore di destra e / la divisione del valore di sinistra in parti di numero pari a quanto a destra, allora x e y potrebbero essere stringhe.\n\n\n\n\n3.1.4 Istruzioni complesse e blocchi di codice\nLe istruzioni complesse sono costituite da più istruzioni semplici e possono includere strutture di controllo del flusso, come condizioni (if), cicli (for, while) ed eccezioni (try, catch). Queste istruzioni sono utilizzate per organizzare il flusso di esecuzione del programma e possono contenere altre istruzioni semplici o complesse al loro interno.\nUn blocco di codice è una sezione del codice che raggruppa una serie di istruzioni che devono essere eseguite insieme. I blocchi di codice sono spesso utilizzati all’interno delle istruzioni complesse per delimitare il gruppo di istruzioni che devono essere eseguite in determinate condizioni o iterazioni.\nIn molti linguaggi di programmazione, i blocchi di codice sono delimitati da parentesi graffe ({}), mentre in altri linguaggi, come Python, l’indentazione è utilizzata per indicare l’inizio e la fine di un blocco di codice.\nAlcuni esempi di istruzione e blocco di codice:\n\nEsempio in C:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n\n  y = x * 2;\n}\nIn questo esempio:\n\nif (x &gt; 0) è un’istruzione complessa.\n{ printf(\"x è positivo\\n\"); y = x * 2; } è un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\nEsempio in Python:\nif x &gt; 0:\n  print(\"x è positivo\")\n\n  y = x * 2\nIn questo esempio:\n\nif x &gt; 0: è un’istruzione complessa.\nLe righe indentate sotto l’istruzione if (print(\"x è positivo\") e y = x * 2) costituiscono un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\n\nAltri esempi:\n\nCondizioni: Istruzioni che eseguono un blocco di codice solo se una condizione è vera. Esempio:\n#include &lt;stdio.h&gt;\n\nx = 42;\n\nif (x &gt; 0) {\n    printf(\"x è positivo\\n\");\n}\n\nif: Parola chiave che introduce la condizione.\n(x &gt; 0): Condizione composta da: x identificatore di variabile, &gt; operatore di confronto e 0 letterale numerico intero.\n{ ... }: Delimitatori che racchiudono il blocco di codice.\nprint(\"x è positivo\"): Istruzione di output.\n\nCicli: Istruzioni che ripetono un blocco di codice. Esempio:\n#include &lt;stdio.h&gt;\n\nint n = 42;\nint somma = 0;\nint i;\n\nfor (i = 0; i &lt; n; i++) {\n    somma = somma + i;\n}\n\nfor: Parola chiave che introduce il ciclo.\n(i = 0; i &lt; n; i++): Espressione di controllo del ciclo composta da: i = 0 assegnazione iniziale, i &lt; n condizione di ciclo e i++ incremento della variabile i.\n{ ... }: Delimitatori che racchiudono il blocco di codice.\nsomma = somma + i: Operazione aritmetica.\n\n\n\n\n3.1.5 Organizzazione del codice in un programma\nIl programma è solitamente salvato in un file di testo in righe. Queste righe possono essere classificate in righe fisiche e righe logiche.\nUna riga fisica è una linea di testo nel file sorgente del programma, terminata da un carattere di a capo.\nEsempio:\n1int x = 10;\n\n1\n\nQuesta è una riga fisica.\n\n\nUna riga logica è una singola istruzione, che può estendersi su una o più righe fisiche.\nEsempio di riga logica con più righe fisiche:\n1int y = (10 + 20 + 30 +\n2         40 + 50);\n\n1\n\nPrima riga fisica della riga logica.\n\n2\n\nSeconda riga fisica della riga logica.\n\n\nIl concetto di righe fisiche e logiche esiste perché le istruzioni (o righe logiche) possono essere lunghe e complesse, richiedendo più righe fisiche per migliorare la leggibilità e la gestione del codice.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi e semantica dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi-semantica.html#semantica",
    "href": "prima-parte-sintassi-semantica.html#semantica",
    "title": "3  Sintassi e semantica dei linguaggi di programmazione",
    "section": "3.2 Semantica",
    "text": "3.2 Semantica\nLa semantica di un linguaggio di programmazione definisce il significato delle istruzioni sintatticamente corrette. In altre parole, la semantica specifica cosa fa un programma quando viene eseguito, descrivendo l’effetto delle istruzioni sullo stato del sistema. Gli elementi semantici sono numerosi, possono essere anche complessi e non tutti presenti in uno specifico linguaggio.\nDi seguito ne sono riportati alcuni tra i principali elementi semantici.\n\n3.2.1 Modello dati\nUn modello dati è una rappresentazione formale dei tipi di dati e delle operazioni che possono essere eseguite su di essi. Esso definisce le strutture fondamentali attraverso le quali i dati vengono organizzati, memorizzati, manipolati e interagiscono all’interno del programma.\nLe componenti il modello dati sono:\n\nTipi di dati:\n\nTipi primitivi: Questi sono i tipi di dati fondamentali che il linguaggio supporta nativamente, come numeri interi, numeri in virgola mobile, caratteri e booleani.\nTipi compositi: Questi sono tipi di dati costruiti combinando tipi primitivi. Esempi comuni includono array, liste, tuple, set e dizionari.\nTipi di dati definiti dall’utente: Questi sono tipi di dati che possono essere definiti dagli utenti del linguaggio, come le struct in C oppure le classi in Python o C++, che permettono di creare tipi di dati personalizzati.\n\nOperazioni:\n\nOperazioni aritmetiche: Operazioni che possono essere eseguite sui tipi di dati, come addizione, sottrazione, moltiplicazione e divisione per i numeri.\nOperazioni logiche: Operazioni che coinvolgono valori booleani, come AND, OR e NOT.\nOperazioni di sequenza: Operazioni che si possono eseguire su sequenze di dati, come l’indicizzazione, la slicing e l’iterazione.\n\nRegole di comportamento:\n\nMutabilità: Determina se un oggetto può essere modificato dopo la sua creazione. Oggetti mutabili, come liste e dizionari in Python, possono essere cambiati. Oggetti immutabili, come tuple e stringhe, non possono essere modificati dopo la loro creazione.\nCopia e clonazione: Regole che determinano come i dati vengono copiati. Per esempio, in Python, la copia di una lista crea una nuova lista con gli stessi elementi, mentre la copia di un intero crea solo un riferimento allo stesso valore.\n\n\n\n3.2.1.1 Linguaggi procedurali\nNei linguaggi di programmazione procedurali, il modello dati è incentrato su tipi di dati semplici e compositi che supportano lo stile di programmazione orientato alle funzioni e procedure. Alcune caratteristiche tipiche includono:\n\nTipi primitivi: Numeri interi, numeri a virgola mobile, caratteri e booleani.\nStrutture composite: Array, strutture (struct) e unioni (union). Gli array permettono di gestire collezioni di elementi dello stesso tipo, mentre le strutture permettono di combinare vari tipi di dati sotto un unico nome. Le unioni consentono di memorizzare diversi tipi di dati nello stesso spazio di memoria, ma solo uno di essi può essere attivo alla volta.\nOperazioni basate su funzioni: Le operazioni sui dati vengono eseguite attraverso funzioni che manipolano i valori passati come argomenti.\n\nEsempio in C:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_DATI 100\n\n1union Valore {\n  int intero;\n  float decimale;\n  char carattere;\n};\n\n2struct Dato {\n  char tipo;  \n  // 'i' per int, 'f' per float, 'c' per char\n  union Valore valore;\n};\n\n3void stampa_dato(struct Dato d) {\n  switch (d.tipo) {\n    case 'i':\n      printf(\"Intero: %d\\n\", d.valore.intero);\n      break;\n\n    case 'f':\n      printf(\"Float: %f\\n\", d.valore.decimale);\n      break;\n\n    case 'c':\n      printf(\"Carattere: %c\\n\", d.valore.carattere);\n      break;\n\n    default:\n      printf(\"Tipo sconosciuto\\n\");\n      break;\n  }\n}\n\nint confronta_dato(struct Dato d1, struct Dato d2) {\n  if (d1.tipo != d2.tipo) return 0;\n\n  switch (d1.tipo) {\n    case 'i': return d1.valore.intero == d2.valore.intero;\n\n    case 'f': return d1.valore.decimale == d2.valore.decimale;\n\n    case 'c': return d1.valore.carattere == d2.valore.carattere;\n\n    default: return 0;\n  }\n}\n\n4void inserisci_dato(struct Dato dati[], int *count, struct Dato nuovo_dato) {\n  if (*count &lt; MAX_DATI) {\n    dati[*count] = nuovo_dato;\n\n    (*count)++;\n\n  } else {\n    printf(\"Array pieno, impossibile inserire nuovo dato.\\n\");\n  }\n}\n\n5void cancella_dato(struct Dato dati[], int *count, struct Dato dato_da_cancellare) {\n  for (int i = 0; i &lt; *count; i++) {\n    if (confronta_dato(dati[i], dato_da_cancellare)) {\n      for (int j = i; j &lt; *count - 1; j++) {\n        dati[j] = dati[j + 1];\n      }\n\n      (*count)--;\n\n      i--; \n    }\n  }\n}\n\nint main() {\n6  struct Dato dati[MAX_DATI];\n  int count = 0;\n\n  struct Dato dato1 = {'i', .valore.intero = 42};\n  struct Dato dato2 = {'f', .valore.decimale = 3.14};\n  struct Dato dato3 = {'c', .valore.carattere = 'A'};\n  \n7  inserisci_dato(dati, &count, dato1);\n  inserisci_dato(dati, &count, dato2);\n  inserisci_dato(dati, &count, dato3);\n\n8  for (int i = 0; i &lt; count; i++) {\n    stampa_dato(dati[i]);\n  }\n\n9  cancella_dato(dati, &count, dato1);\n\n  printf(\"Dopo cancellazione:\\n\");\n\n  for (int i = 0; i &lt; count; i++) {\n    stampa_dato(dati[i]);\n  }\n\n  return 0;\n}\n\n1\n\nDefinizione di una union.\n\n2\n\nDefinizione di una struct che include la union.\n\n3\n\nFunzione per stampare i valori in base al tipo.\n\n4\n\nFunzione per inserire un nuovo dato alla fine dell’array.\n\n5\n\nFunzione per cancellare tutte le occorrenze di un dato dall’array.\n\n6\n\nDefinizione di un array di struct Dato.\n\n7\n\nInserimento di dati nell’array.\n\n8\n\nStampa dei dati nell’array.\n\n9\n\nCancellazione di un dato specifico e ristampa dell’array.\n\n\nL’esempio mostra come nel modello dati del linguaggio C possono essere definiti dei tipi compositi (Dato, Valore) e delle operazioni su quelli (stampa_dato, confronta_dato, inserisci_dato, cancella_dato). Il codice, pur realizzante una semplice libreria, appare slegato, cioè con funzioni che si applicano a tipi di dati specifici solo dall’interpretazione degli identificatori della funzione stessa e dei suoi parametri, cioè senza un legame esplicito e non ambiguo, tra tipo e funzione.\n\n\n3.2.1.2 Linguaggi orientati agli oggetti\nLa programmazione orientata agli oggetti è un paradigma che utilizza oggetti per rappresentare concetti ed entità del mondo reale o astratto. Questo approccio si basa su un processo mentale fondamentale per risolvere problemi complessi: la decomposizione. Un problema complesso è più facilmente risolvibile se diviso in parti più piccole, ciascuna delle quali possiede uno stato e la possibilità di comunicare con le altre parti. Questa divisione permette di continuare la decomposizione fino a raggiungere un livello sufficientemente elementare da poter essere realizzato come istruzioni codificate in costrutti permessi dalla sintassi del linguaggio.\n\n3.2.1.2.1 Oggetti\nLo stato di un oggetto è definito dai suoi attributi, i cui valori possono essere altri oggetti già disponibili, sia definiti dall’utente che dal linguaggio. L’interazione tra diversi oggetti avviene attraverso i metodi, che sono funzioni associate agli oggetti che possono modificare lo stato dell’oggetto o invocare metodi su altri oggetti.\nI membri di un oggetto (attributi e metodi) possono avere diverse limitazioni di accesso, definite dal concetto di visibilità:\n\nPubblica: Gli attributi e i metodi pubblici sono accessibili da qualsiasi parte del programma. Questa visibilità permette a qualsiasi altro oggetto o funzione di interagire con questi membri.\nPrivata: Gli attributi e i metodi privati sono accessibili solo da altri membri dell’oggetto e rispondono alla esigenza di separare il codice di interfaccia da quello utile al funzionamento interno.\nProtetta: Gli attributi e i metodi protetti sono accessibili da tutti i membri del medesimo oggetto ma, a differenza dei privati, anche da quelli degli oggetti derivati. Questo fornisce un livello intermedio di accesso, utile per la gestione dell’ereditarietà.\n\nL’incapsulamento è il principio su cui si basa la gestione della visibilità e guida la separazione del codice realizzante le specificità di un oggetto, da come è fruito dagli altri oggetti. Questo protegge l’integrità del suo stato e ne facilita la manutenzione del codice stesso, permettendo modifiche di implementazione, senza impatti sul codice esterno fintantoché non si cambiano i membri pubblici. Inoltre, se ben sfruttata nella progettazione, rende il codice più comprensibile e riduce la superficie d’attacco.\n\n\n3.2.1.2.2 Classi e prototipi\nUn oggetto può essere generato da una struttura statica che ne definisce tutte le caratteristiche, la classe, oppure può essere creato a partire da un altro oggetto esistente, noto come prototipo.\nNella programmazione ad oggetti basata su classi, ogni oggetto è un’istanza vivente di una classe predefinita, che ne rappresenta il progetto o l’archetipo. La classe definisce i membri e la visibilità, quindi, in definitiva tutte le proprietà comuni agli oggetti dello stesso tipo o matrice. Gli oggetti vengono creati chiamando un metodo speciale della classe, noto come costruttore e, all’atto della loro vita, un secondo metodo, il distruttore, che si occupa di effettuare le azioni di terminazione. La classe può inoltre definire metodi e attributi specifici che possono essere ereditati da altre classi, cioè possono essere utilizzati da quest’ultime al pari dei propri membri, permettendo la definizione di una gerarchia di classi che facilita il riuso del codice per mezzo dell’estensione, al posto della modifica, delle funzionalità. La classe che eredita da un’altra classe si definisce derivata dalla classe che, a sua volta, è detta base.\nAlternativamente, alcuni linguaggi usano il concetto di prototipo, in cui gli oggetti sono le entità principali e non esiste una matrice separata come la classe. In questo paradigma, ogni oggetto può servire da prototipo per altri e ciò significa che, invece di creare nuove istanze di una classe, si creano nuovi oggetti clonando o estendendo oggetti esistenti. È possibile aggiungere o modificare proprietà e metodi di un oggetto prototipo e, in tal caso, queste modifiche si rifletteranno in tutti gli oggetti che derivano da esso.\nIl paradigma basato su prototipi offre maggiore flessibilità e dinamismo rispetto a quello basato su classi, poiché la struttura degli oggetti può essere modificata in modo dinamico. Tuttavia, questo approccio può anche introdurre complessità e rendere più difficile la gestione delle gerarchie di oggetti e la comprensione del codice, poiché non esistono strutture fisse come le classi.\n\n\n\n3.2.1.3 Ereditarietà\nLe lingue OOP sono diverse, ma tipicamente permettono l’ereditarietà per il riuso del codice e l’estensibilità in forma di classi o prototipi. Le classi definiscono il formato dei dati e i metodi disponibili per un tipo di oggetto. Gli oggetti sono creati chiamando un metodo speciale della classe noto come costruttore. Le classi possono ereditare da altre classi, formando una gerarchia che rappresenta relazioni “is-a-type-of” (è un tipo di). Ad esempio, la classe Employee può ereditare dalla classe Person.\n\n3.2.1.3.1 Ereditarietà Basata su Classi\nNella programmazione basata su classi, ogni oggetto è un’istanza di una particolare classe. La classe definisce i dati e i metodi disponibili per un tipo di oggetto. Ad esempio:\nclass Person {\n    String firstName;\n    String lastName;\n\n    public String makeFullName() {\n        return firstName + \" \" + lastName;\n    }\n}\n\nclass Employee extends Person {\n    String position;\n    double salary;\n}\nIn questo esempio, Employee eredita firstName, lastName e makeFullName da Person, ma aggiunge position e salary.\n\n\n3.2.1.3.2 Ereditarietà Basata su Prototipi\nIn contrasto, nella programmazione basata su prototipi, gli oggetti sono le entità principali. Non esiste il concetto di “classe” esplicitamente. In JavaScript, ogni oggetto ha un prototipo a cui è collegato. Ad esempio:\nconst person = {\n    firstName: 'John',\n    lastName: 'Doe',\n    makeFullName: function() {\n        return this.firstName + ' ' + this.lastName;\n    }\n};\n\nconst employee = Object.create(person);\nemployee.position = 'Developer';\nemployee.salary = 50000;\n\nconsole.log(employee.makeFullName()); // John Doe\nIn questo esempio, employee eredita firstName, lastName e makeFullName da person tramite il suo prototipo.\n\n\n\n3.2.1.4 Dinamica e Dispatch di Messaggi\nIn OOP, la selezione del codice procedurale da eseguire in risposta a una chiamata di metodo è responsabilità dell’oggetto. Questa funzionalità è nota come dispatch dinamico. Se la variabilità della chiamata dipende da più di un singolo tipo di oggetto (ad esempio, almeno un altro oggetto parametro è coinvolto nella scelta del metodo), si parla di multiple dispatch. Una chiamata di metodo è anche conosciuta come passaggio di messaggi. È concettualizzata come un messaggio (il nome del metodo e i suoi parametri di input) passato all’oggetto per il dispatch.\nIl dispatch interagisce con l’ereditarietà; se un metodo non è presente in un dato oggetto o classe, il dispatch è delegato al suo oggetto o classe genitore, e così via, salendo la catena dell’ereditarietà.\n\n\n3.2.1.5 Astrazione dei Dati e Incapsulamento\nL’astrazione dei dati è un pattern di design in cui i dati sono visibili solo a funzioni semanticamente correlate, per prevenire l’uso improprio. L’incapsulamento, d’altra parte, impedisce al codice esterno di essere preoccupato per il funzionamento interno di un oggetto. Questo facilita il refactoring del codice, consentendo all’autore della classe di cambiare il modo in cui gli oggetti di quella classe rappresentano i loro dati internamente senza cambiare alcun codice esterno (finché le chiamate ai metodi “pubblici” funzionano allo stesso modo). L’incapsulamento incoraggia anche i programmatori a mettere tutto il codice che riguarda un certo set di dati nella stessa classe, organizzandolo per una facile comprensione da parte di altri programmatori. Questa tecnica promuove il disaccoppiamento.\nIn OOP, gli oggetti forniscono un livello che può essere utilizzato per separare il codice interno da quello esterno e implementare l’astrazione e l’incapsulamento. Il codice esterno può utilizzare un oggetto solo chiamando un metodo di istanza specifico con un certo set di parametri di input, leggendo una variabile di istanza o scrivendo su una variabile di istanza.\n\n\n3.2.1.6 Polimorfismo\nIl polimorfismo è quando il codice chiamante può essere indipendente dalla classe specifica su cui opera, purché faccia parte della gerarchia supportata. Nel frattempo, lo stesso nome di operazione tra oggetti in una gerarchia di ereditarietà può comportarsi in modo diverso. Questo è un altro tipo di astrazione che semplifica il codice esterno alla gerarchia di classi e consente una forte separazione delle preoccupazioni.\nAd esempio, gli oggetti del tipo Circle e Square possono derivare da una classe comune chiamata Shape. La funzione Draw per ciascun tipo di Shape implementa ciò che è necessario per disegnare se stessa, mentre il codice chiamante può rimanere indifferente al particolare tipo di Shape che viene disegnato.\nabstract class Shape {\n    abstract void draw();\n}\n\nclass Circle extends Shape {\n    void draw() {\n        System.out.println(\"Drawing a Circle\");\n    }\n}\n\nclass Square extends Shape {\n    void draw() {\n        System.out.println(\"Drawing a Square\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape circle = new Circle();\n        Shape square = new Square();\n        circle.draw(); // Drawing a Circle\n        square.draw(); // Drawing a Square\n    }\n}\n\n\n3.2.1.7 Ricorsione Aperta\nUn’altra caratteristica comune degli oggetti è che i metodi sono associati a essi e possono accedere e modificare i campi dati dell’oggetto. In questo tipo di OOP, esiste solitamente un nome speciale come this o self usato per riferirsi all’oggetto corrente. Nei linguaggi che supportano la ricorsione aperta, i metodi degli oggetti possono chiamare altri metodi sullo stesso oggetto (inclusi se stessi) usando questo nome. Questa variabile è legata tardivamente; consente a un metodo definito in una classe di invocare un altro metodo che è definito successivamente, in qualche sottoclasse di essa.\n\n\n\n3.2.2 Conclusione\nIl modello dati nella programmazione orientata agli oggetti è complesso e ricco di concetti che migliorano la modularità, il riuso del codice e la manutenibilità del software. Comprendere a fondo questi concetti è fondamentale per sfruttare appieno le potenzialità del paradigma OOP e per progettare software robusto e scalabile.\n\n\n3.2.3 Riferimenti Bibliografici\n\nVariabile: È un nome simbolico associato a locazione di memoria che può contenere uno o più valori. È fondamentale per la manipolazione di dati perché sono un mezzo per astrarre dalla costante memorizzata. Le variabili possono essere associate a diversi tipi di dati e durate di vita. La semantica delle variabili include la loro dichiarazione, inizializzazione, uso e visibilità:\n\nDichiarazione: La dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. La dichiarazione informa il compilatore o l’interprete che una certa variabile esiste e può essere utilizzata nel codice.\nInizializzazione: L’inizializzazione di una variabile è il processo di assegnare un valore iniziale alla variabile. L’inizializzazione può avvenire contestualmente alla dichiarazione o in un’istruzione separata successiva.\nVisibilità: Indica dove la variabile può essere utilizzata all’interno del codice (ad esempio, variabili locali o globali).\nDurata di Vita: Descrive per quanto tempo la variabile rimane in memoria durante l’esecuzione del programma (ad esempio, automatica, statica, dinamica).\n\nTipo di dati: I tipi di dati definiscono il dominio dei valori che una variabile può assumere e le operazioni che possono essere eseguite su quei valori. Un tipo di dato determina la natura del valore (ad esempio, numero intero, carattere, booleano) e le operazioni che possono essere effettuate su di esso. Generalmente si distinguono in:\n\nTipo primitivo: I tipi di dati fondamentali forniti da un linguaggio, come integer, float, boolean e character.\nTipo complesso: Tipo di dati costituiti da più tipi primitivi, come array, struct e oggetti.\nTipo di dati utente: Tipo definito dall’utente, come classi e tipi personalizzati, che permette di creare strutture dati più complesse e specifiche per il problema da risolvere.\n\nAmbito (in inglese, scope): L’ambito rappresenta la porzione del codice in cui un identificatore (come una variabile o una funzione) è definito e, quindi, esiste. L’ambito determina dove un identificatore può essere dichiarato e utilizzato. Tipicamente gli ambiti sono:\n\nGlobale: Identificatori dichiarati a livello globale, accessibili ovunque nel programma.\nLocale: Identificatori dichiarati all’interno di un blocco, come una funzione o un loop, e accessibili solo all’interno di quel blocco.\nStatico e dinamico: L’ambito statico è determinato a tempo di compilazione, mentre l’ambito dinamico è determinato a runtime, influenzando come e dove gli identificatori possono essere utilizzati.\n\nVisibilità: La visibilità si riferisce a dove nel codice un identificatore può essere visto e utilizzato. Anche se correlata all’ambito, la visibilità può essere influenzata da altri fattori come la modularità e i namespace, che organizzano e separano gli identificatori per evitare conflitti di nome. La visibilità è generalmente:\n\nGlobale: Un identificatore dichiarato con visibilità globale può essere utilizzato in qualsiasi parte del programma.\nLocale: Un identificatore dichiarato con visibilità locale è visibile solo all’interno del blocco di codice in cui è stato dichiarato.\n\nFunzioni e metodi: Le funzioni e i metodi sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Alcuni concetti collegati sono:\n\nParametri e argomenti: Valori passati alle funzioni per influenzarne il comportamento. I parametri sono definiti nella dichiarazione della funzione, mentre gli argomenti sono i valori effettivi passati quando la funzione è chiamata.\nValore di ritorno: Il risultato prodotto da una funzione, che può essere utilizzato nell’istruzione chiamante.\nOverloading: Definizione di più funzioni con lo stesso nome ma diversi parametri, consentendo diverse implementazioni basate sui tipi e il numero di argomenti.\nRicorsione: Capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili.\nFunzioni di prima classe: Le funzioni possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.\nFunzioni di ordine superiore: Funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati.\n\nDurata di vita delle variabili: La durata di vita delle variabili si riferisce a quanto tempo una variabile rimane in memoria durante l’esecuzione del programma. Alcune tipologie di durata:\n\nAutomatica: Variabili che esistono solo durante l’esecuzione del blocco in cui sono dichiarate.\nStatica: Variabili che esistono per tutta la durata del programma e mantengono il loro valore tra diverse chiamate di funzione.\nDinamica: Variabili allocate dinamicamente durante l’esecuzione del programma, solitamente gestite manualmente dall’utente (ad esempio, usando malloc/free in C) o automaticamente tramite garbage collection.\n\nDurata di vita di altri identificatori:\n\nFunzioni: Le funzioni stesse generalmente hanno una durata di vita che coincide con la durata del programma. Tuttavia, i puntatori a funzione e le chiusure (in inglese, closures) possono avere durate di vita diverse in alcuni linguaggi.\nClassi e oggetti: Le classi hanno una durata di vita che coincide con la durata del programma, mentre gli oggetti (istanze di classi) hanno durate di vita dinamiche, determinate dalla loro allocazione e deallocazione.\nModuli: In linguaggi come Python, i moduli hanno una durata di vita che coincide con la durata del programma o del processo di importazione.\n\nControllo di flusso: Determina l’ordine in cui le istruzioni vengono eseguite e alcuni esempi sono:\n\nCondizionali: Strutture che permettono al programma di prendere decisioni (if, else, switch/case).\nCicli: Strutture che ripetono un blocco di codice (for, while, do-while).\nEccezioni: Meccanismi per gestire errori e condizioni anomale (try, catch, throw), permettendo al programma di continuare l’esecuzione in modo controllato.\n\nClassi e oggetti: Le classi sono trutture che definiscono proprietà (variabili) e comportamenti (metodi) comuni a tutti gli oggetti di quel tipo. Le classi rappresentano il modello o il blueprint da cui vengono creati gli oggetti. L’oggetto è l’istanza concreta di una classe. Gli oggetti sono entità che combinano dati e comportamenti secondo la struttura definita dalla loro classe. Si applicano i seguenti:\n\nEncapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie, migliorando la modularità e la manutenzione del codice.\nEreditarietà: Permette di creare nuove classi basate su classi esistenti, riutilizzando e estendendo il comportamento delle classi base.\nPolimorfismo: Consente a metodi di comportarsi diversamente a seconda dell’oggetto su cui vengono invocati, fornendo flessibilità e estendibilità.\n\nGestione della memoria utilizzata dal programma: La gestione della memoria è fondamentale per il funzionamento efficiente di un programma. Ne esistono diverse modalità:\n\nAllocazione dinamica: La memoria è allocata e deallocata a runtime, permettendo una gestione flessibile delle risorse.\nGarbage collection: Automatizza la deallocazione della memoria non utilizzata, riducendo il rischio di sfruttamento non ottimale (memory leak) e semplificando la gestione della memoria.\n\nSpazio di nomi (in inglese namespace): I namespace organizzano variabili, funzioni e altri identificatori per evitare conflitti di nome.\nModuli e librerie: I moduli e le librerie suddividono il codice in unità riutilizzabili e organizzate, da importare in programmi. I moduli possono definire degli spazi di nomi.\nConcorrenza: La concorrenza permette l’esecuzione parallela di più sequenze di istruzioni, migliorando le prestazioni e la reattività. Alcuni concetti relativi sono:\n\nThread: Un thread è la più piccola unità di elaborazione che può essere eseguita in modo indipendente. I thread consentono l’esecuzione parallela di codice all’interno di un programma.\nSincronizzazione: Meccanismi per gestire l’accesso concorrente alle risorse condivise, prevenendo condizioni di gara e garantendo la consistenza dei dati.\nLock e mutex: Meccanismi per prevenire condizioni di corsa (in inglese race condition), cioè un fenomeno che si presenta nei sistemi concorrenti quando, in presenza di una sequenza di processi multipli, il risultato finale dell’esecuzione dei processi dipende dalla temporizzazione o dalla sequenza con cui vengono eseguiti. Garantiscono, pertanto, l’accesso sicuro alle risorse condivise.\nAsync/await: Gestione di operazioni asincrone, migliorando l’efficienza e la reattività delle applicazioni.\n\nInput/output (I/O): L’input/output gestisce la comunicazione tra il programma e l’ambiente esterno.\n\nFile I/O: Lettura e scrittura su file per memorizzare e recuperare dati persistenti.\nNetwork I/O: Comunicazione attraverso reti per inviare e ricevere dati tra sistemi diversi.\nStandard I/O: Interazione con l’utente tramite input da tastiera e output su schermo.\n\nAnnotazioni e metadati: Le annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l’analisi del codice.\n\nAnnotazioni: Informazioni extra utilizzate per specificare comportamenti speciali o configurazioni. Ad esempio, in Java, le annotazioni possono essere utilizzate per indicare che un metodo è obsoleto (@Deprecated), per sovrascrivere un metodo della superclasse (@Override), o per specificare la relazione tra entità nel contesto di framework come JPA (Jakarta Persistence; @Entity, @Table). In Python, le annotazioni sono utilizzate principalmente per indicare i tipi di variabili, parametri di funzione e valori di ritorno (type hint). Non influenzano direttamente il comportamento del programma, ma sono utili per la documentazione e il type checking anche automatico.\nDocstring: Commenti strutturati che documentano il codice, spesso utilizzati per generare documentazione automatica. In Python, ad esempio, le docstring possono essere utilizzate per descrivere il funzionamento di moduli, classi, metodi e funzioni, rendendo il codice più leggibile e comprensibile.\n\nMacro e metaprogrammazione: Le macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice.\n\nMacro: Sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale.\nMetaprogrammazione: Tecniche per scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time, migliorando la flessibilità e il riutilizzo del codice. In Python include l’uso di decoratori, metaclassi e introspezione.\n\n\nQuesti elementi semantici combinati determinano il comportamento e la logica di un programma, influenzando il modo in cui il codice viene scritto, eseguito e mantenuto.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi e semantica dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi-semantica.html#applicazione-dei-concetti-di-sintassi-e-semantica",
    "href": "prima-parte-sintassi-semantica.html#applicazione-dei-concetti-di-sintassi-e-semantica",
    "title": "3  Sintassi e semantica dei linguaggi di programmazione",
    "section": "3.3 Applicazione dei concetti di sintassi e semantica",
    "text": "3.3 Applicazione dei concetti di sintassi e semantica\nDissezioniamo un algoritmo molto semplice per illustrare come sintassi e semantica di un linguaggio abbiano ruoli distinti e complementari in un programma. È importante comprendere che un buon programmatore deve avere tutte e tre le competenze, cioè conoscere le specificità formali del linguaggio (o di più linguaggi), quindi, la sua sintassi e semantica e saper comporre algoritmi, che potrà realizzare grazie proprio a quelle.\nConsideriamo un esempio semplice di algoritmo per calcolare la somma dei numeri da 1 a n. In input si avrà un numero intero n e in output il risultato. In pseudocodice (cioè mimiamo il rigore sintattico di un linguaggio di programmazione, ma utilizziamo la lingua italiana) si può rappresentare così:\nInizializza somma a 0\nPer ogni numero i da 1 a n:\n  Aggiungi i a somma\nRestituisci somma\nO, in alternativa, possiamo definire una funzione che implementa l’algoritmo:\nfunzione calcola_somma(n):\n  somma = 0\n  per i da 1 a n:\n    somma = somma + i\n  ritorna somma\nEffettuiamo una analisi dettagliata della funzione per indicare quali elementi sintattici e semantici sono presenti. Partiamo dalla prima riga:\nfunzione calcola_somma(n):\n\nSintassi:\n\nfunzione: Parola chiave che introduce la definizione di una funzione.\ncalcola_somma: Identificatore della funzione.\n(n): Delimitatori che contengono un identificatore.\n\nSemantica: Definisce una funzione chiamata calcola_somma che accetta un parametro n.\n\nLa seconda riga ha l’inizializzazione della variabile che conterrà il risultato:\nsomma = 0\n\nSintassi:\n\nsomma: Identificatore della variabile.\n=: Operatore di assegnazione.\n0: Letterale numero intero.\n\nSemantica:\n\nInizializza la variabile somma a 0.\n\n\nA seguire la definizione di un ciclo:\nper i da 1 a n:\n\nSintassi:\n\nper: Parola chiave che introduce il ciclo.\ni: Identificatore della variabile di controllo del ciclo.\nda 1 a n: Espressione di controllo del ciclo che indica l’intervallo.\n\nSemantica: Itera la variabile i da 1 a n.\n\nUn assegnamento per accumulare i valori nella variabile di ritorno:\nsomma = somma + i\n\nSintassi:\n\nsomma: Identificatore della variabile.\n=: Operatore di assegnazione.\nsomma + i: Espressione aritmetica composta da: somma identificatore di variabile, + operatore aritmetico e i identificatore di variabile.\n\nSemantica: Aggiunge il valore di i alla variabile somma e assegna il risultato a somma.\n\nE finalmente il risultato del calcolo viene restituito al chiamante:\nritorna somma\n\nSintassi:\n\nritorna: Parola chiave che indica la restituzione di un valore.\nsomma: Identificatore della variabile.\n\nSemantica:\n\nRestituisce il valore della variabile somma come risultato della funzione.",
    "crumbs": [
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sintassi e semantica dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html",
    "href": "seconda-parte-python-introduzione.html",
    "title": "4  Introduzione a Python",
    "section": "",
    "text": "4.1 Perché Python è un linguaggio di alto livello?\nPython è considerato un linguaggio di programmazione di alto livello, cioè utilizza un livello di astrazione elevato rispetto alla complessità dell’ambiente in cui i suoi programmi sono eseguiti. Il programmatore ha a disposizione una sintassi che è più intuitiva rispetto ad altri linguaggi come Java, C++, PHP tradizionalmente anch’essi definiti di alto livello.\nInfatti, consente ai programmatori di scrivere codice in modo più concettuale e indipendente dalle caratteristiche degli hardware, anche molto diversi, su cui è disponibile. Ad esempio, invece di preoccuparsi di allocare e deallocare memoria manualmente, Python gestisce queste operazioni automaticamente. Questo libera il programmatore dai dettagli del sistema operativo e dell’elettronica, permettendogli di concentrarsi sulla logica del problema da risolvere.\nCiò ha un effetto importante sulla versatilità perché spesso è utilizzato come interfaccia utente per linguaggi di livello più basso come C, C++ o Fortran. Questo permette a Python di sfruttare le prestazioni dei linguaggi compilati per le parti critiche e computazionalmente intensive del codice, mantenendo al contempo una sintassi semplice e leggibile per la maggior parte del programma. Buoni compilatori per i linguaggi compilati classici possono sì generare codice binario che gira più velocemente di Python, tuttavia, nella maggior parte dei casi, le prestazioni delle applicazioni codificate in Python sono sufficienti.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#python-come-linguaggio-multiparadigma",
    "href": "seconda-parte-python-introduzione.html#python-come-linguaggio-multiparadigma",
    "title": "4  Introduzione a Python",
    "section": "4.2 Python come linguaggio multiparadigma",
    "text": "4.2 Python come linguaggio multiparadigma\nPython è un linguaggio di programmazione multiparadigma, il che significa che supporta diversi paradigmi di programmazione, permettendo di mescolare e combinare gli stili a seconda delle necessità dell’applicazione. Ecco alcuni dei paradigmi supportati da Python:\n\nProgrammazione imperativa: Puoi scrivere ed eseguire script Python direttamente dalla linea di comando, permettendo un approccio interattivo e immediato alla programmazione, come se fosse una calcolatrice.\nProgrammazione procedurale: In Python, è possibile organizzare il codice in funzioni e moduli, rendendo più semplice la gestione e la riutilizzabilità del codice. Puoi raccogliere il codice in file separati e importarli come moduli, migliorando la struttura e la leggibilità del programma.\nProgrammazione orientata agli oggetti: Python supporta pienamente la programmazione orientata agli oggetti, consentendo la definizione di classi e oggetti. Questo paradigma è utile per modellare dati complessi e relazioni tra essi. Le caratteristiche orientate agli oggetti di Python sono concettualmente simili a quelle del C++, ma più semplici da usare.\nProgrammazione funzionale: Python include funzionalità di programmazione funzionale, come funzioni di prima classe e di ordine superiore, lambda e strumenti come map, filter e reduce.\n\nQuesta flessibilità rende Python adatto a una vasta gamma di applicazioni e consente ai programmatori di scegliere l’approccio più adatto al problema da risolvere.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#regole-formali-e-esperienziali",
    "href": "seconda-parte-python-introduzione.html#regole-formali-e-esperienziali",
    "title": "4  Introduzione a Python",
    "section": "4.3 Regole formali e esperienziali",
    "text": "4.3 Regole formali e esperienziali\nPython non è solo un linguaggio con regole sintattiche precise e ben progettate, ma possiede anche una propria filosofia, un insieme di regole di buon senso esperienziali che sono complementari alla sintassi formale. Questa filosofia è spesso riassunta nel zen di Python, una raccolta di aforismi che catturano i principi fondamentali del design di Python. Tali principi aiutano i programmatori a comprendere e utilizzare al meglio le potenzialità del linguaggio e dell’ecosistema Python.\nEcco alcuni dei principi dello zen di Python1:\n1 PEP 20 – The Zen of Python\nLa leggibilità conta: Il codice dovrebbe essere scritto in modo che sia facile da leggere e comprendere.\nEsplicito è meglio di implicito: È preferibile scrivere codice chiaro e diretto piuttosto che utilizzare scorciatoie criptiche.\nSemplice è meglio di complesso: Il codice dovrebbe essere il più semplice possibile per risolvere il problema.\nComplesso è meglio di complicato: Quando la semplicità non è sufficiente, la complessità è accettabile, ma il codice non dovrebbe mai essere complicato.\nPratico batte puro: Le soluzioni pragmatiche sono preferibili alle soluzioni eleganti ma poco pratiche.\n\nQuesti principi, insieme alle regole sintattiche, guidano il programmatore nell’adottare buone pratiche di sviluppo e nel creare codice che sia non solo funzionale ma anche mantenibile e comprensibile da altri.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#lecosistema",
    "href": "seconda-parte-python-introduzione.html#lecosistema",
    "title": "4  Introduzione a Python",
    "section": "4.4 L’ecosistema",
    "text": "4.4 L’ecosistema\nFino ad ora abbiamo visto Python come linguaggio, ma è molto di più: Python è anche una vasta collezione di strumenti e risorse a disposizione degli sviluppatori, strutturata in un ecosistema completo, di cui il linguaggio ne rappresenta la parte formale. Questo ecosistema è disponibile completamente, anche come sorgente, sul sito ufficiale python.org.\n\n4.4.1 L’interprete\nL’interprete Python è lo strumento di esecuzione dei programmi. È il software che legge ed esegue il codice Python. Python è un linguaggio interpretato, il che significa che il codice viene eseguito direttamente dall’interprete, senza bisogno di essere compilato in un linguaggio macchina. Esistono diverse implementazioni dell’interprete Python:\n\nCPython: L’implementazione di riferimento dell’interprete Python, scritta in C. È la versione più utilizzata e quella ufficiale.\nPyPy: Un interprete alternativo che utilizza tecniche di compilazione just-in-time (JIT) per migliorare le prestazioni.\nJython: Un’implementazione di Python che gira sulla JVM (Java Virtual Machine).\nIronPython: Un’implementazione di Python integrata col .NET Framework della Microsoft.\n\n\n\n4.4.2 L’ambiente di sviluppo\nIDLE (integrated development and learning environment) è l’ambiente di sviluppo integrato ufficiale per Python. È incluso nell’installazione standard di Python ed è progettato per essere semplice e facile da usare, ideale per i principianti. Offre diverse funzionalità utili:\n\nEditor di codice: Con evidenziazione della sintassi, indentazione automatica e controllo degli errori.\nShell interattiva: Permette di eseguire codice Python in modo interattivo.\nStrumenti di debug: Include un debugger integrato con punti di interruzione e stepping.\n\n\n\n4.4.3 Le librerie standard\nUna delle caratteristiche più potenti di Python è il vasto insieme di librerie2 utilizzabili in CPython e IDLE, che fornisce moduli e pacchetti per quasi ogni necessità di programmazione. Alcuni esempi, tra le decine e al solo allo scopo di illustrarne la varietà, includono:\n2 Documentazione delle librerie standard di Python\nos: Fornisce funzioni per interagire con il sistema operativo.\nsys: Offre accesso a funzioni e oggetti del runtime di Python.\ndatetime: Consente di lavorare con date e orari.\njson: Permette di leggere e scrivere dati in formato JSON.\nre: Supporta la manipolazione di stringhe tramite espressioni regolari.\nhttp: Include moduli per l’implementazione di client e server HTTP.\nunittest: Fornisce un framework per il testing del codice.\nmath e cmath: Contengono funzioni matematiche di base e complesse.\nitertools, functools, operator: Offrono supporto per il paradigma di programmazione funzionale.\ncsv: Gestisce la lettura e scrittura di file CSV.\ntyping: Fornisce supporto per l’annotazione dei tipi di variabili, funzioni e classi.\nemail: Permette di creare, gestire e inviare email, facilitando la manipolazione di messaggi email MIME.\nhashlib: Implementa algoritmi di hash sicuri come SHA-256 e MD5.\nasyncio: Supporta la programmazione asincrona per la scrittura di codice concorrente e a bassa latenza.\nwave: Fornisce strumenti per leggere e scrivere file audio WAV.\n\n\n\n4.4.4 Moduli di estensione\nPython supporta l’estensione del suo core tramite moduli scritti in C, C++ o altri linguaggi. Questi moduli permettono di ottimizzare parti critiche del codice o di interfacciarsi con librerie e API esterne:\n\nCython: Permette di scrivere moduli C estesi utilizzando una sintassi simile a Python. Cython è ampiamente utilizzato per migliorare le prestazioni di parti critiche del codice, specialmente in applicazioni scientifiche e di calcolo numerico. Ad esempio, molte librerie scientifiche popolari come SciPy e scikit-learn utilizzano Cython per accelerare le operazioni computazionalmente intensive.\nctypes: Permette di chiamare funzioni in librerie dinamiche C direttamente da Python. È utile per interfacciarsi con librerie esistenti scritte in C, rendendo Python estremamente versatile per l’integrazione con altre tecnologie. Ciò è utile in applicazioni che devono interfacciarsi con hardware specifico o utilizzare librerie legacy.\nCFFI (C foreign function interface): Un’altra interfaccia per chiamare librerie C da Python. È progettata per essere facile da usare e per supportare l’uso di librerie C complesse con Python. CFFI è utilizzato in progetti come PyPy e gevent, permettendo di scrivere codice ad alte prestazioni e di gestire le chiamate a funzioni C in modo efficiente.\n\n\n\n4.4.5 Utility e strumenti aggiuntivi\nPython include anche una serie di strumenti e utility che facilitano lo sviluppo e la gestione dei progetti:\n\npip: Il gestore dei pacchetti di Python. Permette di installare e gestire moduli aggiuntivi, cioè non inclusi nello standard.\nvenv: Uno strumento per creare ambienti virtuali isolati, che permettono di gestire separatamente le dipendenze di diversi progetti.\nDocumentazione: Python include una documentazione dettagliata, accessibile tramite il comando pydoc o attraverso il sito ufficiale.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#lalgoritmo-di-ordinamento-bubble-sort",
    "href": "seconda-parte-python-introduzione.html#lalgoritmo-di-ordinamento-bubble-sort",
    "title": "4  Introduzione a Python",
    "section": "4.5 L’algoritmo di ordinamento bubble sort",
    "text": "4.5 L’algoritmo di ordinamento bubble sort\nPer chiudere il capitolo sul primo approccio a Python, possiamo confrontare un algoritmo, di bassa complessità ma non triviale, in diversi linguaggi di programmazione. Un buon esempio potrebbe essere l’implementazione dell’algoritmo di ordinamento bubble sort di una lista di valori. Vediamo come viene scritto in Python, C, C++, Java, Rust e Scala:\n\nPython in versione procedurale:\ndef bubble_sort(arr):\n  n = len(arr)\n\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] &gt; arr[j+1]:\n        arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sort(arr)\n\nprint(\"Array ordinato con bubble sort: \", arr)\nPython in versione sintatticamente orientata agli oggetti, ma praticamente procedurale:\nclass BubbleSort:\n  @staticmethod\n  def bubble_sort(arr):\n    n = len(arr)\n\n    for i in range(n):\n      for j in range(0, n-i-1):\n        if arr[j] &gt; arr[j+1]:\n          arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nBubbleSort.bubble_sort(arr)\n\nprint(\"Array ordinato con bubble sort: \", arr)\nPython in versione orientata agli oggetti, con una interfaccia di ordinamento implementata con due algoritmi (bubble e insertion sort):\n1from abc import ABC, abstractmethod\n\n# Classe astratta per algoritmi di ordinamento\n2class SortAlgorithm(ABC):\n  def __init__(self, arr):\n    self._arr = arr\n\n  @abstractmethod\n3  def sort(self):\n    # Metodo astratto che deve essere implementato dalle sottoclassi\n    pass\n\n  def get_array(self):\n    # Metodo per ottenere l'array corrente\n    return self._arr\n\n  def set_array(self, arr):\n    # Metodo per impostare un nuovo array\n    self._arr = arr\n\n# Implementazione dell'algoritmo di bubble sort\n4class BubbleSort(SortAlgorithm):\n  def sort(self):\n    n = len(self._arr)\n\n    for i in range(n):\n      for j in range(0, n-i-1):\n        if self._arr[j] &gt; self._arr[j+1]:\n          self._arr[j], self._arr[j+1] = self._arr[j+1], self._arr[j]\n\n# Implementazione dell'algoritmo di insertion sort\nclass InsertionSort(SortAlgorithm):\n  def sort(self):\n    for i in range(1, len(self._arr)):\n      key = self._arr[i]\n\n      j = i - 1\n\n      while j &gt;= 0 and key &lt; self._arr[j]:\n        self._arr[j + 1] = self._arr[j]\n\n        j -= 1\n\n      self._arr[j + 1] = key\n\n# Esempio di utilizzo con bubble sort\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sorter = BubbleSort(arr)\n\nbubble_sorter.sort()\n\nprint(\"Array ordinato con bubble sort: \", bubble_sorter.get_array())\n\n# Esempio di utilizzo con insertion sort\narr = [64, 34, 25, 12, 22, 11, 90]\n\ninsertion_sorter = InsertionSort(arr)\n\ninsertion_sorter.sort()\n\nprint(\"Array ordinato con insertion sort: \", insertion_sorter.get_array())\n\n1\n\nImportiamo ABC e abstractmethod dal modulo abc per definire la classe astratta.\n\n2\n\nSortAlgorithm è una classe astratta che rappresenta l’interfaccia di algoritmi di ordinamento.\n\n3\n\nsort è un metodo astratto che deve essere implementato nelle sottoclassi.\n\n4\n\nBubbleSort è una sottoclasse di SortAlgorithm che implementa l’algoritmo di ordinamento a bolle. Idem per InsertionSort.\n\n\nPython in versione funzionale:\ndef bubble_sort(arr):\n1  def sort_pass(arr, n):\n    if n == 1:\n      return arr\n\n2    new_arr = arr[:]\n\n    for i in range(n - 1):\n      if new_arr[i] &gt; new_arr[i + 1]:\n        new_arr[i], new_arr[i + 1] = new_arr[i + 1], new_arr[i]\n\n3    return sort_pass(new_arr, n - 1)\n\n4  return sort_pass(arr, len(arr))\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nsorted_arr = bubble_sort(arr)\n\nprint(\"Sorted array is:\", sorted_arr)\n\n1\n\nAll’interno di bubble_sort, è definita una funzione interna sort_pass che esegue un singolo passaggio dell’algoritmo di ordinamento a bolle.\n\n2\n\nViene creata una copia dell’array arr chiamata new_arr. Poi, per ogni coppia di elementi (new_arr[i], new_arr[i + 1]), se new_arr[i] è maggiore di new_arr[i + 1], vengono scambiati.\n\n3\n\nLa funzione sort_pass viene chiamata ricorsivamente con new_arr e decrementando n di 1.\n\n4\n\nLa funzione bubble_sort avvia il processo chiamando sort_pass con l’array completo e la sua lunghezza.\n\n\nC:\n#include &lt;stdio.h&gt;\n\nvoid bubble_sort(int arr[], int n) {\n  int i, j, temp;\n\n  for (i = 0; i &lt; n-1; i++) {\n    for (j = 0; j &lt; n-i-1; j++) {\n      if (arr[j] &gt; arr[j+1]) {\n        temp = arr[j];\n\n        arr[j] = arr[j+1];\n\n        arr[j+1] = temp;\n      }\n    }\n  }\n}\n\nint main() {\n  int arr[] = {64, 34, 25, 12, 22, 11, 90};\n  int n = sizeof(arr)/sizeof(arr[0]);\n\n  bubble_sort(arr, n);\n\n  printf(\"Array ordinato con bubble sort: \");\n\n  for (int i = 0; i &lt; n; i++) {\n    printf(\"%d \", arr[i]);\n  }\n\n  return 0;\n}\nC++:\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass BubbleSort {\npublic:\n  void sort(int arr[], int n) {\n    for (int i = 0; i &lt; n-1; i++) {\n      for (int j = 0; j &lt; n-i-1; j++) {\n        if (arr[j] &gt; arr[j+1]) {\n          int temp = arr[j];\n\n          arr[j] = arr[j+1];\n\n          arr[j+1] = temp;\n        }\n      }\n    }\n  }\n\n  void printArray(int arr[], int n) {\n    for (int i = 0; i &lt; n; i++) {\n      cout &lt;&lt; arr[i] &lt;&lt; \" \";\n    }\n\n    cout &lt;&lt; endl;\n  }\n};\n\nint main() {\n  int arr[] = {64, 34, 25, 12, 22, 11, 90};\n  int n = sizeof(arr)/sizeof(arr[0]);\n\n  BubbleSort bs;\n  bs.sort(arr, n);\n\n  cout &lt;&lt; \"Array ordinato con bubble sort: \";\n  bs.printArray(arr, n);\n\n  return 0;\n}\nJava:\npublic class BubbleSort {\n\n  public static void bubbleSort(int arr[]) {\n    int n = arr.length;\n\n    for (int i = 0; i &lt; n-1; i++) {\n      for (int j = 0; j &lt; n-i-1; j++) {\n        if (arr[j] &gt; arr[j+1]) {\n\n          int temp = arr[j];\n\n          arr[j] = arr[j+1];\n\n          arr[j+1] = temp;\n        }\n      }\n    }\n  }\n\n  public static void main(String args[]) {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n\n    bubbleSort(arr);\n\n    System.out.println(\"Array ordinato con bubble sort: \");\n\n    for (int i = 0; i &lt; arr.length; i++) {\n      System.out.print(arr[i] + \" \");\n    }\n  }\n}\nRust:\nfn bubble_sort(arr: &mut [i32]) {\n  let n = arr.len();\n\n  for i in 0..n {\n    for j in 0..n-i-1 {\n      if arr[j] &gt; arr[j+1] {\n        arr.swap(j, j+1);\n      }\n    }\n  }\n}\n\nfn main() {\n  let mut arr = [64, 34, 25, 12, 22, 11, 90];\n\n  bubble_sort(&mut arr);\n\n  println!(\"Array ordinato con bubble sort: {:?}\", arr);\n}\nScala:\nobject BubbleSort {\n  def bubbleSort(arr: Array[Int]): Unit = {\n    val n = arr.length\n\n    for (i &lt;- 0 until n) {\n      for (j &lt;- 0 until n - i - 1) {\n        if (arr(j) &gt; arr(j + 1)) {\n          val temp = arr(j)\n\n          arr(j) = arr(j + 1)\n\n          arr(j + 1) = temp\n        }\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val arr = Array(64, 34, 25, 12, 22, 11, 90)\n\n    bubbleSort(arr)\n\n    println(\"Array ordinato con bubble sort: \" + arr.mkString(\", \"))\n  }\n}\n\nConfrontando questi esempi, possiamo osservare le differenze sintattiche e di stile tra Python ed altri, importanti, linguaggi. Python si distingue per la sua sintassi concisa e espressiva soprattutto nella versione procedurale. L’implementazione colla gerarchia di oggetti ha un piccolo incremento di complessità che è ripagato dalla possibilità di creare gerarchie di algoritmi di ordinamento, con impatti nulli sul codice preesistente.\nLa versione procedurale in Python e l’implementazione C, già a primo acchito, presentano un evidente diverso grado di chiarezza del codice. Inoltre, la riga int n = sizeof(arr)/sizeof(arr[0]); in C si rende necessaria per calcolare il numero di valori a partire dalle dimensioni totale della lista e del singolo elemento, rispetto a n = len(arr) di Python dove chiediamo direttamente il numero di valori.\nIl C++ e Java aggiungono caratteristiche relative agli oggetti e funzionalità di alto livello rispetto a C, al prezzo di una sintassi più complessa e verbosa. Rust e Scala sono linguaggi più moderni e si pongono nel mezzo tra C, C++ e Java e Python.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html",
    "href": "seconda-parte-python-installazione.html",
    "title": "5  Scaricare e installare Python",
    "section": "",
    "text": "5.1 Scaricamento",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#scaricamento",
    "href": "seconda-parte-python-installazione.html#scaricamento",
    "title": "5  Scaricare e installare Python",
    "section": "",
    "text": "Visita il sito ufficiale di Python: Vai su python.org.\nNaviga alla pagina di download: Clicca su Downloads nel menu principale.\nScarica il pacchetto di installazione:\n\nPer Windows: Cerca Python 3.12.x e fai partire il download (assicurati di scaricare la versione più recente).\nPer macOS: Come per Windows.\nPer Linux: Python è spesso preinstallato. Se non lo è, usa il gestore di pacchetti della tua distribuzione (ad esempio apt per Ubuntu: sudo apt-get install python3).",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#installazione",
    "href": "seconda-parte-python-installazione.html#installazione",
    "title": "5  Scaricare e installare Python",
    "section": "5.2 Installazione",
    "text": "5.2 Installazione\n\nEsegui il file di installazione:\n\nSu Windows: Esegui il file .exe scaricato. Assicurati di selezionare l’opzione Add Python to PATH durante l’installazione.\nSu macOS: Apri il file .pkg scaricato e segui le istruzioni.\nSu Linux: Usa il gestore di pacchetti per installare Python.\n\nVerifica l’installazione:\n\nApri il terminale (Command Prompt su Windows, Terminal su macOS e Linux).\nDigita python --version o python3 --version e premi Invio. Dovresti vedere la versione di Python installata.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#esecuzione-del-primo-programma-hello-world",
    "href": "seconda-parte-python-installazione.html#esecuzione-del-primo-programma-hello-world",
    "title": "5  Scaricare e installare Python",
    "section": "5.3 Esecuzione del primo programma: “Hello, World!”",
    "text": "5.3 Esecuzione del primo programma: “Hello, World!”\nÈ consuetudine eseguire come primo programma la visualizzazione della stringa “Hello, World!”1. Possiamo farlo in diversi modi e ciò è una delle caratteristiche più apprezzate di Python.\n1 La tradizione del programma “Hello, World!” ha una lunga storia che risale ai primi giorni della programmazione. Questo semplice programma è generalmente il primo esempio utilizzato per introdurre i nuovi programmatori alla sintassi e alla struttura di un linguaggio di programmazione. Il programma “Hello, World!” è diventato famoso grazie a Brian Kernighan, che lo ha incluso nel suo libro (Kernighan e Ritchie 1988) pubblicato nel 1978. Tuttavia, il suo utilizzo risale a un testo precedente di Kernighan, (Kernighan 1973), pubblicato nel 1973, dove veniva utilizzato un esempio simile.\nKernighan, Brian W., e Dennis M. Ritchie. 1988. The C Programming Language. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.\n\nKernighan, Brian W. 1973. «A Tutorial Introduction to the Programming Language B». Murray Hill, NJ: Bell Laboratories.\n\n5.3.1 REPL\nIl primo modo prevede l’utilizzo del REPL di Python. Il REPL (read-eval-print loop) è un ambiente interattivo di esecuzione di comandi Python generato dall’interprete, secondo il ciclo:\n\nRead: Legge un input dell’utente.\nEval: Valuta l’input.\nPrint: Visualizza il risultato dell’esecuzione.\nLoop: Ripete il ciclo.\n\nEseguiamo il nostro primo “Hello, World!”:\n\nApri il terminale ed esegui l’interprete Python digitando python o python3 e premi il tasto di invio della tastiera.\nScrivi ed esegui il programma:\n\nprint(\"Hello, World!\")\nPremi il tasto di invio per vedere il risultato immediatamente.\n\n\n\n\n\n\nAttenzione\n\n\n\nIl REPL e l’interprete Python sono strettamente collegati, ma non sono esattamente la stessa cosa. Quando avvii l’interprete Python senza specificare un file di script da eseguire (digitando semplicemente python o python3 nel terminale), entri in modalità REPL. Nel REPL, l’interprete Python legge l’input direttamente dall’utente, lo esegue, stampa il risultato e poi attende il prossimo input. In sintesi, l’interprete può eseguire programmi Python completi salvati in file, il REPL è progettato per un’esecuzione interattiva e immediata di singole istruzioni.\n\n\n\n\n5.3.2 Interprete\nUn altro modo per eseguire il nostro programma “Hello, World!” è utilizzare l’interprete Python per eseguire un file di codice sorgente. Questo metodo è utile per scrivere programmi più complessi e per mantenere il codice per usi futuri.\nEcco come fare sui diversi sistemi operativi.\n\nWindowsmacOSLinux\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Notepad.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dall’Esplora file.\nEsegui il file Python:\n\nApri il prompt dei comandi.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd %HOMEPATH%\\Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython hello.txt\n\noppure, se il tuo sistema utilizza python3:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come TextEdit.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dal Finder.\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documents\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Gedit o Nano.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello utilizzando il comando mv nel terminale:\n\nmv hello.txt hello\n\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCon queste istruzioni, dovresti essere in grado di eseguire il programma “Hello, World!” utilizzando un file Python su Windows, macOS e Linux.\n\n\n5.3.3 IDE\nUtilizzo di un IDE (integrated development environment) installato sul computer. Ecco alcuni dei più comuni e gratuiti.\n\nIDLEPyCharmVisual Studio Code\n\n\nÈ incluso con l’installazione di Python.\n\nAvvia IDLE.\nCrea un nuovo file (File -&gt; New File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file (File -&gt; Salva).\nEsegui il programma (Run -&gt; Run Module).\n\n\n\nProprietario ma con una versione liberamente fruibile.\n\nScarica e installa PyCharm da jetbrains.com/pycharm/download.\nCrea un nuovo progetto associando l’interprete Python.\nCrea un nuovo file Python (File -&gt; New -&gt; Python File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nEsegui il programma (Run -&gt; Run...).\n\n\n\nProprietario ma liberamente fruibile.\n\nScarica e installa VS Code da code.visualstudio.com.\nInstalla l’estensione Python.\nApri o crea una nuova cartella di progetto.\nCrea un nuovo file Python (File -&gt; Nuovo file).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file con estensione .py, ad esempio hello_world.py.\nEsegui il programma utilizzando il terminale integrato (Visualizza -&gt; Terminale) e digitando python hello_world.py.\n\n\n\n\n\n\n5.3.4 Esecuzione nel browser\nPuoi eseguire Python direttamente nel browser, senza installare nulla. Anche qui abbiamo diverse alternative, sia eseguendo il codice localmente, che utilizzando piattaforme online.\n\nRepl.itGoogle ColabPyScript\n\n\n\nVisita repl.it.\nCrea un nuovo progetto selezionando Python.\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nClicca su “Run” per eseguire il programma.\n\n\n\n\nVisita colab.research.google.com.\nCrea un nuovo notebook.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi il pulsante di esecuzione accanto alla cella.\n\n\n\n\nVisita il sito ufficiale di PyScript per ulteriori informazioni su come iniziare.\nCrea un file HTML con il seguente contenuto:\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Hello, World with PyScript&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/latest/pyscript.css\"&gt;\n    &lt;script defer src=\"https://pyscript.net/latest/pyscript.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;py-script&gt;\n        print(\"Hello, World!\")\n    &lt;/py-script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nSalva il file con estensione .html (ad esempio, hello.html).\nApri il file salvato in un browser web. Vedrai l’output Hello, World! direttamente nella pagina.\n\n\n\n\n\n\n5.3.5 Jupyter Notebook\nJupyter Notebook è un ambiente di sviluppo interattivo per la programmazione che permette di creare e condividere documenti contenenti codice eseguibile, visualizzazioni, testo formattato e altro ancora. Originariamente sviluppato come parte del progetto IPython, Jupyter supporta non solo Python, ma anche numerosi altri linguaggi di programmazione attraverso i cosiddetti kernel tra cui R, Julia e Scala.\n\nUso localeJupyterHubBinder\n\n\n\nAssicurati di avere Python e Jupyter installati sul tuo computer. Se non li hai, puoi installarli utilizzando Anaconda o pip:\n\npip install notebook\n\nAvvia Jupyter Notebook dal terminale:\n\njupyter notebook\n\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita l’istanza di JupyterHub della tua istituzione o azienda (maggiori informazioni).\nAccedi con le tue credenziali.\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita mybinder.org.\nInserisci l’URL del repository GitHub che contiene il tuo notebook o il tuo progetto Python.\nClicca su “Launch”.\nUna volta avviato l’ambiente, crea un nuovo notebook o apri uno esistente.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\nBinder è un servizio simile a Colab, anche se quest’ultimo offre strumenti generalmente più avanzati in termini di risorse computazionali e collaborazione. Binder di contro è basato su GitHub e ciò può essere utile in alcuni contesti.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html",
    "href": "seconda-parte-python-sintassi.html",
    "title": "6  La struttura lessicale di Python",
    "section": "",
    "text": "6.1 Righe\nLe righe sono di due tipi: logiche e fisiche. Le seconde sono le più facilmente individuabili nel testo di un programma, perché sono terminate da un carattere di a capo. Una o più righe fisiche costituiscono una riga logica che corrisponde ad una istruzione. Esiste una eccezione, poco usata e consigliata in Python, per cui una riga fisica contiene più istruzioni separate da ;.\nVi sono due modi per dividere una riga logica in righe fisiche. Il primo è terminare con il backslash (\\, poco usata la traduzione barra rovesciata o simili) tutte le righe fisiche meno l’ultima (intendendo con ciò che il backslash precede l’a capo):\nIl secondo è per mezzo di parentesi, giacché tutte le righe fisiche che seguono una con parentesi tonda (, quadra [ o graffa { aperta, fino a quella con l’analoga parentesi chiusa, sono unite in una logica. Le regole di indentazione, che vedremo nel seguito, si applicano solo alla prima riga fisica.\nEsempi sintatticamente corretti ma sconsigliabili, per l’inerente illeggibilità:",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>La struttura lessicale di Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#righe",
    "href": "seconda-parte-python-sintassi.html#righe",
    "title": "6  La struttura lessicale di Python",
    "section": "",
    "text": "1x = 1 + 2 + \\\n     3\n\n2if x &gt; 5 and \\\n3   x &lt; 9:\n  print(\"5 &lt; x &lt; 9\") \n\n1\n\nL’istruzione di assegnamento è spezzata su due righe fisiche.\n\n2\n\nL’istruzione condizionale ha due espressioni che devono essere entrambe vere, ognuna su una riga fisica.\n\n3\n\nNon importa quanto sono indentate le righe fisiche successive alla prima e ciò può essere sfruttato per incrementare la leggibilità, ad esempio, allineando le espressioni x &gt; 5 e x &lt; 9 in colonna.\n\n\n\n\n1x = (1 + 2\n     + 3 + 4)\n\ny = [1, 2, \n2           3, 4 +\n      5] \n\n3z = [1, 2\n     , 3, 4]   \n\n1\n\nL’espressione è spezzata su due righe fisiche e le parentesi tonde rappresentano un’alternativa all’uso del backslash.\n\n2\n\nLe righe fisiche della lista non hanno la stessa indentazione e una espressione è spezzata su due righe.\n\n3\n\nLa lista è spezzata su due righe fisiche e un delimitatore inizia la riga anziché terminare la precedente.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>La struttura lessicale di Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#commenti",
    "href": "seconda-parte-python-sintassi.html#commenti",
    "title": "6  La struttura lessicale di Python",
    "section": "6.2 Commenti",
    "text": "6.2 Commenti\nUn commento inizia con un carattere cancelletto (#) e termina alla fine della riga fisica. I commenti non possono coesistere con il backslash come separatore di riga logica, giacché entrambi devono chiudere la riga fisica.\nEsempi non sintatticamente corretti:\n1x = 1 + 2 + \\ # Commento\n     3\n\n2if x &gt; 5 and # Commento \\\n   x &lt; 9: \n  print(\"5 &lt; x &lt; 9\") \n\n1\n\nIl backslash deve terminare la riga fisica, quindi non può essere seguito da un commento. Se necessario può andare o alla riga successiva, scelta consigliata, o alla precedente. L’interprete segnalerà l’errore SyntaxError.\n\n2\n\nIl commento rende il backslash parte di esso quindi non segnala più la fine della riga fisica e, all’esecuzione, si avrà anche qui un errore di tipo SyntaxError, perché and deve essere seguito da un’espressione.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>La struttura lessicale di Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#indentazione",
    "href": "seconda-parte-python-sintassi.html#indentazione",
    "title": "6  La struttura lessicale di Python",
    "section": "6.3 Indentazione",
    "text": "6.3 Indentazione\nIndentazione significa che spazi o, in alternativa, tabulazioni precedono un carattere che non sia nessuno dei due. Il numero di spazi ottenuto dopo la trasformazione delle tabulazioni in spazi, si definisce livello di indentazione. L’indentazione del codice è il modo che Python utilizza per raggruppare le istruzioni in un blocco, ove tutte devono presentare la medesima indentazione. La prima riga logica che ha una indentazione minore della precedente, segnala che il blocco è stato chiuso proprio da quest’ultima. Anche le clausole di un’istruzione composta devono avere la stessa indentazione.\nLa prima istruzione di un file o la prima inserita al prompt &gt;&gt;&gt; del REPL non deve presentare spazi o tabulazioni, cioè ha un livello di indentazione pari a 0.\nAlcuni esempi:\n\nDefinizione di una funzione:\n1def somma(a, b):\n2  risultato = a + b\n\n  return risultato \n\n1\n\nPrima riga senza indentazione.\n\n2\n\nQuesta riga e la successiva appartengono allo stesso blocco e, pertanto, hanno la medesima indentazione.\n\n\nTest di condizione:\nx = 10\n\n1if x &lt; 0:\n2    print(\"x è negativo\")\n\nelif x == 0: \n      print(\"x è zero\") \n\nelse: \n        print(\"x è positivo\") \n\n1\n\nLe tre clausole if , then e else hanno identica indentazione.\n\n2\n\nI tre blocchi hanno come unico vincolo quello di avere un livello maggiore della riga precedente. I blocchi corrispondenti alle diverse clausole non devono avere lo stesso livello di indentazione, anche se è buona prassi farlo.\n\n\n\n\n\n\n\n\n\nAttenzione\n\n\n\nNon si possono avere sia spazi che tabulazioni per definire il livello di indentazione nello stesso file. Ciò perché renderebbe ambiguo il numero di spazi che si ottiene dopo la trasformazione delle tabulazioni in spazi. Quindi, o si usano spazi, scelta raccomandata, o tabulazioni.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>La struttura lessicale di Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#token",
    "href": "seconda-parte-python-sintassi.html#token",
    "title": "6  La struttura lessicale di Python",
    "section": "6.4 Token",
    "text": "6.4 Token\nLe righe logiche sono composte da token che si categorizzano in parole chiave, identificatori, operatori, delimitatori e letterali. I token sono separati da un numero arbitrario di spazi e tabulazioni. Ad esempio:\nx = 1  +  2  +  3\n\nif    x &gt; 5    and    x &lt; 9: \n  print(\"5 &lt; x &lt; 9\") \n\n6.4.1 Identificatori\nUn identificatore è un nome assegnato ad un oggetto, cioè una variabile, una funzione, una classe, un modulo e altro. Esso è case sensitive cioè python e Python sono due identificatori diversi.\nAlcuni esempi:\nintero = 42  # Identificatore di numero intero\ndecimale = 3.14  # Identificatore di numero decimale\ntesto = \"Ciao, mondo!\"  # Identificatore di stringa\nlista = [1, 2, 3]  # Identificatore di lista\ndizionario = {\"chiave\": \"valore\"}  # Identificatore di dizionario\n\ndef mia_funzione(): # Identificatore di funzione\n  print(\"Questa è una funzione\")\n\n# Classe\nclass MiaClasse: # Identificatore di classe\n  def __init__(self, valore): # Identificatore di metodo e parametro\n    self.valore = valore  # Identificatore di attributo\n    \n  def metodo(self):\n    print(\"Questo è un metodo della classe\")\n\nimport math  # Identificatore di modulo\n\ndef mio_generatore(): # Identificatore di generatore\n  yield 1\n  yield 2\n  yield 3\n\nmio_oggetto = MiaClasse(10)  # Identificatore di istanza\n\n\n6.4.2 Parole chiave\nLe parole chiave sono parole che non possono essere usate per scopi diversi da quelli predefiniti nel linguaggio e, quindi, non possono essere usate come identificatori. Ad esempio, True che rappresenta il valore logico di verità, non può essere usato per definire ad esempio una variabile.\nEsistono anche delle parole chiave contestuali, cioè che sono tali solo in alcuni contesti ed altrove possono essee usate come identificatori. Usiamo il codice seguente per ottenere una lista di parole chiave e parole chiave contestuali:\nimport keyword\n\n# Otteniamo la lista delle parole chiave\nparole_chiave = keyword.kwlist\n\n# Otteniamo la lista delle parole chiave contestuali\nparole_chiave_contestuale = keyword.softkwlist\n\n# Stampiamo la lista delle parole chiave\nprint(parole_chiave)\n\n# Stampiamo la lista delle parole chiave contestuali\nprint(parole_chiave_contestuale)\nNella tabella seguente invece un elenco completo con breve descrizione:\n\n\n\n\n\n\n\nParola chiave\nDescrizione\n\n\n\n\nValori booleani\n\n\n\nFalse\nValore booleano falso\n\n\nTrue\nValore booleano vero\n\n\nOperatori logici\n\n\n\nand\nOperatore logico AND\n\n\nor\nOperatore logico OR\n\n\nnot\nOperatore logico NOT\n\n\nOperatori di controllo di flusso\n\n\n\nif\nUtilizzato per creare un’istruzione condizionale\n\n\nelif\nUtilizzato per aggiungere condizioni in un blocco if\n\n\nelse\nUtilizzato per specificare il blocco di codice da eseguire se le condizioni precedenti sono false\n\n\nfor\nUtilizzato per creare un ciclo for\n\n\nwhile\nUtilizzato per creare un ciclo while\n\n\nbreak\nInterrompe il ciclo in corso\n\n\ncontinue\nSalta l’iterazione corrente del ciclo e passa alla successiva\n\n\npass\nIndica un blocco di codice vuoto\n\n\nreturn\nUtilizzato per restituire un valore da una funzione\n\n\nGestione delle eccezioni\n\n\n\ntry\nUtilizzato per definire un blocco di codice da eseguire e gestire le eccezioni\n\n\nexcept\nUtilizzato per catturare le eccezioni in un blocco try-except\n\n\nfinally\nBlocco di codice che viene eseguito alla fine di un blocco try, indipendentemente dal fatto che si sia verificata un’eccezione\n\n\nraise\nUtilizzato per sollevare un’eccezione\n\n\nDefinizione delle funzioni e classi\n\n\n\ndef\nUtilizzato per definire una funzione\n\n\nclass\nUtilizzato per definire una classe\n\n\nlambda\nUtilizzato per creare funzioni anonime\n\n\nGestione contesto di dichiarazione di variabili\n\n\n\nglobal\nUtilizzato per dichiarare variabili globali\n\n\nnonlocal\nUtilizzato per dichiarare variabili non locali\n\n\nOperazioni su moduli\n\n\n\nimport\nUtilizzato per importare moduli\n\n\nfrom\nUtilizzato per importare specifici elementi da un modulo\n\n\nas\nUtilizzato per creare alias, ad esempio negli import\n\n\nOperatori di identità e appartenenza\n\n\n\nin\nUtilizzato per verificare se un valore esiste in una sequenza\n\n\nis\nOperatore di confronto di identità\n\n\nGestione delle risorse\n\n\n\nwith\nUtilizzato per garantire un’azione di pulizia come il rilascio delle risorse\n\n\nProgrammazione asincrona\n\n\n\nasync\nUtilizzato per definire funzioni asincrone\n\n\nawait\nUtilizzato per attendere un risultato in una funzione asincrona\n\n\nVarie\n\n\n\ndel\nUtilizzato per eliminare oggetti\n\n\nassert\nUtilizzato per le asserzioni, verifica che un’espressione sia vera\n\n\nyield\nUtilizzato per restituire un generatore da una funzione\n\n\nNone\nRappresenta l’assenza di valore o un valore nullo\n\n\nParole chiave contestuali\n\n\n\nmatch\nUtilizzato nell’istruzione match per il pattern matching\n\n\ncase\nUtilizzato nell’istruzione match per definire un ramo\n\n\n_\nUtilizzato come identificatore speciale nell’istruzione match per indicare un pattern di default o ignorare valori\n\n\ntype\nUtilizzato in specifici contesti per dichiarazioni di tipo\n\n\n\nEsempi di uso di parole chiave contestuali:\n\nmatch, case e _:\n1def process_value(value):\n2  match value:\n3    case 1:\n      print(\"Uno\")\n\n    case 2:\n      print(\"Due\")\n\n4    case _:\n      print(\"Altro\")\n\n5match = \"Questo è un identificatore valido\"\n\n# Test della funzione\nprocess_value(1)  # Output: Uno\nprocess_value(2)  # Output: Due\nprocess_value(3)  # Output: Altro\n\n# Stampa della variabile `match`\nprint(match)  # Output: Questo è un identificatore valido\n\n1\n\nDefiniamo una funzione che utilizza il pattern matching.\n\n2\n\nUso di match come parola chiave.\n\n3\n\nUso di case come parola chiave.\n\n4\n\nUso di _ come parola chiave.\n\n5\n\nUtilizzo di match come identificatore per una variabile.\n\n\ntype:\nfrom typing import TypeAlias\n\n1type Point = tuple[float, float]\n\n# Utilizzo dell'alias di tipo\ndef distanza(p1: Point, p2: Point) -&gt; float:\n  return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n# Test della funzione con alias di tipo\npunto1: Point = (1.0, 2.0) \npunto2: Point = (4.0, 6.0)\n\nprint(distanza(punto1, punto2))  # Output: 5.0\n\n2print(type(punto1)) # Output: &lt;class 'tuple'&gt;\n\n1\n\nUso di type come parola chiave.\n\n2\n\nUso di type identificatore di una funzione.\n\n\n\n\n\n6.4.3 Classi riservate di identificatori\nAlcune classi di identificatori (oltre alle parole chiave) hanno significati speciali in Python. Queste classi sono identificate dai pattern di caratteri di sottolineatura (underscore) all’inizio e alla fine dei nomi. Tuttavia, l’uso di questi identificatori non impone limitazioni rigide al programmatore, ma è importante seguire le convenzioni per evitare ambiguità e problemi di compatibilità.\nIdentificatori speciali:\n\n_:\n\nNon importato da from module import *: Gli identificatori che iniziano con un singolo underscore non vengono importati con un’istruzione di importazione globale. Questo è un meccanismo per indicare che tali variabili o funzioni sono destinate ad essere private al modulo e non dovrebbero essere usate direttamente da altri moduli. Esempio:\n# Nel modulo example.py`\n1_private_variable = \"Variabile da non esportare'\"\n\n# In altro modulo diverso da example.py\nfrom example import *\n\n2print(_private_variable)\n\n1\n\nNel modulo example.py viene definita la variabile come privata.\n\n2\n\nGenera un errore: NameError: name '_private_variable' is not defined\n\n\nPattern nei match: Nel contesto di un pattern di corrispondenza all’interno di un’istruzione match, _ è una parola chiave contestuale che denota un wildcard (carattere jolly), coem indicato sopra.\nInterprete interattivo: L’interprete interattivo rende disponibile il risultato dell’ultima valutazione nella variabile _. Il valore di _ è memorizzato nel modulo builtins, insieme ad altre funzioni e variabili predefinite come print(), permettendo l’accesso globale a _ durante una sessione interattiva. Esempio:\nresult = 5 + 3\nprint(_)  # Output: 8 (nell'interprete interattivo)\nAltro uso: Altrove, _ è un identificatore regolare. Viene spesso usato per nominare elementi speciali per l’utente, ma non speciali per Python stesso. Il nome _ è comunemente usato in congiunzione con l’internazionalizzazione (vedi la documentazione del modulo gettext per ulteriori informazioni su questa convenzione) ed è anche comunemente utilizzato per variabili non usate. Esempio:\n1_ = \"Valore non usato\"\n\nimport gettext\n\ngettext.install('myapplication')\n\n2print(_('Hello, world'))\n\n1\n\nUso di _ come variabile regolare.\n\n2\n\nUso di _ per internazionalizzazione.\n\n\n\n__*__: Questi nomi, informalmente noti come nomi dunder1, sono definiti dall’interprete e dalla sua implementazione (inclusa la libreria standard). Altri potrebbero essere definiti nelle versioni future di Python. Qualsiasi uso di nomi __*__, in qualsiasi contesto, che non segua l’uso esplicitamente documentato, è soggetto a discontinuazione senza preavviso. Esempio:\nclass MyClass:\n1  def __init__(self, value):\n    self.__value = value\n\n  def __str__(self):\n2    return f\"MyClass con valore {self.__value}\"\n\nobj = MyClass(10)\n\n3print(obj)\n\n1\n\nDunder per metodo chiamato alla creazione dell’oggetto.\n\n2\n\nDunder chiamato da print con parametro l’oggetto.\n\n3\n\nOutput: MyClass con valore 10\n\n\n__*: I nomi in questa categoria, quando utilizzati all’interno di una definizione di classe, vengono riscritti dal compilatore (processo noto come name mangling) per evitare conflitti di nome tra attributi “privati” delle classi base e delle classi derivate. Questo aiuta a garantire che gli attributi destinati ad essere privati non vengano accidentalmente sovrascritti nelle sottoclassi. Esempio:\nclass BaseClass:\n  def __init__(self):\n    self.__private_attr = \"Base\"\n\nclass DerivedClass(BaseClass):\n  def __init__(self):\n    super().__init__()\n\n    self.__private_attr = \"Derived\"\n\nbase_obj = BaseClass()\nderived_obj = DerivedClass()\n\n1print(base_obj._BaseClass__private_attr)\n2print(derived_obj._DerivedClass__private_attr)\n\n1\n\nAccesso al nome di BaseClass.\n\n2\n\nAccesso al nome di DerivedClass.\n\n\n\n1 I nomi con doppio underscore (__) sono chiamati dunder come abbreviazione di double underscore.\n\n6.4.4 Operatori\nGli operatori sono rappresentati da simboli non alfanumerici e, quando applicati a uno o più identificatori, letterali o espressioni (definiti genericamente operandi), producono un risultato. Attenzione a non confondere la definizione di operatore come token, come considerata qui, con quella di operatore come funzionalità algoritmica, poiché alcune parole chiave sono operatori algoritmici e anche le funzioni possono agire come operatori.\nEsempi:\nx = 5\ny = 10\n\n1z = x + y\n\n2sum = 3 + 4\n\n3result = (x * y) + (z / 2)\n\n1\n\nUtilizza l’operatore + sugli identificatori x e y.\n\n2\n\nUtilizza l’operatore + su letterali.\n\n3\n\nUtilizza vari operatori su espressioni.\n\n\nIn tabella l’elenco degli operatori:\n\n\n\n\n\n\n\n\nTipo di operatore\nOperatore\nDescrizione\n\n\n\n\nAritmetici\n+\nAddizione\n\n\n\n-\nSottrazione\n\n\n\n*\nMoltiplicazione\n\n\n\n/\nDivisione\n\n\n\n//\nDivisione intera\n\n\n\n%\nModulo\n\n\n\n**\nEsponenziazione\n\n\n\n@\nMatrice (operatore di moltiplicazione)\n\n\nConfronto\n&lt;\nMinore\n\n\n\n&gt;\nMaggiore\n\n\n\n&lt;=\nMinore o uguale\n\n\n\n&gt;=\nMaggiore o uguale\n\n\n\n==\nUguale\n\n\n\n!=\nDiverso\n\n\nBitwise\n&\nAND bit a bit\n\n\n\n|\nOR bit a bit\n\n\n\n^\nXOR bit a bit\n\n\n\n~\nNOT bit a bit\n\n\n\n&lt;&lt;\nShift a sinistra\n\n\n\n&gt;&gt;\nShift a destra\n\n\nAssegnazione\n:=\nOperatore di assegnazione in espressione (walrus o tricheco)\n\n\n\nEsempio su @ che illustra un aspetto importante: il comportamento degli operatori può (o meglio, deve) essere definito quando si creano dei tipi di oggetto. Infatti, nel codice seguente, è definita una matrice assieme a una delle operazioni matematiche più comuni che è la moltiplicazione, implementata per mezzo di __matmul__:\nclass Matrice:\n  def __init__(self, righe):\n    self.righe = righe\n    self.num_righe = len(righe)\n    self.num_colonne = len(righe[0]) if righe else 0\n\n  def __matmul__(self, altra):\n1    if self.num_colonne != altra.num_righe:\n      raise ValueError(\"Non è possibile moltiplicare le matrici: \"\n                       \"dimensioni incompatibili.\")\n    \n2    risultato = [[0 for _ in range(altra.num_colonne)]\n           for _ in range(self.num_righe)]\n    \n3    for i in range(self.num_righe):\n      for j in range(altra.num_colonne):\n        for k in range(self.num_colonne):\n          risultato[i][j] += (self.righe[i][k] *\n                    altra.righe[k][j])\n    \n    return Matrice(risultato)\n\n4  def __repr__(self):\n    return '\\n'.join([' '.join(map(str, riga)) for riga in self.righe])\n\n# Definizione di due matrici\nA = Matrice([[1, 2], \n             [3, 4]])\nB = Matrice([[5, 6], \n             [7, 8]])\n\n# Moltiplicazione di matrici utilizzando l'operatore @\nC = A @ B\n\nprint(\"Matrice A:\")\nprint(A)\n\nprint(\"Matrice B:\")\nprint(B)\n\nprint(\"Risultato di A @ B:\")\n5print(C)\n\n1\n\nControlla se le dimensioni sono compatibili per la moltiplicazione.\n\n2\n\nInizializza la matrice risultato con zeri.\n\n3\n\nEsegue la moltiplicazione delle matrici.\n\n4\n\nRappresentazione leggibile della matrice.\n\n5\n\nChiama __matmul__ per ottenere la stringa su due righe: 19 22 e 43 50.\n\n\nInfine, @ è anche un delimitatore.\n\n\n6.4.5 Delimitatori\nIn Python, alcuni token servono come delimitatori nella grammatica del linguaggio. I delimitatori sono caratteri che separano le varie componenti del codice, come espressioni, blocchi di codice, parametri di funzioni e istruzioni.\nLa seguente tabella include tutti i delimitatori e i principali utilizzi:\n\n\n\n\n\n\n\nDelimitatore\nDescrizione\n\n\n\n\n(\nUtilizzata per raggruppare espressioni, chiamate di funzione e definizioni di tupla\n\n\n)\nUtilizzata per chiudere le parentesi tonde aperte\n\n\n[\nUtilizzate per definire liste e accedere agli elementi delle liste, tuple, o stringhe\n\n\n]\nUtilizzate per chiudere le parentesi quadre aperte\n\n\n{\nUtilizzate per definire dizionari e set\n\n\n}\nUtilizzate per chiudere le parentesi graffe aperte\n\n\n,\nUtilizzata per separare elementi in liste, tuple, e argomenti nelle chiamate di funzione\n\n\n:\nUtilizzato per definire blocchi di codice (come in if, for, while, def, class) e per gli slice\n\n\n.\nUtilizzato per accedere agli attributi di un oggetto. Può apparire in letterali decimnali e immaginari\n\n\n;\nUtilizzato per separare istruzioni multiple sulla stessa riga\n\n\n@\nUtilizzato per dichiarare decoratori per funzioni e metodi\n\n\n=\nOperatore utilizzato per assegnare valori a variabili\n\n\n-&gt;\nAnnotazione del tipo di ritorno delle funzioni\n\n\n+=\nAssegnazione aumentata con addizione. Aggiunge il valore a destra a quello a sinistra e assegna il risultato alla variabile a sinistra. Come i successivi, è sia un delimitatore che un operatore\n\n\n-=\nAssegnazione aumentata con sottrazione\n\n\n*=\nAssegnazione aumentata con moltiplicazione\n\n\n/=\nAssegnazione aumentata con divisione\n\n\n//=\nAssegnazione aumentata con divisione intera\n\n\n%=\nAssegnazione aumentata con modulo\n\n\n@=\nAssegnazione aumentata con moltiplicazione di matrici\n\n\n&=\nAssegnazione aumentata con AND bit a bit\n\n\n|=\nAssegnazione aumentata con OR bit a bit\n\n\n^=\nAssegnazione aumentata con XOR bit a bit\n\n\n&gt;&gt;=\nAssegnazione aumentata con shift a destra\n\n\n&lt;&lt;=\nAssegnazione aumentata con shift a sinistra\n\n\n**=\nAssegnazione aumentata con esponenziazione\n\n\n\nUna sequenza di tre punti, comunemente indicata come ellissi anche al difuori dei linguaggi di programmazione,2 è trattata come un token a sé e corrisponde ad un oggetto predefinito chiamato Ellipsis, con applicazioni in diversi contesti:\n2 L’ellissi è usata, ad esempio, in C per dichiarare funzioni che accettano un numero variaible di parametri e i Javascript come operatore per espandere gli array o le proprietà di un oggetto.1print(type(...))\n\ndef funzione_da_completare():\n2  ...\n\nclass ClasseEsempio:\n  def metodo_da_completare(self):\n    ...\n\nfrom typing import Callable\n\n3def funzione_variadica(func: Callable[..., int]):\n  pass\n\nimport numpy as np\n\narray = np.array([[[1, 2, 3],    [4, 5, 6]], \n                  [[7, 8, 9], [10, 11, 12]]]) \n\n4print(array[..., 1])\n\n1\n\nOtteniamo il tipo dell’oggetto ellissi. L’output è &lt;class 'ellipsis'&gt;.\n\n2\n\nUtilizzo come segnaposto per indicare che la funzione è da completare. Da notare che chiamare la funzione funzione_da_completare() non dà errore.\n\n3\n\nL’uso di Callable[..., int] indica una funzione che può accettare un numero variabile di argomenti di qualsiasi tipo e restituire un valore di tipo int.\n\n4\n\nnumpy è una libreria di calcolo matriciale molto diffusa. L’ellissi è utilizzata per effettuare uno sezione complessa della matrice secondo tutte le dimensioni precedenti all’ultima. In altre parole, l’ellissi permette di selezionare interamente tutte le dimensioni tranne l’ultima specificata. Il risultato stampato in console è su due righe: [[ 2  5] e [ 8 11]].\n\n\nAlcuni caratteri ASCII hanno un significato speciale come parte di altri token o sono significativi per l’analizzatore lessicale:\n\n\n\n\n\n\n\nCarattere\nDescrizione\n\n\n\n\n'\nUtilizzato per definire stringhe di caratteri.\n\n\n\"\nUtilizzato per definire stringhe di caratteri.\n\n\n#\nSimbolo di commento. Utilizzato per indicare un commento, che viene ignorato dall’interprete Python.\n\n\n\\\nBackslash. Utilizzato per caratteri di escape nelle stringhe e per continuare le righe di codice su più righe fisiche.\n\n\n\nAlcuni caratteri ASCII non sono utilizzati in Python e la loro presenza al difuori dei letterali di stringa e dei commenti genera un errore: $, ?, `.\n\n\n6.4.6 Letterali\nI letterali sono notazioni per valori costanti di alcuni tipi predefiniti nel linguaggio. Esistono diversi tipi di letterali, ognuno rappresenta un tipo di dato specifico e ha una sintassi particolare.\n\n6.4.6.1 Numerici\nI letterali numerici includono interi, numeri a virgola mobile e numeri complessi:\n\nInteri, possono essere scritti in base decimale, ottale, esadecimale o binaria:\n\nDecimale: 10, -3.\nOttale: 0o12, -0o7.\nEsadecimale: 0xA, -0x1F.\nBinario: 0b1010, -0b11.\n\nVirgola mobile, possono essere rappresentati con una parte intera e una decimale, oppure con notazione scientifica:\n\nVirgola mobile: 3.14, -0.001.\nNotazione scientifica: 1e10, -2.5e-3.\n\nComplessi, appresentati da una parte reale e una parte immaginaria: 3+4j, -1-0.5j.\n\n\n\n6.4.6.2 Stringhe\nI letterali di stringa possono essere racchiusi tra virgolette singole o doppie. Possono anche essere multi-linea se racchiusi tra triple virgolette singole o doppie:\n\nStringhe racchiuse tra virgolette singole o doppie:\n\nSingole: 'ciao'.\nDoppie: \"mondo\".\n\nStringhe multi-linea racchiuse tra triple virgolette singole o doppie:\n\nTriple singole: '''testo multi-linea'''.\nTriple doppie: \"\"\"testo multi-linea\"\"\".\n\n\nLe stringhe tra tripli apici possono avere degli a capo e degli apici (non tripli) all’interno.\nEsempio:\nstringa_multilinea = \"\"\"Questa è una stringa\nmolto \"importante\".\"\"\"\n\nprint(stringa_multilinea)\nTutte le stringhe sono codificate in Unicode, con il prefisso b la stringa è di tipo byte ed è limitata ai 128 caratteri dell’ASCII. Se si prepone r, che sta per raw cioè grezzo, allora la codifica è sempre Unicode ma i caratteri di escape3 non sono intepretati.\n3 In Python, il carattere di escape \\ è utilizzato nelle stringhe per inserire caratteri speciali che non possono essere facilmente digitati sulla tastiera o che hanno significati speciali.\nAlcuni esempi comuni includono:\n\n\\n per una nuova linea (linefeed).\n\\t per una tabulazione.\n\\\\ per inserire un backslash.\n\\' per un apostrofo.\n\\\" per una doppia virgoletta.\n\nQuesti caratteri permettono di includere simboli speciali nelle stringhe senza interrompere la sintassi del codice.\n\n6.4.6.3 F-stringhe\nLe f-stringhe (stringhe formattate) sono racchiuse tra virgolette singole, doppie o triple e sono precedute dal prefisso f o F. Permettono di includere espressioni Python all’interno.\nSi possono avere stringhe formattate grezze ma non byte.\nEsempio:\nnome = \"Python\"\n\n1f_stringa = f'Ciao, {nome.upper()}!'\n\ndefinizione = \"Linguaggio\"\n\nf_stringa_multi_linea = f'''Questo è un esempio\ndi f-stringa multi-linea\n2in {definizione.lower() + ' ' + nome}'''\n\n3print(f_stringa)\n\n4print(f_stringa_multi_linea)\n\n1\n\nViene chiamato il metodo della stringa lower() per avere il maiuscolo.\n\n2\n\nUsiamo un’espressione di concatenazione di stringhe.\n\n3\n\nOutput: Output: Ciao, python!.\n\n4\n\nOutput composto dalle tre righe Questo è un esempio, di f-stringa multi-linea e in linguaggio Python.",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>La struttura lessicale di Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#istruzioni",
    "href": "seconda-parte-python-sintassi.html#istruzioni",
    "title": "6  La struttura lessicale di Python",
    "section": "6.5 Istruzioni",
    "text": "6.5 Istruzioni\nUn programma Python è una sequenza di istruzioni che si distinguono in semplici e composte.\n\n6.5.1 Istruzioni semplici\nUn’istruzione semplice è sempre contenuta in una riga logica, che può presentare più istruzioni semplici separate da ;. È permesso ma scaonsigliato perché in pochi casi porta a codice leggibile.\nIn Python, le istruzioni semplici sono:\n\nAssegnazione, attribuisce un valore a una variabile:\nx = 10\nIstruzioni di importazione, permettono di utilizzare gli identificatori definiti in altri moduli:\nimport math\nfrom math import sqrt\nIstruzioni di controllo del flusso nei cicli:\n\nbreak: Interrompe un ciclo.\ncontinue: Salta all’iterazione successiva di un ciclo.\npass: Non esegue alcuna operazione.\n\nfor i in range(10):\n    if i == 5:\n        break\nIstruzioni di gestione dell’uscita da una funzione, della generazione di valori o del sollevamento di eccezioni:\n\nreturn: Restituisce un valore da una funzione.\nyield: Restituisce un generatore.\nraise: Solleva un’eccezione per segnalare uan condizione di errore.\n\ndef func():\n    return x\nIstruzioni di asserzione in cui si verifica una condizione e viene generata un’eccezione se la condizione è falsa:\nassert x &gt; 0, \"x deve essere positivo\"\nIstruzioni di diichiarazione di modifica dell’ambito di variabili:\nglobal x\nnonlocal y\n\nUn’espressione è una istruzione semplice ed, infatti, inserita nel REPL, ne viene prodotto il risultato della valutazione. D’altronde, una espressione è spesso utilizzata per chiamare funzioni che hanno effetti collaterali, come, ad esempio, produrre un output:\n\nProduzione di output:\n# Funzione che stampa un messaggio\ndef stampa_messaggio(messaggio):\n  print(messaggio)\n\n# Istruzione di espressione che chiama la funzione \n# con un effetto collaterale (stampa del messaggio)\nstampa_messaggio(\"Ciao, mondo!\")\nModifica di parametri:\n# Funzione che modifica un argomento mutabile (lista)\ndef aggiungi_elemento(lista, elemento):\n  lista.append(elemento)\n\n# Lista iniziale\nnumeri = [1, 2, 3]\n\n# Istruzione di espressione che chiama la funzione \n# con un effetto collaterale (modifica dell'argomento)\naggiungi_elemento(numeri, 4)\n\nprint(numeri)  # Output: [1, 2, 3, 4]\nModifica di variabili globali:\n# Variabile globale\ncontatore = 0\n\n# Funzione che modifica una variabile globale\ndef incrementa_contatore():\n  global contatore\n\n  contatore += 1\n\n# Istruzione di espressione che chiama la funzione \n# con un effetto collaterale (modifica della variabile globale)\nincrementa_contatore()\n\nprint(contatore)  # Output: 1\nLancio di eccezioni:\n# Funzione che solleva un'eccezione\ndef solleva_eccezione(messaggio):\n  raise ValueError(messaggio)\n\n# Istruzione di espressione che chiama la funzione con un effetto collaterale (sollevamento di un'eccezione)\ntry:\n  solleva_eccezione(\"Qualcosa è andato storto!\")\n\nexcept ValueError as e:\n  print(e)  # Output: Qualcosa è andato storto!\n\nUn assegnamento con = è anch’esso un’istruzione semplice e non può mai essere all’interno di una espressione, dove, invece, si può usare l’operatore tricheco :=:\nif (n := len(\"Python\")) &gt; 5:\n  print(f\"La lunghezza della stringa è {n}\") \n  # Output: La lunghezza della stringa è 6\n\n\n6.5.2 Istruzioni composte\nUna istruzione composta è costituita da altre istruzioni (semplici o composte). Il controllo dell’esecuzione delle istruzioni componenti avviene per mezzo di una o più clausole che iniziano tutte con una parola chiave, sono terminate da : e seguite da un blocco di codice. Ogni blocco deve avere almeno una istruzione semplice, ma può non avere una propria riga logica, cioè stare sulla stessa riga fisica e logica del :.\nAlcuni esempi del rapporto tra istruzioni e righe:\n\nBlocco di istruzioni separato su più righe con medesima indentazione:\nif x &gt; 0:\n  print(\"x è positivo\")\n\n  x += 1\n\n  print(f\"x ora è {x}\")\nBlocco come singola istruzione sulla stessa riga logica:\nif x &gt; 0: print(\"x è positivo\")\nDiverse istruzioni semplici sulla stessa riga logica (non consigliato):\nif x &gt; 0: print(\"x è positivo\"); x += 1; print(f\"x ora è {x}\")\n\nEd ecco le principali istruzioni composte:\n\nif, controlla l’esecuzione di un blocco di codice in base a una condizione:\nif condizione:\n    # blocco di codice\nfor, itera su una sequenza (come una lista, una tupla o una stringa):\nfor elemento in sequenza:\n    # blocco di codice\nwhile, esegue un blocco di codice finché una condizione è vera:\nwhile condizione:\n    # blocco di codice\ntry, gestisce gli errori che possono verificarsi durante l’esecuzione di un blocco di codice:\ntry:\n    # blocco di codice\nexcept Eccezione:\n    # blocco di codice per gestire l'eccezione\nwith, gestisce l’allocazione e la deallocazione di risorse:\nwith open('file.txt', 'r') as file:\n    # blocco di codice\ndef, definisce una funzione:\ndef nome_funzione(parametri):\n    # blocco di codice\nclass, definisce una classe:\nclass NomeClasse:\n    # blocco di codice\nmatch, esegue il pattern matching su un valore:\nmatch valore:\n    case pattern:\n        # blocco di codice",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>La struttura lessicale di Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html",
    "href": "seconda-parte-esercizi.html",
    "title": "8  Esercizi",
    "section": "",
    "text": "8.1 Funzioni e istruzioni composte",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-esercizi.html#funzioni-e-istruzioni-composte",
    "href": "seconda-parte-esercizi.html#funzioni-e-istruzioni-composte",
    "title": "8  Esercizi",
    "section": "",
    "text": "8.1.1 ★ ☆ ☆ ☆ ☆ Numeri pari o dispari\nDefinire una funzione che prende in input un numero intero e restituisce una stringa di Pari o Dispari.\n\n8.1.1.1 Soluzione 1: test con operatore modulo\n\n\nMostra il codice\ndef pari_o_dispari(n):\n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\n\n\n\n8.1.1.2 Soluzione 2: test con operatore modulo e controllo degli input\n\n\nMostra il codice\ndef pari_o_dispari(n):\n    if not isinstance(n, int):\n        return \"Errore: l'input deve essere un numero intero!\"\n    \n    if n % 2 == 0:\n        return \"Pari\"\n\n    else:\n        return \"Dispari\"\n\n\n\n\n8.1.1.3 Soluzione 3: test con operatore modulo e generazione di errore su input non intero\n\n\nMostra il codice\ndef pari_o_dispari(n):\n    assert isinstance(n, int), \\\n      \"Errore: l'input deve essere un numero intero!\"\n    \n    if n % 2 == 0:\n        return \"Pari\"\n    else:\n        return \"Dispari\"\n\n\n\n\n8.1.1.4 Soluzione 4: uso di funzione built-in\n\n\nMostra il codice\ndef pari_o_dispari(n):\n    _, remainder = divmod(n, 2)\n\n    return \"Pari\" if remainder == 0 else \"Dispari\"",
    "crumbs": [
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "appendice-riferimenti.html",
    "href": "appendice-riferimenti.html",
    "title": "Riferimenti",
    "section": "",
    "text": "Kernighan, Brian W. 1973. “A Tutorial Introduction to the\nProgramming Language b.” Murray Hill, NJ: Bell Laboratories.\n\n\nKernighan, Brian W., and Dennis M. Ritchie. 1988. The c Programming\nLanguage. 2nd ed. Englewood Cliffs, NJ: Prentice Hall.\n\n\nStone, Harold S. 1971. Introduction to Computer Organization and\nData Structures. USA: https://dl.acm.org/doi/10.5555/578826; McGraw-Hill, Inc.\n\n\nStroustrup, Bjarne. 2013. The c++ Programming Language. 4th ed.\nhttps://dl.acm.org/doi/10.5555/2543987; Addison-Wesley\nProfessional.",
    "crumbs": [
      "Appendici",
      "Riferimenti"
    ]
  }
]