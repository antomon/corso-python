[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Prefazione\nNel 2024, il panorama tecnologico è stato radicalmente trasformato dai progressi dell’Intelligenza Artificiale (IA) generativa. Gli strumenti di IA sono ora in grado di scrivere codice, creare contenuti e risolvere problemi complessi in modo autonomo. Tuttavia, nonostante questi straordinari progressi, imparare un linguaggio di programmazione rimane una competenza fondamentale e preziosa. La capacità di programmare permette agli individui non solo di comprendere come funzionano gli strumenti tecnologici che utilizzano quotidianamente, ma anche di personalizzare e sviluppare nuove soluzioni su misura per le proprie esigenze specifiche.\nGli strumenti di IA generativa possono automatizzare molte attività, ma comprendere il codice che generano richiede comunque una conoscenza approfondita della programmazione. Sapere come funziona un programma aiuta a diagnosticare e risolvere problemi in modo più efficace. Le soluzioni create da strumenti di IA possono essere generalizzate, ma imparare a programmare consente agli individui di creare soluzioni su misura per problemi specifici, innovare e andare oltre ciò che è possibile con gli strumenti standard.\nLa programmazione sviluppa abilità di pensiero critico e logico, essenziali non solo per la tecnologia ma anche per risolvere problemi in molti altri campi. La programmazione non è solo per sviluppatori di software. In settori come la scienza, l’ingegneria, la finanza, e persino le arti, la capacità di programmare può fornire un vantaggio significativo, migliorando l’efficienza e aprendo nuove possibilità di analisi e creazione. Imparare a programmare stimola la creatività e l’abilità di pensare in modo sistematico, due qualità che sono utili in qualsiasi campo.\nPython è ampiamente riconosciuto come uno dei migliori linguaggi di programmazione per principianti e per esperti provenienti da altri linguaggi, grazie alle sue numerose caratteristiche vantaggiose. Python è un linguaggio di programmazione di alto livello, il che significa che è progettato per essere facile da leggere e scrivere. Le sue sintassi semplici e chiare riducono la complessità della programmazione, permettendo agli studenti di concentrarsi sui concetti fondamentali senza essere ostacolati dai dettagli tecnici.\nPython supporta vari paradigmi di programmazione, tra cui la programmazione procedurale, la programmazione orientata agli oggetti e la programmazione funzionale. Questo rende Python estremamente versatile e permette agli studenti di esplorare e padroneggiare diversi stili di programmazione all’interno dello stesso linguaggio. Inoltre, Python ha una delle comunità di sviluppatori più grandi e attive al mondo. Questa comunità contribuisce continuamente allo sviluppo del linguaggio e delle sue librerie, offre supporto attraverso forum, tutorial, e documentazione, e crea una vasta gamma di risorse didattiche accessibili.\nPython dispone di un ecosistema vasto e in continua crescita di librerie e framework per una vasta gamma di applicazioni, tra cui sviluppo web (Django, Flask), scienza dei dati (pandas, NumPy, SciPy), intelligenza artificiale e machine learning (TensorFlow, Keras, PyTorch), automazione, sviluppo di giochi (Pygame), e molto altro ancora. Questa diversità consente agli studenti di applicare Python a numerosi campi e di sviluppare progetti interessanti e rilevanti.\nImparare Python non è solo un passo fondamentale per diventare un programmatore competente, ma è anche un modo per comprendere meglio la tecnologia che ci circonda e per essere in grado di contribuire attivamente all’innovazione. Con la sua semplicità, versatilità e supporto comunitario, Python rappresenta una scelta ideale per chiunque desideri iniziare il proprio viaggio nel mondo della programmazione o per chi vuole aggiungere un potente strumento al proprio arsenale tecnologico.\nL’obiettivo di questo corso è di guidarti attraverso le basi di Python, fornendoti una comprensione solida e completa del linguaggio. Spero che troverai questo corso utile e stimolante, e che ti ispiri a esplorare ulteriormente il mondo della programmazione.\nBuon apprendimento!",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html",
    "href": "prima-parte-linguaggi-programmazione.html",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "",
    "text": "1.1 Definizioni\nLa programmazione è il processo di ideazione e scrittura di istruzioni, nella forma statica, ad esempio un file di testo, identificate come codice sorgente, che un computer può ricevere per eseguire compiti predefiniti. Queste istruzioni sono codificate in un linguaggio di programmazione, che traduce gli algoritmi e le finalità del programmatore, in un formato comprensibile ed eseguibile dal computer.\nUn programma informatico è una sequenza di istruzioni scritte per eseguire una specifica operazione o un insieme di operazioni su un computer. Queste istruzioni sono codificate ino dei linguaggi che il computer specifico può comprendere e utilizzare per eseguire attività come calcoli, manipolazione di dati, controllo di dispositivi e interazione con l’utente. Pensate a un programma come a una ricetta di cucina. La ricetta elenca gli ingredienti necessari (dati) e fornisce istruzioni passo-passo (algoritmo) per preparare un piatto. Allo stesso modo, un programma informatico specifica i dati da usare e le istruzioni da seguire per ottenere un risultato desiderato.\nUn linguaggio di programmazione è un linguaggio formale che fornisce un insieme di regole e sintassi per scrivere programmi informatici. Questi linguaggi permettono ai programmatori di comunicare con i computer e di creare software da distribuire al difuori di quello usato per la creazione. Alcuni esempi di linguaggi di programmazione includono Python, Java, C++, SQL, Rust, Haskell, Prolog, C, Assembly, Fortran, JavaScript e altre centinaia (o forse migliaia) (List of programming languages, Wikipedia).3",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#definizioni",
    "href": "prima-parte-linguaggi-programmazione.html#definizioni",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "",
    "text": "3 WikipediaList of programming languageshttps://en.wikipedia.org/wiki/List_of_programming_languagesAccessed: 2024-07-09.\nWikipediaList of programming languageshttps://en.wikipedia.org/wiki/List_of_programming_languagesAccessed: 2024-07-09.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#linguaggi-naturali-e-di-programmazione",
    "href": "prima-parte-linguaggi-programmazione.html#linguaggi-naturali-e-di-programmazione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.2 Linguaggi naturali e di programmazione",
    "text": "1.2 Linguaggi naturali e di programmazione\nI linguaggi di programmazione hanno dei punti in comune e delle differenze coi linguaggi naturali (come l’italiano o l’inglese). Quest’ultime sono principalmente:\n\nPrecisione e rigidità: I linguaggi di programmazione sono estremamente precisi e rigidi. Ogni istruzione deve essere scritta in un modo specifico affinché il computer possa comprenderla ed eseguirla correttamente. Anche un piccolo errore di sintassi può impedire il funzionamento di un programma.\nAmbiguità: I linguaggi naturali sono spesso ambigui e aperti a interpretazioni. Le stesse parole possono avere significati diversi a seconda del contesto. I linguaggi di programmazione, invece, sono progettati per essere privi di ambiguità; ogni istruzione ha un significato preciso e univoco.\nVocabolario limitato: I linguaggi naturali hanno un vocabolario vastissimo e in continua espansione. I linguaggi di programmazione, al contrario, hanno un vocabolario limitato costituito da parole chiave e comandi definiti dal linguaggio stesso.\nForma di mediazione: I linguaggi naturali sono direttamente utilizzati per comunicare, quelli di programmazione non sono comprensibili immediatamente dai computer, ma devono essere tradotti in una forma opportuna per mezzo di programmi ad hoc.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#algoritmi",
    "href": "prima-parte-linguaggi-programmazione.html#algoritmi",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.3 Algoritmi",
    "text": "1.3 Algoritmi\nUn algoritmo è\n\nUn insieme di regole che definiscono con precisione una sequenza di operazioni”.4\n4 H. S. StoneIntroduction to Computer Organization and Data Structureshttps://dl.acm.org/doi/10.5555/578826; McGraw-Hill, Inc., USA0070617260.\nH. S. StoneIntroduction to Computer Organization and Data Structureshttps://dl.acm.org/doi/10.5555/578826; McGraw-Hill, Inc., USA0070617260.\n\nTale definizione, per quanto generica, coglie i due aspetti fondanti, cioè regole, intese come prescrizioni sintattiche o semantiche, che si traducono in operazioni richieste ad un agente, umano o informatico.\nIn altre parole, un algoritmo è una sequenza ben definita di passi o operazioni ben codificata, che, a partire da un input, produce un output in un tempo finito e, quindi, presenta la seguente serie di caratteristiche:\n\nFinitudine: L’algoritmo deve terminare dopo un numero finito di passi.\nDeterminismo: Ogni passo dell’algoritmo deve essere definito in modo preciso e non ambiguo.\nInput: L’algoritmo riceve zero o più dati in ingresso.\nOutput: L’algoritmo produce uno o più risultati.\nEffettività: Ogni operazione dell’algoritmo deve essere fattibile ed eseguibile in un tempo finito.\n\nPer un testo introduttivo si può far riferimento a.5\n5 J. EricksonAlgorithmsIndependenthttps://www.amazon.it/Algorithms-Jeff-Erickson/dp/1792644833https://jeffe.cs.illinois.edu/teaching/algorithms/.\nJ. EricksonAlgorithmsIndependenthttps://www.amazon.it/Algorithms-Jeff-Erickson/dp/1792644833https://jeffe.cs.illinois.edu/teaching/algorithms/.\n\n1.3.1 Rappresentazione\nUn algoritmo è un concetto astratto, esistente come idea nella mente di chi lo crea. Quando si vuole condividere un algoritmo con qualcun altro, è cruciale scegliere una rappresentazione che lo comunichi in modo completo e accurato. Alcune rappresentazioni di algoritmi sono comprensibili solo dagli esseri umani, come quelle che utilizzano il linguaggio naturale o i diagrammi. Al contrario, un programma è una rappresentazione di un algoritmo destinata ad essere leggibile da una macchina, generalmente un computer. L’esecuzione di un programma da parte di un computer è detta processo.\nRappresentare un algoritmo richiede, pertanto, l’uso di un insieme di simboli e di regole di combinazione dei medesimi. I simboli fondamentali utilizzati per rappresentare gli algoritmi sono chiamati primitivi. Questi primitivi rappresentano le operazioni base, le unità minime di lavoro che un algoritmo può eseguire. Devono essere combinati seguendo una specifica sintassi, che è l’insieme delle regole che definiscono come questi simboli possono essere correttamente organizzati per formare istruzioni.\nQuando i simboli primitivi sono assemblati secondo la sintassi corretta, il risultato è una rappresentazione significativa dell’algoritmo, ovvero la sua semantica. Le istruzioni create combinando questi primitivi costituiscono il codice sorgente di un programma, che può essere eseguito da un computer per realizzare l’algoritmo desiderato.\nLa sintassi di un linguaggio di programmazione determina come appare un programma, mentre la semantica determina cosa significa il programma e come esegue l’algoritmo.\nAlcuni esempi di rappresentazione degli algoritmi includono:\n\nLinguaggio naturale: Rappresentazioni verbali utilizzabili dagli esseri umani.\nDiagrammi: Rappresentazioni visive come i flowchart.\nPseudocodice: Notazione semi-formale usata principalmente per la comprensione umana.\nCodice sorgente: Rappresentazioni formali in un linguaggio di programmazione specifico.\n\nUn esempio di algoritmo è dato dall’ordinamento di una lista di numeri interi. Le rappresentazioni di quello che ex-post è il Bubble Sort, sono:\n\nLinguaggio naturale: Gli elementi adiacenti vengono scambiati se sono nell’ordine sbagliato e ciò prosegue fino a quando tutto l’elenco risulti ordinato.\nDiagramma di flusso:\nflowchart TD\n    Start --&gt; Controlla(Sono presenti elementi da confrontare?)\n    Controlla -- No --&gt; End(Fine)\n    Controlla -- Sì --&gt; Confronta(Confronta elementi adiacenti)\n    Confronta --&gt; Scambia(Gli elementi sono nell'ordine sbagliato?)\n    Scambia -- Sì --&gt; ScambiaElementi(Scambia gli elementi)\n    Scambia -- No --&gt; ProssimoElemento(Passa al prossimo elemento)\n    ScambiaElementi --&gt; ProssimoElemento\n    ProssimoElemento --&gt; Controlla\nPseudocodice:\nprocedure BubbleSort(A: lista di elementi ordinabili)\n  n := lunghezza(A)\n\n  repeat\n    scambiato := falso\n\n    for i := 1 to n-1 inclusive do\n      if A[i-1] &gt; A[i] then\n        scambia(A[i-1], A[i])\n\n        scambiato := vero\n\n      end if\n\n    end for\n\n    n := n - 1\n\n  until not scambiato\n\nend procedure\n\nNel seguito sarà data anche una rappresentazione in codice sorgente Python.\nIn questo esempio, abbiamo rappresentato l’algoritmo Bubble Sort in vari modi per dimostrare come un singolo algoritmo possa essere descritto e compreso attraverso differenti forme di rappresentazione.\n\n\n1.3.2 Generazione\nLa generazione degli algoritmi è un’arte in sé, non esistendo una ricetta garantita per trovarne almeno uno corretto. Tuttavia, alcune strategie generali possono aumentare le probabilità di successo. La capacità di ideare algoritmi efficaci richiede creatività, pensiero analitico e una profonda comprensione del problema da risolvere.\nAlcune strategie:\n\nApproccio top-down: Un approccio comune alla scoperta degli algoritmi è scomporre un problema complesso in sottoproblemi più piccoli e gestibili. Questo metodo, noto come approccio top-down, prevede di iniziare con una visione globale del problema e poi dividere il problema in parti sempre più piccole fino a raggiungere sottoproblemi che possono essere risolti direttamente. Ogni sottoproblema è affrontato individualmente e le soluzioni sono poi combinate per risolvere il problema originale. Questo approccio è particolarmente utile quando si affrontano problemi complessi che possono essere suddivisi in componenti indipendenti.\nApproccio bottom-up: Un altro metodo è l’approccio bottom-up, che prevede di partire da casi specifici o esempi concreti e di cercare di generalizzare la soluzione. Questo approccio consiste nell’identificare soluzioni per piccoli problemi specifici e poi combinare queste soluzioni per affrontare problemi più grandi. È un metodo efficace quando le soluzioni a problemi semplici possono essere adattate e combinate per risolvere problemi più complessi. L’approccio bottom-up è spesso utilizzato in combinazione con l’approccio top-down per fornire una comprensione completa del problema e della sua soluzione.\nInduzione: L’induzione è una tecnica matematica che può essere molto utile nella determinazione di algoritmi. Consiste nel risolvere il problema per un caso base semplice e poi dimostrare che se il problema può essere risolto per un caso generico, allora può essere risolto anche per il caso successivo. Questa tecnica è particolarmente utile per i problemi ricorsivi, dove la soluzione a un problema dipende dalla soluzione di istanze più semplici dello stesso problema.\nContraddizione: La contraddizione è un’altra tecnica matematica che può essere utilizzata nella definizone di algoritmi. Consiste nel dimostrare che l’assunzione opposta porta a una contraddizione, e quindi l’assunzione iniziale deve essere vera. Questa tecnica è utile per provare che certi problemi non possono essere risolti o che certe proprietà devono essere vere per un algoritmo efficace.\n\n\n\n1.3.3 Metodologia di Polya\nGeorge Polya, nel suo libro How to Solve It,6 propone una metodologia strutturata per la risoluzione dei problemi che può essere applicata alla scoperta degli algoritmi.\n6 G. PolyaHow to Solve ItPrinceton University Press9780691119663.\nG. PolyaHow to Solve ItPrinceton University Press9780691119663.\n\n1.3.3.1 Le fasi\nPolya suggerisce quattro fasi principali:\n\nComprendere il problema: Prima di tutto, è fondamentale avere una chiara comprensione del problema. Ciò include identificare esattamente cosa è richiesto, quali sono i dati di input e quale deve essere l’output. Una comprensione chiara aiuta a focalizzare l’attenzione sui punti cruciali del problema.\nFormulare piani: Una volta compreso il problema, il passo successivo è ideare uno o più piani per risolverlo. Questo può includere la suddivisione del problema in sottoproblemi, l’uso di analogie con problemi già risolti, o l’applicazione di tecniche matematiche come l’induzione. È utile pensare a diverse strategie e considerare quale possa essere la più efficace.\nEseguire i piani: Dopo aver formulato un piano, bisogna metterlo in pratica. Questo implica scrivere il codice, testare le soluzioni e verificare che l’algoritmo funzioni correttamente per i casi di test previsti. Durante questa fase, è possibile che si scoprano nuovi sottoproblemi o che si debba modificare il piano originale.\nValutare l’efficacia: Infine, è importante valutare l’efficacia della soluzione. Questo include verificare che l’algoritmo funzioni correttamente per tutti i casi di input, che sia efficiente in termini di tempo e risorse, e che sia possibile migliorarlo ulteriormente. La valutazione permette di rifinire l’algoritmo e di identificare eventuali punti deboli o aree di miglioramento.\n\nQueste fasi aiutano a strutturare il processo di definizione di algoritmi in modo sistematico e metodico, aumentando le probabilità di trovare soluzioni efficaci ai problemi. La scrittura degli algoritmi, quindi, non è solo una questione di creatività, ma anche di applicazione rigorosa di tecniche e metodologie strutturate.\n\n\n1.3.3.2 Esempio di applicazione\nApplichiamo la metodologia di Polya per definire un algoritmo, rappresentato con codice sorgente, che ordini una lista di numeri interi in ordine crescente.\n\nComprendere il problema: Ordinare una lista di numeri interi in ordine crescente; ad esempio [64, 34, 25, 12, 22, 11, 90] deve diventare [11, 12, 22, 25, 34, 64, 90].\nFormulare piani:\n\n\nPiano 1: Confrontare ogni elemento con ogni altro elemento e scambiarli se sono nell’ordine sbagliato. Tuttavia, questo potrebbe non essere efficiente.\nPiano 2: Confrontare elementi adiacenti e scambiarli se sono nell’ordine sbagliato, ripetendo questo processo fino a quando la lista è ordinata. Questo ci porta all’idea dell’algoritmo Bubble Sort.\n\n\nEseguire i piani: Immplementiamo l’algoritmo in codice sorgente Python, eventualmente preceduto da uno pseudocodice come quello presentato sopra:\n\n1def bubble_sort(lista):\n2  n = len(lista)\n\n3  for i in range(n):\n4    scambiato = False\n    \n5    for j in range(0, n-i-1):\n6      if lista[j] &gt; lista[j + 1]:\n7        lista[j], lista[j + 1] = lista[j + 1], lista[j]\n        \n8        scambiato = True\n          \n9    if not scambiato:\n10      break\n\n# Esempio di utilizzo\n11lista = [64, 34, 25, 12, 22, 11, 90]\n\n12print(\"La lista da ordinare è: \", lista)\n\n13bubble_sort(lista)\n\n14print(\"La lista ordinata è: \", lista)\n\n1\n\nDefinizione della funzione bubble_sort.\n\n2\n\nCalcolo della lunghezza della lista.\n\n3\n\nCiclo esterno che ripete il processo di ordinamento.\n\n4\n\nInizializzazione della variabile scambiato a False.\n\n5\n\nCiclo interno che percorre la lista fino alla fine non ordinata.\n\n6\n\nConfronto tra elementi adiacenti.\n\n7\n\nScambio degli elementi se sono nell’ordine sbagliato.\n\n8\n\nImpostazione della variabile scambiato a True se avviene uno scambio.\n\n9\n\nVerifica se sono stati effettuati scambi.\n\n10\n\nInterruzione del ciclo se non ci sono stati scambi, la lista è ordinata.\n\n11\n\nEsempio di lista da ordinare.\n\n12\n\nStampa della lista da ordinare.\n\n13\n\nChiamata della funzione bubble_sort sulla lista.\n\n14\n\nStampa della lista ordinata.\n\n\nDa notare che abbiamo applicato l’algoritmo all’input così come dato nella definizione del problema, ma, in generale, più coppie input/output dovrebbero essere fornite per coprire anche casi particolari.\n\nValutare l’efficacia:\n\n\nL’algoritmo Bubble Sort funziona correttamente per l’elenco di esempio fornito.\nL’algoritmo ha una complessità temporale di O(n^2), che può essere migliorata utilizzando algoritmi di ordinamento più efficienti come il Quick Sort o il Merge Sort.\nL’algoritmo è semplice da implementare e comprendere, ma non è adatto per grandi dataset a causa della sua inefficienza.\n\nIn questo esempio, abbiamo applicato le fasi della metodologia di Polya per determinare l’algoritmo Bubble Sort per l’ordinamento di una lista di numeri interi. Questo dimostra come una struttura metodica possa aiutare a definire e implementare algoritmi efficaci in un programma in uno specifico linguaggio di programmazione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#dal-codice-sorgente-allesecuzione",
    "href": "prima-parte-linguaggi-programmazione.html#dal-codice-sorgente-allesecuzione",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.4 Dal codice sorgente all’esecuzione",
    "text": "1.4 Dal codice sorgente all’esecuzione\nPer comprendere come un programma scritto in un linguaggio di programmazione passi dal file di testo contenente il codice sorgente all’esecuzione delle istruzioni da parte della CPU, è fondamentale capire che questo processo richiede un programma che interpreti il codice sorgente. Tale programma può essere un compilatore o un interprete, le due macrocategorie che definiscono come il codice sorgente viene tradotto ed eseguito.\nUn compilatore è un programma che traduce l’intero codice sorgente di un programma scritto in un linguaggio di alto livello (come C o C++) in codice macchina, che è il linguaggio comprensibile direttamente dalla CPU. Questa traduzione avviene una sola volta, generando un file eseguibile che può essere eseguito direttamente dalla CPU.\nUn interprete, invece, è un programma che esegue il codice sorgente direttamente, istruzione per istruzione, senza produrre un file eseguibile separato. L’interprete legge una riga di codice, la traduce in codice macchina e la esegue immediatamente. Questo processo viene ripetuto per ogni riga del codice sorgente.\nÈ importante notare che alcuni linguaggi di programmazione possono essere sia compilati che interpretati, a seconda dell’implementazione disponibile. Ad esempio, Java utilizza sia la compilazione (per generare bytecode) che l’interpretazione, e la Java Virtual Machine (JVM) spesso utilizza anche la compilazione just-in-time (JIT) per tradurre il bytecode in codice macchina nativo durante l’esecuzione.\nDetto ciò i passaggi macro perché un programma sia eseguito e possa produrre gli effetti pronosticati, sono:\n\nIl programmatore scrive il codice sorgente utilizzando un editor di testo o un ambiente di sviluppo integrato (integrated development environment, IDE). Questo codice contiene le istruzioni del programma, scritte secondo la sintassi del linguaggio di programmazione scelto.\nL’interpreto o il compilatore vengono eseguiti con input il programma e un componente, l’analizzatore lessicale, legge il codice sorgente e lo divide in lessemi, che sono sequenze di caratteri che corrispondono agli elementi atomici del linguaggio. Ogni lessema viene identificato come un token specifico, come una parola chiave, un operatore o un identificatore.\nA seguire un secondo compoenente, il parser, riceve la sequenza di token dall’analizzatore lessicale e costruisce un albero di sintassi, che rappresenta la struttura grammaticale del programma. Il parser verifica che il codice rispetti le regole sintattiche del linguaggio.\nUn altro componente effettua la verifica che il programma abbia un senso logico. Ad esempio, controlla che le variabili siano dichiarate prima di essere utilizzate e che i tipi di dati siano compatibili con le operazioni eseguite su di essi.\nIl compilatore, a questo punto, genera una rappresentazione intermedia del programma, che è più vicina al linguaggio macchina ma ancora indipendente dall’architettura specifica del computer. Ciò è tipico dei linguaggi compilati, anche se alcuni interpreti possono generare un bytecode intermedio.\nIl compilatore ottimizza codice intermedio al fine di migliorare le prestazioni del programma, riducendo il numero di istruzioni o migliorando l’efficienza delle operazioni.\nIl codice intermedio ottimizzato viene tradotto in codice macchina, che è specifico per l’architettura del computer su cui il programma verrà eseguito.\nLinking: Il codice macchina viene combinato con altre librerie e moduli necessari per formare un eseguibile completo.\nEsecuzione: L’eseguibile viene caricato nella memoria del computer e il processore esegue le istruzioni, portando a termine le operazioni definite nel programma.\n\nNel caso di un interprete, i passaggi di generazione del codice intermedio e macchina possono essere sostituiti da una valutazione diretta delle istruzioni del programma, eseguendole una per una. In pratica, l’interprete traduce ogni singola istruzione del codice sorgente in un formato conprensibile dalla CPU e passa questa istruzione alla CPU stessa per l’esecuzione. Questo processo continua fino a quando tutte le istruzioni del programma non sono state eseguite.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-linguaggi-programmazione.html#ciclo-di-vita-del-software",
    "href": "prima-parte-linguaggi-programmazione.html#ciclo-di-vita-del-software",
    "title": "1  I linguaggi di programmazione, i programmi e i programmatori",
    "section": "1.5 Ciclo di vita del software",
    "text": "1.5 Ciclo di vita del software\nUn software è composto da uno o più programmi e, quando eseguito, realizza un compito con un grado di utilità specifico. La gerarchia concettuale, dal più generale all’elemento più granulare, è: software, programmi, moduli, istruzioni.\nUn modulo è una componente autonoma di un programma che contiene una parte specifica della logica o delle funzionalità del sistema. I moduli facilitano la gestione della complessità, permettono il riutilizzo del codice e migliorano la manutenibilità del software.\nCosì come il disegno dei programmi è quello computazionale degli algoritmi, il disegno del software è funzionale per determinare i suoi obiettivi e architetturale per la decomposizione nei programmi e nei relativi moduli.\nPer creare il software, quindi, è necessario percorrere una sequenza di fasi ben definita che, concisamente, è data da:\n\nLa progettazione di un’applicazione inizia con la fase di analisi dei requisiti, in cui si identificano cosa deve fare il software, chi sono gli utenti e quali sono i requisiti funzionali e non funzionali che deve soddisfare.\nSegue il disegno funzionale che dettaglia come ogni componente del sistema possa rispondere alle funzionalità richieste. In questa fase si descrivono le operazioni specifiche che ogni componente deve eseguire, utilizzando diagrammi di processo per rappresentare il flusso di attività al fine di rispondere ai requisiti.\nIl disegno architetturale riguarda l’organizzazione ad alto livello del sistema software. In questa fase si definiscono i componenti principali del sistema e come essi interagiscono tra di loro per supportare le attività di processo. Questo include la suddivisione del sistema in moduli o componenti, la definizione delle interfacce tra di essi e l’uso di tecniche di modellazione per rappresentare l’architettura del sistema.\nUna volta che l’architettura è stata progettata, si passa alla fase di implementazione, in cui i programmatori scrivono il codice sorgente nei linguaggi di programmazione scelti. I programmatori lavorano sui vari moduli, integrandoli secondo l’architettura definita per costruire i programmi completi.\nDopo l’implementazione, è essenziale verificare che il software funzioni correttamente:\n\nTesting: Scrivere ed eseguire test per verificare che il software soddisfi i requisiti specificati. I test sono di diversi generi in funzione dell’oggetto di verifica, come test unitari per segmenti di codice (spesso a livello di moduli), test di integrazione per componenti, e test di sistema nella sua interezza.\nDebugging: Identificare e correggere gli errori (bug) nel codice. Questo può includere l’uso di strumenti di debugging per tracciare l’esecuzione del programma e trovare i punti in cui si verificano gli errori.\n\nUna volta che il software è stato testato e ritenuto pronto, si passa alla fase di messa a disposizione delle funzionalità agli utenti (in inglese, deployment):\n\nDistribuzione: Rilasciare il software agli utenti finali, che può includere l’installazione su server, la distribuzione di applicazioni desktop o il rilascio di app mobile.\nManutenzione: Continuare a supportare il software dopo il rilascio. Questo include la correzione di bug scoperti dopo il rilascio, l’aggiornamento del software per miglioramenti e nuove funzionalità, e l’adattamento a nuovi requisiti o ambienti.\n\n\nLa complessità del processo induce la necessità di avere dei team con qualità individuali diverse e il programmatore, oltre alle competenze specifiche, deve saper interpretare i vari artefatti di disegno e saperli tramutare in algoritmi e codice sorgente. La modularità del software facilita questa trasformazione, permettendo ai programmatori di focalizzarsi su singole parti del sistema alla volta e garantendo al contempo che le varie componenti si integrino correttamente in un sistema funzionante e coerente.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>I linguaggi di programmazione, i programmi e i programmatori</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html",
    "href": "prima-parte-paradigmi-programmazione.html",
    "title": "2  I paradigmi di programmazione",
    "section": "",
    "text": "2.1 L’importanza dei paradigmi di programmazione\nComprendere i paradigmi di programmazione è fondamentale per diversi motivi:",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#limportanza-dei-paradigmi-di-programmazione",
    "href": "prima-parte-paradigmi-programmazione.html#limportanza-dei-paradigmi-di-programmazione",
    "title": "2  I paradigmi di programmazione",
    "section": "",
    "text": "Approccio alla risoluzione dei problemi: Ogni paradigma offre una visione diversa su come affrontare e risolvere problemi. Conoscere vari paradigmi permette ai programmatori di scegliere l’approccio più adatto in base al problema specifico. Ad esempio, per problemi che richiedono una manipolazione di stati, la programmazione imperativa può essere più intuitiva. Al contrario, per problemi che richiedono trasformazioni di dati senza effetti collaterali, la programmazione funzionale potrebbe essere più adatta.\nVersatilità e adattabilità: I linguaggi moderni che supportano più paradigmi permettono ai programmatori di essere più versatili e adattabili. Possono utilizzare il paradigma più efficiente per diverse parti del progetto, migliorando sia la leggibilità che le prestazioni del codice.\nManutenzione del codice: La comprensione dei paradigmi aiuta nella scrittura di codice più chiaro e manutenibile. Ad esempio, il paradigma orientato agli oggetti può essere utile per organizzare grandi basi di codice in moduli e componenti riutilizzabili, migliorando la gestione del progetto.\nEvoluzione professionale: La conoscenza dei vari paradigmi arricchisce le competenze di un programmatore, rendendolo più competitivo nel mercato del lavoro. Conoscere più paradigmi permette di comprendere e lavorare con una gamma più ampia di linguaggi di programmazione e tecnologie.\nOttimizzazione del codice: Alcuni paradigmi sono più efficienti in determinate situazioni. Ad esempio, la programmazione concorrente è essenziale per lo sviluppo di software che richiede alta prestazione e scalabilità, come nei sistemi distribuiti. Comprendere come implementare la concorrenza in vari paradigmi permette di scrivere codice più efficiente.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-imperativo",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-imperativo",
    "title": "2  I paradigmi di programmazione",
    "section": "2.2 Paradigma imperativo",
    "text": "2.2 Paradigma imperativo\nLa programmazione imperativa, a differenza della programmazione dichiarativa, è un paradigma di programmazione che descrive l’esecuzione di un programma come una serie di istruzioni che cambiano il suo stato. In modo simile al modo imperativo delle lingue naturali, che esprime comandi per compiere azioni, i programmi imperativi sono una sequenza di comandi che il computer deve eseguire in sequenza. Un caso particolare di programmazione imperativa è quella procedurale.\nI linguaggi di programmazione imperativa si contrappongono ad altri tipi di linguaggi, come quelli funzionali e logici. I linguaggi di programmazione funzionale, come Haskell, non producono sequenze di istruzioni e non hanno uno stato globale come i linguaggi imperativi. I linguaggi di programmazione logica, come Prolog, sono caratterizzati dalla definizione di cosa deve essere calcolato, piuttosto che come deve avvenire il calcolo, a differenza di un linguaggio di programmazione imperativo.\nL’implementazione hardware di quasi tutti i computer è imperativa perché è progettata per eseguire il codice macchina, che è scritto in stile imperativo. Da questa prospettiva a basso livello, lo stato del programma è definito dal contenuto della memoria e dalle istruzioni nel linguaggio macchina nativo del processore. Al contrario, i linguaggi imperativi di alto livello sono caratterizzati da un modello dati e istruzioni che risultano più facilmente usabili come strumenti di espressione di passi algoritmici.\n\n2.2.1 Esempio in assembly\nAssembly è una categoria di linguaggi di basso livello, cioè strettamente legati all’hardware del computer, tanto che ogni processore ha il suo dialetto. Un esempio di un semplice programma scritto per l’architettura x86, utilizzando la sintassi dell’assembler NASM (Netwide Assembler), è il seguente che effettua la somma di due numeri e stampa il risultato:\nsection .data\n    num1 db 5           ; Definisce il primo numero\n    num2 db 3           ; Definisce il secondo numero\n    result db 0         ; Variabile per memorizzare il risultato\n    msg db 'Result: ', 0 ; Messaggio di output\n\nsection .bss\n    result_str resb 4   ; Buffer per la stringa del risultato\n\nsection .text\n    global _start\n\n_start:\n    ; Somma num1 e num2\n    mov al, [num1]      ; Carica il primo numero in AL\n    add al, [num2]      ; Aggiunge il secondo numero a AL\n    mov [result], al    ; Memorizza il risultato in result\n\n    ; Converti il risultato in stringa ASCII\n    mov eax, [result]   ; Carica il risultato in EAX\n    add eax, '0'        ; Converti il valore numerico in carattere ASCII\n    mov [result_str], eax ; Memorizza il carattere ASCII in result_str\n\n    ; Stampa il messaggio\n    mov eax, 4          ; syscall numero per sys_write\n    mov ebx, 1          ; file descriptor 1 (stdout)\n    mov ecx, msg        ; puntatore al messaggio\n    mov edx, 8          ; lunghezza del messaggio\n    int 0x80            ; chiamata di sistema\n\n    ; Stampa il risultato\n    mov eax, 4          ; syscall numero per sys_write\n    mov ebx, 1          ; file descriptor 1 (stdout)\n    mov ecx, result_str ; puntatore alla stringa del risultato\n    mov edx, 1          ; lunghezza della stringa del risultato\n    int 0x80            ; chiamata di sistema\n\n    ; Terminazione del programma\n    mov eax, 1          ; codice di sistema per l'uscita\n    xor ebx, ebx        ; codice di ritorno 0\n    int 0x80            ; interruzione per chiamare il kernel\nLe sezioni del codice:\n\nLa sezione .data definisce i dati statici num1, num2, result e msg.\nSezione .bss alloca lo spazio per result_str, che conterrà la stringa del risultato.\nSezione .textdefinisce _start come punto di ingresso del programma e:\n\nImplementa la logica principale del programma.\nSomma i valori di num1 e num2.\nConverte il risultato numerico in una stringa ASCII.\nUtilizza chiamate al sistema operativo per scrivere il messaggio e il risultato su stdout.\nTermina il programma.\n\n\nL’assembly è usato nello sviluppo di:\n\nSistemi operativi, ad esempio il kernel, che ha il controllo del sistema e i driver, cioè i programmi utili alla comunicazione coll’hardware.\nApplicazioni embedded: Microcontrollori di dispositivi medici, sistemi di controllo di veicoli, dispositivi IoT, ecc., cioè)dove è necessaria un’ottimizzazione estrema delle risorse computazionali.\nApplicazioni HPC (high performance computing): Il focus qui è eseguire calcoli intensivi e complessi in tempi relativamente brevi. Queste applicazioni richiedono un numero di operazioni per unità di tempo elevato e sono ottimizzate per sfruttare al massimo le risorse hardware disponibili, come CPU, GPU e memoria.\n\n\n\n2.2.2 Esempio in Python\nAll’altro estremo della immediatezza di comprensione del testo del codice per un essere umano, troviamo Python, un linguaggio di alto livello noto per la leggibilità ed eleganza.\nEcco il medesimo esempio, visibilmente più conciso e certamente intuibile anche avendo basi limitate di programmazione:\n1num1 = 5\nnum2 = 3\n\n2result = num1 + num2\n\n3print(\"Il risultato è: \", result)\n\n1\n\nDefinizione delle variabili che identificano gli addendi.\n\n2\n\nSomma dei due numeri.\n\n3\n\nStampa del risultato della somma.\n\n\n\n\n2.2.3 Analisi comparativa\nAssembly:\n\nBasso livello di astrazione: Assembly lavora direttamente con i registri della CPU e la memoria, quindi non astrae granché della complessità dell’hardware.\nScarsa versatilità: Il linguaggio è progettato per una ben definita architettura e, quindi, ha una scarsa applicabilità ad altre, anche se alcuni dialetti di assembly presentano delle similitudini.\nElevata precisione: Il programmatore ha un controllo dettagliato su ogni singola operazione compiuta dal processore, perché c’è una corrispondenza col codice macchina.\nComplessità: Ogni operazione deve essere definita esplicitamente e in sequenza, il che rende il codice più lungo e difficile da leggere.\n\nPython:\n\nAlto livello di astrazione: Python fornisce un’astrazione più elevata sia dei dati che delle istruzioni, permettendo di ignorare i dettagli dei diversi hardware.\nElevata semplicità: Il codice è più breve e leggibile, facilitando la comprensione e la manutenzione.\nElevata versatilità: Il linguaggio è applicabile senza modifiche a un elevato numero di architetture hardware-software.\nProduttività: I programmatori possono concentrarsi sulla complessità intrinseca del problema, senza preoccuparsi di molti dettagli implementativi del processo di esecuzione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-procedurale",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-procedurale",
    "title": "2  I paradigmi di programmazione",
    "section": "2.3 Paradigma procedurale",
    "text": "2.3 Paradigma procedurale\nLa programmazione procedurale è un paradigma di programmazione, derivato da quella imperativa, che organizza il codice in unità chiamate procedure o funzioni. Ogni procedura o funzione è un blocco di codice che può essere richiamato da altre parti del programma, promuovendo la riutilizzabilità e la modularità del codice.\nLa programmazione procedurale è una naturale evoluzione della imperativa e uno dei paradigmi più antichi e ampiamente utilizzati. Ha avuto origine negli anni ’60 e ’70 con linguaggi come Fortan, COBOL e C, tutt’oggi rilevanti. Questi linguaggi hanno introdotto concetti fondamentali come funzioni, sottoprogrammi e la separazione tra codice e dati. Il C, in particolare, ha avuto un impatto duraturo sulla programmazione procedurale, diventando uno standard de facto per lo sviluppo di sistemi operativi e software di sistema.\nI vantaggi principali sono:\n\nModularità: La programmazione procedurale incoraggia la suddivisione del codice in funzioni o procedure più piccole e gestibili. Questo facilita la comprensione, la manutenzione e il riutilizzo del codice.\nRiutilizzabilità: Le funzioni possono essere riutilizzate in diverse parti del programma o in progetti diversi, riducendo la duplicazione del codice e migliorando l’efficienza dello sviluppo.\nStruttura e organizzazione: Il codice procedurale è generalmente più strutturato e organizzato, facilitando la lettura e la gestione del progetto software.\nFacilità di debug e testing: La suddivisione del programma in funzioni isolate rende più facile individuare e correggere errori, oltre a testare parti specifiche del codice.\n\nD’altro canto, presenta anche degli svantaggi che hanno spinto i ricercatori a continuare l’innovazione:\n\nScalabilità limitata: Nei progetti molto grandi, la programmazione procedurale può diventare difficile da gestire. La mancanza di meccanismi di astrazione avanzati, come quelli offerti dalla programmazione orientata agli oggetti, può complicare la gestione della complessità.\nGestione dello stato: La programmazione procedurale si basa spesso su variabili globali per condividere stato tra le funzioni, il che può portare a bug difficili da individuare e risolvere.\nDifficoltà nell’aggiornamento: Le modifiche a una funzione possono richiedere aggiornamenti in tutte le parti del programma che la utilizzano, aumentando il rischio di introdurre nuovi errori.\nMeno Adatta per Applicazioni Moderne: Per applicazioni complesse e moderne che richiedono la gestione di eventi, interfacce utente complesse e modellazione del dominio, la programmazione procedurale può essere meno efficace rispetto ad altri paradigmi come quello orientato agli oggetti.\n\n\n2.3.1 Funzioni e procedure\nNella programmazione procedurale, il codice è suddiviso in unità elementari chiamate funzioni e procedure. La differenza principale tra le due è la seguente:\n\nFunzione: Una funzione è un blocco di codice che esegue un compito specifico e restituisce un valore. Le funzioni sono utilizzate per calcoli o operazioni che producono un risultato. Ad esempio, una funzione che calcola la somma di due numeri in linguaggio C:\nint somma(int a, int b) {\n  return a + b;\n}\nProcedura: Una procedura è simile a una funzione, ma non restituisce un valore. È utilizzata per eseguire azioni o operazioni che non necessitano di un risultato. Ad esempio, una procedura che stampa un messaggio in Pascal:\nprocedure stampaMessaggio;\nbegin\n  writeln('Ciao, Mondo!');\nend;\n\n\n\n2.3.2 Creazione di librerie\nUn altro aspetto importante della programmazione procedurale è la possibilità di creare librerie, che sono collezioni di funzioni e procedure riutilizzabili. Le librerie permettono di organizzare e condividere codice comune tra diversi progetti, aumentando la produttività e riducendo la duplicazione del codice, nonché abilitando un modello commerciale che mette a disposizione del software prodotto da aziende o comunità specializzate.\nEsempio di una semplice libreria ipotetica di somme in C:\n\nFile header (mialibreria.h):\n#ifndef MIALIBRERIA_H\n#define MIALIBRERIA_H\n\nint somma_interi(int a, int b);\n\nchar* somma_stringhe(const char* a, const char* b);\n\nint somma_array(int arr[], int n);\n\nvoid stampa_messaggio(const char* messaggio, \n                      void* risultato, \n                      char tipo);\n\n#endif\nFile di implementazione (mialibreria.c):\n#include \"mialibreria.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint somma_interi(int a, int b) {\n  return a + b;\n}\n\nchar* somma_stringhe(const char* a, const char* b) {\n1  char* risultato = malloc(strlen(a) + strlen(b) + 1);\n\n2  if (risultato) {\n3    strcpy(risultato, a);\n4    strcat(risultato, b);\n  }\n\n  return risultato;\n}\n\nint somma_array_interi(int arr[], int n) {\n  int somma = 0;\n\n  for (int i = 0; i &lt; n; i++) {\n    somma += arr[i];\n  }\n\n  return somma;\n}\n\nvoid stampa_messaggio(const char* messaggio, \n                      void* risultato, \n                      char tipo) {\n  printf(\"%s\", messaggio);\n\n  if (tipo == 'i') {\n5    printf(\"%d\\n\", *(int*)risultato);\n  } else if (tipo == 's') {\n6    printf(\"%s\\n\", (char*)risultato);\n  }\n}\n\n1\n\nAllocazione della memoria per la somma delle due stringhe e +1 per il carattere di terminazione \\0.\n\n2\n\nControllo se la funzione malloc ha avuto successo nell’allocare la memoria richiesta. Se risultato è NULL, significa che malloc ha fallito e il blocco di codice all’interno dell’if viene saltato, evitando così di tentare di accedere a memoria non valida.\n\n3\n\nSe l’allocazione ha avuto successo, copia la prima stringa nel risultato.\n\n4\n\nConcatenazione della seconda stringa nel risultato.\n\n5\n\nStampa del risultato se il tipo è intero.\n\n6\n\nStampa del risultato se il tipo è una stringa.\n\n\nFile principale (main.c):\n#include \"mialibreria.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n1  int risultato = somma_interi(5, 3);\n  stampa_messaggio(\"Il risultato della somma di interi è: \", \n                   &risultato, 'i');\n\n2  char* risultato_stringhe = somma_stringhe(\"Ciao, \", \"mondo!\");\n  stampa_messaggio(\"Il risultato della somma di stringhe è: \", \n                   risultato_stringhe, 's');\n3  free(risultato_stringhe);\n\n  int array[] = {1, 2, 3, 4, 5}; \n4  int risultato_array = somma_array_interi(array, 5);\n  stampa_messaggio(\"Il risultato della somma dell'array di interi è: \", \n                   &risultato_array, 'i');\n\n  return 0;\n}\n\n1\n\nChiamata della funzione per la somma di due interi.\n\n2\n\nChiamata della funzione per la somma di due stringhe (implementata come una concatenazione).\n\n3\n\nLiberazione della memoria allocata per la stringa risultante.\n\n4\n\nChiamata della funzione per la somma di un array di interi.\n\n\n\nE il medesimo, ma in Python:\ndef somma_interi(a, b):\n  return a + b\n\n1def somma_stringhe(a, b):\n  return a + b\n\n2def somma_array(arr):\n3  return sum(arr)\n\nrisultato_interi = somma_interi(3, 5)\nprint(f\"Il risultato della somma di interi è: {risultato_interi}\")\n\nrisultato_stringhe = somma_stringhe(\"Ciao, \", \"mondo!\")\nprint(f\"Il risultato della somma di stringhe è: {risultato_stringhe}\")\n\narray_interi = [1, 2, 3, 4, 5]\nrisultato_array = somma_array(array_interi) \nprint(f\"Il risultato della somma dell'array è: {risultato_array}\")\n\n1\n\nIl codice di somma_interi e somma_stringhe è identico e questo ci suggerisce che una delle due è ridondante.\n\n2\n\nLa funzione ora prende in input solo l’array e non c’è bisogno di inserire anche la sua dimensione.\n\n3\n\nIn Python, per evitare errori quando si usa la funzione sum, l’array (o lista) deve contenere elementi che supportano l’operazione di addizione tra di loro. Tipicamente, si usano numeri (interi o a virgola mobile), ma è possibile anche sommare altri tipi di elementi se l’operazione di addizione è definita per quel tipo di dato.\n\n\nAnche qui Python appare più semplice e immediato, sicuramente vincente sul piano della comprensione del codice e della immediatezza di utilizzo. In realtà, Python e C hanno sia una forte complementarietà sulle applicazioni, sia una dipendenza perché molte librerie e l’interprete stesso di Python sono in C.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-di-orientamento-agli-oggetti",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-di-orientamento-agli-oggetti",
    "title": "2  I paradigmi di programmazione",
    "section": "2.4 Paradigma di orientamento agli oggetti",
    "text": "2.4 Paradigma di orientamento agli oggetti\nLa programmazione orientata agli oggetti (in inglese object-oriented programming, OOP) è un paradigma di programmazione che organizza il software in termini di oggetti, ciascuno dei quali rappresenta un’istanza di una matrice detta classe. Una classe definisce un tipo di dato che include attributi (dati) e metodi (funzionalità). Gli oggetti interagiscono tra loro attraverso messaggi, permettendo una struttura modulare e intuitiva.\nL’OOP è emersa negli anni ’60 e ’70 con il linguaggio Simula, il primo linguaggio di programmazione a supportare questo paradigma. Tuttavia, è stato con Smalltalk, sviluppato negli anni ’70 da Alan Kay e altri presso Xerox PARC, che l’OOP ha guadagnato popolarità. Il paradigma è stato ulteriormente consolidato con il linguaggio C++ negli anni ’80 e con Java negli anni ’90, rendendolo uno dei più utilizzati per lo sviluppo software moderno. Oggi numerosi sono i linguaggi a oggetti, ad esempio Python, C#, Ruby, Java, Swift, Javascript, ecc. ed altri lo supportano come PHP (dalla versione 5) e financo il Fortran nella versione 2003.\nRispetto ai paradigmi precedenti, l’OOP introduce diversi concetti chiave che ineriscono al disegno architetturale di software:\n\nClasse e oggetto: La classe è un modello o schema per creare oggetti. Contiene definizioni di attributi e metodi. L’oggetto è un’istanza di una classe e rappresenta un’entità concreta nel programma con stato e comportamento mutevoli.\nIncapsulamento: Nasconde i dettagli interni di un oggetto e mostra solo le interfacce necessarie agli altri oggetti. Migliora la modularità e protegge l’integrità dei dati.\nEreditarietà (relazione is-a): Permette a una classe di estenderne un’altra, ereditandone attributi e metodi. Favorisce il riuso del codice e facilita l’estensione delle funzionalità. Si usa quando una classe può essere considerata una specializzazione di un’altra. Ad esempio, un Gatto è un Animale, quindi la classe Gatto eredita dalla classe Animale.\nPolimorfismo: Consente a oggetti di classi diverse di essere trattati come oggetti di una classe comune. Facilita l’uso di un’interfaccia uniforme per operazioni diverse. Il polimorfismo è strettamente legato all’ereditarietà e permette di usare un metodo in modi diversi a seconda dell’oggetto che lo invoca. Ad esempio, un metodo muovi() può comportarsi diversamente se invocato su un oggetto di classe Gatto rispetto a un oggetto di classe Uccello, ma entrambi sono trattati come Animale.\nAstrazione: Permette di definire interfacce di alto livello per oggetti, senza esporre i dettagli implementativi. Facilita la comprensione e la gestione della complessità del sistema, perché, assieme a ereditarietà e polimorfismo, permette di pensare in modo più naturale, basando la decomposizione del problema anche su relazioni di tipo gerarchico e concettuale. Attraverso l’astrazione, si definiscono classi e interfacce che rappresentano concetti generici, come Forma o Veicolo, senza specificare i dettagli concreti delle implementazioni.\nComposizione (relazione has-a): Permette a una classe di contenere altre classi come parte dei suoi attributi. È una forma di relazione che indica che un oggetto è composto da uno o più oggetti di altre classi. Si usa quando una classe ha bisogno di utilizzare funzionalità di altre classi ma non rappresenta una specializzazione di quelle classi. Ad esempio, una classe Auto può avere un oggetto Motore come attributo, indicando che un’Auto ha un Motore.\n\nI vantaggi principali dell’OOP sono:\n\nModularità: Le classi e gli oggetti favoriscono la suddivisione del codice in moduli indipendenti, in una forma più granulare rispetto al paradigma procedurale. Non solo le istruzioni sono raggruppate per soddisfare una specifica operazione, ma possono essere viste come più operazioni su uno stato associato. La modularità è rafforzata dalle relazioni has-a e is-a, che aiutano a organizzare il codice in componenti logicamente separati e interconnessi.\nRiutilizzabilità: L’uso di classi e l’ereditarietà (relazione is-a) consentono di riutilizzare il codice in nuovi progetti senza riscriverlo, limitando gli effetti collaterali sul codice con cui interagiscono. Le classi base possono essere estese per creare nuove classi con funzionalità aggiuntive, mantenendo al contempo la compatibilità con il codice esistente.\nFacilità di manutenzione: L’incapsulamento e l’astrazione riducono la complessità perché permettono una migliore assegnazione logica dei principi usati nella progettazione dell’applicazione alle singole classi. Ciò facilita la manutenzione del codice, poiché nella modifica si possono individuare rapidamente le istruzioni impattate. La relazione has-a contribuisce ulteriormente alla manutenzione isolando le responsabilità all’interno delle classi.\nEstendibilità: Le classi possono essere estese (relazione is-a) per aggiungere nuove funzionalità senza modificare il codice già preesistente, riducendo così gli impatti per il codice che ne dipende. Questo approccio facilita l’integrazione di nuove caratteristiche e miglioramenti, mantenendo la stabilità del sistema.\n\nAnche se sussistono dei caveat:\n\nComplessità iniziale: L’OOP può essere complesso da apprendere e implementare correttamente per i nuovi programmatori.\nOverhead di prestazioni: L’uso intensivo di oggetti può introdurre un overhead di memoria e prestazioni rispetto alla programmazione procedurale.\nAbuso di ereditarietà: L’uso improprio dell’ereditarietà può portare a gerarchie di classi troppo complesse e difficili da gestire, quindi, producendo un effetto opposto ad una delle ragioni di esistenza del concetto, cioè la semplicità di comunicazione della progettazione del software.\n\n\n2.4.1 Esempio in Java\nIn questo esempio, la classe Animale rappresenta una tipo di dato generico con un attributo nome e un metodo faiVerso. La classe Cane specializza Animale, usando l’attributo nome e sovrascrivendo il metodo faiVerso, per fornire un’implementazione coerente colle sue caratteristiche. La classe Main crea un’istanza di Cane e chiama il suo metodo faiVerso (annotato con @Override4), dimostrando il polimorfismo e l’ereditarietà:\n4 In Java, l’annotazione @Override è opzionale, ma altamente consigliata. Non omettere l’annotazione @Override non causerà un errore di compilazione o di runtime. Tuttavia, l’uso di @Override offre dei vantaggi importanti perché, innanzitutto, il compilatore può verificare che il metodo stia effettivamente sovrascrivendo uno nella classe base e segnalare un errore in caso contrario. Inoltre, l’annotazione migliora la leggibilità del codice perché indica chiaramente al lettore come il metodo è inteso rispetto all’ereditarietà.1class Animale {\n  String nome;\n\n  Animale(String nome) {\n    this.nome = nome;\n  }\n\n  void faiVerso() {\n    System.out.println(\"L'animale fa un verso\");\n  }\n}\n\n2class Cane extends Animale {\n\n  Cane(String nome) {\n    super(nome);\n  }\n\n3  @Override\n  void faiVerso() {\n    System.out.println(\"Il cane abbaia\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Animale mioCane = new Cane(\"Fido\");\n\n4    mioCane.faiVerso();\n  }\n}\n\n1\n\nDefinizione della classe Animale che ha il doppio compito di provvedere all’implementazione per una caratteristica comune (nome e descrizione()) e una particolare (faiVerso()).\n\n2\n\nDefinizione della classe derivata Cane.\n\n3\n\n@Override indica in esplicito che il faiVerso() del Cane sovrascrive (non eredita) il faiVerso() di Animale.\n\n4\n\nOutput: Il cane abbaia.\n\n\nIn realtà, se gli oggetti devono rappresentare animali reali vorrà dire che non deve essere possibile crearne dalla matrice Animale. Vediamo, quindi, come implementare il medesimo esempio con una classe astratta, cioè una classe che non può essere usata per generare direttamente oggetti, sempre in Java.\nNel caso pratico, ogni animale ha il suo verso, quindi dobbiamo costringere il programmatore che vuole implementare classi corrispondenti ad animali reali, ad aggiungere tassativamente il metodo faiVerso() per comunicarne la caratteristica distintiva. Una modalità è marchiare Animale e il suo metodo da caratterizzare (faiVerso()), con costrutti ad hoc perché siano, rispettivamente, identificata come classe astratta (per mezzo della parola riservata abstract) e metodo da implementare. Al contempo, Cane non subisce specifiche modifiche sintattiche, ma deve rispettare il vincolo (implementare faiVerso()) perché, ereditando le caratteristiche di Animale, possa essere una classe concreta, cioè da cui si possono creare oggetti. Il codice risultate è:\n1abstract class Animale {\n  String nome;\n\n  Animale(String nome) {\n    this.nome = nome;\n  }\n\n2  abstract String faiVerso();\n\n3  String descrizione() {\n    return \"L'animale si chiama \" + nome;\n  }\n}\n\n4class Cane extends Animale {\n\n  Cane(String nome) {\n    super(nome);\n  }\n\n  @Override\n  String faiVerso() {\n    return \"Il cane abbaia\";\n  }\n}\n\n5class Coccodrillo extends Animale {\n\n  Coccodrillo(String nome) {\n    super(nome);\n  }\n\n  @Override\n6  String faiVerso() {\n    return \"\";  \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Animale mioCane = new Cane(\"Fido\");\n\n7    System.out.println(mioCane.descrizione());\n8    System.out.println(mioCane.faiVerso());\n\n    Animale mioCoccodrillo = new Coccodrillo(\"Crocky\");\n\n9    System.out.println(mioCoccodrillo.descrizione());\n10    System.out.println(mioCoccodrillo.faiVerso());\n  }\n}\n\n1\n\nDefinizione della classe astratta che ha il doppio compito di fornire una implementazione di default per una caratteristica comune (nome) e un vincolo di implementazione nelle classe derivate per una seconda caratteristica comune non implementabile nello stesso modo per tutte (faiVerso()).\n\n2\n\nMetodo astratto faiVerso() che le classi corrispondenti ad animali reali dovranno implementare e che dovrà resituire una stringa.\n\n3\n\nMetodo concreto faiVerso() che restituisce una stringa.\n\n4\n\nDefinizione della classe derivata Cane.\n\n5\n\nDefinizione della classe derivata Coccodrillo.\n\n6\n\nIl coccodrillo non emette versi!\n\n7\n\nStampa: L'animale si chiama Fido.\n\n8\n\nStampa: Il cane abbaia.\n\n9\n\nStampa: L'animale si chiama Crocky.\n\n10\n\nNon stampa nulla perché il coccodrillo non emette versi!\n\n\n\n\n2.4.2 Template\nI template, o generics, non sono specifici dell’OOP, anche se sono spesso associati a essa. I template permettono di scrivere funzioni, classi, e altri costrutti di codice in modo generico, cioè indipendente dal tipo dei dati che manipolano. Questo concetto è particolarmente utile per creare librerie e moduli riutilizzabili e flessibili.\nAd esempio, definiamo la classe Box nel modo seguente:\n1template &lt;typename T&gt;\n2class Box {\n3  T value;\n\npublic:\n4  void setValue(T val) { value = val; }\n\n5  T getValue() { return value; }\n};\n\n1\n\nLa keyword template definisce un template di classe che può lavorare con qualsiasi tipo T specificato al momento dell’uso.\n\n2\n\nDichiarazione della classe Box che utilizza il template di tipo T.\n\n3\n\nDichiarazione del membro dati value di tipo T, che rappresenta il valore contenuto nella scatola.\n\n4\n\nMetodo pubblico setValue che imposta il valore del membro dati value con il parametro val di tipo T.\n\n5\n\nMetodo pubblico getValue che restituisce il valore del membro dati value di tipo T.\n\n\nBox può contenere un valore di qualsiasi tipo specificato al momento della creazione dell’istanza per mezzo del template T:\n1Box&lt;int&gt; intBox;\n\n2intBox.setValue(123);\n3int x = intBox.getValue();\n\n4Box&lt;std::string&gt; stringBox;\n\n5stringBox.setValue(\"Hello, World!\");\n6std::string str = stringBox.getValue();\n\n1\n\nCreazione di un’istanza di Box con tipo int, chiamata intBox.\n\n2\n\nChiamata del metodo setValue per impostare il valore di intBox a 123.\n\n3\n\nChiamata del metodo getValue per ottenere il valore di intBox e assegnarlo alla variabile x di tipo int.\n\n4\n\nCreazione di un’istanza di Box con tipo std::string, chiamata stringBox.\n\n5\n\nChiamata del metodo setValue per impostare il valore di stringBox a \"Hello, World!\".\n\n6\n\nChiamata del metodo getValue per ottenere il valore di stringBox e assegnarlo alla variabile str di tipo std::string.\n\n\nAnche nei linguaggi non orientati agli oggetti, i template trovano applicazione. Ad esempio, in Rust, un linguaggio di programmazione sistemistica non puramente OOP, il codice seguente restituisce il valore più grande di una lista:\n1fn largest&lt;T: PartialOrd&gt;(list: &[T]) -&gt; &T {\n2    let mut largest = &list[0];\n\n3    for item in list {\n4        if item &gt; largest {\n5            largest = item;\n        }\n    }\n6    largest\n}\n\n7fn main() {\n8    let numbers = vec![34, 50, 25, 100, 65];\n9    let max = largest(&numbers);\n\n10    println!(\"The largest number is {}\", max);\n}\n\n1\n\nDefinizione della funzione generica largest che accetta una lista di riferimenti a un tipo T che implementa il tratto PartialOrd e restituisce un riferimento a un valore di tipo T.\n\n2\n\nInizializzazione della variabile largest con il primo elemento della lista.\n\n3\n\nIterazione attraverso ogni elemento della lista.\n\n4\n\nControllo se l’elemento corrente item è maggiore di largest.\n\n5\n\nSe item è maggiore, aggiornamento della variabile largest con item.\n\n6\n\nRestituzione di largest, che è il riferimento al più grande elemento trovato nella lista.\n\n7\n\nDefinizione della funzione main, punto di ingresso del programma.\n\n8\n\nCreazione di un vettore di numeri interi numbers.\n\n9\n\nChiamata della funzione largest con un riferimento a numbers e assegnazione del risultato a max.\n\n10\n\nStampa del valore più grande trovato nella lista usando la macro println!.\n\n\n\n\n2.4.3 Metaprogrammazione\nLa metaprogrammazione è un paradigma che consente al programma di trattare il codice come dati, permettendo al codice di generare, manipolare o eseguire altro codice. Anche questo concetto non è esclusivo dell’OOP. In C++, la metaprogrammazione è strettamente legata ai template. Un esempio classico è la template metaprogramming (TMP), che permette di eseguire calcoli a tempo di compilazione.\nUn esempio è il codice seguente di calcolo del fattoriale:\ntemplate&lt;int N&gt;\nstruct Factorial {\n1    static const int value = N * Factorial&lt;N - 1&gt;::value;\n};\n\ntemplate&lt;&gt;\nstruct Factorial&lt;0&gt; {\n2    static const int value = 1;\n};\n\n1\n\nQuesta riga definisce un membro statico value della struttura Factorial. Per un dato N, il valore viene calcolato come N moltiplicato per il valore del fattoriale di N - 1. Questo è un esempio di ricorsione a livello di metaprogrammazione template.\n\n2\n\nQuesta riga è una specializzazione del template Factorial per il caso base quando N è 0. In questo caso, value è definito come 1, terminando la ricorsione template.\n\n\nLa metaprogrammazione è presente anche in linguaggi non OOP come Lisp, che utilizza le macro per trasformare e generare codice. Un esempio è il codice proposto di seguito dove è definita la macro when, che prende due parametri in input, cioè test e body, ove test è un’espressione condizionale e body un insieme di istruzioni da eeseguire se la condizione è vera:\n(defmacro when (test &rest body)  \n  `(if ,test                      \n       (progn ,@body)))           \nCommento riga per riga:\n\nDefinizione di una macro chiamata when, che accetta un test e un numero variabile di espressioni (body).\nLa macro espande in un’espressione if che valuta test. Se test è vero, esegue le espressioni contenute in body.\nprogn è utilizzato per racchiudere ed eseguire tutte le espressioni in body in sequenza. L’operatore ,@ è usato per spalmare gli elementi di body nell’espressione progn.\n\nVediamo un esempio pratico di come si utilizza la macro when. Il test è valutare se x è maggiore di 10 e, nel caso, stampare \"x is greater than 10\" e poi assegnare x a 0. Chiamiamo la macro con i due parametri:\n(when (&gt; x 10)                      \n  (print \"x is greater than 10\")     \n  (setf x 0))                        \nCommento riga per riga:\n\nInvocazione della macro when con la condizione &gt; x 10.\nSe la condizione è vera, viene eseguita l’istruzione (print \"x is greater than 10\"), che stampa il messaggio.\nSuccessivamente, viene eseguita l’istruzione (setf x 0), che assegna il valore 0 a x.\n\nQuesto viene espanso in:\n(if (&gt; x 10)                        \n    (progn                        \n      (print \"x is greater than 10\") \n      (setf x 0)))                   \nCommento riga per riga:\n\nL’istruzione if valuta la condizione &gt; x 10.\nSe la condizione è vera, viene eseguito il blocco progn.\nAll’interno del blocco progn, viene eseguita l’istruzione (print \"x is greater than 10\").\nInfine, viene eseguita l’istruzione (setf x 0) all’interno del blocco progn.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-dichiarativo",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-dichiarativo",
    "title": "2  I paradigmi di programmazione",
    "section": "2.5 Paradigma dichiarativo",
    "text": "2.5 Paradigma dichiarativo\nLa programmazione dichiarativa è un paradigma di programmazione che si focalizza sul cosa deve essere calcolato piuttosto che sul come calcolarlo. In altre parole, i programmi dichiarativi descrivono il risultato desiderato senza specificare esplicitamente i passaggi per ottenerlo. Questo è in netto contrasto con la programmazione imperativa, dove si fornisce una sequenza dettagliata di istruzioni per modificare lo stato del programma.\nLa programmazione dichiarativa ha radici nella logica e nella matematica, ed è emersa come un importante paradigma negli anni ’70 e ’80 con l’avvento di linguaggi come Prolog (per la programmazione logica) e SQL (per la gestione dei database). La programmazione funzionale, con linguaggi come Haskell, è anch’essa una forma di programmazione dichiarativa.\nI concetti principali associati alla programazione dichiarativa sono:\n\nDescrizione del risultato: I programmi dichiarativi descrivono le proprietà del risultato desiderato senza specificare l’algoritmo per ottenerlo. Esempio: In SQL, per ottenere tutti i record di una tabella con un certo valore, si scrive una query che descrive la condizione, non un algoritmo che scorre i record uno per uno.\nAssenza di stato esplicito: La programmazione dichiarativa evita l’uso esplicito di variabili di stato e di aggiornamenti di stato. Ciò riduce i rischi di effetti collaterali e rende il codice più facile da comprendere e verificare.\nIdempotenza: Le espressioni dichiarative sono spesso idempotenti, cioè possono essere eseguite più volte senza cambiare il risultato. Questo è particolarmente utile per la concorrenza e la parallelizzazione.\n\nIl vantaggio principale è relativo alla sua chiarezza perché ci si concentra sul risultato desiderato piuttosto che sui dettagli di implementazione.\nLa programmazione imperativa specifica come ottenere un risultato mediante una sequenza di istruzioni, modificando lo stato del programma. La programmazione dichiarativa, al contrario, specifica cosa deve essere ottenuto senza descrivere i dettagli di implementazione. In termini di livello di astrazione, la programmazione dichiarativa si trova a un livello superiore rispetto a quella imperativa.\n\n2.5.1 Linguaggi\nEcco una lista di alcuni linguaggi di programmazione dichiarativi:\n\nSQL (Structured Query Language): Utilizzato per la gestione e l’interrogazione di database relazionali.\nProlog: Un linguaggio di programmazione logica usato principalmente per applicazioni di intelligenza artificiale e linguistica computazionale.\nHTML (HyperText Markup Language): Utilizzato per creare e strutturare pagine web.\nCSS (Cascading Style Sheets): Utilizzato per descrivere la presentazione delle pagine web scritte in HTML o XML.\nXSLT (Extensible Stylesheet Language Transformations): Un linguaggio per trasformare documenti XML in altri formati.\nHaskell: Un linguaggio funzionale che è anche dichiarativo, noto per la sua pura implementazione della programmazione funzionale.\nErlang: Un linguaggio utilizzato per sistemi concorrenti e distribuiti, con caratteristiche dichiarative.\nVHDL (VHSIC Hardware Description Language): Utilizzato per descrivere il comportamento e la struttura di sistemi digitali.\nVerilog: Un altro linguaggio di descrizione hardware usato per la modellazione di sistemi elettronici.\nXQuery: Un linguaggio di query per interrogare documenti XML.\n\nQuesti linguaggi rappresentano diversi ambiti di applicazione, dai database alla descrizione hardware, e sono accomunati dall’approccio dichiarativo nel quale si specifica cosa ottenere piuttosto che come ottenerlo.\n\n\n\n\n\n\nNota\n\n\n\nSQL è uno degli esempi più diffusi di linguaggio di programmazione dichiarativo. Le query SQL descrivono i risultati desiderati piuttosto che le procedure operative.\nUna stored procedure in PL/SQL (Procedural Language/SQL) combina SQL con elementi di linguaggi di programmazione procedurali come blocchi di codice, condizioni e cicli. PL/SQL è quindi un linguaggio procedurale, poiché consente di specificare “come” ottenere i risultati attraverso un flusso di controllo esplicito, rendendolo non puramente dichiarativo. PL/SQL è utilizzato principalmente con il database Oracle.\nUn’alternativa a PL/SQL è T-SQL (Transact-SQL), utilizzato con Microsoft SQL Server e Sybase ASE. Anche T-SQL estende SQL con funzionalità procedurali simili, consentendo la scrittura di istruzioni condizionali, cicli e la gestione delle transazioni. Come PL/SQL, T-SQL è un linguaggio procedurale e non puramente dichiarativo.\nEsistono anche estensioni ad oggetti come il PL/pgSQL (Procedural Language/PostgreSQL) per il database PostgreSQL.\n\n\n\n\n2.5.2 Esempi\nEsempio di una query SQL che estrae tutti i nomi degli utenti con età maggiore di 30:\nCertamente! Ecco il codice SQL con i commenti identificati da un ID progressivo e l’elenco esplicativo:\n1SELECT nome\n2FROM utenti\n3WHERE età &gt; 30;\n\n1\n\nSeleziona la colonna nome.\n\n2\n\nDalla tabella utenti.\n\n3\n\nPer le righe dove la colonna età è maggiore di 30.\n\n\nIn Prolog, si definiscono fatti e regole che descrivono relazioni logiche. Il motore di inferenza di Prolog utilizza queste definizioni per risolvere query, senza richiedere un algoritmo dettagliato. Di seguito, sono definiti due fatti (le prime due righe) e due regole (la terza e la quarta) e quindi si effettua una query che dà come risultato true:\ngenitore(padre, figlio). \ngenitore(madre, figlio).  \nantenato(X, Y) :- genitore(X, Y).  \nantenato(X, Y) :- genitore(X, Z), antenato(Z, Y).  \n\n?- antenato(padre, figlio). \nCommento riga per riga:\n\nQuesta regola dichiara che padre è genitore di figlio.\nQuesta regola dichiara che madre è genitore di figlio.\nQuesta regola stabilisce che X è antenato di Y se X è genitore di Y.\nQuesta regola stabilisce che X è antenato di Y se X è genitore di Z e Z è antenato di Y.\nRiga vuota.\nQuesta è una query che chiede se padre è un antenato di figlio.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-paradigmi-programmazione.html#paradigma-funzionale",
    "href": "prima-parte-paradigmi-programmazione.html#paradigma-funzionale",
    "title": "2  I paradigmi di programmazione",
    "section": "2.6 Paradigma funzionale",
    "text": "2.6 Paradigma funzionale\nLa programmazione funzionale è un paradigma di programmazione che tratta il calcolo come la valutazione di funzioni matematiche ed evita lo stato mutabile e i dati modificabili. I programmi funzionali sono costruiti applicando e componendo funzioni. Questo paradigma è stato ispirato dal calcolo lambda, una formalizzazione matematica del concetto di funzione. La programmazione funzionale è un paradigma alternativo alla programmazione imperativa, che descrive la computazione come una sequenza di istruzioni che modificano lo stato del programma.\nLa programmazione funzionale ha radici storiche che risalgono agli anni ’30, con il lavoro di Alonzo Church sul calcolo lambda. I linguaggi di programmazione funzionale hanno iniziato a svilupparsi negli anni ’50 e ’60 con Lisp, ma è stato negli anni ’70 e ’80 che linguaggi come ML e Haskell hanno consolidato questo paradigma. Haskell, in particolare, è stato progettato per esplorare nuove idee in programmazione funzionale e ha avuto un impatto significativo sulla ricerca e sulla pratica del software.\nLa programmazione funzionale è una forma di programmazione dichiarativa che si basa su funzioni pure e immutabilità. Entrambi i paradigmi evitano stati mutabili e si concentrano sul risultato finale, ma la programmazione funzionale utilizza funzioni matematiche come unità fondamentali di calcolo.\nConcetti fondamentali:\n\nImmutabilità: I dati sono immutabili, il che significa che una volta creati non possono essere modificati. Questo riduce il rischio di effetti collaterali e rende il codice più prevedibile.\nFunzioni di prima classe e di ordine superiore: Le funzioni possono essere passate come argomenti a altre funzioni, ritornate da funzioni, e assegnate a variabili. Le funzioni di ordine superiore accettano altre funzioni come argomenti o restituiscono funzioni.\nPurezza: Le funzioni pure sono funzioni che, dato lo stesso input, restituiscono sempre lo stesso output e non causano effetti collaterali. Questo rende il comportamento del programma più facile da comprendere e prevedere.\nTrasparenza referenziale: Un’espressione è trasparentemente referenziale se può essere sostituita dal suo valore senza cambiare il comportamento del programma. Questo facilita l’ottimizzazione e il reasonig sul codice.\nRicorsione: È spesso utilizzata al posto di loop iterativi per eseguire ripetizioni, poiché si adatta meglio alla natura immutabile dei dati e alla definizione di funzioni.\nComposizione di funzioni: Consente di costruire funzioni complesse combinando funzioni più semplici. Questo favorisce la modularità e la riusabilità del codice.\n\nIl paradigma funzionale ha diversi vantaggi:\n\nPrevedibilità e facilità di test: Le funzioni pure e l’immutabilità rendono il codice più prevedibile e più facile da testare, poiché non ci sono stati mutabili o effetti collaterali nascosti.\nConcorrenza: La programmazione funzionale è ben adatta alla programmazione concorrente e parallela, poiché l’assenza di stato mutabile riduce i problemi di sincronizzazione e competizione per le risorse.\nModularità e riutilizzabilità: La composizione di funzioni e la trasparenza referenziale facilitano la creazione di codice modulare e riutilizzabile.\n\nE qualche svantaggio:\n\nCurva di apprendimento: La programmazione funzionale può essere difficile da apprendere per chi proviene da paradigmi imperativi o orientati agli oggetti, a causa dei concetti matematici sottostanti e della diversa mentalità necessaria.\nPrestazioni: In alcuni casi, l’uso intensivo di funzioni ricorsive può portare a problemi di prestazioni, come il consumo di memoria per le chiamate ricorsive. Tuttavia, molte implementazioni moderne offrono ottimizzazioni come la ricorsione di coda (in inglese, tail recursion).\nDisponibilità di librerie e strumenti: Alcuni linguaggi funzionali potrebbero non avere la stessa ampiezza di librerie e strumenti disponibili rispetto ai linguaggi imperativi più diffusi.\n\n\n2.6.1 Linguaggi\nOltre a Haskell, ci sono molti altri linguaggi funzionali, tra cui:\n\nErlang: Utilizzato per sistemi concorrenti e distribuiti.\nElixir: Costruito a partire da Erlang, è utilizzato per applicazioni web scalabili.\nF#: Parte della piattaforma .NET, combina la programmazione funzionale con lo OOP.\nScala: Anch’esso combina programmazione funzionale e orientata agli oggetti ed è interoperabile con Java.\nOCaml: Conosciuto per le sue prestazioni e sintassi espressiva.\nLisp: Uno dei linguaggi più antichi, multi-paradigma con forti influenze funzionali.\nClojure: Dialetto di Lisp per la JVM, adatto alla concorrenza.\nScheme: Dialetto di Lisp spesso usato nell’educazione.\nML: Linguaggio influente che ha portato allo sviluppo di OCaml e F#.\nRacket: Derivato da Scheme, usato nella ricerca accademica.\n\n\n\n2.6.2 Esempio in Haskell\nDi seguito due funzioni, la prima sumToN è pura e somma i primi n numeri. (*2) è una funzione che prende un argomento e lo moltiplica per 2 e ciò rende la seconda funzione applyFunction una vera funzione di ordine superiore, poiché accetta (*2) come argomento oltre ad una lista, producendo come risultato il raddoppio di tutti i suoi elementi:\nCertamente! Ecco il codice con i commenti identificati da un ID progressivo e l’elenco esplicativo che include le descrizioni:\nsumToN :: Integer -&gt; Integer\n1sumToN n = sum [1..n]\n\napplyFunction :: (a -&gt; b) -&gt; [a] -&gt; [b]\n2applyFunction f lst = map f lst\n\nmain = do\n3    print (sumToN 10)\n4    print (applyFunction (*2) [1, 2, 3, 4])\n\n1\n\nDefinizione di una funzione pura che calcola la somma dei numeri da 1 a n.\n\n2\n\nFunzione di ordine superiore che accetta una funzione e una lista.\n\n3\n\nNel main, stampa il risultato di sumToN 10, che è 55.\n\n4\n\nNel main, stampa il risultato di applyFunction (*2) [1, 2, 3, 4], che è [2, 4, 6, 8].",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>I paradigmi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html",
    "href": "prima-parte-sintassi.html",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "",
    "text": "3.1 Token\nGli elementi atomici della sintassi sono i token. Essi compongono tutte le istruzioni e possono essere sia prodotti dal programmatore che generati dall’analisi del testo da parte dell’interprete o compilatore. La comprensione di quali token siano validi, ci permette sia di scrivere istruzioni corrette, sia di sfruttare appieno i costrutti del linguaggio:\nUn lessema è una sequenza di caratteri nel programma sorgente che corrisponde al pattern di un token ed è identificata dall’analizzatore lessicale come un’istanza di quel token. Un token è una coppia composta da un nome di token e un valore attributo opzionale. Il nome del token è un simbolo astratto che rappresenta un tipo di unità lessicale, come una particolare parola chiave o una sequenza di caratteri di input che denota un identificatore. Un pattern è una descrizione della forma che possono assumere i lessemi di un token. Ad esempio, nel caso di una parola chiave come token, il pattern è semplicemente la sequenza di caratteri che forma la parola chiave. Per gli identificatori e altri token, il pattern è una struttura più complessa che corrisponde a molte stringhe.\nUn esempio per visualizzare i concetti introdotti:",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#token",
    "href": "prima-parte-sintassi.html#token",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "",
    "text": "Parole chiave: Sono termini riservati del linguaggio che hanno significati specifici e non possono essere utilizzati per altri scopi, come if, else, while, for, ecc.\nOperatori: Simboli utilizzati per eseguire operazioni su identificatori e letterali, come +, -, *, /, =, ==, ecc.\nDelimitatori: Caratteri utilizzati per separare elementi del codice, come punto e virgola (;), parentesi tonde (()), parentesi quadre ([]), parentesi graffe ({}), ecc.\nIdentificatori: Nomi utilizzati per identificare variabili, funzioni, classi, e altri oggetti.\nLetterali: Rappresentazioni di valori costanti nel codice, come numeri (123), stringhe (\"hello\"), caratteri ('a'), ecc.\nCommento: Non fanno parte della logica del programma e sono ignorati nell’esecuzione.\nSpazi e tabulazioni: Sono gruppi di caratteri non visualizzabili e spesso ignorati.\n\n\n\nif x == 10:\n\nToken coinvolti:\n\nif: Parola chiave.\nNAME: Identificatore.\nEQEQUAL: Operatore.\nNUMBER: Letterale numerico.\nCOLON: Delimitatore.\n\nLessemi:\n\nIl lessema per il token if è la sequenza di caratteri “if”.\nIl lessema per il token NAME è “x”.\nIl lessema per il token EQEQUAL è “==”.\nIl lessema per il token NUMBER “10”.\nIl lessema per il token COLON “:”.\n\nPattern:\n\nIl pattern per il token if è la stringa esatta “if”.\nIl pattern per un identificatore è una sequenza di lettere e numeri che inizia con una lettera.\nIl pattern per l’operatore == è la stringa esatta “==”.\nIl pattern per un letterale numerico è una sequenza di cifre.\nIl pattern per il delimitatore : è la stringa esatta “:”.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#analizzatore-lessicale-e-parser",
    "href": "prima-parte-sintassi.html#analizzatore-lessicale-e-parser",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.2 Analizzatore lessicale e parser",
    "text": "3.2 Analizzatore lessicale e parser\nL’analizzatore lessicale (o lexer) è un componente del compilatore o interprete che prende in input il codice sorgente del programma e lo divide in lessemi. Esso confronta ciascun lessema con i pattern definiti per il linguaggio di programmazione e genera una sequenza di token. Questi token sono poi passati al parser.\nAd esempio, il codice if x == 10: viene trasformato in una sequenza di token: [IF, NAME(x), EQEQUAL, NUMBER(10), COLON].\nIl parser è un altro componente del compilatore o interprete che prende in input la sequenza di token generata dall’analizzatore lessicale e verifica che la sequenza rispetti le regole sintattiche del linguaggio di programmazione. Il parser analizza i token per formare una struttura gerarchica che rappresenti le relazioni grammaticali tra di essi. Questa struttura interna è spesso un albero di sintassi (parse tree o syntax tree), che riflette la struttura grammaticale del codice sorgente, solitamente descritta usando una forma standard di notazione come la BNF (Backus-Naur Form) o varianti di essa 3. L’albero di sintassi ottenuto viene utilizzato per le successive fasi di compilazione o interpretazione, come quella di analisi semantica e di generazione del codice eseguibile. Ad esempio, il parser può verificare che le espressioni aritmetiche siano ben formate, che le istruzioni siano correttamente annidate e che le dichiarazioni di variabili siano valide.\n3 La BNF (Backus-Naur form o Backus normal form) è una metasintassi, ovvero un formalismo attraverso cui è possibile descrivere la sintassi di linguaggi formali (il prefisso meta ha proprio a che vedere con la natura circolare di questa definizione). Si tratta di uno strumento molto usato per descrivere in modo preciso e non ambiguo la sintassi dei linguaggi di programmazione, dei protocolli di rete e così via, benché non manchino in letteratura esempi di sue applicazioni a contesti anche non informatici e addirittura non tecnologici. Un esempio è la grammatica di Python.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#espressioni",
    "href": "prima-parte-sintassi.html#espressioni",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.3 Espressioni",
    "text": "3.3 Espressioni\nUn’espressione è una combinazione di lessemi che viene valutata per produrre un risultato. Le espressioni sono fondamentali nei linguaggi di programmazione perché permettono di eseguire calcoli, prendere decisioni e manipolare dati.\nEcco alcune tipologie di espressioni (notazioni in Python, ma non molto dissimili da altri linguaggi):\n\nEspressioni aritmetiche: Combinano letterali numerici, identificatori valorizzabili in numeri e operatori aritmetici per eseguire calcoli matematici. Esempi: 5 + 3, y / 4.0, \"Hello, \" + \"world!\".\nEspressioni logiche: Applicano operatori logici per valutare condizioni e produrre valori booleani (vero o falso) a letterali e identificatori. Esempi: x or 5, not y, a and b.\nEspressioni di confronto: Confrontano due valori usando operatori di confronto e restituiscono valori booleani, sempre a partire da letterali e identificatori. Esempi: x &lt; y, x != 42, a &gt;= b.\nEspressioni di chiamata a funzione: Invocano identificatori particolari, funzioni e metodi di oggetti, spesso con parametri definiti da identificatori e letterali, per eseguire operazioni più complesse. Esempi: max(a, b), sin(theta), my_function(x, 42).\nEspressioni di manipolazione di contenitori di dati: Creano e manipolano strutture dati come liste, dizionari, tuple e insiemi contenenti identificatori e letterali. Esempi: [1, x, 3], { 'key': 'value' }, ( 'y', 42 )\nEspressioni condizionali (ternarie): Valutano espressioni e restituiscono un valore basato sul risultato. Esempi: x if x &gt; y else y, 'Even' if n % 2 == 0 else 'Odd'.\n\nLe espressioni si possono comporre in espressioni più complesse come accade per quelle matematiche pur che siano rispettate le regole di compatibilità tra operatori, identificatori e letterali; esempio (x &lt; y) and sin(theta).",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#istruzioni-semplici",
    "href": "prima-parte-sintassi.html#istruzioni-semplici",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.4 Istruzioni semplici",
    "text": "3.4 Istruzioni semplici\nLe istruzioni semplici sono operazioni atomiche secondo il linguaggio e sono costituite da tutti i tipi di lessemi per compiere operazioni di base. I linguaggi di programmazione presentano delle istruzioni condivise nel senso di fondamentali che hanno solo minime differenze ed altre più particolari, perché dipendenti da specificità dalla progettazione del linguaggio. Ciò potrebbe essere anche solo questione di sintassi più che rappresentanti nuovi concetti.\nDi seguito un elenco di istruzioni semplici, alcune standard cioè presenti in tutti o la gran parte dei linguaggi considerati, altre specifiche ma che mettono in evidenza aspetti rilevanti di progettazione:\n\nEspressioni: È eseguibile dal compilatore o interprete, quindi, è una delle istruzioni semplici più importanti quando a sé stante, ma sono presenti anche all’interno di istruzioni semplici e composte. Alcuni esempi in vari linguaggi di somma di due identificatori:\n\nIn Python: x + y.\nIn Java: x + y;.\nIn C: x + y;.\nIn C++: x + y;.\n\nDichiarazione di variabili: La dichiarazione di una variabile introduce una nuova variabile nel programma e specifica il suo tipo4. La dichiarazione non assegna necessariamente un valore iniziale alla variabile. Esempi:\n\nIn Python la dichiarazione avviene automaticamente con l’assegnazione, anche se è possibile annotare il tipo di una variabile, ad esempio x: int = 5, anche se ciò non costringe il programmatore a utilizzare x on interi.\nIn Java: int x;.\nIn C: int x;.\nIn C++: int x;.\n\nAssegnazione: Utilizza un operatore di assegnazione (ad esempio, =) per attribuire un valore rappresentato da un letterale, una espressione o un identificatore, ad un identificatore di variabile, che possiamo pensare come un nome simbolico rappresentante una posizione dove è memorizzato un valore. In alcuni linguaggi deve essere preceduta dalla dichiarazione. Esempio:\n\nIn Python:\nz = (x * 2) + (y / 2)\n\nz: Identificatore della variabile.\n=: Operatore di assegnazione.\n(x * 2): Espressione che moltiplica x per 2.\n(y / 2): Espressione che divide y per 2.\n+: Operatore aritmetico che somma i risultati delle due espressioni in una più complessa. L’esecuzione dell’istruzione produce un risultato valido solo se x e y sono associate a valori numerici e ciò perché non tutte le istruzioni sintatticamente corrette sono semanticamente corrette. D’altronde ciò non deve essere preso come regola, perché se * fosse un operatore che ripete quanto a sinistra un numero di volte definito dal valore di destra e / la divisione del valore di sinistra in parti di numero pari a quanto a destra, allora x e y potrebbero essere stringhe.\n\nIn Java: z = (x * 2) + (y / 2);.\nIn C: z = (x * 2) + (y / 2);.\nIn C++: z = (x * 2) + (y / 2);.\n\nAssegnazione aumentata: Combina un’operazione e un’assegnazione in un’unica istruzione. Esempi per una assegnazione di una variabile del valore ottenuto dalla somma di quello proprio con il numero intero 1:\n\nIn Python: x += 1 è come scrivere x = x + 1.\nIn Java: x += 1;.\nIn C: x += 1;.\nIn C++: x += 1;.\n\nIstruzioni di input/output: Sono espressioni particolari ma generalmente evidenziate perché permettono di interagire con l’utente o di produrre output, spesso con sintassi ad hoc. Esempi:\n\nIn Python: print(\"Hello, World!\").\nIn Java: System.out.println(\"Hello, World!\");.\nIn C: printf(\"Hello, World!\\n\");.\nIn C++: std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;.\n\nIstruzioni di controllo del flusso: Permettono di interrompere o continuare l’esecuzione di cicli o di saltare a una specifica etichetta nel codice. Esempi:\n\nIn Python: break, continue.\nIn Java: break;, continue;.\nIn C: break;, continue;, goto label;.\nIn C++: break;, continue;, goto label;.\n\nGestione della vita degli oggetti: Include la creazione, l’utilizzo e la distruzione dei dati presenti nella memoria del computer. In alcuni linguaggi ciò è parzialmente o totalmente a carico del programmatore, mentre, all’altro estremo, è completamente gestito dal linguaggio. Esempi:\n\nCreazione di oggetti:\n\nIn C++: int* ptr = new int;.\nIn Java: String str = new String(\"Hello, world!\");\nIn Python: Non è presente una istruzione specifica giacché l’espressione MyClass() crea un oggetto di tipo MyClass.\nIn C: La creazione di oggetti è spesso gestita manualmente attraverso l’allocazione di memoria dinamica con funzioni come malloc.\n\nDistruzione di oggetti:\n\nIn Python: La gestione della memoria è automatica tramite il garbage collector.\nIn Java: In Java, la gestione della memoria è affidata al garbage collector.\nIn C++: delete ptr;.\nIn C: free(ptr); (richiede #include &lt;stdlib.h&gt;).\n\nEliminazione di variabili:\n\nIn Python: del x.\n\n\nRitorno di valori: Utilizzata all’interno di funzioni per restituire un valore. Esempi:\n\nIn Python: return x.\nIn Java: return x;.\nIn C: return x;.\nIn C++: return x;.\n\nGenerazione di eccezioni: Utilizzata per generare e inviare un’eccezione, cioè una interruzione della sequenza ordinaria delle istruzione per segnalare una anomalia. Esempi:\n\nIn Python: raise ValueError(\"Invalid input\").\nIn Java: throw new IllegalArgumentException(\"Invalid input\");.\nIn C++: throw std::invalid_argument(\"Invalid input\");.\nIn C: Non esiste un equivalente diretto, ma si possono utilizzare meccanismi come setjmp e longjmp per la gestione degli errori.\n\nImportazione di moduli: Permettono di importare moduli o parti di essi, cioè di utilizzare funzioni, classi, variabili e altri identificatori definiti in altri file o librerie. Esempi:\n\nIn Python: import math, from math import sqrt\nIn Java: import java.util.List;\nIn C: #include &lt;stdio.h&gt;\nIn C++: #include &lt;iostream&gt;\n\nDichiarazioni globali e non locali: Permettono di dichiarare variabili che esistono nell’ambito globale o non locale. Esempi:\n\nIn Python: global x, nonlocal y.\nIn Java: Le variabili globali non sono supportate direttamente; si utilizzano campi statici delle classi.\nIn C: Le variabili globali sono dichiarate al di fuori di qualsiasi funzione.\nIn C++: Le variabili globali sono dichiarate al di fuori di qualsiasi funzione.\n\nAssert: Utilizzata per verificare se una condizione è vera e, in caso contrario, sollevare un’eccezione. Esempi:\n\nIn Python: assert x &gt; 0, \"x deve essere positivo\".\nIn Java: assert x &gt; 0 : \"x deve essere positivo\";.\nIn C: assert(x &gt; 0); (richiede #include &lt;assert.h&gt;).\nIn C++: assert(x &gt; 0); (richiede #include &lt;cassert&gt;).\n\n\n4 Spiegheremo il concetto di tipo a breve, per ora si può pensare ad esso come l’insieme dei possibili valori e operazioni che si possono effettuare su di essi.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#istruzioni-composte-e-blocchi-di-codice",
    "href": "prima-parte-sintassi.html#istruzioni-composte-e-blocchi-di-codice",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.5 Istruzioni composte e blocchi di codice",
    "text": "3.5 Istruzioni composte e blocchi di codice\nLe istruzioni composte sono costituite da più istruzioni semplici e possono includere strutture di controllo del flusso, come condizioni (if), cicli (for, while) ed eccezioni (try, catch). Queste istruzioni sono utilizzate per organizzare il flusso di esecuzione del programma e possono contenere altre istruzioni semplici o composte al loro interno.\nUn blocco di codice è una sezione del codice che raggruppa una serie di istruzioni che devono essere eseguite insieme. I blocchi di codice sono spesso utilizzati all’interno delle istruzioni composte per delimitare il gruppo di istruzioni che devono essere eseguite in determinate condizioni o iterazioni.\nIn molti linguaggi di programmazione, i blocchi di codice sono delimitati da parentesi graffe ({}), mentre in altri linguaggi, come Python, l’indentazione è utilizzata per indicare l’inizio e la fine di un blocco di codice.\nAlcuni esempi di istruzione e blocco di codice:\n\nEsempio in C:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n\n  y = x * 2;\n}\nIn questo esempio:\n\nif (x &gt; 0) e quanto nelle parentesi graffe è un’istruzione composta. if è una parola chiave seguita da una espressione tra delimitatori.\n{ printf(\"x è positivo\\n\"); y = x * 2; } è un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera. Sono presenti diversi delimitatori, una espressione e una istruzione di assegnamento.\n\nEsempio in Python:\nif x &gt; 0:\n  print(\"x è positivo\")\n\n  y = x * 2\nIn questo esempio:\n\nif x &gt; 0: è un’istruzione composta.\nLe righe indentate sotto l’istruzione if, cioè print(\"x è positivo\") e y = x * 2, costituiscono un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\n\nAlcuni esempi di istruzione e blocco di codice:\n\nEsempio in C:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n  y = x * 2;\n}\nIn questo esempio:\n\nif (x &gt; 0) e quanto nelle parentesi graffe è un’istruzione composta.\n{ printf(\"x è positivo\\n\"); y = x * 2; } è un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\nEsempio in Python:\nif x &gt; 0:\n  print(\"x è positivo\")\n  y = x * 2\nIn questo esempio:\n\nif x &gt; 0: è un’istruzione composta.\nLe righe indentate sotto l’istruzione if (print(\"x è positivo\") e y = x * 2) costituiscono un blocco di codice che viene eseguito se la condizione dell’istruzione if è vera.\n\n\nDi seguito sono elencate le istruzioni composte principali, con spiegazioni e semplici esempi di sintassi per Python, Java, C e C++:\n\nCondizionali (if, else if, else): Le istruzioni condizionali permettono l’esecuzione di blocchi di codice basati su espressioni logiche.\n\nPython:\nif x &gt; 0:\n  print(\"x è positivo\")\n\nelif x == 0:\n  print(\"x è zero\")\n\nelse:\n  print(\"x è negativo\")\nJava:\nif (x &gt; 0) {\n  System.out.println(\"x è positivo\");\n} else if (x == 0) {\n  System.out.println(\"x è zero\");\n} else {\n  System.out.println(\"x è negativo\");\n}\nC:\nif (x &gt; 0) {\n  printf(\"x è positivo\\n\");\n} else if (x == 0) {\n  printf(\"x è zero\\n\");\n} else {\n  printf(\"x è negativo\\n\");\n}\nC++:\nif (x &gt; 0) {\n  std::cout &lt;&lt; \"x è positivo\" &lt;&lt; std::endl;\n} else if (x == 0) {\n  std::cout &lt;&lt; \"x è zero\" &lt;&lt; std::endl;\n} else {\n  std::cout &lt;&lt; \"x è negativo\" &lt;&lt; std::endl;\n}\n\nCicli (for): I cicli for permettono di iterare su un insieme di valori o di ripetere l’esecuzione di un blocco di codice per un numero specificato di volte.\n\nPython:\nfor i in range(5):\n  print(i)\nJava:\nfor (int i = 0; i &lt; 5; i++) {\n  System.out.println(i);\n}\nC:\nfor (int i = 0; i &lt; 5; i++) {\n  printf(\"%d\\n\", i);\n}\nC++:\nfor (int i = 0; i &lt; 5; i++) {\n  std::cout &lt;&lt; i &lt;&lt; std::endl;\n}\n\n\nCicli (while): I cicli while ripetono l’esecuzione di un blocco di codice finché una condizione specificata rimane vera.\n\nPython:\nwhile x &gt; 0:\n  print(x)\n\n  x -= 1\nJava:\nwhile (x &gt; 0) {\n  System.out.println(x);\n\n  x--;\n}\nC:\nwhile (x &gt; 0) {\n  printf(\"%d\\n\", x);\n\n  x--;\n}\nC++:\nwhile (x &gt; 0) {\n  std::cout &lt;&lt; x &lt;&lt; std::endl;\n\n  x--;\n}\nGestione delle eccezioni (try, catch): Le istruzioni di gestione delle eccezioni permettono di gestire errori o condizioni anomale che possono verificarsi durante l’esecuzione del programma.\n\nPython:\ntry:\n  value = int(input(\"Inserisci un numero: \"))\n\nexcept ValueError:\n  print(\"Input non valido\")\nJava:\ntry {\n  int value = Integer.parseInt(input);\n\n} catch (NumberFormatException e) {\n  System.out.println(\"Input non valido\");\n}\nC++:\ntry {\n  int value = std::stoi(input);\n\n} catch (const std::invalid_argument& e) {\n  std::cout &lt;&lt; \"Input non valido\" &lt;&lt; std::endl;\n}\nC: C non ha un supporto nativo per la gestione delle eccezioni, ma si possono usare meccanismi come setjmp e longjmp.\n#include &lt;setjmp.h&gt;\n\n1jmp_buf buf;\n\nvoid error() {\n2  longjmp(buf, 1);\n}\n\nint main() {\n3  if (setjmp(buf)) {\n4    printf(\"Errore rilevato\\n\");\n\n  } else {\n5    error();\n  }\n  return 0;\n}\n\n1\n\nDichiarazione di una variabile di tipo jmp_buf.\n\n2\n\nSalta al punto salvato in buf con valore di ritorno 1.\n\n3\n\nSalva il contesto di esecuzione attuale in buf.\n\n4\n\nEsegue se longjmp viene chiamato.\n\n5\n\nChiama la funzione error, che salta indietro al punto setjmp.\n\n\n\nSelezione multipla (switch, case, default): Le istruzioni di selezione multipla permettono di eseguire uno tra diversi blocchi di codice basati sul valore di un’espressione.\n\nPython (a partire da Python 3.10 con match):\nmatch x:\n  case 0:\n    print(\"x è zero\")\n\n  case 1:\n    print(\"x è uno\")\n\n  case _:\n    print(\"x è un altro numero\")\nJava:\nswitch (x) {\n  case 0:\n    System.out.println(\"x è zero\");\n\n    break;\n\n  case 1:\n    System.out.println(\"x è uno\");\n\n    break;\n\n  default:\n    System.out.println(\"x è un altro numero\");\n\n    break;\n}\nC:\nswitch (x) {\n  case 0:\n    printf(\"x è zero\\n\");\n\n    break;\n\n  case 1:\n    printf(\"x è uno\\n\");\n\n    break;\n\n  default:\n    printf(\"x è un altro numero\\n\");\n\n    break;\n}\nC++:\nswitch (x) {\n  case 0:\n    std::cout &lt;&lt; \"x è zero\" &lt;&lt; std::endl;\n\n    break;\n\n  case 1:\n    std::cout &lt;&lt; \"x è uno\" &lt;&lt; std::endl;\n\n    break;\n\n  default:\n    std::cout &lt;&lt; \"x è un altro numero\" &lt;&lt; std::endl;\n\n    break;\n}",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-sintassi.html#organizzazione-delle-istruzioni-in-un-programma",
    "href": "prima-parte-sintassi.html#organizzazione-delle-istruzioni-in-un-programma",
    "title": "3  La sintassi dei linguaggi di programmazione",
    "section": "3.6 Organizzazione delle istruzioni in un programma",
    "text": "3.6 Organizzazione delle istruzioni in un programma\nIl programma è solitamente salvato in un file di testo in righe. Queste righe possono essere classificate in righe fisiche e righe logiche.\nUna riga fisica è una linea di testo nel file sorgente del programma, terminata da un carattere di a capo.\nEsempio:\n1int x = 10;\n\n1\n\nQuesta è una riga fisica.\n\n\nUna riga logica è una singola istruzione, che può estendersi su una o più righe fisiche.\nEsempio di riga logica con più righe fisiche:\n1int y = (10 + 20 + 30 +\n2         40 + 50);\n\n1\n\nPrima riga fisica della riga logica.\n\n2\n\nSeconda riga fisica della riga logica.\n\n\nIl concetto di righe fisiche e logiche esiste perché le istruzioni (o righe logiche) possono essere lunghe e composte, richiedendo più righe fisiche per migliorare la leggibilità e la gestione del codice.\nIn molti linguaggi di programmazione, l’uso di righe fisiche e logiche facilita l’organizzazione e la formattazione del codice. Ad esempio:\n\nPython utilizza l’indentazione per definire i blocchi di codice, quindi una riga logica che si estende su più righe fisiche deve continuare con una corretta indentazione. Inoltre, è possibile usare il carattere di continuazione (\\) per indicare che una riga logica prosegue sulla riga successiva:\nresult = (10 + 20 + 30 + \\\n          40 + 50)\nJava e C utilizzano le parentesi graffe ({}) per delimitare i blocchi di codice, e le istruzioni possono estendersi su più righe fisiche senza il bisogno di un carattere di continuazione, grazie al punto e virgola (;) che termina le istruzioni:\nint y = (10 + 20 + 30 + \n         40 + 50);\nint y = (10 + 20 + 30 + \n         40 + 50);\n\nL’uso corretto di righe fisiche e logiche migliora la leggibilità del codice, rendendolo più facile da capire e mantenere. Inoltre, una buona formattazione del codice facilita il lavoro di squadra, poiché gli sviluppatori possono facilmente seguire e comprendere la logica implementata da altri.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La sintassi dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html",
    "href": "prima-parte-variabili-funzioni.html",
    "title": "4  Le variabili e le funzioni",
    "section": "",
    "text": "4.1 Variabili\nLe variabili sono uno dei concetti fondamentali nella programmazione, essenziali per la manipolazione e la gestione dei dati. Una variabile è un nome simbolico associato a una locazione di memoria che può contenere uno o più valori di un certo tipo di dato. Questo concetto permette agli sviluppatori di astrarre dalla memoria fisica e concentrarsi sulla logica del programma.\nLa gestione delle variabili varia tra i diversi linguaggi di programmazione, quindi esploreremo le variabili con particolare attenzione a Python, Java, C e C++.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html#variabili",
    "href": "prima-parte-variabili-funzioni.html#variabili",
    "title": "4  Le variabili e le funzioni",
    "section": "",
    "text": "4.1.1 Dichiarazione e inizializzazione\nLa dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. Questo processo informa il compilatore o l’interprete che una certa variabile esiste e può essere utilizzata nel codice. Abbiamo visto che esiste una istruzione specifica in alcuni linguaggi, mentre in altri è implicita nella assegnazione.\nL’inizializzazione di una variabile è il processo di assegnazione di un valore iniziale alla variabile. Questo può avvenire contestualmente alla dichiarazione o in un’istruzione separata successiva, quella di assegnamento.\nEsempi:\n\nIn Python, le variabili sono dichiarate automaticamente al momento dell’assegnazione del valore. Non è necessario specificare il tipo di dato, poiché Python è dinamicamente tipizzato, cioè determina durante l’esecuzione il tipo di dato del valore associato alla variabile.\n1x = 10\n2x = \"Hello\"\n\n1\n\nDichiarazione e inizializzazione.\n\n2\n\nCambia il tipo di x dinamicamente a stringa.\n\n\nJava: In Java, le variabili devono essere dichiarate con un tipo di dato esplicito. La dichiarazione può avvenire contestualmente all’inizializzazione o separatamente.\nint x;\nx = 10;\nint y = 20;\n\n\nDichiarazione.\nInizializzazione.\nDichiarazione e inizializzazione.\n\n\nC: In C, la dichiarazione delle variabili richiede la specifica del tipo di dato. La dichiarazione e l’inizializzazione possono essere separate o combinate.\nint x;\nx = 10;\nint y = 20;\n\n\nDichiarazione.\nInizializzazione.\nDichiarazione e inizializzazione.\n\n\nC++: Simile al C, ma con funzionalità aggiuntive come l’inizializzazione a lista.\n1int x;\n2x = 10;\n3int y = 20;\n4int z{30};\n5int arr[5] = {1, 2, 3, 4, 5};\n\n1\n\nDichiarazione.\n\n2\n\nInizializzazione.\n\n3\n\nDichiarazione e inizializzazione.\n\n4\n\nDichiarazione e inizializzazione a lista di z con l’intero 30.\n\n5\n\nDichiarazione e inizializzazione a lista di un array con 5 valori predefiniti.\n\n\n\n\n\n4.1.2 Ambito delle variabili\nL’ambito di una variabile rappresenta la porzione del codice in cui l’identificatore della variabile è definito e, quindi, può essere utilizzato. Gli approcci dei diversi linguaggi sono diversi, infatti Java, C e C++ hanno una gestione dell’ambito delle variabili per cui quelle dichiarate all’interno di un blocco sono limitate a quel blocco e non sono visibili al di fuori di esso. In Python, invece, le variabili definite all’interno di un blocco di un’istruzione composta (come un ciclo for o una condizione if) rimangono accessibili anche al di fuori del blocco, purché siano ancora nel medesimo ambito di funzione o modulo e, soprattutto quel blocco sia stato eseguito.\n\nGlobale: Le variabili globali sono dichiarate al di fuori di qualsiasi blocco e sono accessibili ovunque nel programma.\n1int globalVar = 10;\n\n2void function() {\n3  printf(\"%d\\n\", globalVar);\n}\n\n1\n\nVariabile globale.\n\n2\n\nInizio del blocco.\n\n3\n\nAccesso alla variabile globale.\n\n\nLocale: Le variabili locali sono dichiarate all’interno di un blocco, come una funzione o un loop, e sono accessibili solo all’interno di quel blocco.\npublic class Main {\n  public static void main(String[] args) {\n    if (true) {\n1      int x = 10;\n    }\n\n2    System.out.println(x);\n\n    for (int i = 0; i &lt; 10; i++) {\n3      int y = i;\n    }\n\n4    System.out.println(y);\n  }\n}\n\n1\n\nVariabile locale al blocco if.\n\n2\n\nErrore: x non è visibile qui!\n\n3\n\nVariabile locale al blocco for.\n\n4\n\nErrore: y non è visibile qui.\n\n\nIn Python, una variabile definita all’interno di un blocco di un’istruzione composta, come all’interno di un ciclo for o di una condizione if, rimane accessibile anche dopo l’esecuzione del blocco:\nfor i in range(10):\n  loopVar = i  # \n\nprint(loopVar)  # \n\nVariabile locale al ciclo.\nloopVar è ancora accessibile qui.\n\n\n\n\n4.1.3 Visibilità delle variabili\nLa visibilità si riferisce alla possibilità che in una regione di codice una certa variabile possa essere vista e utilizzata. Anche se correlata all’ambito, la visibilità può essere influenzata da altri fattori come la modularità e gli spazi di nomi (namespace).\n\nConsideriamo un esempio in C++ per illustrare la differenza tra ambito e visibilità:\n#include &lt;iostream&gt;\n\n1int globalVar = 10;\n\nvoid function() {\n2  int localVar = 5;\n\n3  std::cout &lt;&lt; globalVar &lt;&lt; std::endl;\n4  std::cout &lt;&lt; localVar &lt;&lt; std::endl;\n}\n\nint main() {\n  function();\n\n5  std::cout &lt;&lt; globalVar &lt;&lt; std::endl;\n6  std::cout &lt;&lt; localVar &lt;&lt; std::endl;\n\n  return 0;\n}\n\n1\n\nVariabile globale (ambito globale).\n\n2\n\nVariabile locale (ambito locale alla funzione).\n\n3\n\nVisibilità globaleVar all’interno della funzione.\n\n4\n\nVisibilità localVar all’interno della funzione.\n\n5\n\nVisibilità globalVar all’interno di main.\n\n6\n\nErrore: localVar non è visibile qui (ambito locale alla funzione function).\n\n\nIn Python, le variabili definite all’interno di una funzione sono locali a quella funzione, ma le variabili definite all’interno di un blocco (come un ciclo for o un if) sono visibili all’interno della funzione o del modulo in cui si trovano:\n1globalVar = 10\n\ndef function():\n2  localVar = 5\n\n  if True:\n3    blockVar = 20\n\n4  print(localVar)\n5  print(blockVar)\n\nfunction()\n\n6print(globalVar)\n7print(localVar)\n8print(blockVar)\n\n1\n\nVariabile globale.\n\n2\n\nVariabile locale.\n\n3\n\nVisibile all’interno della funzione.\n\n4\n\nVisibile.\n\n5\n\nVisibile.\n\n6\n\nVisibile.\n\n7\n\nErrore: non visibile al di fuori della funzione.\n\n8\n\nErrore: non visibile al di fuori della funzione.\n\n\n\n\n\n4.1.4 Durata di vita degli oggetti referenziati\nLa durata di vita descrive per quanto tempo un oggetto rimane in memoria durante l’esecuzione del programma. Questo è distinto dalla variabile (o puntatore) che fa riferimento all’oggetto.\nIn alcuni linguaggi di programmazione è presente il garbage collector, cioè un processo avviato dal compilatore o interprete che si occupa di rendere nuovamente disponibili le aree di memoria precedentemente occupate da oggetti non più referenziati da variabili. Questo accade quando l’esecuzione del programma raggiunge regioni di codice dove quelle variabili non sono più visibili. In questo modo, la visibilità è legata alla durata di vita degli oggetti, rendendo la gestione della memoria non più una preoccupazione del programmatore.\n\nVariabile automatica: L’oggetto esiste solo durante l’esecuzione del blocco di codice in cui è stata dichiarata la variabile a cui è associato.\nvoid function() {\n1  int autoVar = 10;\n} \n\n2printf(\"autoVar cancellata!\");\n\n1\n\nDichiarazione di autoVar e creazione in memoria di un oggetto corrispondente all’intero 10.\n\n2\n\nPrima di questa istruzione l’oggetto 10 non è più presente in memoria.\n\n\nVariabile statica: La variabile esiste per tutta la durata del programma, ma è accessibile solo all’interno del blocco in cui è dichiarata.\nvoid function() {\n1  static int staticVar = 10;\n}\n\n1\n\nVariabile statica ottenuta con una parola chiave ad hoc in fase di dichiarazione.\n\n\nVariabile dinamica: Le variabili dinamiche sono utilizzate per riservare memoria che persiste oltre la durata del blocco di codice in cui sono state create. L’oggetto è creato in memoria e deve essere cancellato esplicitamente dall’utente, utilizzando funzioni di gestione della memoria come delete. La variabile che punta all’oggetto è separata dall’oggetto stesso, quindi se la variabile non è più visibile, l’oggetto continuerà a rimanere in memoria e non sarà più eliminabile, causando una perdita di memoria (memory leak).\n#include &lt;iostream&gt;\n\nvoid function() {\n1  int* dynamicVar = new int(10);\n2  std::cout &lt;&lt; \"dynamicVar: \" &lt;&lt; *dynamicVar &lt;&lt; std::endl;\n}\n\nint main() {\n3  function();\n\n4  int* safeDynamicVar = new int(20);\n\n5  std::cout &lt;&lt; \"safeDynamicVar: \" &lt;&lt; *safeDynamicVar &lt;&lt; std::endl;\n\n6  delete safeDynamicVar;\n\n  return 0;\n\n1\n\nAllocazione dinamica di un intero all’interno della funzione function().\n\n2\n\nStampa del valore puntato da dynamicVar. Prima della chiusura del blocco non viene deallocata dynamicVar per dimostrare il problema di perdita di memoria\n\n3\n\nChiamata alla funzione function(). Dopo l’uscita dalla funzione, dynamicVar non è più accessibile, causando una perdita di memoria poiché non è stata deallocata.\n\n4\n\nAllocazione dinamica di un intero.\n\n5\n\nStampa del valore puntato da safeDynamicVar.\n\n6\n\nDeallocazione dinamica dell’intero. Corretto uso di allocazione e deallocazione dinamica.\n\n\nIn Python, la gestione della memoria è automatica grazie al garbage collector. Quando non ci sono più riferimenti di variabili a un oggetto, il garbage collector lo rimuove dalla memoria.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html#funzioni",
    "href": "prima-parte-variabili-funzioni.html#funzioni",
    "title": "4  Le variabili e le funzioni",
    "section": "4.2 Funzioni",
    "text": "4.2 Funzioni\nLe funzioni sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Questi costrutti sono fondamentali per la strutturazione e la modularizzazione del codice, consentendo di definire operazioni che possono essere invocate più volte durante l’esecuzione di un programma. La distinzione tra funzioni e metodi è che le funzioni sono indipendenti, mentre i metodi sono associati a oggetti o classi.\n\n4.2.1 Parametri e argomenti\nI parametri e gli argomenti sono strumenti fondamentali per passare informazioni alle funzioni e influenzarne il comportamento.\n\nParametri o parametri formali: I parametri sono definiti nella dichiarazione della funzione e rappresentano i nomi delle variabili che la funzione utilizzerà per accedere ai dati passati.\nArgomenti o parametri attuali: Gli argomenti sono i valori effettivi passati alla funzione quando viene chiamata.\n\nEsempio in Python:\n1def add(a, b):\n  return a + b\n\n2result = add(3, 4)\n\n3print(result)\n\n1\n\na e b sono parametri della funzione add.\n\n2\n\n3 e 4 sono argomenti passati alla funzione add.\n\n3\n\nIl risultato della funzione add viene stampato.\n\n\n\n\n4.2.2 Valore di ritorno\nIl valore di ritorno è il risultato prodotto da una funzione, che può essere utilizzato nell’istruzione chiamante. Una funzione può restituire un valore utilizzando la parola chiave return.\nEsempio in Java:\npublic class Main {\n1  public static int add(int a, int b) {\n2    return a + b;\n  }\n\n  public static void main(String[] args) {\n3    int result = add(3, 4);\n\n4    System.out.println(result);\n  }\n}\n\n1\n\nDichiarazione della funzione add che accetta due parametri interi.\n\n2\n\nLa funzione add ritorna la somma di a e b.\n\n3\n\nChiamata della funzione add con argomenti 3 e 4.\n\n4\n\nIl risultato della funzione add viene stampato.\n\n\n\n\n4.2.3 Ricorsione\nLa ricorsione è la capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili. Ogni chiamata ricorsiva deve avvicinarsi a una condizione di terminazione per evitare loop infiniti.\nEsempio in C++ (calcolo del fattoriale):\n#include &lt;iostream&gt;\n\n1int factorial(int n) {\n2  if (n &lt;= 1) return 1;\n\n3  return n * factorial(n - 1);\n}\n\nint main() {\n4  int result = factorial(5);\n\n5  std::cout &lt;&lt; result &lt;&lt; std::endl;\n  \n  return 0;\n}\n\n1\n\nDichiarazione della funzione factorial.\n\n2\n\nCondizione di terminazione: se n è minore o uguale a 1, ritorna 1.\n\n3\n\nChiamata ricorsiva: factorial chiama se stessa con n - 1.\n\n4\n\nChiamata della funzione factorial con argomento 5.\n\n5\n\nIl risultato della funzione factorial viene stampato.\n\n\n\n\n4.2.4 Funzioni di prima classe\nLe funzioni di prima classe sono funzioni che possono essere trattate come qualsiasi altra variabile. Possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.\n\nEsempio in Python:\ndef greet(name):\n  return f\"Hello, {name}!\"\n\n1say_hello = greet\n\n2print(say_hello(\"World\"))\n\n1\n\nLa funzione greet viene assegnata alla variabile say_hello.\n\n2\n\nsay_hello viene chiamata con l’argomento \"World\".\n\n\nEsempio in C++:\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nvoid greet(const std::string& name) {\n  std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; std::endl;\n}\n\nint main() {\n  std::function&lt;void(const std::string&)&gt; say_hello = greet;\n\n  say_hello(\"World\");\n\n  return 0;\n\n\nLa funzione greet viene assegnata alla variabile say_hello utilizzando std::function.\nsay_hello viene chiamata con l’argomento \"World\".\n\n\n\n4.2.5 Funzioni di ordine superiore\nLe funzioni di ordine superiore sono funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati. Sono fondamentali per la programmazione funzionale.\n\nEsempio in Python:\ndef add(a):\n  def inner(b):\n    return a + b\n\n1  return inner\n\n2add_five = add(5)\n\n3print(add_five(3))\n\n1\n\nLa funzione add ritorna una nuova funzione inner che somma a al suo argomento b.\n\n2\n\nadd(5) ritorna una nuova funzione che somma 5 al suo argomento.\n\n3\n\nLa funzione risultante viene chiamata con l’argomento 3, restituendo 8.\n\n\nEsempio in C++:\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstd::function&lt;int(int)&gt; add(int a) {\n  return [a](int b) { return a + b; };\n}\n\nint main() {\n  auto add_five = add(5);\n\n  std::cout &lt;&lt; add_five(3) &lt;&lt; std::endl;\n\n  return 0;\n}\n\n\nDichiarazione della funzione add che ritorna un std::function&lt;int(int)&gt;.\nadd ritorna una funzione lambda che somma a al suo argomento b.\nadd(5) ritorna una nuova funzione che somma 5 al suo argomento.\nLa funzione risultante viene chiamata con l’argomento 3, restituendo 8.\n\n\n\n4.2.6 Ambito e visibilità\nL’ambito e la visibilità degli identificatori delle funzioni sono concetti sono simili a quelli delle variabili, ma presentano alcune differenze chiave che è importante comprendere.\n\n4.2.6.1 Ambito\nPer le funzioni distinguiamo sempre i seguenti:\n\nAmbito globale: Una funzione dichiarata a livello globale, cioè al di fuori di qualsiasi altra funzione o blocco di codice, ha un ambito globale. Questo significa che la funzione è visibile e può essere chiamata da qualsiasi punto del programma dopo la sua dichiarazione.\nEsempio in C++:\n#include &lt;iostream&gt;\n\n1void globalFunction() {\n  std::cout &lt;&lt; \"Funzione globale\" &lt;&lt; std::endl;\n}\n\nint main() {\n2  globalFunction();\n\n  return 0;\n\n1\n\nDichiarazione della funzione globalFunction a livello globale.\n\n2\n\nChiamata della funzione globalFunction all’interno di main.\n\n\nIl comportamento è identico in Java e C. In Python, le funzioni definite a livello globale hanno ambito globale.\nAmbito locale: Una funzione dichiarata all’interno di un blocco di codice (come all’interno di una funzione o di una classe) ha un ambito locale. La funzione è visibile e può essere chiamata solo all’interno di quel blocco.\nEsempio in Python:\ndef outerFunction():\n1  def localFunction():\n    print(\"Funzione locale\")\n\n2  localFunction()\n\nouterFunction()\n\n3localFunction()\n\n1\n\nDichiarazione della funzione localFunction all’interno di outerFunction.\n\n2\n\nChiamata della funzione localFunction all’interno di outerFunction.\n\n3\n\nChiamata a localFunction al di fuori di outerFunction, che genera un errore poiché localFunction non è visibile a questo livello.\n\n\nIn Java e C++, le funzioni dichiarate all’interno di un blocco (come metodi all’interno di una classe) sono accessibili solo all’interno di quel blocco, simile a Python.\nIn C, le funzioni locali non sono standard, ma è possibile ottenere un comportamento simile usando funzioni statiche o funzioni inline definite all’interno di un file sorgente specifico.\n\n\n\n4.2.6.2 Visibilità\nLa visibilità si riferisce a dove nel codice l’identificatore di una funzione può essere utilizzato. La visibilità è strettamente legata all’ambito, ma può essere influenzata anche da altre considerazioni come la modularità e le regole di accesso.\n\nVisibilità Globale: Le funzioni con ambito globale sono visibili ovunque nel programma come per le variabili.\nVisibilità Locale: Le funzioni con ambito locale sono visibili solo all’interno del blocco in cui sono dichiarate. Questo è utile per creare funzioni di supporto (helper) o interne che non devono essere accessibili dall’esterno.\nEsempio in Python:\ndef outerFunction():\n1  def helperFunction():\n    print(\"Funzione helper\")\n\n2  helperFunction()\n\n  print(\"Funzione esterna\")\n\nouterFunction()\n\n1\n\nDichiarazione della funzione helperFunction all’interno di outerFunction.\n\n2\n\nChiamata della funzione helperFunction all’interno di outerFunction.\n\n\n\n\n\n4.2.6.3 Differenze tra funzioni con variabili e oggetti\nSebbene l’ambito e la visibilità delle funzioni condividano concetti simili con le variabili e gli oggetti, ci sono alcune differenze chiave:\n\nDurata di vita: Le variabili locali (automatiche) hanno una durata di vita limitata al blocco di codice in cui sono dichiarate. Quando il controllo esce dal blocco, la memoria allocata per la variabile viene liberata. Le funzioni, tuttavia, non vengono “distrutte” quando il controllo esce dal loro ambito; semplicemente non sono più visibili e chiamabili. In Python, le variabili definite all’interno di un blocco di un’istruzione composta rimangono accessibili finché sono nello stesso ambito di funzione o modulo, mentre le funzioni definite all’interno di un’altra funzione (nested functions) sono visibili solo all’interno di quella funzione.\nAllocazione dinamica: In C++, le variabili e gli oggetti possono essere allocati dinamicamente usando new e deallocati usando delete. Le funzioni non richiedono un’allocazione esplicita di memoria; la loro dichiarazione è sufficiente per renderle utilizzabili nell’ambito definito.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-variabili-funzioni.html#spazi-di-nomi-moduli-e-file",
    "href": "prima-parte-variabili-funzioni.html#spazi-di-nomi-moduli-e-file",
    "title": "4  Le variabili e le funzioni",
    "section": "4.3 Spazi di nomi, moduli e file",
    "text": "4.3 Spazi di nomi, moduli e file\nIn molti linguaggi di programmazione, la gestione dell’ambito e della visibilità delle variabili e delle funzioni può essere ulteriormente organizzata utilizzando spazio di nomi (namespace), moduli, header e file separati. Questa organizzazione aiuta a evitare conflitti di nome e a mantenere il codice più modulare e manutenibile.\n\n4.3.1 Python\nIn Python, i moduli sono file che contengono definizioni di variabili, funzioni e classi. I moduli possono essere importati in altri moduli o script per riutilizzare il codice. Quando un modulo viene importato, gli identificatori definiti in quel modulo (come variabili, funzioni e classi) diventano accessibili attraverso il nome del modulo. Sebbene i moduli siano spesso implementati come file separati, è possibile definirli anche all’interno di un file di codice sorgente principale.\nEsempio di modulo (mymodule.py):\n# mymodule.py\n1my_var = 10\n\ndef my_function():\n2    print(\"Funzione del modulo\")\n\n1\n\nVariabile globale nel modulo.\n\n2\n\nFunzione nel modulo.\n\n\nImportazione di un modulo in un altro file sorgente (main.py):\n# main.py\n1import mymodule\n\n2print(mymodule.my_var)\n3mymodule.my_function()\n\n1\n\nImportazione del modulo mymodule.\n\n2\n\nAccesso alla variabile my_var dal modulo mymodule.\n\n3\n\nChiamata della funzione my_function dal modulo mymodule.\n\n\n\n\n4.3.2 Java\nIn Java, i pacchetti (package) sono utilizzati per organizzare le classi in namespace separati. Ogni classe deve dichiarare il pacchetto di appartenenza.\nEsempio di classe in un pacchetto (mypackage/MyClass.java):\n// mypackage/MyClass.java\n1package mypackage;\n\npublic class MyClass {\n2    public static int myVar = 10;\n\n    public static void myMethod() {\n3        System.out.println(\"Metodo del pacchetto\");\n    }\n}\n\n1\n\nDichiarazione del pacchetto mypackage.\n\n2\n\nVariabile globale di classe.\n\n3\n\nMetodo della classe.\n\n\nImportazione di una classe da un pacchetto in un’altra classe (Main.java):\n// Main.java\n1import mypackage.MyClass;\n\npublic class Main {\n    public static void main(String[] args) {\n2        System.out.println(MyClass.myVar);\n3        MyClass.myMethod();\n    }\n}\n\n1\n\nImportazione della classe MyClass dal pacchetto mypackage.\n\n2\n\nAccesso alla variabile myVar dalla classe MyClass.\n\n3\n\nChiamata del metodo myMethod dalla classe MyClass.\n\n\n\n\n4.3.3 C\nIn C, i file di intestazione (header file) sono utilizzati per dichiarare funzioni e variabili che possono essere utilizzate in più file sorgente, a mo’ di libreria.\nEsempio di file di intestazione (mymodule.h):\n// mymodule.h\n#ifndef MYMODULE_H \n#define MYMODULE_H\n\n1extern int myVar;\n\n2void myFunction();\n\n#endif\n\n1\n\nDichiarazione della variabile globale myVar.\n\n2\n\nDichiarazione della funzione myFunction.\n\n\nEsempio di file sorgente (mymodule.c):\n#include \"mymodule.h\"\n\n1int myVar = 10;\n\nvoid myFunction() {\n2    printf(\"Funzione del modulo\\n\");\n}\n\n1\n\nDefinizione della variabile globale myVar.\n\n2\n\nDefinizione della funzione myFunction.\n\n\nUtilizzo del file di intestazione in un altro file sorgente (main.c):\n#include &lt;stdio.h&gt;\n1#include \"mymodule.h\"\n\nint main() {\n2    printf(\"%d\\n\", myVar);\n\n3    myFunction();\n\n    return 0;\n}\n\n1\n\nInclusione del file di intestazione mymodule.h.\n\n2\n\nAccesso alla variabile myVar dichiarata in mymodule.h.\n\n3\n\nChiamata della funzione myFunction dichiarata in mymodule.h.\n\n\n\n\n4.3.4 C++\nIn C++, la parola chiave namespace è utilizzata per organizzare le classi, le funzioni e le variabili in spazi di nomi separati, simili ai pacchetti in Java.\nEsempio di dichiarazione di uno spazio di nomi (mymodule.h):\n#ifndef MYMODULE_H \n#define MYMODULE_H\n\n1namespace mynamespace {\n2    extern int myVar;\n\n3    void myFunction();\n}\n\n#endif\n\n1\n\nDichiarazione dello spazio di nomi mynamespace.\n\n2\n\nDichiarazione della variabile globale myVar all’interno dello spazio di nomi.\n\n3\n\nDichiarazione della funzione myFunction all’interno dello spazio di nomi.\n\n\nEsempio di definizione dello spazio di nomi (mymodule.cpp):\n#include \"mymodule.h\"\n#include &lt;iostream&gt;\n\nnamespace mynamespace {\n1    int myVar = 10;\n\n    void myFunction() {\n2        std::cout &lt;&lt; \"Funzione del namespace\" &lt;&lt; std::endl;\n    }\n}\n\n1\n\nDefinizione della variabile globale myVar all’interno dello spazio di nomi.\n\n2\n\nDefinizione della funzione myFunction all’interno dello spazio di nomi.\n\n\nUtilizzo dello spazio di nomi in un altro file sorgente (main.cpp):\n#include \"mymodule.h\"\n#include &lt;iostream&gt;\n\nint main() {\n1    std::cout &lt;&lt; mynamespace::myVar &lt;&lt; std::endl;\n2    mynamespace::myFunction();\n    return 0;\n}\n\n1\n\nAccesso alla variabile myVar all’interno dello spazio di nomi mynamespace.\n\n2\n\nChiamata della funzione myFunction all’interno dello spazio di nomi mynamespace.\n\n\n\n\n4.3.5 Impatti\nL’uso di spazio di nomi, moduli e file di intestazione influisce sull’ambito e sulla visibilità delle variabili e delle funzioni. In generale, questi meccanismi consentono una maggiore modularità e organizzazione del codice, facilitando la gestione di grandi progetti.\n\nAmbito: L’ambito delle variabili e delle funzioni può essere limitato a uno spazio di nomi o a un modulo, riducendo il rischio di conflitti di nome.\nVisibilità: Le variabili e le funzioni dichiarate in namespace o moduli possono essere visibili solo all’interno di quel namespace o modulo, a meno che non vengano esplicitamente esportate.\nDurata di vita degli oggetti: La durata di vita degli oggetti non è direttamente influenzata dallo spazio di nomi o moduli, ma l’organizzazione del codice può rendere più chiaro quando e dove gli oggetti vengono creati e distrutti.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Le variabili e le funzioni</span>"
    ]
  },
  {
    "objectID": "prima-parte-modello-dati.html",
    "href": "prima-parte-modello-dati.html",
    "title": "5  Il modello dati dei linguaggi di programmazione",
    "section": "",
    "text": "5.1 Linguaggi procedurali\nNei linguaggi di programmazione procedurali, il modello dati è incentrato su tipi di dati semplici e compositi che supportano lo stile di programmazione orientato alle funzioni e procedure. Alcune caratteristiche tipiche includono:\nEsempio in C:\nL’esempio mostra come nel modello dati del linguaggio C possono essere definiti dei tipi compositi (Dato, Valore) e delle operazioni su quelli (stampa_dato, confronta_dato, inserisci_dato, cancella_dato). Il codice, pur realizzante una semplice libreria, appare slegato, cioè con funzioni che si applicano a tipi di dati specifici solo dall’interpretazione degli identificatori della funzione stessa e dei suoi parametri, cioè senza un legame esplicito e non ambiguo, tra tipo e funzione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Il modello dati dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-modello-dati.html#linguaggi-procedurali",
    "href": "prima-parte-modello-dati.html#linguaggi-procedurali",
    "title": "5  Il modello dati dei linguaggi di programmazione",
    "section": "",
    "text": "Tipi primitivi: Numeri interi, numeri a virgola mobile, caratteri e booleani.\nStrutture composite: Array, strutture (struct) e unioni (union). Gli array permettono di gestire collezioni di elementi dello stesso tipo, mentre le strutture permettono di combinare vari tipi di dati sotto un unico nome. Le unioni consentono di memorizzare diversi tipi di dati nello stesso spazio di memoria, ma solo uno di essi può essere attivo alla volta.\nOperazioni basate su funzioni: Le operazioni sui dati vengono eseguite attraverso funzioni che manipolano i valori passati come argomenti.\n\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_DATI 100\n\n1union Valore {\n  int intero;\n  float decimale;\n  char carattere;\n};\n\n2struct Dato {\n  char tipo;  \n  // 'i' per int, 'f' per float, 'c' per char\n  union Valore valore;\n};\n\n3void stampa_dato(struct Dato d) {\n  switch (d.tipo) {\n    case 'i':\n      printf(\"Intero: %d\\n\", d.valore.intero);\n      break;\n\n    case 'f':\n      printf(\"Float: %f\\n\", d.valore.decimale);\n      break;\n\n    case 'c':\n      printf(\"Carattere: %c\\n\", d.valore.carattere);\n      break;\n\n    default:\n      printf(\"Tipo sconosciuto\\n\");\n      break;\n  }\n}\n\nint confronta_dato(struct Dato d1, struct Dato d2) {\n  if (d1.tipo != d2.tipo) return 0;\n\n  switch (d1.tipo) {\n    case 'i': return d1.valore.intero == d2.valore.intero;\n\n    case 'f': return d1.valore.decimale == d2.valore.decimale;\n\n    case 'c': return d1.valore.carattere == d2.valore.carattere;\n\n    default: return 0;\n  }\n}\n\n4void inserisci_dato(struct Dato dati[], int *count, struct Dato nuovo_dato) {\n  if (*count &lt; MAX_DATI) {\n    dati[*count] = nuovo_dato;\n\n    (*count)++;\n\n  } else {\n    printf(\"Array pieno, impossibile inserire nuovo dato.\\n\");\n  }\n}\n\n5void cancella_dato(struct Dato dati[], int *count, struct Dato dato_da_cancellare) {\n  for (int i = 0; i &lt; *count; i++) {\n    if (confronta_dato(dati[i], dato_da_cancellare)) {\n      for (int j = i; j &lt; *count - 1; j++) {\n        dati[j] = dati[j + 1];\n      }\n\n      (*count)--;\n\n      i--; \n    }\n  }\n}\n\nint main() {\n6  struct Dato dati[MAX_DATI];\n  int count = 0;\n\n  struct Dato dato1 = {'i', .valore.intero = 42};\n  struct Dato dato2 = {'f', .valore.decimale = 3.14};\n  struct Dato dato3 = {'c', .valore.carattere = 'A'};\n  \n7  inserisci_dato(dati, &count, dato1);\n  inserisci_dato(dati, &count, dato2);\n  inserisci_dato(dati, &count, dato3);\n\n8  for (int i = 0; i &lt; count; i++) {\n    stampa_dato(dati[i]);\n  }\n\n9  cancella_dato(dati, &count, dato1);\n\n  printf(\"Dopo cancellazione:\\n\");\n\n  for (int i = 0; i &lt; count; i++) {\n    stampa_dato(dati[i]);\n  }\n\n  return 0;\n}\n\n1\n\nDefinizione di una union.\n\n2\n\nDefinizione di una struct che include la union.\n\n3\n\nFunzione per stampare i valori in base al tipo.\n\n4\n\nFunzione per inserire un nuovo dato alla fine dell’array.\n\n5\n\nFunzione per cancellare tutte le occorrenze di un dato dall’array.\n\n6\n\nDefinizione di un array di struct Dato.\n\n7\n\nInserimento di dati nell’array.\n\n8\n\nStampa dei dati nell’array.\n\n9\n\nCancellazione di un dato specifico e ristampa dell’array.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Il modello dati dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-modello-dati.html#linguaggi-orientati-agli-oggetti",
    "href": "prima-parte-modello-dati.html#linguaggi-orientati-agli-oggetti",
    "title": "5  Il modello dati dei linguaggi di programmazione",
    "section": "5.2 Linguaggi orientati agli oggetti",
    "text": "5.2 Linguaggi orientati agli oggetti\nLa programmazione orientata agli oggetti è un paradigma che utilizza oggetti per rappresentare concetti ed entità del mondo reale o astratto. Questo approccio si basa su un processo mentale fondamentale per risolvere problemi complessi: la decomposizione. Un problema complesso è più facilmente risolvibile se diviso in parti più piccole, ciascuna delle quali possiede uno stato e la possibilità di interagire con le altre parti. Questa divisione può essere effettuata per gradi, come se si osservasse sempre più da vicino il problema, effettivamente continunandone la specificazione, fino a raggiungere un livello sufficientemente di dettaglio da poter essere realizzato come istruzioni, codificate in costrutti permessi dalla sintassi del linguaggio, dell’oggetto.\n\n5.2.1 Oggetti\nLo stato di un oggetto è definito dai suoi attributi, i cui valori possono essere altri oggetti già disponibili, sia definiti dall’utente che dal linguaggio. L’interazione tra diversi oggetti avviene attraverso i metodi, che sono funzioni associate agli oggetti che possono modificare lo stato dell’oggetto o invocare metodi su altri oggetti.\nI membri di un oggetto (attributi e metodi) possono avere diverse limitazioni di accesso, definite dal concetto di visibilità:\n\nPubblica: Gli attributi e i metodi pubblici sono accessibili da qualsiasi parte del programma. Questa visibilità permette a qualsiasi altro oggetto o funzione di interagire con questi membri.\nPrivata: Gli attributi e i metodi privati sono accessibili solo da altri membri dell’oggetto e rispondono alla esigenza di separare il codice di interfaccia da quello utile al funzionamento interno.\nProtetta: Gli attributi e i metodi protetti sono accessibili da tutti i membri del medesimo oggetto ma, a differenza dei privati, anche da quelli degli oggetti derivati. Questo fornisce un livello intermedio di accesso, utile per la gestione dell’ereditarietà.\n\nL’incapsulamento è il principio su cui si basa la gestione della visibilità e guida la separazione del codice realizzante le specificità di un oggetto, da come è fruito dagli altri oggetti. Questo protegge l’integrità del suo stato e ne facilita la manutenzione del codice stesso, permettendo modifiche di implementazione, senza impatti sul codice esterno fintantoché non si cambiano i membri pubblici. Inoltre, se ben sfruttata nella progettazione, rende il codice più comprensibile e riduce la superficie d’attacco.\n\n\n5.2.2 Classi\nUn oggetto può essere generato da una struttura statica che ne definisce tutte le caratteristiche, la classe, oppure può essere creato a partire da un altro oggetto esistente, noto come prototipo.\nNella programmazione ad oggetti basata su classi, ogni oggetto è un’istanza vivente di una classe predefinita, che ne rappresenta il progetto o l’archetipo. La classe definisce i membri e la visibilità, quindi, in definitiva tutte le proprietà comuni agli oggetti dello stesso tipo o matrice. Gli oggetti vengono creati chiamando un metodo speciale della classe, noto come costruttore e, all’atto della loro vita, un secondo metodo, il distruttore, che si occupa di effettuare le azioni di terminazione.\nLa classe può inoltre definire metodi e attributi particolari, che possono essere ereditati da altre classi, cioè possono essere utilizzati da quest’ultime al pari dei propri membri. In tal modo, il linguaggio permette la costruzioni di gerarchie di classi che modellano relazioni di specializzazione, dalla più generale alla più particolare.\nCiò, oltre ad essere uno strumento di progettazione utile di per sé, facilita il riuso del codice per mezzo dell’estensione, al posto della modifica, di funzionalità. La classe che eredita da un’altra classe si definisce derivata dalla classe che, a sua volta, è detta base.\n\n\n5.2.3 Prototipi\nAlternativamente, alcuni linguaggi usano il concetto di prototipo, in cui gli oggetti sono le entità principali e non esiste una matrice separata come la classe. In questo paradigma, ogni oggetto può servire da prototipo per altri e ciò significa che, invece di creare nuove istanze di una classe, si creano nuovi oggetti clonando o estendendo quelli esistenti. È possibile aggiungere o modificare proprietà e metodi di un oggetto prototipo e, in tal caso, queste modifiche si propagheranno in tutti gli oggetti che derivano da esso.\nIl paradigma basato su prototipi offre maggiore flessibilità e dinamismo rispetto a quello basato su classi, poiché la struttura degli oggetti può essere modificata in modo dinamico. D’altronde, questo approccio può anche introdurre complessità e rendere più difficile la gestione delle gerarchie di oggetti e la comprensione del codice, poiché non esistono strutture fisse come le classi.\n\n\n5.2.4 Esempi di gerarchie di classi e prototipi\nVediamo le differenze tra classi e prototipi, riprendendo l’esempio in Java nella versione semplificata (senza astrazione):\nclass Animale { \n    String nome;\n\n    Animale(String nome) {\n        this.nome = nome;\n    }\n\n    void faiVerso() {\n        System.out.println(\"L'animale fa un verso\");\n    }\n}\n\nclass Cane extends Animale { \n\n    Cane(String nome) {\n        super(nome);\n    }\n\n    @Override\n    void faiVerso() {\n        System.out.println(\"Il cane abbaia\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animale mioCane = new Cane(\"Fido\");\n\n        mioCane.faiVerso(); \n    }\n}\nImplementiamo il medesimo programma in Javascript3, linguaggio che usa il concetto di prototipo:\n3 In JavaScript, le classi come sintassi sono state introdotte in ECMAScript 6 (ES6), per semplificare la creazione di oggetti e la gestione dell’ereditarietà prototipale. Tuttavia, è importante capire che sotto il cofano, JavaScript non utilizza classi nel senso tradizionale come in linguaggi come Java o C++ e non esiste un meccanismo nativo per creare classi astratte, anche se è possibile simulare il comportamento delle classi astratte utilizzando varie tecniche. Una comune è quella di lanciare un’eccezione se un metodo funzionalmente astratto non viene sovrascritto nella classe derivata.1let Animale = {\n    nome: \"Generic\",\n\n    init: function(nome) {\n        this.nome = nome;\n    },\n\n    faiVerso: function() {\n        console.log(\"L'animale fa un verso\");\n    }\n};\n\n2let Cane = Object.create(Animale);\n\n3Cane.faiVerso = function() {\n    console.log(\"Il cane abbaia\");\n};\n\n4let mioCane = Object.create(Cane);\n5mioCane.init(\"Fido\");\n\n6mioCane.faiVerso();\n\n1\n\nDefinizione dell’oggetto prototipo Animale.\n\n2\n\nCreazione di un nuovo oggetto basato sul prototipo Animale.\n\n3\n\nViene creato un nuovo oggetto Cane basato sul prototipo Animale, usando Object.create(Animale). Questo permette a Cane di ereditare proprietà e metodi da Animale. Il metodo faiVerso viene sovrascritto nell’oggetto Cane per specificare il comportamento da cane.\n\n4\n\nUn nuovo oggetto mioCane viene creato basandosi sul prototipo Cane usando Object.create(Cane).\n\n5\n\nIl metodo init viene chiamato per inizializzare il nome dell’oggetto mioCane.\n\n6\n\nQuando viene chiamato mioCane.faiVerso(), il metodo sovrascritto nell’oggetto Cane viene eseguito, mostrando Il cane abbaia.\n\n\n\n\n5.2.5 Ereditarietà\nCome abbiamo visto, l’ereditarietà è un meccanismo che permette a una classe di ereditare membri da un’altra classe. Essa si può presentare singola o multipla, ove la prima consente a una classe derivata di estendere solo una classe base. Questo è il modello di ereditarietà più comune e supportato da molti linguaggi di programmazione orientati agli oggetti, come Java e C#.\nL’ereditarietà multipla è tale da permettere a una classe di ricevere attributi e metodi contemporaneamente da più classi base. Questo meccanismo risponde all’esigenza di specializzare più concetti allo stesso tempo. Va sottolineato che è uno strumento potente prono, però, ad abusi, perché può introdurre complessità nella gestione delle gerarchie di classi e causare conflitti quando lo stesso metodo è ereditato da più classi, situazione nota come problema del diamante. Pertanto, alcuni linguaggi ne limitano l’applicazione, come Java che consente solo l’ereditarietà multipla di interfacce, ma non di classi. Altri, come Go, non supportano l’ereditarietà per scelta di progettazione. Go enfatizza la composizione rispetto all’ereditarietà per promuovere uno stile di programmazione più essenziale e flessibile. La composizione consente di costruire comportamenti complessi aggregando oggetti più semplici, evitando le complicazioni delle gerarchie di classi multilivello. Il C++, invece, supporta completamente l’ereditarietà multipla.\n\n\n5.2.6 Interfacce e classi astratte\nLe interfacce e le classi astratte sono due concetti fondamentali nella programmazione orientata agli oggetti, che consentono di definire contratti che le classi concrete devono rispettare.\nUn’interfaccia è un contratto che specifica un insieme di metodi che una classe deve implementare, senza fornire l’implementazione effettiva di questi metodi. Sono utilizzate per definire comportamenti comuni che possono essere condivisi da classi diverse, indipendentemente dalla loro posizione nella gerarchia delle classi. Le classi che implementano un’interfaccia devono fornire una definizione concreta per tutti i metodi dichiarati nell’interfaccia. In Java, ad esempio, le interfacce sono definite con la parola chiave interface.\nUna classe astratta è una classe che non può essere istanziata direttamente. Può contenere sia metodi astratti (senza codice al loro interno, che devono essere implementati dalle classi derivate) sia metodi concreti (con codice allinterno, che possono essere utilizzati dalle classi derivate). Le classi astratte sono utilizzate per fornire una base comune con alcune implementazioni di default e lasciare ad altre classi il compito di completare l’implementazione. In Java, le classi astratte sono definite con la parola chiave abstract.\nEsempio di interfaccia, classa astratta e ereditarietà multipla in Java:\n1interface Domesticazione {\n2  void assegnaAddomesticato(boolean addomesticato);\n3  boolean ottieniAddomesticato();\n}\n\n4abstract class Animale {\n  String nome;\n\n  Animale(String nome) {\n    this.nome = nome;\n  }\n\n5  abstract String faiVerso();\n\n6  String descrizione() {\n    return \"L'animale si chiama \" + nome;\n  }\n}\n\n7class Cane extends Animale implements Domesticazione {\n8  private boolean addomesticato;\n\n  Cane(String nome) {\n    super(nome);\n  }\n\n  @Override\n9  String faiVerso() {\n    return \"Il cane abbaia\";\n  }\n\n  @Override\n10  public void assegnaAddomesticato(boolean addomesticato) {\n    this.addomesticato = addomesticato; \n  }\n\n  @Override\n11  public boolean ottieniAddomesticato() {\n    return addomesticato; \n  }\n}\n\n12class Coccodrillo extends Animale {\n\n  Coccodrillo(String nome) {\n    super(nome);\n  }\n\n  @Override\n  String faiVerso() {\n    return \"\";  \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n13    Cane mioCane = new Cane(\"Fido\");\n\n    System.out.println(mioCane.descrizione()); \n    System.out.println(mioCane.faiVerso());    \n\n    mioCane.assegnaAddomesticato(true); \n    System.out.println(\"Cane addomesticato: \" + \n                       mioCane.ottieniAddomesticato());\n\n14    Coccodrillo mioCoccodrillo = new Coccodrillo(\"Crocky\");\n\n    System.out.println(mioCoccodrillo.descrizione()); \n    System.out.println(mioCoccodrillo.faiVerso());   \n  }\n}\n\n1\n\nInterfaccia che definisce una proprietà che gli animali possono possedere, la domesticazione. Da notare che la domesticazione è una proprietà complementare alle altre caratterizzanti l’animale, addirittura non aprioristica.\n\n2\n\nMetodo per impostare lo stato di addomesticamento dell’animale.\n\n3\n\nMetodo per verificare se è addomesticato.\n\n4\n\nClasse astratta che ha l’implementazione di una caratteristica condivisa dalle classi derivate, descrizione(), e un metodo astratto per una seconda, faiVerso(), che, deve essere sempre presente negli oggetti di tipo base animale, ma non ne è comume l’implementazione.\n\n5\n\nMetodo astratto.\n\n6\n\nMetodo concreto.\n\n7\n\nIl cane è un animale che può essere addomesticato, quindi la classe Cane deriva Animale (cioè deve implementare necessariamente faiVerso()) e implementa Domesticazione (cioè deve implementare assegnaAddomesticato() e ottieniAddomesticato()). descrizione() viene ereditato colla implementazione di Animale.\n\n8\n\nVariabile utile a registrare se il cane è stato addomesticato.\n\n9\n\nCane implementa faiVerso() di Animale.\n\n10\n\nCane implementa assegnaAddomesticato() di Domesticazione.\n\n11\n\nCane implementa ottieniAddomesticato() di Domesticazione.\n\n12\n\nIl coccodrillo non è addomesticabile, quindi, Coccodrillo non implementa l’interfaccia Domesticazione, ma è comunque un animale quindi deriva Animale e ne implementa l’unico metodo astratto faiVerso(). Non essendo addomesticabile, non ha neanche l’attributo addomesticato.\n\n13\n\nCreazione dell’oggetto Cane.\n\n14\n\nCreazione dell’oggetto Coccodrillo.\n\n\nLe interfacce e le classi astratte sono strumenti potenti per promuovere la riusabilità del codice e l’estensibilità dei sistemi software, poiché permettono di definire contratti chiari e di implementare diverse versioni di una funzionalità senza modificare il codice preesistente.\n\n\n5.2.7 Polimorfismo\nIl polimorfismo è un concetto chiave della programmazione orientata agli oggetti che permette a oggetti di classi diverse di essere trattati come oggetti di una classe comune. È uno strumento complementare all’ereditarietà, nelle mani del programmatore, utile a modellare comportamenti comuni per oggetti di tipi diversi, permettendo al codice di interagire con questi oggetti senza conoscere esattamente il loro tipo specifico. In termini pratici, il polimorfismo permette di chiamare metodi su oggetti di tipi diversi e ottenere comportamenti specifici a seconda del tipo di oggetto su cui viene chiamato il medesimo metodo.\nIl concetto di polimorfismo è strettamente legato all’idea di contratto tra oggetti. Questo contratto è definito dalle interfacce o dalle classi base e specifica quali metodi devono essere implementati dalle classi derivate. Quando un oggetto di una classe derivata è trattato come un oggetto della classe base o di un’interfaccia, si garantisce che esso rispetti il contratto definito dalla classe base o dall’interfaccia.\nEsistono due tipi principali di polimorfismo:\n\nPolimorfismo statico: Conosciuto soprattutto come overloading, si verifica quando più metodi nella stessa classe hanno lo stesso nome ma firme diverse (diverso numero o tipo di parametri). Il compilatore decide quale metodo chiamare in base alla firma del metodo.\n\nEsempio in Java che supporta l’overloading:\nclass Esempio {\n  void stampa(int a) {\n    System.out.println(\"Intero: \" + a);\n  }\n\n  void stampa(String a) {\n    System.out.println(\"Stringa: \" + a);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Esempio es = new Esempio();\n\n1    es.stampa(5);\n2    es.stampa(\"ciao\");\n  }\n}\n\n1\n\nChiama il metodo stampa(int a).\n\n2\n\nChiama il metodo stampa(String a).\n\n\n\nPolimorfismo dinamico: Noto come overriding, si verifica quando una classe derivata fornisce una specifica implementazione di un metodo già definito nella sua classe base. L’implementazione da chiamare è determinata a runtime, cioè a tempo di esecuzione e non compilazione, in base al tipo dell’oggetto.\n\nEsempio in Java riprendendo l’esempio con gli animali:\nclass Animale {\n  void faiVerso() {\n    System.out.println(\"L'animale fa un verso\");\n  }\n}\n\nclass Cane extends Animale {\n  @Override\n  void faiVerso() {\n    System.out.println(\"Il cane abbaia\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n1    Animale mioAnimale = new Cane();\n\n2    mioAnimale.faiVerso();\n  }\n}\n\n1\n\nL’oggetto mioAnimale è dichiarato come tipo Animale ma istanziato come Cane. Questo è un esempio di polimorfismo.\n\n2\n\nIl metodo faiVerso() viene chiamato sull’oggetto mioAnimale, ma viene eseguita la versione del metodo faiVerso() definita nella classe Cane, grazie al polimorfismo.\n\n\nIl polimorfismo è strettamente legato all’ereditarietà, poiché l’ereditarietà è spesso il meccanismo che permette al polimorfismo di funzionare. Quando una classe derivata estende una classe base e sovrascrive i suoi metodi, permette agli oggetti della classe derivata di essere trattati come oggetti della classe base ma di comportarsi in modo specifico alla classe derivata.\nI linguaggi di programmazione hanno delle differenze in relazione al supporto del polimorfismo:\n\nJava: Supporta sia l’overloading che l’overriding.\nC++: Supporta sia l’overloading che l’overriding. Fornisce meccanismi per specificare il tipo di legame (statico o dinamico) usando parole chiave come virtual.\nPython: Supporta l’overriding, ma non l’overloading nello stesso senso di Java o C++. Python permette la definizione di metodi con argomenti predefiniti o argomenti variabili per ottenere un effetto simile all’overloading.\n\nEsempio in Java da confrontare con quello seguente in Python:\nclass Animale {\n1  void faiVerso() {\n    System.out.println(\"L'animale fa un verso\"); \n  }\n}\n\nclass Cane extends Animale {\n  @Override\n2  void faiVerso() {\n    System.out.println(\"Il cane abbaia\"); \n  }\n\n3  void faiVerso(String suono) {\n    System.out.println(\"Il cane fa: \" + suono); \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n4    Animale mioAnimale = new Cane();\n5    mioAnimale.faiVerso();\n\n    Cane mioCane = new Cane();\n6    mioCane.faiVerso(\"bau\");\n  }\n}\n\n1\n\nMetodo faiVerso() definito nella classe base Animale.\n\n2\n\nOverriding del metodo faiVerso() nella classe derivata Cane.\n\n3\n\nOverloading del metodo faiVerso() nella classe derivata Cane.\n\n4\n\nDichiarazione di un oggetto di tipo Animale, ma istanziato come Cane.\n\n5\n\nChiamata al metodo faiVerso(), che esegue la versione del metodo nella classe Cane grazie al polimorfismo.\n\n6\n\nChiamata al metodo faiVerso(String suono), che dimostra l’overloading del metodo nella classe Cane.\n\n\nE in Python diventa:\nclass Animale:\n1  def fai_verso(self):\n    print(\"L'animale fa un verso\")  \n\nclass Cane(Animale):\n2  def fai_verso(self):\n    print(\"Il cane abbaia\")  \n\n3  def fai_verso_con_suono(self, suono):\n    print(f\"Il cane fa: {suono}\")  \n\n4mio_animale = Cane()\n5mio_animale.fai_verso()\n\nmio_cane = Cane()\n6mio_cane.fai_verso_con_suono(\"bau\")\n\n1\n\nMetodo fai_verso() definito nella classe base Animale.\n\n2\n\nOverriding del metodo fai_verso() nella classe derivata Cane.\n\n3\n\nDefinizione di un metodo aggiuntivo fai_verso_con_suono nella classe derivata Cane (Python non supporta l’overloading nello stesso senso di Java).\n\n4\n\nDichiarazione e istanziazione di un oggetto mio_animale come Cane.\n\n5\n\nChiamata al metodo fai_verso(), che esegue la versione del metodo nella classe Cane grazie al polimorfismo.\n\n6\n\nChiamata al metodo fai_verso_con_suono(suono), che dimostra una forma di polimorfismo simile all’overloading in Python.\n\n\nL’overriding è possibile grazie al dynamic dispatch, un meccanismo che consente di selezionare a runtime il metodo corretto da invocare in base al tipo effettivo dell’oggetto. Lo static disptach, al contrario, avviene al tempo di compilazione.\nMa il dispatch, cioè l’individuazione del metodo da eseguire, può essere singolo (single dispatch), così come presente nella maggior parte dei linguaggi orientati agli oggetti come Java e C++, e dove la scelta del metodo dipende solo dal tipo dell’oggetto sul quale il metodo stesso viene chiamato. Questo tipo di dispatch è sufficiente per supportare il polimorfismo detto di sottotipo, dove le classi derivate possono sovrascrivere i metodi della classe base e il metodo corretto viene selezionato a runtime in base al tipo effettivo dell’oggetto.\nIl multiple dispatch, invece, estende ulteriormente le capacità del polimorfismo permettendo la selezione del metodo da invocare basandosi sui tipi runtime di più di un argomento. Questo è particolarmente utile in scenari dove il comportamento dipende da combinazioni di tipi di oggetti, e non solo dal tipo dell’oggetto su cui il metodo è chiamato. Linguaggi come Julia e CLOS (Common Lisp Object System)supportano nativamente il multiple dispatch, mentre linguaggi come Java e C++ non lo supportano direttamente ma possono emularlo attraverso pattern come il visitor.\n\n\n5.2.8 Altri concetti\nDopo aver compreso i concetti fondamentali della programmazione orientata agli oggetti (OOP), come oggetti, classi, prototipi, ereditarietà e polimorfismo, è importante esplorare altri aspetti avanzati che contribuiscono alla potenza e alla flessibilità di questo paradigma.\n\n5.2.8.1 Mixin e trait\nI mixin e i trait sono concetti che permettono di aggiungere funzionalità a una classe senza utilizzare l’ereditarietà classica.\nI mixin sono classi che offrono metodi che possono essere utilizzati da altre classi senza essere una classe base di queste ultime. Permettono di combinare comportamenti comuni tra diverse classi.\nEsempio:\nclass MixinA:\n    def metodo_a(self):\n        print(\"Metodo A\")\n\nclass MixinB:\n    def metodo_b(self):\n        print(\"Metodo B\")\n\nclass ClasseConMixin(MixinA, MixinB):\n    pass\n\nobj = ClasseConMixin()\nobj.metodo_a()\nobj.metodo_b()\nI trait sono simili ai mixin e permettono di definire metodi che possono essere riutilizzati in diverse classi. Sono supportati nativamente in linguaggi come Scala e Rust.\ntrait TraitA {\n    def metodoA(): Unit = println(\"Metodo A\")\n}\n\ntrait TraitB {\n    def metodoB(): Unit = println(\"Metodo B\")\n}\n\nclass ClasseConTrait extends TraitA with TraitB\n\nval obj = new ClasseConTrait()\nobj.metodoA()\nobj.metodoB()\n\n\n5.2.8.2 Duck Typing\nIl duck typing è un concetto che si applica principalmente nei linguaggi dinamici, dove l’importanza è data al comportamento degli oggetti piuttosto che alla loro appartenenza a una specifica classe. Se un oggetto implementa i metodi richiesti da una certa operazione, allora può essere utilizzato per quella operazione, indipendentemente dal suo tipo.\nEsempio:\nclass Anatra:\n    def quack(self):\n        print(\"Quack!\")\n\nclass Persona:\n    def quack(self):\n        print(\"Sono una persona che imita un'anatra\")\n\ndef fai_quack(oggetto):\n    oggetto.quack()\n\nanatra = Anatra()\npersona = Persona()\n\nfai_quack(anatra)\nfai_quack(persona)",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Il modello dati dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html",
    "href": "prima-parte-altri-concetti-semantici.html",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "",
    "text": "6.1 Concorrenza\nLa concorrenza è la capacità di un programma di eseguire più sequenze di istruzioni in parallelo, migliorando le prestazioni e la reattività. La concorrenza è particolarmente utile in applicazioni che richiedono l’elaborazione simultanea di compiti indipendenti, come server web, sistemi di gestione di basi di dati e applicazioni interattive.\nUn concetto fondamentale della concorrenza è il thread, che rappresenta la più piccola unità di elaborazione eseguibile in modo indipendente. I thread permettono l’esecuzione parallela di codice all’interno di un programma, ma introducono la necessità di gestire l’accesso concorrente alle risorse condivise.\nLa sincronizzazione è essenziale per evitare condizioni di gara, che si verificano quando il risultato dell’esecuzione dipende dalla sequenza temporale in cui i thread accedono alle risorse. Meccanismi come i lock e i mutex garantiscono che solo un thread alla volta possa accedere a una risorsa condivisa, prevenendo conflitti e garantendo la consistenza dei dati.\nIn linguaggi moderni, come Python e JavaScript, la gestione delle operazioni asincrone è facilitata da costrutti come async/await. Questi costrutti migliorano l’efficienza e la reattività delle applicazioni, permettendo di eseguire operazioni di I/O senza bloccare il thread principale.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html#inputoutput-io",
    "href": "prima-parte-altri-concetti-semantici.html#inputoutput-io",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "6.2 Input/Output (I/O)",
    "text": "6.2 Input/Output (I/O)\nL’input/output (I/O) gestisce la comunicazione tra un programma e il suo ambiente esterno. Il File I/O permette la lettura e la scrittura su file, consentendo di memorizzare e recuperare dati persistenti. In molti linguaggi, come C e Python, le operazioni di file I/O sono supportate da funzioni o metodi che aprono, leggono, scrivono e chiudono file.\nIl Network I/O facilita la comunicazione tra sistemi diversi attraverso reti, consentendo di inviare e ricevere dati tra computer. Linguaggi come Java e Python offrono librerie per la gestione delle connessioni di rete, il trasferimento di dati e la comunicazione tra client e server.\nLo Standard I/O comprende l’interazione con l’utente tramite input da tastiera e output su schermo. In C, funzioni come scanf e printf gestiscono lo standard I/O, mentre in Python si utilizzano input e print.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html#annotazioni-e-metadati",
    "href": "prima-parte-altri-concetti-semantici.html#annotazioni-e-metadati",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "6.3 Annotazioni e Metadati",
    "text": "6.3 Annotazioni e Metadati\nLe annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l’analisi del codice.\nLe annotazioni sono utilizzate per specificare comportamenti speciali o configurazioni. In Java, le annotazioni come @Deprecated indicano che un metodo è obsoleto, @Override segnala che un metodo sovrascrive un metodo della superclasse, e @Entity e @Table in JPA (Jakarta Persistence) definiscono la relazione tra entità e tabelle nel contesto di un database. In Python, le annotazioni dei tipi (type hint) indicano i tipi delle variabili, dei parametri di funzione e dei valori di ritorno, migliorando la leggibilità e facilitando il type checking automatico.\nLe docstring in Python sono commenti strutturati che documentano il codice. Utilizzate per descrivere moduli, classi, metodi e funzioni, le docstring rendono il codice più leggibile e comprensibile e possono essere utilizzate per generare documentazione automatica.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "prima-parte-altri-concetti-semantici.html#macro-e-metaprogrammazione",
    "href": "prima-parte-altri-concetti-semantici.html#macro-e-metaprogrammazione",
    "title": "6  Altri concetti semantici dei linguaggi di programmazione",
    "section": "6.4 Macro e Metaprogrammazione",
    "text": "6.4 Macro e Metaprogrammazione\nLe macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice, migliorando la flessibilità e il riutilizzo.\nLe macro sono sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, le macro sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale. Le macro permettono di evitare la duplicazione di codice, ma possono anche introdurre complessità e difficoltà di debug.\nLa metaprogrammazione consiste nello scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time. In Python, la metaprogrammazione include l’uso di decoratori, che sono funzioni che modificano il comportamento di altre funzioni, e metaclassi, che permettono di controllare la creazione e il comportamento delle classi. L’introspezione, che consente di esaminare gli oggetti durante l’esecuzione del programma, è un’altra potente tecnica di metaprogrammazione.",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Altri concetti semantici dei linguaggi di programmazione</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html",
    "href": "seconda-parte-python-introduzione.html",
    "title": "7  Introduzione a Python",
    "section": "",
    "text": "7.1 Perché Python è un linguaggio di alto livello?\nPython è considerato un linguaggio di programmazione di alto livello, cioè utilizza un livello di astrazione elevato rispetto alla complessità dell’ambiente in cui i suoi programmi sono eseguiti. Il programmatore ha a disposizione una sintassi che è più intuitiva rispetto ad altri linguaggi come Java, C++, PHP tradizionalmente anch’essi definiti di alto livello.\nInfatti, consente ai programmatori di scrivere codice in modo più concettuale e indipendente dalle caratteristiche degli hardware, anche molto diversi, su cui è disponibile. Ad esempio, invece di preoccuparsi di allocare e deallocare memoria manualmente, Python gestisce queste operazioni automaticamente. Questo libera il programmatore dai dettagli del sistema operativo e dell’elettronica, permettendogli di concentrarsi sulla logica del problema da risolvere.\nCiò ha un effetto importante sulla versatilità perché spesso è utilizzato come interfaccia utente per linguaggi di livello più basso come C, C++ o Fortran. Questo permette a Python di sfruttare le prestazioni dei linguaggi compilati per le parti critiche e computazionalmente intensive del codice, mantenendo al contempo una sintassi semplice e leggibile per la maggior parte del programma. Buoni compilatori per i linguaggi compilati classici possono sì generare codice binario che gira più velocemente di Python, tuttavia, nella maggior parte dei casi, le prestazioni delle applicazioni codificate in Python sono sufficienti.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#python-come-linguaggio-multiparadigma",
    "href": "seconda-parte-python-introduzione.html#python-come-linguaggio-multiparadigma",
    "title": "7  Introduzione a Python",
    "section": "7.2 Python come linguaggio multiparadigma",
    "text": "7.2 Python come linguaggio multiparadigma\nPython è un linguaggio di programmazione multiparadigma, il che significa che supporta diversi paradigmi di programmazione, permettendo di mescolare e combinare gli stili a seconda delle necessità dell’applicazione. Ecco alcuni dei paradigmi supportati da Python:\n\nProgrammazione imperativa: Puoi scrivere ed eseguire script Python direttamente dalla linea di comando, permettendo un approccio interattivo e immediato alla programmazione, come se fosse una calcolatrice.\nProgrammazione procedurale: In Python, è possibile organizzare il codice in funzioni e moduli, rendendo più semplice la gestione e la riutilizzabilità del codice. Puoi raccogliere il codice in file separati e importarli come moduli, migliorando la struttura e la leggibilità del programma.\nProgrammazione orientata agli oggetti: Python supporta pienamente la programmazione orientata agli oggetti, consentendo la definizione di classi e oggetti. Questo paradigma è utile per modellare dati complessi e relazioni tra essi. Le caratteristiche orientate agli oggetti di Python sono concettualmente simili a quelle del C++, ma più semplici da usare.\nProgrammazione funzionale: Python include funzionalità di programmazione funzionale, come funzioni di prima classe e di ordine superiore, lambda e strumenti come map, filter e reduce.\n\nQuesta flessibilità rende Python adatto a una vasta gamma di applicazioni e consente ai programmatori di scegliere l’approccio più adatto al problema da risolvere.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#regole-formali-e-esperienziali",
    "href": "seconda-parte-python-introduzione.html#regole-formali-e-esperienziali",
    "title": "7  Introduzione a Python",
    "section": "7.3 Regole formali e esperienziali",
    "text": "7.3 Regole formali e esperienziali\nPython non è solo un linguaggio con regole sintattiche precise e ben progettate, ma possiede anche una propria filosofia, un insieme di regole di buon senso esperienziali che sono complementari alla sintassi formale. Questa filosofia è spesso riassunta nel zen di Python, una raccolta di aforismi che catturano i principi fondamentali del design di Python. Tali principi aiutano i programmatori a comprendere e utilizzare al meglio le potenzialità del linguaggio e dell’ecosistema Python.\nEcco alcuni dei principi dello zen di Python3:\n3 PEP 20 – The Zen of Python\nLa leggibilità conta: Il codice dovrebbe essere scritto in modo che sia facile da leggere e comprendere.\nEsplicito è meglio di implicito: È preferibile scrivere codice chiaro e diretto piuttosto che utilizzare scorciatoie criptiche.\nSemplice è meglio di complesso: Il codice dovrebbe essere il più semplice possibile per risolvere il problema.\nComplesso è meglio di complicato: Quando la semplicità non è sufficiente, la complessità è accettabile, ma il codice non dovrebbe mai essere complicato.\nPratico batte puro: Le soluzioni pragmatiche sono preferibili alle soluzioni eleganti ma poco pratiche.\n\nQuesti principi, insieme alle regole sintattiche, guidano il programmatore nell’adottare buone pratiche di sviluppo e nel creare codice che sia non solo funzionale ma anche mantenibile e comprensibile da altri.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#lecosistema",
    "href": "seconda-parte-python-introduzione.html#lecosistema",
    "title": "7  Introduzione a Python",
    "section": "7.4 L’ecosistema",
    "text": "7.4 L’ecosistema\nFino ad ora abbiamo visto Python come linguaggio, ma è molto di più: Python è anche una vasta collezione di strumenti e risorse a disposizione degli sviluppatori, strutturata in un ecosistema completo, di cui il linguaggio ne rappresenta la parte formale. Questo ecosistema è disponibile completamente, anche come sorgente, sul sito ufficiale python.org.\n\n7.4.1 L’interprete\nL’interprete Python è lo strumento di esecuzione dei programmi. È il software che legge ed esegue il codice Python. Python è un linguaggio interpretato, il che significa che il codice viene eseguito direttamente dall’interprete, senza bisogno di essere compilato in un linguaggio macchina. Esistono diverse implementazioni dell’interprete Python:\n\nCPython: L’implementazione di riferimento dell’interprete Python, scritta in C. È la versione più utilizzata e quella ufficiale.\nPyPy: Un interprete alternativo che utilizza tecniche di compilazione just-in-time (JIT) per migliorare le prestazioni.\nJython: Un’implementazione di Python che gira sulla JVM (Java Virtual Machine).\nIronPython: Un’implementazione di Python integrata col .NET Framework della Microsoft.\n\n\n\n7.4.2 L’ambiente di sviluppo\nIDLE (integrated development and learning environment) è l’ambiente di sviluppo integrato ufficiale per Python. È incluso nell’installazione standard di Python ed è progettato per essere semplice e facile da usare, ideale per i principianti. Offre diverse funzionalità utili:\n\nEditor di codice: Con evidenziazione della sintassi, indentazione automatica e controllo degli errori.\nShell interattiva: Permette di eseguire codice Python in modo interattivo.\nStrumenti di debug: Include un debugger integrato con punti di interruzione e stepping.\n\n\n\n7.4.3 Le librerie standard\nUna delle caratteristiche più potenti di Python è il vasto insieme di librerie4 utilizzabili in CPython e IDLE, che fornisce moduli e pacchetti per quasi ogni necessità di programmazione. Alcuni esempi, tra le decine e al solo allo scopo di illustrarne la varietà, includono:\n4 Documentazione delle librerie standard di Python\nos: Fornisce funzioni per interagire con il sistema operativo.\nsys: Offre accesso a funzioni e oggetti del runtime di Python.\ndatetime: Consente di lavorare con date e orari.\njson: Permette di leggere e scrivere dati in formato JSON.\nre: Supporta la manipolazione di stringhe tramite espressioni regolari.\nhttp: Include moduli per l’implementazione di client e server HTTP.\nunittest: Fornisce un framework per il testing del codice.\nmath e cmath: Contengono funzioni matematiche di base e complesse.\nitertools, functools, operator: Offrono supporto per il paradigma di programmazione funzionale.\ncsv: Gestisce la lettura e scrittura di file CSV.\ntyping: Fornisce supporto per l’annotazione dei tipi di variabili, funzioni e classi.\nemail: Permette di creare, gestire e inviare email, facilitando la manipolazione di messaggi email MIME.\nhashlib: Implementa algoritmi di hash sicuri come SHA-256 e MD5.\nasyncio: Supporta la programmazione asincrona per la scrittura di codice concorrente e a bassa latenza.\nwave: Fornisce strumenti per leggere e scrivere file audio WAV.\n\n\n\n7.4.4 Moduli di estensione\nPython supporta l’estensione del suo core tramite moduli scritti in C, C++ o altri linguaggi. Questi moduli permettono di ottimizzare parti critiche del codice o di interfacciarsi con librerie e API esterne:\n\nCython: Permette di scrivere moduli C estesi utilizzando una sintassi simile a Python. Cython è ampiamente utilizzato per migliorare le prestazioni di parti critiche del codice, specialmente in applicazioni scientifiche e di calcolo numerico. Ad esempio, molte librerie scientifiche popolari come SciPy e scikit-learn utilizzano Cython per accelerare le operazioni computazionalmente intensive.\nctypes: Permette di chiamare funzioni in librerie dinamiche C direttamente da Python. È utile per interfacciarsi con librerie esistenti scritte in C, rendendo Python estremamente versatile per l’integrazione con altre tecnologie. Ciò è utile in applicazioni che devono interfacciarsi con hardware specifico o utilizzare librerie legacy.\nCFFI (C Foreign Function Interface): Un’altra interfaccia per chiamare librerie C da Python. È progettata per essere facile da usare e per supportare l’uso di librerie C complesse con Python. CFFI è utilizzato in progetti come PyPy e gevent, permettendo di scrivere codice ad alte prestazioni e di gestire le chiamate a funzioni C in modo efficiente.\n\n\n\n7.4.5 Le utility e gli strumenti aggiuntivi\nPython include anche una serie di strumenti e utility che facilitano lo sviluppo e la gestione dei progetti:\n\npip: Il gestore dei pacchetti di Python. Permette di installare e gestire moduli aggiuntivi, cioè non inclusi nello standard.\nvenv: Uno strumento per creare ambienti virtuali isolati, che permettono di gestire separatamente le dipendenze di diversi progetti.\nDocumentazione: Python include una documentazione dettagliata, accessibile tramite il comando pydoc o attraverso il sito ufficiale.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-introduzione.html#un-esempio-di-algorimo-in-python-il-bubble-sort",
    "href": "seconda-parte-python-introduzione.html#un-esempio-di-algorimo-in-python-il-bubble-sort",
    "title": "7  Introduzione a Python",
    "section": "7.5 Un esempio di algorimo in Python: il bubble sort",
    "text": "7.5 Un esempio di algorimo in Python: il bubble sort\nPer chiudere il capitolo sul primo approccio a Python, possiamo confrontare un algoritmo, di bassa complessità ma non triviale, in diversi linguaggi di programmazione. Un buon esempio potrebbe essere l’implementazione dell’algoritmo di ordinamento bubble sort di una lista di valori. Vediamo come viene scritto in Python, C, C++, Java, Rust e Scala:\n\nPython in versione procedurale:\ndef bubble_sort(arr):\n  n = len(arr)\n\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] &gt; arr[j+1]:\n        arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sort(arr)\n\nprint(\"Array ordinato con bubble sort: \", arr)\nPython in versione sintatticamente orientata agli oggetti, ma praticamente procedurale:\nclass BubbleSort:\n  @staticmethod\n  def bubble_sort(arr):\n    n = len(arr)\n\n    for i in range(n):\n      for j in range(0, n-i-1):\n        if arr[j] &gt; arr[j+1]:\n          arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nBubbleSort.bubble_sort(arr)\n\nprint(\"Array ordinato con bubble sort: \", arr)\nPython in versione orientata agli oggetti, con una interfaccia di ordinamento implementata con due algoritmi (bubble e insertion sort):\n1from abc import ABC, abstractmethod\n\n# Classe astratta per algoritmi di ordinamento\n2class SortAlgorithm(ABC):\n  def __init__(self, arr):\n    self._arr = arr\n\n  @abstractmethod\n3  def sort(self):\n    # Metodo astratto che deve essere implementato dalle sottoclassi\n    pass\n\n  def get_array(self):\n    # Metodo per ottenere l'array corrente\n    return self._arr\n\n  def set_array(self, arr):\n    # Metodo per impostare un nuovo array\n    self._arr = arr\n\n# Implementazione dell'algoritmo di bubble sort\n4class BubbleSort(SortAlgorithm):\n  def sort(self):\n    n = len(self._arr)\n\n    for i in range(n):\n      for j in range(0, n-i-1):\n        if self._arr[j] &gt; self._arr[j+1]:\n          self._arr[j], self._arr[j+1] = self._arr[j+1], self._arr[j]\n\n# Implementazione dell'algoritmo di insertion sort\nclass InsertionSort(SortAlgorithm):\n  def sort(self):\n    for i in range(1, len(self._arr)):\n      key = self._arr[i]\n\n      j = i - 1\n\n      while j &gt;= 0 and key &lt; self._arr[j]:\n        self._arr[j + 1] = self._arr[j]\n\n        j -= 1\n\n      self._arr[j + 1] = key\n\n# Esempio di utilizzo con bubble sort\narr = [64, 34, 25, 12, 22, 11, 90]\n\nbubble_sorter = BubbleSort(arr)\n\nbubble_sorter.sort()\n\nprint(\"Array ordinato con bubble sort: \", bubble_sorter.get_array())\n\n# Esempio di utilizzo con insertion sort\narr = [64, 34, 25, 12, 22, 11, 90]\n\ninsertion_sorter = InsertionSort(arr)\n\ninsertion_sorter.sort()\n\nprint(\"Array ordinato con insertion sort: \", insertion_sorter.get_array())\n\n1\n\nImportiamo ABC e abstractmethod dal modulo abc per definire la classe astratta.\n\n2\n\nSortAlgorithm è una classe astratta che rappresenta l’interfaccia di algoritmi di ordinamento.\n\n3\n\nsort è un metodo astratto che deve essere implementato nelle sottoclassi.\n\n4\n\nBubbleSort è una sottoclasse di SortAlgorithm che implementa l’algoritmo di ordinamento a bolle. Idem per InsertionSort.\n\n\nPython in versione funzionale:\ndef bubble_sort(arr):\n1  def sort_pass(arr, n):\n    if n == 1:\n      return arr\n\n2    new_arr = arr[:]\n\n    for i in range(n - 1):\n      if new_arr[i] &gt; new_arr[i + 1]:\n        new_arr[i], new_arr[i + 1] = new_arr[i + 1], new_arr[i]\n\n3    return sort_pass(new_arr, n - 1)\n\n4  return sort_pass(arr, len(arr))\n\n# Esempio di utilizzo\narr = [64, 34, 25, 12, 22, 11, 90]\n\nsorted_arr = bubble_sort(arr)\n\nprint(\"Sorted array is:\", sorted_arr)\n\n1\n\nAll’interno di bubble_sort, è definita una funzione interna sort_pass che esegue un singolo passaggio dell’algoritmo di ordinamento a bolle.\n\n2\n\nViene creata una copia dell’array arr chiamata new_arr. Poi, per ogni coppia di elementi (new_arr[i], new_arr[i + 1]), se new_arr[i] è maggiore di new_arr[i + 1], vengono scambiati.\n\n3\n\nLa funzione sort_pass viene chiamata ricorsivamente con new_arr e decrementando n di 1.\n\n4\n\nLa funzione bubble_sort avvia il processo chiamando sort_pass con l’array completo e la sua lunghezza.\n\n\nC:\n#include &lt;stdio.h&gt;\n\nvoid bubble_sort(int arr[], int n) {\n  int i, j, temp;\n\n  for (i = 0; i &lt; n-1; i++) {\n    for (j = 0; j &lt; n-i-1; j++) {\n      if (arr[j] &gt; arr[j+1]) {\n        temp = arr[j];\n\n        arr[j] = arr[j+1];\n\n        arr[j+1] = temp;\n      }\n    }\n  }\n}\n\nint main() {\n  int arr[] = {64, 34, 25, 12, 22, 11, 90};\n  int n = sizeof(arr)/sizeof(arr[0]);\n\n  bubble_sort(arr, n);\n\n  printf(\"Array ordinato con bubble sort: \");\n\n  for (int i = 0; i &lt; n; i++) {\n    printf(\"%d \", arr[i]);\n  }\n\n  return 0;\n}\nC++:\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass BubbleSort {\npublic:\n  void sort(int arr[], int n) {\n    for (int i = 0; i &lt; n-1; i++) {\n      for (int j = 0; j &lt; n-i-1; j++) {\n        if (arr[j] &gt; arr[j+1]) {\n          int temp = arr[j];\n\n          arr[j] = arr[j+1];\n\n          arr[j+1] = temp;\n        }\n      }\n    }\n  }\n\n  void printArray(int arr[], int n) {\n    for (int i = 0; i &lt; n; i++) {\n      cout &lt;&lt; arr[i] &lt;&lt; \" \";\n    }\n\n    cout &lt;&lt; endl;\n  }\n};\n\nint main() {\n  int arr[] = {64, 34, 25, 12, 22, 11, 90};\n  int n = sizeof(arr)/sizeof(arr[0]);\n\n  BubbleSort bs;\n  bs.sort(arr, n);\n\n  cout &lt;&lt; \"Array ordinato con bubble sort: \";\n  bs.printArray(arr, n);\n\n  return 0;\n}\nJava:\npublic class BubbleSort {\n\n  public static void bubbleSort(int arr[]) {\n    int n = arr.length;\n\n    for (int i = 0; i &lt; n-1; i++) {\n      for (int j = 0; j &lt; n-i-1; j++) {\n        if (arr[j] &gt; arr[j+1]) {\n\n          int temp = arr[j];\n\n          arr[j] = arr[j+1];\n\n          arr[j+1] = temp;\n        }\n      }\n    }\n  }\n\n  public static void main(String args[]) {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n\n    bubbleSort(arr);\n\n    System.out.println(\"Array ordinato con bubble sort: \");\n\n    for (int i = 0; i &lt; arr.length; i++) {\n      System.out.print(arr[i] + \" \");\n    }\n  }\n}\nRust:\nfn bubble_sort(arr: &mut [i32]) {\n  let n = arr.len();\n\n  for i in 0..n {\n    for j in 0..n-i-1 {\n      if arr[j] &gt; arr[j+1] {\n        arr.swap(j, j+1);\n      }\n    }\n  }\n}\n\nfn main() {\n  let mut arr = [64, 34, 25, 12, 22, 11, 90];\n\n  bubble_sort(&mut arr);\n\n  println!(\"Array ordinato con bubble sort: {:?}\", arr);\n}\nScala:\nobject BubbleSort {\n  def bubbleSort(arr: Array[Int]): Unit = {\n    val n = arr.length\n\n    for (i &lt;- 0 until n) {\n      for (j &lt;- 0 until n - i - 1) {\n        if (arr(j) &gt; arr(j + 1)) {\n          val temp = arr(j)\n\n          arr(j) = arr(j + 1)\n\n          arr(j + 1) = temp\n        }\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val arr = Array(64, 34, 25, 12, 22, 11, 90)\n\n    bubbleSort(arr)\n\n    println(\"Array ordinato con bubble sort: \" + arr.mkString(\", \"))\n  }\n}\n\nConfrontando questi esempi, possiamo osservare le differenze sintattiche e di stile tra Python ed altri, importanti, linguaggi. Python si distingue per la sua sintassi concisa e espressiva soprattutto nella versione procedurale. L’implementazione colla gerarchia di oggetti ha un piccolo incremento di complessità che è ripagato dalla possibilità di creare gerarchie di algoritmi di ordinamento, con impatti nulli sul codice preesistente.\nLa versione procedurale in Python e l’implementazione C, già a primo acchito, presentano un evidente diverso grado di chiarezza del codice. Inoltre, la riga int n = sizeof(arr)/sizeof(arr[0]); in C si rende necessaria per calcolare il numero di valori a partire dalle dimensioni totale della lista e del singolo elemento, rispetto a n = len(arr) di Python, dove chiediamo direttamente il numero di valori.\nIl C++ e Java aggiungono caratteristiche relative agli oggetti e funzionalità di alto livello rispetto a C, al prezzo di una sintassi più complessa e verbosa. Rust e Scala sono linguaggi più moderni e si pongono nel mezzo tra C, C++ e Java e Python.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduzione a Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html",
    "href": "seconda-parte-python-installazione.html",
    "title": "8  Scaricare e installare Python",
    "section": "",
    "text": "8.1 Scaricamento",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#scaricamento",
    "href": "seconda-parte-python-installazione.html#scaricamento",
    "title": "8  Scaricare e installare Python",
    "section": "",
    "text": "Visita il sito ufficiale di Python: Vai su python.org.\nNaviga alla pagina di download: Clicca su Downloads nel menu principale.\nScarica il pacchetto di installazione:\n\nPer Windows: Cerca Python 3.12.x e fai partire il download (assicurati di scaricare la versione più recente).\nPer macOS: Come per Windows.\nPer Linux: Python è spesso preinstallato. Se non lo è, usa il gestore di pacchetti della tua distribuzione (ad esempio apt per Ubuntu: sudo apt-get install python3).",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#installazione",
    "href": "seconda-parte-python-installazione.html#installazione",
    "title": "8  Scaricare e installare Python",
    "section": "8.2 Installazione",
    "text": "8.2 Installazione\n\nEsegui il file di installazione:\n\nSu Windows: Esegui il file .exe scaricato. Assicurati di selezionare l’opzione Add Python to PATH durante l’installazione.\nSu macOS: Apri il file .pkg scaricato e segui le istruzioni.\nSu Linux: Usa il gestore di pacchetti per installare Python.\n\nVerifica l’installazione:\n\nApri il terminale (Command Prompt su Windows, Terminal su macOS e Linux).\nDigita python --version o python3 --version e premi Invio. Dovresti vedere la versione di Python installata.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-installazione.html#esecuzione-del-primo-programma-hello-world",
    "href": "seconda-parte-python-installazione.html#esecuzione-del-primo-programma-hello-world",
    "title": "8  Scaricare e installare Python",
    "section": "8.3 Esecuzione del primo programma: “Hello, World!”",
    "text": "8.3 Esecuzione del primo programma: “Hello, World!”\nÈ consuetudine eseguire come primo programma la visualizzazione della stringa “Hello, World!”3. Possiamo farlo in diversi modi e ciò è una delle caratteristiche più apprezzate di Python.\n3 La tradizione del programma “Hello, World!” ha una lunga storia che risale ai primi giorni della programmazione. Questo semplice programma è generalmente il primo esempio utilizzato per introdurre i nuovi programmatori alla sintassi e alla struttura di un linguaggio di programmazione. Il programma “Hello, World!” è diventato famoso grazie a Brian Kernighan, che lo ha incluso nel suo libro  (B. W. Kernighan e D. M. RitchieThe C Programming LanguagePrentice Hall, Englewood Cliffs, NJ978-0131103627) pubblicato nel 1978. Tuttavia, il suo utilizzo risale a un testo precedente di Kernighan,  (B. W. KernighanA Tutorial Introduction to the Programming Language BBell Laboratories, Murray Hill, NJ), pubblicato nel 1973, dove veniva utilizzato un esempio simile.\nB. W. Kernighan e D. M. RitchieThe C Programming LanguagePrentice Hall, Englewood Cliffs, NJ978-0131103627.\n\nB. W. KernighanA Tutorial Introduction to the Programming Language BBell Laboratories, Murray Hill, NJ.\n\n8.3.1 REPL\nIl primo modo prevede l’utilizzo del REPL di Python. Il REPL (read-eval-print loop) è un ambiente interattivo di esecuzione di comandi Python generato dall’interprete, secondo il ciclo:\n\nRead: Legge un input dell’utente.\nEval: Valuta l’input.\nPrint: Visualizza il risultato dell’esecuzione.\nLoop: Ripete il ciclo.\n\nEseguiamo il nostro primo “Hello, World!”:\n\nApri il terminale ed esegui l’interprete Python digitando python o python3 e premi il tasto di invio della tastiera.\nScrivi ed esegui il programma:\n\nprint(\"Hello, World!\")\nPremi il tasto di invio per vedere il risultato immediatamente.\n\n\n\n\n\n\nAttenzione\n\n\n\nIl REPL e l’interprete Python sono strettamente collegati, ma non sono esattamente la stessa cosa. Quando avvii l’interprete Python senza specificare un file di script da eseguire (digitando semplicemente python o python3 nel terminale), entri in modalità REPL. Nel REPL, l’interprete Python legge l’input direttamente dall’utente, lo esegue, stampa il risultato e poi attende il prossimo input. In sintesi, l’interprete può eseguire programmi Python completi salvati in file, il REPL è progettato per un’esecuzione interattiva e immediata di singole istruzioni.\n\n\n\n\n8.3.2 Interprete\nUn altro modo per eseguire il nostro programma “Hello, World!” è utilizzare l’interprete Python per eseguire un file di codice sorgente. Questo metodo è utile per scrivere programmi più complessi e per mantenere il codice per usi futuri.\nEcco come fare sui diversi sistemi operativi.\n\nWindowsmacOSLinux\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Notepad.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dall’Esplora file.\nEsegui il file Python:\n\nApri il prompt dei comandi.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd %HOMEPATH%\\Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython hello.txt\n\noppure, se il tuo sistema utilizza python3:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come TextEdit.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello direttamente dal Finder.\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documents\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCrea un file di testo:\n\nApri il tuo editor di testo preferito, come Gedit o Nano.\nScrivi il seguente codice nel file:\n\nprint(\"Hello, World!\")\n\nSalva il file con il nome hello.txt.\n\nRinomina il file (facoltativo): se desideri mantenere il file senza estensione .txt, puoi rinominarlo in hello utilizzando il comando mv nel terminale:\n\nmv hello.txt hello\n\nEsegui il file Python:\n\nApri il terminale del sistema operativo.\nNaviga fino alla directory in cui hai salvato il file. Ad esempio, se il file si trova nella cartella Documenti, puoi digitare:\n\ncd ~/Documenti\n\nEsegui l’interprete Python passando come argomento il file che hai creato:\n\npython3 hello.txt\nVisualizza il risultato:\n\nHello, World!\n\n\n\nCon queste istruzioni, dovresti essere in grado di eseguire il programma “Hello, World!” utilizzando un file Python su Windows, macOS e Linux.\n\n\n8.3.3 IDE\nUtilizzo di un IDE (integrated development environment) installato sul computer. Ecco alcuni dei più comuni e gratuiti.\n\nIDLEPyCharmVisual Studio Code\n\n\nÈ incluso con l’installazione di Python.\n\nAvvia IDLE.\nCrea un nuovo file (File -&gt; New File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file (File -&gt; Salva).\nEsegui il programma (Run -&gt; Run Module).\n\n\n\nProprietario ma con una versione liberamente fruibile.\n\nScarica e installa PyCharm da jetbrains.com/pycharm/download.\nCrea un nuovo progetto associando l’interprete Python.\nCrea un nuovo file Python (File -&gt; New -&gt; Python File).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nEsegui il programma (Run -&gt; Run...).\n\n\n\nProprietario ma liberamente fruibile.\n\nScarica e installa VS Code da code.visualstudio.com.\nInstalla l’estensione Python.\nApri o crea una nuova cartella di progetto.\nCrea un nuovo file Python (File -&gt; Nuovo file).\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nSalva il file con estensione .py, ad esempio hello_world.py.\nEsegui il programma utilizzando il terminale integrato (Visualizza -&gt; Terminale) e digitando python hello_world.py.\n\n\n\n\n\n\n8.3.4 Esecuzione nel browser\nPuoi eseguire Python direttamente nel browser, senza installare nulla. Anche qui abbiamo diverse alternative, sia eseguendo il codice localmente, che utilizzando piattaforme online.\n\nRepl.itGoogle ColabPyScript\n\n\n\nVisita repl.it.\nCrea un nuovo progetto selezionando Python.\nScrivi il programma:\n\nprint(\"Hello, World!\")\n\nClicca su “Run” per eseguire il programma.\n\n\n\n\nVisita colab.research.google.com.\nCrea un nuovo notebook.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi il pulsante di esecuzione accanto alla cella.\n\n\n\n\nVisita il sito ufficiale di PyScript per ulteriori informazioni su come iniziare.\nCrea un file HTML con il seguente contenuto:\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Hello, World with PyScript&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://pyscript.net/latest/pyscript.css\"&gt;\n    &lt;script defer src=\"https://pyscript.net/latest/pyscript.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;py-script&gt;\n        print(\"Hello, World!\")\n    &lt;/py-script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nSalva il file con estensione .html (ad esempio, hello.html).\nApri il file salvato in un browser web. Vedrai l’output Hello, World! direttamente nella pagina.\n\n\n\n\n\n\n8.3.5 Jupyter Notebook\nJupyter Notebook è un ambiente di sviluppo interattivo per la programmazione che permette di creare e condividere documenti contenenti codice eseguibile, visualizzazioni, testo formattato e altro ancora. Originariamente sviluppato come parte del progetto IPython, Jupyter supporta non solo Python, ma anche numerosi altri linguaggi di programmazione attraverso i cosiddetti kernel tra cui R, Julia e Scala.\n\nUso localeJupyterHubBinder\n\n\n\nAssicurati di avere Python e Jupyter installati sul tuo computer. Se non li hai, puoi installarli utilizzando Anaconda o pip:\n\npip install notebook\n\nAvvia Jupyter Notebook dal terminale:\n\njupyter notebook\n\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita l’istanza di JupyterHub della tua istituzione o azienda (maggiori informazioni).\nAccedi con le tue credenziali.\nCrea un nuovo notebook Python.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\n\n\n\nVisita mybinder.org.\nInserisci l’URL del repository GitHub che contiene il tuo notebook o il tuo progetto Python.\nClicca su “Launch”.\nUna volta avviato l’ambiente, crea un nuovo notebook o apri uno esistente.\nIn una cella di codice, scrivi:\n\nprint(\"Hello, World!\")\n\nPremi Shift + Enter per eseguire la cella.\n\nBinder è un servizio simile a Colab, anche se quest’ultimo offre strumenti generalmente più avanzati in termini di risorse computazionali e collaborazione. Binder di contro è basato su GitHub e ciò può essere utile in alcuni contesti.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Scaricare e installare Python</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html",
    "href": "seconda-parte-python-sintassi.html",
    "title": "9  La sintassi",
    "section": "",
    "text": "9.1 Premessa",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#premessa",
    "href": "seconda-parte-python-sintassi.html#premessa",
    "title": "9  La sintassi",
    "section": "",
    "text": "9.1.1 Elementi semantici\nPer dare un senso, anche intuitivo, agli esempi presentati assieme ai concetti sintattici che saranno introdotti nel seguito, è opportuno definire, informalmente, alcuni elementi semantici, a partire da nozioni di base:\n\nVariabile: È un nome dato ad un valore presente in memoria.\nEspressione: È una combinazione di elementi di sintassi che può essere valutata per produrre un valore. In altre parole, un’espressione è un insieme di elementi come letterali, variabili, accessi ad attributi, operatori o chiamate di funzione che restituiscono tutti un valore.\nFunzione: È un insieme di istruzioni che può essere parametrizzato da una serie di input predefiniti e può avere una serie di output, a cui è associato un nome.\nClasse: È una definizione che raggruppa un insieme di attributi e operazioni che agiscono sugli attributi della propria o di altre classi.\nOggetto: È un’istanza di una classe, cioè un particolare valore di una classe che è stato creato in memoria.\nModulo: È un file contenente definizioni di variabili, funzioni e classi che possono essere importate e utilizzate in altri programmi o moduli.\n\n\n\n9.1.2 Le funzioni print() e help()\nNel seguito useremo molto la funzione print() che permette di visualizzare informazioni sullo schermo. Ciò è fondamentale per capire cosa sta succedendo nel programma in modo immediato ed è una semplice alternativa a strumenti di ispezione o debugging messi a diposizione da IDE.\nUsare print() è facile: basta scrivere print(espressione) e mettere nelle parentesi una espressione che si vuole visualizzare.\nAd esempio, per stampare \"Ciao, mondo!\", si scrive:\nprint(\"Ciao, mondo!\")\nNel REPL, invece, ciò si ottiene semplicemente dando l’invio:\n&gt;&gt;&gt; \"Ciao, mondo!\"\n'Ciao, mondo!'\nUna seconda funzione molto utile è help(). Fornisce informazioni sulla documentazione di moduli, funzioni, classi e metodi.\nAd esempio, per ottenere informazioni sulla funzione print(), possiamo scrivere:\n1&gt;&gt;&gt; help(print)\n\n1\n\nOutput di help(print):\n\n\nHelp on built-in function print in module builtins:\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n  Prints the values to a stream, or to sys.stdout by default.\n\n  sep\n    string inserted between values, default a space.\n  end\n    string appended after the last value, default a newline.\n  file\n    a file-like object (stream); defaults to the current sys.stdout.\n  flush\n    whether to forcibly flush the stream.\nNel REPL offre la massima utilità, perché eseguendo help() si passa dalla modalità interattiva del REPL a quella di navigazione del contenuto testuale della risposta, funzionalità molto comoda soprattutto per testi lunghi. Per ritornare al REPL, basta premere q e poi Invio.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#righe",
    "href": "seconda-parte-python-sintassi.html#righe",
    "title": "9  La sintassi",
    "section": "9.2 Righe",
    "text": "9.2 Righe\nLe righe sono di due tipi: logiche e fisiche. Le seconde sono le più facilmente individuabili nel testo di un programma, perché sono terminate da un carattere di a capo. Una o più righe fisiche costituiscono una riga logica che corrisponde ad una istruzione. Esiste una eccezione, poco usata e consigliata in Python, per cui una riga fisica contiene più istruzioni separate da ;.\nVi sono due modi per dividere una riga logica in righe fisiche. Il primo è terminare con il backslash (\\, poco usata la traduzione barra rovesciata o simili) tutte le righe fisiche meno l’ultima (intendendo con ciò che il backslash precede l’a capo):\n1x = 1 + 2 + \\\n     3\n\n2if x &gt; 5 and \\\n3   x &lt; 9:\n\n  print(\"5 &lt; x &lt; 9\") \n\n1\n\nL’istruzione di assegnamento è spezzata su due righe fisiche.\n\n2\n\nL’istruzione condizionale ha due espressioni che devono essere entrambe vere, ognuna su una riga fisica.\n\n3\n\nNon importa quanto sono indentate le righe fisiche successive alla prima e ciò può essere sfruttato per incrementare la leggibilità, ad esempio, allineando le espressioni x &gt; 5 e x &lt; 9 in colonna.\n\n\nIl secondo è per mezzo di parentesi, giacché tutte le righe fisiche che seguono una con parentesi tonda (, quadra [ o graffa { aperta, fino a quella con l’analoga parentesi chiusa, sono unite in una logica. Le regole di indentazione, che vedremo nel seguito, si applicano solo alla prima riga fisica.\nEsempi sintatticamente corretti ma sconsigliabili, per l’inerente illeggibilità:\n1x = (1 + 2\n     + 3 + 4)\n\ny = [1, 2, \n2           3, 4 +\n      5] \n\n3z = [1, 2\n     , 3, 4]   \n\n1\n\nL’espressione è spezzata su due righe fisiche e le parentesi tonde rappresentano un’alternativa all’uso del backslash.\n\n2\n\nLe righe fisiche della lista non hanno la stessa indentazione e una espressione è spezzata su due righe.\n\n3\n\nLa lista è spezzata su due righe fisiche e un delimitatore inizia la riga anziché terminare la precedente.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#commenti",
    "href": "seconda-parte-python-sintassi.html#commenti",
    "title": "9  La sintassi",
    "section": "9.3 Commenti",
    "text": "9.3 Commenti\nUn commento inizia con un carattere cancelletto (#) e termina alla fine della riga fisica. I commenti non possono coesistere con il backslash come separatore di riga logica, giacché entrambi devono chiudere la riga fisica.\nEsempi non sintatticamente corretti:\n1x = 1 + 2 + \\ # Commento\n     3\n\n2if x &gt; 5 and # Commento \\\n   x &lt; 9: \n  print(\"5 &lt; x &lt; 9\") \n\n1\n\nIl backslash deve terminare la riga fisica, quindi non può essere seguito da un commento. Se necessario può andare o alla riga successiva, scelta consigliata, o alla precedente. L’interprete segnalerà l’errore SyntaxError.\n\n2\n\nIl commento rende il backslash parte di esso quindi non segnala più la fine della riga fisica e, all’esecuzione, si avrà anche qui un errore di tipo SyntaxError, perché and deve essere seguito da un’espressione.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#indentazione",
    "href": "seconda-parte-python-sintassi.html#indentazione",
    "title": "9  La sintassi",
    "section": "9.4 Indentazione",
    "text": "9.4 Indentazione\nIndentazione significa che spazi o, in alternativa, tabulazioni precedono un carattere che non sia nessuno dei due. Il numero di spazi, ottenuto dopo la trasformazione delle tabulazioni in spazi, si definisce livello di indentazione.\nL’indentazione del codice è il modo che Python utilizza per raggruppare le istruzioni in un blocco, ove tutte devono presentare la medesima indentazione. La prima riga logica che ha una indentazione minore della precedente, segnala che il blocco è stato chiuso proprio da quest’ultima. Anche le clausole di un’istruzione composta devono avere la stessa indentazione.\nLa prima istruzione di un file o la prima inserita al prompt &gt;&gt;&gt; del REPL non deve presentare spazi o tabulazioni, cioè ha un livello di indentazione pari a 0.\nAlcuni esempi:\n\nDefinizione di una funzione:\n1def somma(a, b):\n2  risultato = a + b\n\n  return risultato \n\n1\n\nPrima riga senza indentazione.\n\n2\n\nQuesta riga e la successiva appartengono allo stesso blocco e, pertanto, hanno la medesima indentazione.\n\n\nTest di condizione:\nx = 10\n\n1if x &lt; 0:\n2    print(\"x è negativo\")\n\nelif x == 0: \n      print(\"x è zero\") \n\nelse: \n        print(\"x è positivo\") \n\n1\n\nLe tre clausole if , then e else della medesima istruzione composta di test di condizione, devono avere identica indentazione.\n\n2\n\nI tre blocchi hanno come unico vincolo quello di avere un livello maggiore di indentazione della riga precedente. I blocchi corrispondenti alle diverse clausole non devono avere lo stesso livello di indentazione, anche se è buona prassi farlo.\n\n\n\n\n\n\n\n\n\nAttenzione\n\n\n\nNon si possono avere sia spazi che tabulazioni per definire il livello di indentazione nello stesso file. Ciò perché renderebbe ambiguo il numero di spazi che si ottiene dopo la trasformazione delle tabulazioni in spazi. Quindi, o si usano spazi, scelta raccomandata, o tabulazioni.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-sintassi.html#token",
    "href": "seconda-parte-python-sintassi.html#token",
    "title": "9  La sintassi",
    "section": "9.5 Token",
    "text": "9.5 Token\nLe righe logiche sono composte da token che si categorizzano in parole chiave, identificatori, operatori, delimitatori e letterali. I token sono separati da un numero arbitrario di spazi e tabulazioni. Ad esempio:\nx = 1  +  2  +  3\n\nif    x &gt; 5    and    x &lt; 9: \n  print(\"5 &lt; x &lt; 9\") \n\n9.5.1 Identificatori\nUn identificatore è un nome assegnato ad un oggetto, cioè una variabile, una funzione, una classe, un modulo e altro. Esso è case sensitive cioè python e Python sono due identificatori diversi.\nAlcuni esempi:\n1intero = 42\n2decimale = 3.14\n3testo = \"Ciao, mondo!\"\n4lista = [1, 2, 3]\n5dizionario = {\"chiave\": \"valore\"}\n\n6def mia_funzione():\n  print(\"Questa è una funzione\")\n\n7class MiaClasse:\n8  def __init__(self, valore):\n9    self.valore = valore\n    \n10  def metodo(self):\n    print(\"Questo è un metodo della classe\")\n\n11import math\n\n12def mio_generatore():\n  yield 1\n  yield 2\n  yield 3\n\n13mio_oggetto = MiaClasse(10)\n\n1\n\nIdentificatore di numero intero: intero.\n\n2\n\nIdentificatore di numero decimale: decimale.\n\n3\n\nIdentificatore di stringa: testo.\n\n4\n\nIdentificatore di lista: lista.\n\n5\n\nIdentificatore di dizionario: dizionario.\n\n6\n\nIdentificatore di funzione: mia_funzione.\n\n7\n\nIdentificatore di classe: MiaClasse.\n\n8\n\nIdentificatore di metodo e parametro: __init__ e valore.\n\n9\n\nIdentificatore di attributo: valore.\n\n10\n\nIdentificatore di metodo: metodo.\n\n11\n\nIdentificatore di modulo: math.\n\n12\n\nIdentificatore di generatore: mio_generatore.\n\n13\n\nIdentificatore di oggetto: mio_oggetto.\n\n\n\n\n9.5.2 Parole chiave\nLe parole chiave sono parole che non possono essere usate per scopi diversi da quelli predefiniti nel linguaggio e, quindi, non possono essere usate come identificatori. Ad esempio, True che rappresenta il valore logico di verità, non può essere usato per definire ad esempio una variabile.\nEsistono anche delle parole chiave contestuali, cioè che sono tali solo in alcuni contesti ed altrove possono essee usate come identificatori. Usiamo il codice seguente per ottenere una lista di parole chiave e parole chiave contestuali:\n1import keyword\n\n2parole_chiave = keyword.kwlist\n\n3parole_chiave_contestuale = keyword.softkwlist\n\n4print(parole_chiave)\n\n5print(parole_chiave_contestuale)\n\n1\n\nImporta il modulo keyword.\n\n2\n\nOttiene la lista delle parole chiave.\n\n3\n\nOttiene la lista delle parole chiave contestuali.\n\n4\n\nStampa la lista delle parole chiave.\n\n5\n\nStampa la lista delle parole chiave contestuali.\n\n\nNella tabella seguente invece un elenco completo con breve descrizione:\n\nParole chiave di Python\n\n\n\n\n\n\nParola chiave\nDescrizione\n\n\n\n\nValori booleani\n\n\n\nFalse\nValore booleano falso\n\n\nTrue\nValore booleano vero\n\n\nOperatori logici\n\n\n\nand\nOperatore logico AND\n\n\nor\nOperatore logico OR\n\n\nnot\nOperatore logico NOT\n\n\nOperatori di controllo di flusso\n\n\n\nif\nUtilizzato per creare un’istruzione condizionale\n\n\nelif\nUtilizzato per aggiungere condizioni in un blocco if\n\n\nelse\nUtilizzato per specificare il blocco di codice da eseguire se le condizioni precedenti sono false\n\n\nfor\nUtilizzato per creare un ciclo for\n\n\nwhile\nUtilizzato per creare un ciclo while\n\n\nbreak\nInterrompe il ciclo in corso\n\n\ncontinue\nSalta l’iterazione corrente del ciclo e passa alla successiva\n\n\npass\nIndica un blocco di codice vuoto\n\n\nreturn\nUtilizzato per restituire un valore da una funzione\n\n\nGestione delle eccezioni\n\n\n\ntry\nUtilizzato per definire un blocco di codice da eseguire e gestire le eccezioni\n\n\nexcept\nUtilizzato per catturare le eccezioni in un blocco try-except\n\n\nfinally\nBlocco di codice che viene eseguito alla fine di un blocco try, indipendentemente dal fatto che si sia verificata un’eccezione\n\n\nraise\nUtilizzato per sollevare un’eccezione\n\n\nDefinizione delle funzioni e classi\n\n\n\ndef\nUtilizzato per definire una funzione\n\n\nclass\nUtilizzato per definire una classe\n\n\nlambda\nUtilizzato per creare funzioni anonime\n\n\nGestione contesto di dichiarazione di variabili\n\n\n\nglobal\nUtilizzato per dichiarare variabili globali\n\n\nnonlocal\nUtilizzato per dichiarare variabili non locali\n\n\nOperazioni su moduli\n\n\n\nimport\nUtilizzato per importare moduli\n\n\nfrom\nUtilizzato per importare specifici elementi da un modulo\n\n\nas\nUtilizzato per creare alias, ad esempio negli import\n\n\nOperatori di identità e appartenenza\n\n\n\nin\nUtilizzato per verificare se un valore esiste in una sequenza\n\n\nis\nOperatore di confronto di identità\n\n\nGestione delle risorse\n\n\n\nwith\nUtilizzato per garantire un’azione di pulizia come il rilascio delle risorse\n\n\nProgrammazione asincrona\n\n\n\nasync\nUtilizzato per definire funzioni asincrone\n\n\nawait\nUtilizzato per attendere un risultato in una funzione asincrona\n\n\nVarie\n\n\n\ndel\nUtilizzato per eliminare oggetti\n\n\nassert\nUtilizzato per le asserzioni, verifica che un’espressione sia vera\n\n\nyield\nUtilizzato per restituire un generatore da una funzione\n\n\nNone\nRappresenta l’assenza di valore o un valore nullo\n\n\nParole chiave contestuali\n\n\n\nmatch\nUtilizzato nell’istruzione match per il pattern matching\n\n\ncase\nUtilizzato nell’istruzione match per definire un ramo\n\n\n_\nUtilizzato come identificatore speciale nell’istruzione match per indicare un pattern di default o ignorare valori\n\n\ntype\nUtilizzato in specifici contesti per dichiarazioni di tipo\n\n\n\nEsempi di uso di parole chiave contestuali:\n\nmatch, case e _:\n1def process_value(value):\n2  match value:\n3    case 1:\n      print(\"Uno\")\n\n    case 2:\n      print(\"Due\")\n\n4    case _:\n      print(\"Altro\")\n\n5match = \"Questo è un identificatore valido\"\n\nprocess_value(1)  # Output: Uno\nprocess_value(2)  # Output: Due\nprocess_value(3)  # Output: Altro\n\n6print(match)\n\n1\n\nDefiniamo una funzione che utilizza il pattern matching.\n\n2\n\nUso di match come parola chiave.\n\n3\n\nUso di case come parola chiave.\n\n4\n\nUso di _ come parola chiave.\n\n5\n\nUtilizzo di match come identificatore per una variabile.\n\n6\n\nOutput: Questo è un identificatore valido.\n\n\ntype:\nfrom typing import TypeAlias\n\n1type Point = tuple[float, float]\n\n2def distanza(p1: Point, p2: Point) -&gt; float:\n  return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n3punto1: Point = (1.0, 2.0)\npunto2: Point = (4.0, 6.0)\n\n4print(distanza(punto1, punto2))\n\n5print(type(punto1))\n\n1\n\nUso di type come parola chiave.\n\n2\n\nUtilizzo dell’alias di tipo Point per i parametri p1 e p2 della funzione.\n\n3\n\nDefinizione delle variabili punto1 e punto2 come Point utilizzando l’alias di tipo. Questo rende chiaro che entrambe le variabili sono tuple di due float, anche se l’interprete non controlla la coerenza tra oggetto e alias di tipo.\n\n4\n\nOutput: 5.0.\n\n5\n\nUso di type identificatore di una funzione. Output: &lt;class 'tuple'&gt;.\n\n\n\n\n\n9.5.3 Classi riservate di identificatori\nAlcune classi di identificatori (oltre alle parole chiave) hanno significati speciali in Python. Queste classi sono identificate dai pattern di caratteri di sottolineatura (underscore) all’inizio e alla fine dei nomi. Tuttavia, l’uso di questi identificatori non impone limitazioni rigide al programmatore, ma è importante seguire le convenzioni per evitare ambiguità e problemi di compatibilità.\nIdentificatori speciali:\n\n_:\n\nNon importato da from module import *: Gli identificatori che iniziano con un singolo underscore non vengono importati con un’istruzione di importazione globale. Questo è un meccanismo per indicare che tali variabili o funzioni sono destinate ad essere private al modulo e non dovrebbero essere usate direttamente da altri moduli. Esempio:\n\nIn un file example.py:\n1_private_variable = \"Variabile da non esportare'\"\n\n1\n\nNel modulo example.py viene definita la variabile come privata.\n\n\nIn altro modulo diverso da example.py:\n1from example import *\n\n2print(_private_variable)\n\n1\n\nDal modulo example vengono importatati tutti gli identificatori pubblici.\n\n2\n\nGenera un errore: NameError: name '_private_variable' is not defined.\n\n\n\nPattern nei match: Nel contesto di un pattern di corrispondenza all’interno di un’istruzione match, _ è una parola chiave contestuale che denota un wildcard (carattere jolly), coem indicato sopra.\nInterprete interattivo: L’interprete interattivo rende disponibile il risultato dell’ultima valutazione nella variabile _. Il valore di _ è memorizzato nel modulo builtins, insieme ad altre funzioni e variabili predefinite come print(), permettendo l’accesso globale a _ durante una sessione interattiva. Esempio:\n# Eseguire nel REPL\nresult = 5 + 3\n\n1print(_)\n\n1\n\nOutput: 8 (nell’interprete interattivo).\n\n\nAltro uso: Altrove, _ è un identificatore regolare. Viene spesso usato per nominare elementi speciali per l’utente, ma non speciali per Python stesso. Il nome _ è comunemente usato in congiunzione con l’internazionalizzazione (vedi la documentazione del modulo gettext per ulteriori informazioni su questa convenzione) ed è anche comunemente utilizzato per variabili non usate. Esempio:\n1_ = \"Valore non usato\"\n\nimport gettext\n\ngettext.install('myapplication')\n\n2print(_('Hello, world'))\n\n1\n\nUso di _ come variabile regolare.\n\n2\n\nUso di _ per internazionalizzazione.\n\n\n\n__*__: Questi nomi, informalmente noti come nomi dunder3, sono definiti dall’interprete e dalla sua implementazione (inclusa la libreria standard). Altri potrebbero essere definiti nelle versioni future di Python. Qualsiasi uso di nomi __*__, in qualsiasi contesto, che non segua l’uso esplicitamente documentato, è soggetto a discontinuazione senza preavviso. Esempio:\nclass MyClass:\n1  def __init__(self, value):\n    self.__value = value\n\n  def __str__(self):\n2    return f\"MyClass con valore {self.__value}\"\n\nobj = MyClass(10)\n\n3print(obj)\n\n1\n\nDunder per metodo chiamato alla creazione dell’oggetto.\n\n2\n\nDunder chiamato da print con parametro l’oggetto.\n\n3\n\nOutput: MyClass con valore 10.\n\n\n__*: I nomi in questa categoria, quando utilizzati all’interno di una definizione di classe, vengono riscritti dal compilatore (processo noto come name mangling) per evitare conflitti di nome tra attributi “privati” delle classi base e delle classi derivate. Questo aiuta a garantire che gli attributi destinati ad essere privati non vengano accidentalmente sovrascritti nelle sottoclassi. Esempio:\nclass BaseClass:\n  def __init__(self):\n    self.__private_attr = \"Base\"\n\nclass DerivedClass(BaseClass):\n  def __init__(self):\n    super().__init__()\n\n    self.__private_attr = \"Derived\"\n\nbase_obj = BaseClass()\nderived_obj = DerivedClass()\n\n1print(base_obj._BaseClass__private_attr)\n2print(derived_obj._DerivedClass__private_attr)\n\n1\n\nAccesso al nome di BaseClass.\n\n2\n\nAccesso al nome di DerivedClass.\n\n\n\n3 I nomi con doppio underscore (__) sono chiamati dunder come abbreviazione di double underscore.\n\n9.5.4 Operatori\nGli operatori sono rappresentati da simboli non alfanumerici e, quando applicati a uno o più identificatori, letterali o espressioni (definiti genericamente operandi), producono un valore di risultato. Attenzione a non confondere la definizione di operatore come token, considerata qui, con quella di operatore come funzionalità algoritmica, poiché alcune parole chiave sono operatori algoritmici e anche le funzioni possono agire come operatori.\nEsempi:\nx = 5\ny = 10\n\n1z = x + y\n\n2sum = 3 + 4\n\n3result = (x * y) + (z / 2)\n\n1\n\nUtilizza l’operatore + sugli identificatori x e y.\n\n2\n\nUtilizza l’operatore + su letterali numerici.\n\n3\n\nUtilizza vari operatori su espressioni.\n\n\nIn tabella l’elenco degli operatori:\n\nOperatori di Python\n\n\n\n\n\n\nOperatore\nDescrizione\n\n\n\n\nAritmetici\n\n\n\n+\nAddizione\n\n\n-\nSottrazione\n\n\n*\nMoltiplicazione\n\n\n/\nDivisione\n\n\n//\nDivisione intera\n\n\n%\nModulo\n\n\n**\nEsponenziazione\n\n\n@\nMatrice (operatore di moltiplicazione)\n\n\nDi confronto\n\n\n\n&lt;\nMinore\n\n\n&gt;\nMaggiore\n\n\n&lt;=\nMinore o uguale\n\n\n&gt;=\nMaggiore o uguale\n\n\n==\nUguale\n\n\n!=\nDiverso\n\n\nSui bit\n\n\n\n&\nAND bit a bit\n\n\n|\nOR bit a bit\n\n\n^\nXOR bit a bit\n\n\n~\nNOT bit a bit\n\n\n&lt;&lt;\nShift a sinistra\n\n\n&gt;&gt;\nShift a destra\n\n\nDi assegnazione\n\n\n\n:=\nOperatore di assegnazione in espressione (walrus o tricheco)\n\n\n\nUna caratteristica molto potente del linguaggio è che gli operatori sono utilizzabili anche sui tipi creati dall’utente con logica determinata dalla implementazione. Pertanto, non vanno visti come limitati alle espressioni artimetiche o di assegnazione sui letterali definiti dal linguaggio, ma anche sugli identificatori corrispondenti a tipi più complessi, anche definiti nel programma o importati.\nUn esempio è dato dall’operatore @ che, nel codice seguente, è applicato ad un nuovo tipo di oggetto corrispondente al concetto matematico di matrice. La classe Matrice presenta gli attributi per memorizzare gli elementi numerici e anche l’implementazione dell’operazione matematica di moltiplicazione, nel metodo __matmul__. Quando l’interprete trova @, chiama __matmul__ dell’operando di sinistra e gli passa l’oggetto corrispondente all’operando di destra.\nCodice:\nclass Matrice:\n  def __init__(self, righe):\n    self.righe = righe\n    self.num_righe = len(righe)\n    self.num_colonne = len(righe[0]) if righe else 0\n\n1  def __matmul__(self, altra):\n2    if self.num_colonne != altra.num_righe:\n      raise ValueError(\"Non è possibile moltiplicare le matrici: \"\n                       \"dimensioni incompatibili.\")\n    \n3    risultato = [[0 for _ in range(altra.num_colonne)]\n                 for _ in range(self.num_righe)]\n    \n4    for i in range(self.num_righe):\n      for j in range(altra.num_colonne):\n        for k in range(self.num_colonne):\n          risultato[i][j] += (self.righe[i][k] *\n                              altra.righe[k][j])\n    \n    return Matrice(risultato)\n\n5  def __repr__(self):\n    return '\\n'.join([' '.join(map(str, riga)) for riga in self.righe])\n\n6A = Matrice([[1, 2],\n             [3, 4]])\n7B = Matrice([[5, 6],\n             [7, 8]])\n\n8C = A @ B\n\nprint(\"Matrice A:\") \n9print(A)\n\nprint(\"Matrice B:\")\nprint(B)\n\nprint(\"Risultato di A @ B:\")\n10print(C)\n\n1\n\nMetodo di implementazione della moltiplicazione di matrici, chiamato da @ usato come operatore su oggetti di tipo Matrice.\n\n2\n\nControlla se le dimensioni sono compatibili per la moltiplicazione.\n\n3\n\nInizializza la matrice risultato con zeri.\n\n4\n\nEsegue la moltiplicazione delle matrici.\n\n5\n\nChiamato da print() quando applicato su oggetti di tipo Matrice.\n\n6\n\nRappresentazione leggibile della matrice operando di sinistra.\n\n7\n\nRappresentazione leggibile della matrice operando di destra.\n\n8\n\nMoltiplicazione di matrici utilizzando l’operatore @ che chiama __matmul__() per il calcolo effettivo.\n\n9\n\nChiama __repr__() di Matrice per ottenere la stringa su due righe per A: 1 2 e 3 4.\n\n10\n\nChiama __repr__() di Matrice per ottenere la stringa su due righe per C: 19 22 e 43 50.\n\n\n\n\n9.5.5 Delimitatori\nIn Python, alcuni token servono come delimitatori nella grammatica del linguaggio. I delimitatori sono caratteri che separano le varie componenti del codice, come espressioni, blocchi di codice, parametri di funzioni e istruzioni.\nLa seguente tabella include tutti i delimitatori e i principali utilizzi:\n\nDelimitatori di Python\n\n\n\n\n\n\nDelimitatore\nDescrizione\n\n\n\n\n(\nUtilizzata per raggruppare espressioni, chiamate di funzione e definizioni di tupla\n\n\n)\nUtilizzata per chiudere le parentesi tonde aperte\n\n\n[\nUtilizzate per definire liste e accedere agli elementi delle liste, tuple, o stringhe\n\n\n]\nUtilizzate per chiudere le parentesi quadre aperte\n\n\n{\nUtilizzate per definire dizionari e set\n\n\n}\nUtilizzate per chiudere le parentesi graffe aperte\n\n\n,\nUtilizzata per separare elementi in liste, tuple, e argomenti nelle chiamate di funzione\n\n\n:\nUtilizzato per definire blocchi di codice (come in if, for, while, def, class) e per gli slice\n\n\n.\nUtilizzato per accedere agli attributi di un oggetto. Può apparire in letterali decimnali e immaginari\n\n\n;\nUtilizzato per separare istruzioni multiple sulla stessa riga\n\n\n@\nUtilizzato per dichiarare decoratori per funzioni e metodi\n\n\n=\nOperatore utilizzato per assegnare valori a variabili\n\n\n-&gt;\nAnnotazione del tipo di ritorno delle funzioni\n\n\n+=\nAssegnazione aumentata con addizione. Aggiunge il valore a destra a quello a sinistra e assegna il risultato alla variabile a sinistra. Come i successivi, è sia un delimitatore che un operatore\n\n\n-=\nAssegnazione aumentata con sottrazione\n\n\n*=\nAssegnazione aumentata con moltiplicazione\n\n\n/=\nAssegnazione aumentata con divisione\n\n\n//=\nAssegnazione aumentata con divisione intera\n\n\n%=\nAssegnazione aumentata con modulo\n\n\n@=\nAssegnazione aumentata con moltiplicazione di matrici\n\n\n&=\nAssegnazione aumentata con AND bit a bit\n\n\n|=\nAssegnazione aumentata con OR bit a bit\n\n\n^=\nAssegnazione aumentata con XOR bit a bit\n\n\n&gt;&gt;=\nAssegnazione aumentata con shift a destra\n\n\n&lt;&lt;=\nAssegnazione aumentata con shift a sinistra\n\n\n**=\nAssegnazione aumentata con esponenziazione\n\n\n\nUna sequenza di tre punti, comunemente indicata come ellissi anche al difuori dei linguaggi di programmazione,4 è trattata come un token a sé e corrisponde ad un oggetto predefinito chiamato Ellipsis, con applicazioni in diversi contesti:\n4 L’ellissi è usata, ad esempio, in C per dichiarare funzioni che accettano un numero variaible di parametri e i Javascript come operatore per espandere gli array o le proprietà di un oggetto.1print(type(...))\n\ndef funzione_da_completare():\n2  ...\n\nclass ClasseEsempio:\n  def metodo_da_completare(self):\n    ...\n\nfrom typing import Callable\n\n3def funzione_variadica(func: Callable[..., int]):\n  pass\n\nimport numpy as np\n\narray = np.array([[[1, 2, 3],    [4, 5, 6]], \n                  [[7, 8, 9], [10, 11, 12]]]) \n\n4print(array[..., 1])\n\n1\n\nOtteniamo il tipo dell’oggetto ellissi. L’output è &lt;class 'ellipsis'&gt;.\n\n2\n\nUtilizzo come segnaposto per indicare che la funzione è da completare. Da notare che chiamare la funzione funzione_da_completare() non dà errore.\n\n3\n\nL’uso di Callable[..., int] indica una funzione che può accettare un numero variabile di argomenti di qualsiasi tipo e restituire un valore di tipo int.\n\n4\n\nnumpy è una libreria di calcolo matriciale molto diffusa. L’ellissi è utilizzata per effettuare uno sezione complessa della matrice secondo tutte le dimensioni precedenti all’ultima. In altre parole, l’ellissi permette di selezionare interamente tutte le dimensioni tranne l’ultima specificata. Il risultato stampato in console è su due righe: [[ 2  5] e [ 8 11]].\n\n\nAlcuni caratteri ASCII hanno un significato speciale come parte di altri token o sono significativi per l’analizzatore lessicale:\n\nCaratteri speciali di Python\n\n\n\n\n\n\nCarattere\nDescrizione\n\n\n\n\n'\nUtilizzato per definire stringhe di caratteri.\n\n\n\"\nUtilizzato per definire stringhe di caratteri.\n\n\n#\nSimbolo di commento. Utilizzato per indicare un commento, che viene ignorato dall’interprete Python.\n\n\n\\\nBackslash. Utilizzato per caratteri di escape nelle stringhe e per continuare le righe di codice su più righe fisiche.\n\n\n\nAlcuni caratteri ASCII non sono utilizzati in Python e la loro presenza al difuori dei letterali di stringa e dei commenti genera un errore: $, ?, `.\n\n\n9.5.6 Letterali\nI letterali sono notazioni per valori costanti di alcuni tipi predefiniti nel linguaggio. Esistono diversi tipi di letterali, ognuno rappresenta un tipo di dato specifico e ha una sintassi particolare.\n\n9.5.6.1 Numerici\nI letterali numerici includono interi, numeri a virgola mobile e numeri immaginari:\n\nInteri, possono essere scritti in base decimale, ottale, esadecimale o binaria:\n\nDecimale: 42.\nOttale: 0o12, 0O7.\nEsadecimale: 0xA, 0X1F.\nBinario: 0b1010, 0B11.\n\nVirgola mobile, possono essere rappresentati con una parte intera e una decimale, oppure con notazione scientifica:\n\nVirgola mobile: 3.14, 0.001.\nNotazione scientifica: 1e10, 2.5E-3.\n\nNumeri immaginari, ottenuti da un letterale intero o a virgola mobile con un suffisso j o J: 4j, 4.j, 3.14e-10j.\n\n\n\n9.5.6.2 Stringhe\nI letterali di stringa possono essere racchiusi tra virgolette singole o doppie. Possono anche essere multi-linea se racchiusi tra triple virgolette singole o doppie:\n\nStringhe racchiuse tra virgolette singole o doppie:\n\nSingole: 'ciao'.\nDoppie: \"mondo\".\n\nStringhe multi-linea racchiuse tra triple virgolette singole o doppie:\n\nTriple singole: '''testo multi-linea'''.\nTriple doppie: \"\"\"testo multi-linea\"\"\".\n\n\nLe stringhe tra tripli apici possono avere degli a capo e degli apici (non tripli) all’interno.\nEsempio:\nstringa_multilinea = \"\"\"Questa è una stringa\nmolto \"importante\".\"\"\"\n\nprint(stringa_multilinea)\nTutte le stringhe sono codificate in Unicode, con il prefisso b la stringa è di tipo byte ed è limitata ai 128 caratteri dell’ASCII. Se si prepone r, che sta per raw cioè grezzo, allora la codifica è sempre Unicode ma i caratteri di escape5 non sono intepretati.\n5 In Python, il carattere di escape \\ è utilizzato nelle stringhe per inserire caratteri speciali che non possono essere facilmente digitati sulla tastiera o che hanno significati speciali.Alcuni esempi comuni includono:\n\n\\n per una nuova linea (linefeed).\n\\t per una tabulazione.\n\\\\ per inserire un backslash.\n\\' per il singolo apice.\n\\\" per i doppi apici.\n\n\n\n9.5.6.3 F-stringhe\nLe f-stringhe (stringhe formattate) sono racchiuse tra virgolette singole, doppie o triple e sono precedute dal prefisso f o F. Il formattato nel nome deriva dalla possibilità di includere espressioni Python all’interno che sono valutate all’atto della esecuzione della istruzione contenente la stringa. Si possono avere stringhe formattate grezze ma non byte.\nEsempio:\nnome = \"Python\"\n\n1f_stringa = f'Ciao, {nome.upper()}!'\n\ndefinizione = \"Linguaggio\"\n\nf_stringa_multi_linea = f'''Questo è un esempio\ndi f-stringa multi-linea\n2in {definizione.lower() + ' ' + nome}'''\n\n3print(f_stringa)\n\n4print(f_stringa_multi_linea)\n\n1\n\nViene chiamato il metodo della stringa lower() per avere il maiuscolo.\n\n2\n\nUsiamo un’espressione di concatenazione di stringhe colla prima generata da un metodo che mette in minuscolo la stringa di definizione.\n\n3\n\nOutput: Ciao, python!.\n\n4\n\nOutput composto dalle tre righe Questo è un esempio, di f-stringa multi-linea e in linguaggio Python.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>La sintassi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html",
    "href": "seconda-parte-python-modello-dati.html",
    "title": "10  Il modello dati",
    "section": "",
    "text": "10.1 Elementi di programmazione orientata agli oggetti\nGli oggetti sono l’astrazione dei dati definita in Python. Ogni oggetto è caratterizzato da un’identità, un tipo e un valore. L’identità di un oggetto non cambia una volta creato e possiamo pensarlo come l’indirizzo dell’oggetto in memoria3. Python permette di ricavarlo per mezzo della funzione predefinita (built-in) id():\nIl tipo di un oggetto determina le operazioni che l’oggetto supporta per la manipolazione del proprio stato o di quello di altri oggetti, e definisce anche i possibili valori per gli oggetti di quel tipo (dominio dei valori, per prendere in prestito un termine dalla matematica). Il linguaggio fornisce una funzione per conoscere il tipo dell’oggetto:",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html#elementi-di-programmazione-orientata-agli-oggetti",
    "href": "seconda-parte-python-modello-dati.html#elementi-di-programmazione-orientata-agli-oggetti",
    "title": "10  Il modello dati",
    "section": "",
    "text": "3 In CPython è effettivamente implementato così.s = \"Hello\"\n\n1print(id(s))\n\n1\n\nOutput: un numero come 4467381744.\n\n\n\ns = \"Hello\"\n\n1print(type(s))\n\n1\n\nOutput: &lt;class 'str'&gt;.\n\n\n\n10.1.1 Tipi e classi\nIn Python, i tipi di dati sono implementati come classi. Una classe è una definizione che specifica una struttura di dati e il comportamento associato attraverso attributi e metodi. Gli attributi sono variabili legate alla classe o alle sue istanze e rappresentano lo stato, mentre i metodi sono funzioni che definiscono il comportamento.\nUn’istanza (o oggetto) è un’implementazione concreta della classe. Mentre di una classe esiste una sola definizione, si possono creare infinite istanze della stessa classe, a meno che non siano state implementate limitazioni particolari. Ogni istanza ha il proprio stato (valore degli attributi). Gli attributi e i metodi possono essere membri sia delle classi che delle istanze. In generale, ogni oggetto può avere i propri attributi e metodi, ma può anche accedere agli attributi e ai metodi della classe a cui appartiene.\nGli attributi possono essere di classe o di istanza:\n\nGli attributi di classe sono condivisi tra tutte le istanze della classe.\nGli attributi di istanza sono specifici di ogni istanza.\n\nI metodi di istanza operano su istanze specifiche della classe e possono accedere e modificare gli attributi dell’istanza stessa. I metodi di classe, invece, operano a livello della classe e possono accedere e modificare gli attributi della classe attraverso il parametro cls. Infine, i metodi statici sono funzioni associate alla classe che non dipendono né dalla classe né dalle sue istanze; non possono modificare lo stato della classe o delle sue istanze.\nEcco un esempio di definizione di una classe in Python, utile, per il momento, solo a mostrare la sintassi dei membri:\nclass Esempio:\n1  attributo_di_classe = 'Valore di classe'\n\n  def __init__(self, attributo):\n2    self.attributo_di_istanza = attributo\n\n3  def metodo_di_istanza(self):\n    return f\"Metodo di istanza: {self.attributo_di_istanza}\"\n\n  @classmethod\n4  def metodo_di_classe(cls):\n    return f\"Metodo di classe: {cls.attributo_di_classe}\"\n\n  @staticmethod\n5  def metodo_statico():\n    return \"Metodo statico\"\n\n6oggetto = Esempio(\"Valore di istanza\")\n\n7print(oggetto.metodo_di_istanza())\n8print(Esempio.metodo_di_classe())\n9print(Esempio.metodo_statico())\n\n1\n\nAttributo di classe.\n\n2\n\nAttributo di istanza.\n\n3\n\nMetodo di istanza.\n\n4\n\nMetodo di classe, preceduto da @classmethod.\n\n5\n\nMetodo statico, preceduto da @staticmethod.\n\n6\n\nCreazione di un oggetto della classe Esempio associato alla variabile oggetto.\n\n7\n\nOutput: Metodo di istanza: Valore di istanza.\n\n8\n\nOutput: Metodo di classe: Valore di classe.\n\n9\n\nOutput: Metodo statico.\n\n\nIn questo esempio, Esempio è una classe con un attributo di classe, un attributo di istanza, un metodo di istanza, un metodo di classe e un metodo statico. La classe definisce la struttura e il comportamento, mentre l’oggetto oggetto è un’istanza concreta della classe.\n\n\n10.1.2 Creazione di oggetti\nUna volta definita una classe, si possono creare nuove istanze o oggetti di quella classe, il che rappresenta un modo efficiente per riutilizzare funzionalità nel proprio codice. Questo passaggio è spesso chiamato costruzione o istanziazione degli oggetti. Lo strumento responsabile per la specializzazione di questo processo, è comunemente noto come costruttore della classe.\nIn Python, il costruttore è il metodo speciale __init__ e può avere un numero arbitrario di parametri. Questo metodo viene eseguito automaticamente dall’interprete quando un nuovo oggetto della classe viene creato ed è il luogo possiamo scrivere delle istruzioni utili all’inizializzazione dell’oggetto, anche usando gli argomenti passati. La sintassi per l’istanziazione è data dall’identificatore della classe, seguita da una coppia di parentesi tonde, con all’interno l’elenco degli argomenti.\nEsempio:\n1s = str(4)\n\n1\n\nL’identificatore della classe delle stringhe str è seguito da un unico argomento, 4 , dato da un letterale intero, passato al costruttore per l’inizializzazione.\n\n\nIl metodo __init__ è sempre presente: se non è definito esplicitamente nella classe, viene ereditato dalla classe base object.\nLa creazione di un oggetto avviene in diversi contesti:\n\nUso di letterali. Ad esempio, per creare un oggetto stringa, si usano i letterali stringa e analogamente per gli altri:\n1s = \"Hello\"\n\n2n = 42\n\n3f = 3.14\n\n1\n\nCreazione di un oggetto di tipo str.\n\n2\n\nCreazione di un oggetto di tipo int.\n\n3\n\nCreazione di un oggetto di tipo float.\n\n\nChiamata del costruttore della classe, ad esempio a quello della classe list passiamo una sequenza di interi:\nlista = list((1, 2, 3))\nUtilizzo di funzioni e metodi che restituiscono oggetti. Ad esempio, il metodo upper() della classe str restituisce un nuovo oggetto di tipo str, ottenuto a partire da quello su cui è eseguito:\ns1 = \"Hello, World!\"\n\n1su_1 = s1.upper()\n\n2su_2 = \"Hello, World!\".upper()\n\n1\n\nupper() crea un secondo oggetto stringa che viene associato alla variabile su_1.\n\n2\n\nSintassi alternativa che ha il medesimo effetto.\n\n\nClonazione o copia utilizzando la funzione copy del modulo copy:\nimport copy\n\n1lista_originale = [1, 2, 3]\n\n2lista_copiata = copy.copy(lista_originale)\n\n1\n\nlista_originale identifica un oggetto lista.\n\n2\n\ncopy() produce una copia di lista_originale identificata da lista_copiata.\n\n\n\n\n\n10.1.3 Accesso a attributi e metodi\nIn Python, si utilizza la notazione con il punto . per accedere agli attributi e ai metodi di un oggetto o di una classe, semplicemente accodando all’identificatore della variabile (che rappresenta un’istanza della classe) o a quello della classe, il punto e l’identificatore del membro (attributo o metodo).\nEsempio su str:\n1s = \"hello world\"\n\n2s_upper = s.upper()\n\n3print(s_upper)\n\n4print(s.__class__)\n\n1\n\nCreazione di un oggetto stringa.\n\n2\n\nChiamata del metodo upper() usando l’identificatore s.\n\n3\n\nOutput: HELLO WORLD.\n\n4\n\nOutput dell’attributo __class__: &lt;class 'str'&gt;.\n\n\n\n\n10.1.4 Gerarchie di classi\nLe classi sono organizzate in una gerarchia. In cima alla gerarchia delle classi di Python c’è la classe object, con un nome po’ infelice, da cui derivano tutte le altre classi. Questo significa che ogni classe in Python eredita gli attributi e i metodi della classe object.\nLa funzione isinstance() è utile per investigare questa gerarchia, poiché permette di verificare se un oggetto è un’istanza di una determinata classe o di una sua classe derivata. isinstance(), pertanto, ha due parametri, l’identificatore dell’oggetto e l’identificatore della classe e restituisce un valore logico, True o False.\nAd esempio:\ns = \"Hello\" \n\n1print(isinstance(s, str))\n\n2print(isinstance(s, object))\n\n1\n\nOutput: True. isinstance conferma che s è un’istanza della classe str.\n\n2\n\nOutput: True. isinstance conferma che s è un’istanza anche della classe object, da cui deriva str.\n\n\nLa funzione issubclass() è altrettanto utile per esplorare le gerarchie delle classi, in quanto permette di verificare se una classe è una sottoclasse di un’altra. Ha due parametri, cioè il nome della classe derivata e quella base e restituisce un valore logico.\nAd esempio:\n1print(issubclass(str, object))\n\n1\n\nOutput: True. issubclass conferma che str è una sottoclasse di object.\n\n\n\n\n10.1.5 Mutabilità e immutabilità\nGli oggetti il cui valore può cambiare sono detti mutabili, mentre gli oggetti il cui valore non lo può, una volta creati, sono chiamati immutabili. L’immutabilità di un oggetto è determinata dalla progettazione del suo tipo. Ad esempio, per i tipi definiti nel linguaggio, numeri interi e in virgola mobile, stringhe e tuple sono immutabili, mentre dizionari e liste sono mutabili.\nAlcuni oggetti, chiamati contenitori, contengono riferimenti ad altri oggetti. Esempi di contenitori sono tuple, liste e dizionari, strutture dati di base definite in molti linguaggi di programmazione. I riferimenti ad altri oggetti contribuiscono al valore di un contenitore e, nella maggior parte dei casi, quando parliamo del valore di un contenitore, intendiamo proprio i valori degli oggetti contenuti. Ad esempio:\n1t = (1, 2, 3)\n\n2l = [\"Qui\", \"Quo\", \"Qua\"]\n\n1\n\nTupla con tre oggetti al suo interno: 1, 2, 3. Diciamo che la tupla contiene i tre valori interi.\n\n2\n\nLista con tre oggetti all’interno: \"Qui\", \"Quo\", \"Qua\". Diciamo che la lista contiene le tre stringhe.\n\n\nLa mutabilità di un contenitore si riferisce alla identità degli oggetti referenziati e non al loro valore, quindi, ad esempio, se una tupla contiene un riferimento ad un oggetto mutabile, il valore della tupla cambia se quell’oggetto mutabile viene modificato:\ns = ([1, 2, 3], [\"Qui\", \"Quo\", \"Qua\"])\n\n1print(s)\n\n2print(id(s[0]))\n3print(id(s[1]))\n\n4s[1][0] = \"Huey\"\ns[1][1] = \"Dewey\" \ns[1][2] = \"Louie\"\n\n5print(s)\n\n6print(id(s[0]))\n7print(id(s[1]))\n\n1\n\nOutput: ([1, 2, 3], ['Qui', 'Quo', 'Qua']).\n\n2\n\nModifico gli elementi della lista, traducendoli in inglese.\n\n3\n\nOutput dell’identità del primo oggetto contenuto (su ogni computer e sessione sarà diverso): 4361472384.\n\n4\n\nOutput dell’identità del secondo oggetto contenuto: 4361474176.\n\n5\n\nOutput: ([1, 2, 3], ['Huey', 'Dewey', 'Louie']). La tupla è cambiata!\n\n6\n\nOutput: 4361472384, l’identità del primo oggetto contenuto non è cambiata!\n\n7\n\nOutput: 4361474176, l’identità del secondo oggetto contenuto non è cambiata!\n\n\nCiò è un po’ più generale, perché per gli oggetti di tipo immutabile, quando sono assegnati ad una variaible o risultato di un’espressione, a parità di valore, potrebbero avere la stessa identità, cioè essere lo stesso oggetto. Il condizionale è dovuto alla presenza e applicazione logiche di ottimizzazione, ad esempio della memoria, implementate nell’interprete.\nAd esempio, dopo:\ns1 = \"Qui, Quo, Qua\"\n\n1print(id(s1))\n\ns2 = \"Qui, Quo, Qua\"\n\n2print(id(s2))\n\n1\n\nOutput dell’identità di s1: 4432491760.\n\n2\n\nOutput dell’identità di s2: 4432491760, cioè è la medesima identità dell’oggetto il cui nome è s1.\n\n\nPer gli oggetti mutabili, questo non accade anche in casi su cui potrebbe essere ottimizzante:\nl1 = []\n\n1print(id(l1))\n\nl2 = []\n\n2print(id(l2))\n\n1\n\nOutput dell’identità di l1: 4454287744.\n\n2\n\nOutput dell’identità di l2: 4454289536, cioè le identità sono diverse.\n\n\nAttenzione però ad alcune scorciatoie di Python:\nc = d = []\nè equivalente a:\nc = []\nd = c\ncioè l’oggetto lista ha due nomi nel programma.\n\n\n10.1.6 Tipi hashable\nI tipi di dati possono essere classificati come hashable o non hashable. Un tipo è considerato hashable se gli oggetti creati da quel tipo hanno un valore di hash4 che rimane costante per tutta la durata della loro vita e possono essere confrontati con altri oggetti. Questo è garantito per i tipi immutabili, come numeri, stringhe e tuple.\n4 In informatica, le tabelle hash (hash table) sono una struttura dati essenziale per l’efficienza e la velocità di accesso ai dati. Le tabelle hash sono costituite da coppie indice-valore e sono progettate per sostituire la ricerca sequenziale in array, che può essere lenta soprattutto per grandi quantità di dati.Una funzione di hash prende un valore (come una stringa o un numero) e restituisce un numero di lunghezza fissa, chiamato hash. Questo hash viene utilizzato come indice per memorizzare il valore nella tabella di hash. Quando si desidera cercare un elemento, la funzione di hash calcola l’indice corrispondente, consentendo un accesso diretto all’elemento. Questo processo rende la ricerca, l’inserimento e la cancellazione degli elementi molto efficienti, con un tempo di accesso medio costante (O(1)).\nGli oggetti di tipo hashable possiedono le seguenti caratteristiche principali:\n\nValore di hash costante: Gli oggetti devono avere un valore di hash che non cambia durante la loro vita. Questo è tipico degli oggetti immutabili.\nComparabilità: Gli oggetti devono poter essere confrontati con altri oggetti per determinare se sono uguali. Due oggetti che sono considerati uguali devono avere lo stesso valore di hash.\n\nLa proprietà di essere hashable è strettamente legata all’immutabilità. Gli oggetti immutabili sono naturalmente hashable perché il loro stato non cambia dopo la creazione, garantendo che il valore di hash rimanga costante. Ad esempio, tipi di dati immutabili come numeri, stringhe e tuple possono essere considerati hashable. Il viceversa non è vero, cioè esistono alcuni tipi mutabili che sono hashable.\n\n\n10.1.7 Eliminazione\nGli oggetti non vengono mai eliminati esplicitamente dall’utente, ma, quando diventano inaccessibili, possono essere raccolti dal garbage collector, che è eseguito contemporaneamente al codice del programma, come parte dell’interprete. L’implementazione specifica quando e come la memoria debba essere liberata.\nAlcuni oggetti contengono riferimenti a risorse esterne rispetto al programma, come file aperti, connessioni di rete, finestre (graphical user interface, GUI) o dispositivi hardware. Queste risorse generalmente non vengono liberate dal garbage collector, perché le azioni corrispondenti sono particolari della risorsa stessa. Pertanto, i loro oggetti forniscono anche un metodo esplicito di rilascio, solitamente chiamato close(). È molto importante tener conto di ciò per evitare effetti indesiderati.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-modello-dati.html#tipi-predefiniti",
    "href": "seconda-parte-python-modello-dati.html#tipi-predefiniti",
    "title": "10  Il modello dati",
    "section": "10.2 Tipi predefiniti",
    "text": "10.2 Tipi predefiniti\nPython mette a disposizione molti tipi generali, cioè utili alla gestione di dati comunemente presenti in algoritmi. Esistono, inoltre, sia meccanismi di estensione della distribuzione Python che modificano l’installazione sul proprio computer, sia la possibilità conferita al programmatore di creare i propri tipi o di importarli da librerie prodotte da terze parti.\nI tipi predefiniti sono immediatamente disponibili, cioè non necessitano di alcuna azione da parte del programmatore, come, ad esempio, l’importazione di moduli.\nPer ragioni di esposizione, distingueremo tra tipi predefiniti fondamentali, cioè che possono essere introdotti con un insieme limitato di concetti, tipi legati alla astrazione del paradigma di orientamento agli oggetti e, infine, costruzioni del linguaggio legate all’esecuzione asincrona.\n\n10.2.1 Tipi predefiniti fondamentali\nPrima di entrare nel dettaglio per ognuno, di seguito un elenco dei tipi predefiniti fondamentali:\n\nNumeri: Sia interi relativi che reali, cioè in virgola mobile, sia complessi.\nSequenze: Contenitori caratterizzati da un ordinamento degli oggetti al loro interno, sia mutabili che immutabili.\nInsiemi: Contenitori non caratterizzati da un ordinamento degli oggetti.\nDizionari: Contenitori di coppie di oggetti, rispettivamente, chiave e valore.\nAltri: None, NotImplemented, Ellipsis.\n\n\n\n10.2.2 Numeri\nI tipi predefiniti numerici corrispondono agli interi, i numeri a virgola mobile e quelli complessi. Sono immutabili, il che significa che effettuando una operazione su un oggetto numerico si produrrà sempre un nuovo oggetto e non una modifica del precedente.\nEsistono anche altri tipi numerici nelle librerie fornite coll’interprete, per i numeri decimali a precisione arbitraria e i numeri razionali come frazioni.\nI letterali numerici non hanno segno, cioè + e - sono operatori unari che precedono la rappresentazione di un numero, quindi -3 è una espressione che diventa il valore di un oggetto intero di valore -3. Nei letterali numerici si può inserire un trattino basso (underscore) tra le cifre o dopo gli specificatori della base per gli interi.\n\n10.2.2.1 Interi\nEsistono due tipi di interi. Il primo è int, per gli usuali numeri interi, a cui corrispondono diverse rappresentazioni sintattiche in basi diverse, come i letterali decimali, binari, ottali o esadecimali:\n\nUn letterale decimale inizia sempre con una cifra diversa da zero, esempi: 10, 1_0.\nQuello binario inizia con 0b o 0B seguito da una sequenza di cifre binarie (0 o 1), esempi: 0b1010, 0B1010, 0b_10_10, 0b1_0_10.\nL’ottale inizia con 0o o 0O seguito da una sequenza di cifre ottali (da 0 a 7), esempi: 0o12, 0O12.\nL’esadecimale inizia con 0x o 0X seguito da una sequenza di cifre esadecimali (da 0 a 9 e da A a F, in maiuscolo o minuscolo), esempi: 0xA, 0XA.\n\nGli interi in Python sono illimitati, al netto della finitezza della memoria del computer disponibile per la loro rappresentazione.\nlarge_int = 10**100\n\n1print(f\"Un intero molto grande: {large_int}\")\n\n1\n\nOutput: 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.\n\n\nL’altro tipo è bool, che ha solo due oggetti possibili, che si comportano come quelli corrispondenti agli interi 1 e 0 per rappresentare i valori logici, rispettivamente, di vero e falso. bool come classe deriva da int che, a sua volta, deriva da object:\n1print(issubclass(bool, int))\n2print(issubclass(int, object))\n\n1\n\nOutput: True.\n\n2\n\nOutput: True.\n\n\n\n\n10.2.2.2 Numeri in virgola mobile\nI numeri in virgola mobile in Python sono istanze della classe float e sono utilizzati per rappresentare numeri reali con una parte decimale. I letterali corrispondenti sono una sequenza di cifre in base 10, e solo in base 10, che include un punto (.), un suffisso di notazione scientifica (e o E, opzionalmente seguito da + o - e da una o più cifre), o entrambi. Il carattere iniziale di un letterale in virgola mobile non può essere e o E, ma può essere qualsiasi cifra (anche zeri a differenza degli interi) o un punto (.) seguito da una cifra.\nEsempi di literali in virgola mobile: 0., 0.1, .0, 1., 1.0, 1e0, 1.e0, 1.0E0, 1_0_0.0_1. Attenzione: 1 è un intero, 1. non lo è.\nPer conoscere l’intervallo esatto e la precisione dei valori in virgola mobile sulla piattaforma in uso, e molti altri dettagli, è possibile usare sys.float_info nel modo seguente:\nimport sys\n\n1float_info = sys.float_info\n\n2print(f\"Massimo valore rappresentabile (max): {float_info.max}\")\n3print(f\"Minimo valore rappresentabile positivo (min): {float_info.min}\")\n4print(f\"Massimo esponente base 2 (max_exp): {float_info.max_exp}\")\n5print(f\"Minimo esponente base 2 (min_exp): {float_info.min_exp}\")\n6print(f\"Massimo esponente base 10 (max_10_exp): {float_info.max_10_exp}\")\n7print(f\"Minimo esponente base 10 (min_10_exp): {float_info.min_10_exp}\")\n8print(f\"Precisione in bit (dig): {float_info.dig}\")\n9print(f\"Numero di bit di mantissa (mant_dig): {float_info.mant_dig}\")\n10print(f\"Epsilon macchina (epsilon): {float_info.epsilon}\")\n\n1\n\nOggetto con all’interno le informazioni relative alla gestione dei numeri in virgola mobile della macchina.\n\n2\n\nOutput: Massimo valore rappresentabile (max): 1.7976931348623157e+308. Il massimo valore rappresentabile per un numero in virgola mobile.\n\n3\n\nOutput: Minimo valore rappresentabile positivo (min): 2.2250738585072014e-308. Il minimo valore positivo rappresentabile per un numero in virgola mobile.\n\n4\n\nOutput: Massimo esponente base 2 (max_exp): 1024. Il massimo esponente base 2.\n\n5\n\nOutput: Minimo esponente base 2 (min_exp): -1021. Il minimo esponente base 2.\n\n6\n\nOutput: Massimo esponente base 10 (max_10_exp): 308. Il massimo esponente base 10.\n\n7\n\nOutput: Minimo esponente base 10 (min_10_exp): -307. Il minimo esponente base 10.\n\n8\n\nOutput: Precisione in bit (dig): 15. La precisione in bit, cioè il numero di cifre decimali che possono essere rappresentate senza perdita di precisione.\n\n9\n\nOutput: Numero di bit di mantissa (mant_dig): 53. Il numero di bit nella mantissa.\n\n10\n\nOutput: Epsilon macchina (epsilon): 2.220446049250313e-16. La differenza tra 1 e il numero più piccolo maggiore di 1 che può essere rappresentato.\n\n\n\n\n10.2.2.3 Numeri complessi\nUn numero complesso è composto da due valori in virgola mobile, uno per la parte reale e uno per la parte immaginaria. In Python, i numeri complessi sono istanze della classe complex, che presenta due attributi di sola lettura real e imag, rispettivamente per la parte reale e immaginaria, di tipo float.\nUn letterale immaginario può essere specificato come qualsiasi letterale decimale in virgola mobile o intero seguito da una j o J: 0j, 0.j, 0.0j, .0j, 1j, 1.j, 1.0j, 1e0j, 1.e0j, 1.0e0j. La j alla fine del letterale immaginario indica la radice quadrata di -1. Per denotare un qualsiasi numero complesso costante, si potrà sommare o sottrarre un letterale in virgola mobile (o letterale intero) e uno immaginario.\n1z = 42+3.14j\n\n2print(z)\n\n3print(z.real)\n4print(z.imag)\n\n5print(type(z.real))\n6print(type(z.imag))\n7print(type(z))\n\n1\n\nAssegnamento di un numero complesso alla variabile z.\n\n2\n\nOutput: (42+3.14j).\n\n3\n\nOutput: 42.0.\n\n4\n\nOutput: 3.14.\n\n5\n\nOutput: &lt;class 'float'&gt;.\n\n6\n\nOutput: &lt;class 'float'&gt;.\n\n7\n\nOutput: &lt;class 'complex'&gt;.\n\n\n\n\n\n10.2.3 Sequenze\nUna sequenza è un contenitore ordinato di oggetti, il cui indice è un intero che parte da 0. Se la sequenza è referenziata da una variabile c, per ottenere il numero totale di oggetti contenuti si userà la funzione predefinita len(), cioè len(c), e per l’oggetto i-esimo le parentesi quadre e l’indice, c[i]. È possibile usare indici negativi che sono interpretati come la somma di tale indice col numero totale di oggetti contenuti, quindi -i è trattato come len(c)-i e l’indice risultante dovrà sempre essere compreso tra 0 e len(c)-1.\nSi può sezionare (slicing) la sequenza per ottenere una nuova sottosequenza, dello stesso tipo, di oggetti originariamente contigui tra gli indici i e j, cioè con indici x tali che i≤x&lt;j, usando c[i:j]. Aggiungendo un terzo parametro di passo, k, si possono selezionare solo gli oggetti con indici i+l*k e l≥0, che siano compresi tra i due indici, cioè i≤i+l*k&lt;j, con c[i:j:k].\nLe sequenze sono categorizzate in base alla mutabilità:\n\nImmutabili: stringhe, tuple, bytes.\nMutabili: liste e array di bytes.\n\n\n10.2.3.1 Iterabilità\nLe sequenze sono iterabili, cioè possono essere ottenuti tutti gli oggetti contenuti nell’ordine corretto, per mezzo di un oggetto ad hoc detto iteratore. Un iteratore è un oggetto separato dalla sequenza stessa, che mantiene uno stato interno per tenere traccia dell’elemento successivo da restituire. Questo permette di iterare sulla sequenza senza modificarla direttamente. L’iteratore prende in input un oggetto iterabile e ne restituisce i valori uno alla volta secondo un certo protocollo. Per le sequenze, questo protocollo consiste nel partire dal primo elemento e procedere fino all’ultimo.\n\n\n10.2.3.2 Stringhe\nUna stringa in Python è un oggetto che si può creare a partire da un letterale composto di un numero non negativo di caratteri Unicode racchiusi o tra apici singoli ', oppure doppi \". Per inserire un a capo nella stringa dovrà essere usato \\n, mentre per spezzarla su due righe fisiche dovrà essere usato un singolo backslash alla fine della prima riga fisica per indicare la continuazione nella riga fisica successiva.\nEsempi:\ns1 = \"Hello \" \\\n1    \"World!\"\n\n2print(s1)\n\ns2 = \"Hello \\n\" \\\n3    \"World!\"\n\n4print(s2)\n\n1\n\nStringa su due righe fisiche ma senza a capo all’interno.\n\n2\n\nOutput: Hello World!.\n\n3\n\nStringa su due righe fisiche con un a capo all’interno.\n\n4\n\nOutput: Hello World!.\n\n\nAlternativamente, si possono usare letterali con coppie di tripli apici singoli ''' o doppi \"\"\", dove la differenza è che è possibile inserire un a capo nell’editor e sarà mantenuto nella stringa. Un singolo backslash non può essere presente.\ns1 = \"\"\"Hello \n1World!\"\"\"\n\n2print(s1)\n\ns2 = \"\"\"Hello \\n\n3        World!\"\"\"\n\n4print(s2)\n\n1\n\nStringa su due righe fisiche ma senza a capo all’interno.\n\n2\n\nOutput: Hello World!.\n\n3\n\nStringa su due righe fisiche con un a capo all’interno.\n\n4\n\nOutput: Hello\n\n\nWorld!.\nNei letterali stringa si possono inserire caratteri non stampabili o caratteri che non sono disponibili a tastiera, usando le cosiddette sequenze di escape, come da tabella seguente:\n\nSequenze di escape\n\n\n\n\n\n\n\n\nSequenza\nSignificato\nCodice ASCII/ISO\nEsempio di stringa Python\n\n\n\n\n\\&lt;newline&gt;\nIgnora fine linea\n-\n\"Questo è un testo\\ con una linea continuata\"\n\n\n\\\\\nBackslash\n0x5c\n\"C:\\\\percorso\\\\al\\\\file\"\n\n\n\\'\nApice singolo\n0x27\n\"L'apice singolo: \\' esempio\"\n\n\n\\\"\nApice doppio\n0x22\n\"L'apice doppio: \\\" esempio\"\n\n\n\\a\nCampanello\n0x07\n\"Suono del campanello\\a\"\n\n\n\\b\nBackspace\n0x08\n\"Carattere di backspace\\b\"\n\n\n\\f\nForm feed\n0x0c\n\"Form feed\\f esempio\"\n\n\n\\n\nNuova linea\n0x0a\n\"Nuova linea\\n esempio\"\n\n\n\\r\nRitorno carrello\n0x0d\n\"Ritorno carrello\\r esempio\"\n\n\n\\t\nTabulazione\n0x09\n\"Tabulazione\\tesempio\"\n\n\n\\v\nTabulazione verticale\n0x0b\n\"Tabulazione verticale\\v esempio\"\n\n\n\\DDD\nValore ottale DDD del codice Unicode del carattere (solo per caratteri ASCII)\nDDD (in ottale)\n\"Valore ottale: \\101 esempio\" (\\101 rappresenta 'A' che in ASCII è 65)\n\n\n\\xXX\nValore esadecimale XX del codice Unicode del carattere\nXX (in esadecimale)\n\"Valore esadecimale: \\x41 esempio\" (\\x41 rappresenta ‘A’)\n\n\n\\uXXXX\nCarattere Unicode con valore esadecimale a 4 cifre\nXXXX (in esadecimale)\n\"Carattere cinese: \\u4e2d\" (\\u4e2d rappresenta ‘中’)\n\n\n\\UXXXXXXXX\nCarattere Unicode con valore esadecimale a 8 cifre\nXXXXXXXX (in esadecinale)\n\"Carattere: \\U0001f600\" (\\U0001f600 rappresenta ‘😀’)\n\n\n\\N{name}\nCarattere Unicode\n-\n\"Carattere Unicode: \\N{LATIN CAPITAL LETTER A} esempio\"\n\n\n\nEsistono anche i letterali di stringhe grezze (raw), sintatticamente identiche alle altre a meno di un suffisso r o R, comportante che le sequenze di escape non siano interpretate. Si usano comunemente per esprimere pattern di espressioni regolari o percorsi di file in Windows.\n1stringa = \"C:\\\\Users\\\\username\\\\Documents\\\\file.txt\"\n\n2print(stringa)\n\n3stringa_raw = r\"C:\\Users\\username\\Documents\\file.txt\"\n\n4print(stringa_raw)\n\n1\n\nPerché un path sia corretto in Windows è necessario usare il backslash per escape del backslash come separatore di path.\n\n2\n\nOutput: C:\\Users\\username\\Documents\\file.txt.\n\n3\n\nDefinendo la stringa come grezza allora il backslash è intepretato come tale, quindi separatore di path.\n\n4\n\nOutput: C:\\Users\\username\\Documents\\file.txt.\n\n\nDopo aver identificato il letterale stringa, l’inteprete crea l’oggetto stringa in memoria con tipo str. Alternativamente, si può crearla in altri modi:\n\nSebbene non sia comune usare il costruttore per creare una stringa da un letterale stringa, è comunque possibile:\n1s = str(\"Hello, World!\")\n\n2print(s)\n\n1\n\nPasso \"Hello, World!\" al costruttore di str.\n\n2\n\nOutput: Hello, World!.\n\n\nPossiamo creare una stringa a partire da un numero (intero o in virgola mobile):\ns = str(42)\n\n1print(s)\n\ns = str(3.14)\n\n2print(s)\n\n1\n\nOutput: 3.14.\n\n2\n\nOutput: 42.\n\n\nSi può creare una stringa concatenando i caratteri di una lista:\ncl = ['H', 'e', 'l', 'l', 'o']\n\ns = ''.join(cl)\n\n1print(s)\n\n1\n\nOutput: Hello.\n\n\nSe un oggetto definisce il metodo speciale __str__() che restituisce una stringa, il costruttore di str lo chiama per ottenerla:\nl = [\"Hello\", \" \", \"World!\"]\n\ns = str(l)\n\n1print(s)\n\n1\n\nOutput: ['Hello', ' ', 'World!'].\n\n\nSi può creare una nuova stringa da qualsiasi oggetto iterabile, come liste o tuple, utilizzando il metodo join che inserisce tra gli elementi della sequenza la stringa dell’oggetto di cui è membro:\nlista = ['Python', 'è', 'fantastico']\n\ns = ' '.join(lista)\n\n1print(s)\n\ntupla = ('Hello', 'World!')\n\ns = ' '.join(tupla)\n\n2print(s)\n\n1\n\nOutput: Python è fantastico. Lo spazio tra le parole è stato inserito perché join è stato chiamato su un oggetto la cui stringa era data dal solo carattere di spazio.\n\n2\n\nOutput: Hello World!.\n\n\n\n\n\n10.2.3.3 Oggetti bytes\nUn oggetto bytes è un array immutabile i cui elementi sono byte a 8 bit, rappresentati da interi nel range da 0 a 255. Gli oggetti bytes sono utili per gestire dati binari, come quelli letti o scritti su file o trasmessi su reti.\nEsistono diversi modi per creare oggetti bytes:\n\nÈ possibile creare oggetti bytes utilizzando letterali bytes, che sono simili ai letterali stringa, ma sono preceduti dal prefisso b. Ad esempio:\n1b'abc'\n\n1\n\nCrea un oggetto bytes con i byte corrispondenti ai caratteri ASCII 'a', 'b', 'c'.\n\n\nÈ possibile creare oggetti bytes utilizzando il costruttore bytes(), che può accettare diversi tipi di argomenti:\n\nSenza argomenti, crea un oggetto bytes vuoto:\n1bytes()\n\n1\n\nOutput: b''.\n\n\nDa un oggetto iterabile contenente interi (ognuno dei quali deve essere nel range da 0 a 255):\n1bytes([97, 98, 99])\n\n1\n\nOutput: b'abc'.\n\n\nDa una stringa e una codifica:\nbytes('abc', 'utf-8')  # Output: b'abc'\n\nOutput: b'abc'.\n\n\nÈ possibile creare una stringa a partire da un oggetto bytes specificando la codifica:\n1b = b'Hello, World!'\n\n2s = str(b, 'ASCII')\n\n3print(s)\n\n1\n\nOggetto di tipo bytes.\n\n2\n\nCreazione di una stringa da oggetto bytes che è codificato in ASCII.\n\n3\n\nOutput: Hello World!.\n\n\n\nAlcuni esempi di utilizzo degli oggetti bytes:\n\nCreazione e accesso:\nb = b'hello'\n\n1print(b[0])\n\n2print(b[1:3])\n\n1\n\nOutput: 104 (ASCII per ‘h’).\n\n2\n\nOutput: b'el'.\n\n\nConcatenazione e ripetizione:\nb1 = b'hello'\nb2 = b'world'\n\nb3 = b1 + b2\n\n1print(b3)\n\nb4 = b1 * 3\n\n2print(b4)\n\n1\n\nOutput: b'helloworld'.\n\n2\n\nOutput: b'hellohellohello'.\n\n\nConversione da e verso stringhe:\ns = \"hello\"\n1b = s.encode('utf-8')\n2print(b)\n\n3s2 = b.decode('utf-8')\n4print(s2)\n\n1\n\nConverte la stringa in bytes usando la codifica UTF-8.\n\n2\n\nOutput: b'hello'.\n\n3\n\nDecodifica i bytes in una stringa.\n\n4\n\nOutput: 'hello'.\n\n\n\n\n\n10.2.3.4 Tuple\nLe tuple in Python sono sequenze ordinate immutabili, in cui gli oggetti contenuti possono essere di tipi diversi. La classe è tuple che deriva da object.\nPer creare una tupla, si può utilizzare una serie di espressioni separate da virgole (,), come elementi della tupla. Si può opzionalmente mettere una virgola ridondante dopo l’ultimo elemento, che è necessaria se si ha un solo elemento. Si possono raggruppare gli elementi della tupla tra parentesi, ma le parentesi sono necessarie solo quando le virgole avrebbero altrimenti un altro significato (ad esempio, nelle chiamate di funzione), o per denotare tuple vuote o annidate.\nEsempi di tuple costruite con letterali e espressioni:\n1t1 = 42., \"Hello\", 0x42\n2t2 = (42,)\n3t3 = 21 + 21,\n4t4 = ()\n\n1\n\nTupla con tre oggetti contenuti da letterale numerico, letterale stringa e ancora letterale numerico.\n\n2\n\nTupla con un solo oggetto da letterale numerico.\n\n3\n\nTupla con un solo oggetto da espressione.\n\n4\n\nTupla vuota.\n\n\nPossiamo creare le tuple anche usando il costruttore di tuple, che accetta come argomento un iterabile:\n1t1 = tuple()\n\n2t2 = tuple(\"Hello\")\n\n3t3 = tuple([1, 2, 3])\n\n1\n\nCrea una tupla vuota.\n\n2\n\nCrea una tupla con 5 stringhe, una per ogni carattere.\n\n3\n\nCrea una tupla con una lista di 3 interi.\n\n\nEsempi di operazioni sulle tuple:\n\nAccesso e numero di elementi:\nt1 = 42., \"Hello\", 0x42\n\n1print(t1[1])\n\n2print(t1[1:3])\n\n3print(42. in t1)\n\n4print(len(t1))\n\n5print(t1[2:6])\n\n6print(t1[4:6])\n\n1\n\nOutput: \"Hello\".\n\n2\n\nOutput: 3.\n\n3\n\nOutput: ('Hello', 66). Slicing di tupla che produce una nuova tupla con 2 oggetti.\n\n4\n\nTest di appartenenza di 42. nella tupla (42.0, 'Hello', 66, 42). Output: True.\n\n5\n\nSlicing con indice destro oltre la lunghezza della lista. Output: (66,).\n\n6\n\nSlicing con entrambi gli indici oltre la lunghezza della lista. Output: ().\n\n\nConcatenazione:\nt1 = 42., \"Hello\", 0x42\nt2 = (42,)\n\nt3 = t1 + t2\n\n1print(t3)\n\n1\n\nConcatenazione di tuple che produce una nuova tupla con 4 oggetti contenuti. Output: (42.0, 'Hello', 66, 42).\n\n\n\n\n\n\n10.2.4 Liste\nLe liste in Python sono sequenze ordinate mutabili, in cui gli oggetti contenuti possono essere di tipi diversi. La classe è list che deriva da object.\nPer creare una lista, si utilizza una serie di espressioni, separate da virgole (,), all’interno di parentesi quadre, per indicare gli elementi della lista. Si può opzionalmente mettere una virgola ridondante dopo l’ultimo elemento. Per denotare una lista vuota, si utilizza una coppia di parentesi quadre vuote.\nEsempi di liste costruite con letterali e espressioni:\n1l1 = [42., \"Hello\", 0x42]\n\n2l2 = [21 + 21]\n\n3l3 = []\n\n1\n\nLista con tre oggetti: un letterale numerico, un letterale stringa e un altro letterale numerico.\n\n2\n\nLista con un solo oggetto creato da un’espressione.\n\n3\n\nLista vuota.\n\n\nPossiamo creare le liste usando il costruttore della classe list, passando come argomento un iterabile o nulla:\n1l1 = list()\n\n2l2 = list(\"Hello\")\n\n1\n\nCrea una lista vuota.\n\n2\n\nCrea una lista con 5 stringhe, una per ogni carattere della stringa “Hello”.\n\n\nLe operazioni comuni sulle liste:\n\nAccesso e modifica:\nl1 = [42., \"Hello\", 0x42]\n\n1print(l1[1])\n\n2print(len(l1))\n\nl1[1] = \"Ciao\"\n\n3print(l1)\n\n1\n\nOutput: \"Hello\". Accesso all’elemento in posizione 1 della lista.\n\n2\n\nOutput: 3. Numero totale di elementi nella lista l1.\n\n3\n\nModifica della lista con l’assegnazione di un nuovo valore a un indice. Output: [42.0, 'Ciao', 66].\n\n\nConcatenazione:\nl1 = [42., \"Hello\", 0x42]\nl2 = [42]\nl3 = l1 + l2 \n\n1print(l3)\n\nl2 += l1 \n2print(l2)\n\n1\n\nConcatenazione di liste che produce una nuova lista. Output: [42.0, 'Hello', 66, 42].\n\n2\n\nConcatenazione sul posto modificando l2. Output: [42, 42.0, 'Hello', 66].\n\n\nEstensione e aggiunta di elementi:\nl1 = [42., \"Hello\", 0x42]\nl4 = []\n\nl4.extend(l1) \n\n1print(l4)\n\nl5 = []\n\nl5.append(l1) \n\n2print(l5)\n\n1\n\nEstende l4 aggiungendo gli elementi di l1. Output: [42.0, 'Hello', 66].\n\n2\n\nAggiunge l1 come un singolo elemento alla fine di l5. Output: [[42.0, 'Hello', 66]].\n\n\nSlicing, rimozione e riassegnazione di elementi:\nl1 = [42., \"Hello\", 0x2A, \"Hello\", 0o52, \"Hello\", 42]\nl2 = [42]\n\n1print(l1[1:3])\n\nl1.remove(\"Hello\")\n2print(l1)\n\nl1.pop(0)\n3print(l1)\n\ndel l1[0:2]\n4print(l1)\n\nl1[1:3] = [\"Ciao\", 24]\n5print(l1)\n\nl1[1:3] = []\n6print(l1)\n\n1\n\nSlicing di lista che produce una nuova lista. Output: ['Hello', 66].\n\n2\n\nRimozione della prima occorrenza di elemento dalla lista usando remove() che, scorrendo la sequenza, applica un test di uguaglianza per stabilire che l’oggetto nella lista sia uguale a quello passato come argomento e, quindi, lo elimina. remove() non restituisce l’elemento eliminato. Output: [42.0, 42, 'Hello', 42, 'Hello', 42].\n\n3\n\nRimozione di un elemento della lista usando pop() per eliminare l’elemento in posizione indicata dall’indice passato come argomento, qui 0. pop() restituisce l’elemento eliminato. Output: [42, 'Hello', 42, 'Hello', 42].\n\n4\n\nRimozione di elementi con slicing usando la parola chiave del. Output: [42, 'Hello', 42].\n\n5\n\nRiassegnazione usando lo slicing. Output: [42, 'Ciao', 24].\n\n6\n\nEliminazione per mezzo di assegnazione e slicing. Output: [42].\n\n\n\n\n\n10.2.5 Insiemi\nPython ha due tipi predefiniti di insiemi per rappresentare collezioni di elementi unici con ordine arbitrario: set e frozenset.\nGli elementi in un set possono essere di tipi diversi, ma devono essere tutti hashable. Le istanze del tipo set sono mutabili e quindi non hashable, mentre le istanze del tipo frozenset sono immutabili e hashable.\nNon è possibile avere un set i cui elementi siano altri set, ma è possibile avere un set, o un frozenset, i cui elementi siano frozenset.\nEntrambi i tipi set e frozenset derivano direttamente dalla classe base object.\n\n10.2.5.1 set\nPer denotare un set, si utilizza una serie di espressioni separate da virgole all’interno di parentesi graffe. Si può opzionalmente mettere una virgola ridondante dopo l’ultimo elemento.\nEsempi di letterali di set:\n1s = {42, 3.14, 'hello'}\n\n2s = {100}\n\ns = set()\n\n1\n\nset definito per mezzo di letterali e delimitatori.\n\n2\n\nNon esiste un letterale per un set vuoto, pertanto si deve usare il costruttore set().\n\n\nSi può creare una istanza di set chiamando il costruttore senza argomenti, per un set vuoto, o con un oggetto iterabile (per un set i cui elementi sono quelli dell’iterabile).\nI set sono mutabili, il che significa che una volta creati, possono essere modificati. Supportano operazioni come aggiunta, rimozione e controllo dell’esistenza di elementi.\n\nAggiunta di elementi:\ns = {1, 2, 3}\n\ns.add(4)\n\n1print(s)\n\n1\n\nadd() aggiunge un elemento. Output: {1, 2, 3, 4}.\n\n\nRimozione di elementi:\n1s = {1, 2, 3, 4, 3}\n\ns.remove(3)\n\n2print(s)\n\n1\n\nQuando crei un set con elementi duplicati, come {1, 2, 3, 4, 3}, Python rimuove automaticamente i duplicati. Quindi, il set s diventerà {1, 2, 3, 4}.\n\n2\n\nremove() elimina l’elemento specificato dal set. Output: {1, 2, 4}.\n\n\nControllo dell’esistenza di un elemento:\ns = {1, 2, 3}\n\n1print(2 in s)\n\n2print(5 in s)\n\n1\n\nOutput: True.\n\n2\n\nOutput: False.\n\n\nOperazioni insiemistiche:\ns1 = set([1, 2, 3])\ns2 = set([3, 4, 5])\n\n1print(s1 | s2)\n\n2print(s1 & s2)\n\n3print(s1 - s2)\n\n1\n\nOperazione di unione insiemistica. Output: set({1, 2, 3, 4, 5}).\n\n2\n\nOperazione di intersezione insiemistica. Output: set({3}).\n\n3\n\nOperazione di differenza insiemistica. Output: set({1, 2}).\n\n\n\n\n\n10.2.5.2 frozenset\nAllo stesso modo, si può creare un frozenset per mezzo del costruttore, senza argomenti o con un iterabile.\n# \nfs = frozenset([1, 2, 3, 4])\n\n1print(fs)\n\nfs_empty = frozenset()\n\n2print(fs_empty)\n\n1\n\nCreazione di un frozenset da una lista. Output: frozenset({1, 2, 3, 4}).\n\n2\n\nCreazione di un frozenset vuoto. Output: frozenset().\n\n\nI frozenset sono immutabili, il che significa che una volta creati, non possono essere modificati. Supportano operazioni di lettura come controllo dell’esistenza di elementi e operazioni insiemistiche (unione, intersezione, differenza), ma non supportano operazioni di modifica. Il comportamento è identico alle operazioni di set.\n\n\n\n10.2.6 Mappature\nLe mappature rappresentano insiemi finiti di oggetti indicizzati da insiemi di indici arbitrari. La notazione con le parentesi quadre, a[k], seleziona l’elemento indicizzato da k nella mappatura a e può essere utilizzata all’interno di espressioni oppure a sinistra di assegnazioni o istruzioni del. La funzione len() restituisce il numero di elementi in una mappatura.\nAttualmente, esiste un solo tipo di mappatura predefinita in Python: il dizionario. È mutabile e la classe corrispondente è dict che deriva da object.\nI dizionari rappresentano insiemi finiti di oggetti indicizzati da valori quasi arbitrari, detti chiavi. Le chiavi nei dizionari devono essere di tipi arbitrati ma hashable e, come oggetti, uniche. La ragione è che l’implementazione efficiente dei dizionari richiede che il valore hash di una chiave rimanga costante.\nI dizionari preservano l’ordine di inserimento, il che significa che le chiavi verranno prodotte nello stesso ordine in cui sono state aggiunte sequenzialmente al dizionario. Sostituire una chiave esistente non cambia l’ordine; tuttavia, rimuovere una chiave e reinserirla la aggiungerà alla fine invece di mantenerne la posizione precedente.\nI dizionari si possono creare per mezzo di una serie di coppie di espressioni, separate da virgole, all’interno di parentesi graffe. Le chiavi e i valori sono separati da due punti. È possibile inserire una virgola dopo l’ultimo elemento.\nEsempi:\n1d1 = {\"a\": 42, \"b\": 2, 42: 3, \"b\": 24}\n\n2print(d1)\n\nx = 2.\n\nd2 = {2**2: \"uno\", 2 * x: \"due\", \"hello\".upper(): x, }  \n\n3print(d2)\n\n4d3 = {}\n\n1\n\nDizionario con tre coppie chiave-valore.\n\n2\n\nLe chiavi devono essere uniche quindi l’interprete mantiene solo una chiave con un valore arbitrario. Output: {'a': 42, 'b': 24, 42: 3}.\n\n3\n\nDizionario con due coppie chiave-valore e virgola opzionale in fondo. Output: {4: 'due', 'HELLO': 2.0}.\n\n4\n\nDizionario vuoto.\n\n\nPossiamo creare i dizionari anche usando la classe dict oltre che i letterali:\n1d1 = dict()\n\n2d2 = dict(a=1, b=2, c=3)\n\nd3 = dict([(\"a\", 1), (\"b\", 2), (\"c\", 3)])  \n\n3print(d3)\n\n1\n\nCrea un dizionario vuoto.\n\n2\n\nCrea un dizionario con tre coppie chiave-valore specificate come argomenti.\n\n3\n\nCrea un dizionario a partire da un iterabile di tuple. Output: {'a': 1, 'b': 2, 'c': 3}.\n\n\nOperazioni sui dizionari:\n\nAccesso agli elementi:\nd = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n1print(d[\"a\"])\n\n2print(d.get(\"b\"))\n\n3print(d.keys())\n\n4print(d.values())\n\n5print(d.items())\n\n1\n\nAccesso al valore associato alla chiave \"a\". Output: 1.\n\n2\n\nUtilizzo del metodo get() per accedere al valore associato alla chiave \"b\". Output: 2.\n\n3\n\nAccesso a tutte le chiavi del dizionario. Output: dict_keys(['a', 'b', 'c']).\n\n4\n\nAccesso a tutti i valori del dizionario. Output: dict_values([1, 2, 3]).\n\n5\n\nAccesso a tutte le coppie chiave-valore del dizionario. Output: dict_items([('a', 1), ('b', 2), ('c', 3)]).\n\n\nModifica degli elementi:\nd = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n1d[\"b\"] = 20\n\n2d[\"d\"] = 4\n\n3print(d)\n\n1\n\nModifica del valore associato alla chiave \"b\". Output: {\"a\": 1, \"b\": 20, \"c\": 3}.\n\n2\n\nAggiunta di una nuova coppia chiave-valore. Output: {\"a\": 1, \"b\": 20, \"c\": 3, \"d\": 4}.\n\n3\n\nOutput del dizionario dopo le modifiche: {\"a\": 1, \"b\": 20, \"c\": 3, \"d\": 4}.\n\n\nRimozione degli elementi:\nd = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n1del d[\"b\"]\n\n2print(d)\n\n3valore = d.pop(\"c\")\n\n4print(d)\n\n5print(valore)\n\n6d.clear()\n\n7print(d)\n\n1\n\nRimozione della coppia chiave-valore con chiave \"b\" usando del.\n\n2\n\nOutput dopo la rimozione con del. Output: {\"a\": 1, \"c\": 3}.\n\n3\n\nRimozione della coppia chiave-valore con chiave \"c\" usando pop(), che restituisce il valore associato.\n\n4\n\nOutput dopo la rimozione con pop(). Output: {\"a\": 1}.\n\n5\n\nValore rimosso con pop(). Output: 3.\n\n6\n\nRimozione di tutte le coppie chiave-valore usando clear().\n\n7\n\nOutput dopo l’uso di clear(). Output: {}.\n\n\nOperazioni di controllo:\nd = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n1print(\"a\" in d)\n\n2print(\"z\" in d)\n\n1\n\nVerifica se la chiave \"a\" è presente nel dizionario. Output: True.\n\n2\n\nVerifica se la chiave \"z\" è presente nel dizionario. Output: False.\n\n\n\nLo spacchettamento (unpacking) è una funzionalità che permette di combinare i contenuti di più dizionari in un unico dizionario. Si utilizza l’operatore ** per esplodere i contenuti del singolo dizionario. Alternativamente, si può effettuare l’unione di dizionari per mezzo dell’operatore |.\nEsempi:\nd1 = {'a': 1, 'b': 2}\nd2 = {'c': 3, 'd': 4}\n\n1d3 = {**d1, **d2}\n\n2print(d3)\n\n3d4 = d1 | d2\n\n4print(d4)\n\n5d5 = dict.fromkeys('a', 1)\n\n6print(d5)\n\n7d6 = dict.fromkeys(['a', 'b', 'c'])\n\n8print(d6)\n\n1\n\nSpacchettamento dei dizionari d1 e d2 in un nuovo dizionario d3.\n\n2\n\nStampa del dizionario d3. Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4}.\n\n3\n\nCreazione di un nuovo dizionario d4 unendo d1 e d2 per mezzo dell’operatore |.\n\n4\n\nStampa del dizionario d4. Output: {'a': 1, 'x': 5, 'c': 2}.\n\n5\n\nCreazione di un dizionario d5 usando dict.fromkeys con le chiavi dalla stringa 'a' e valore 1.\n\n6\n\nStampa del dizionario d5. Output: {'a': 1}.\n\n7\n\nCreazione di un dizionario d6 usando dict.fromkeys con le chiavi dalla lista [1, 2, 3] e valori None.\n\n8\n\nStampa del dizionario d6. Output: {'a': None, 'b': None, 'c': None}.\n\n\n\n\n10.2.7 None\nNone è un oggetto predefinito in Python che rappresenta un valore nullo. Non ha metodi né altri attributi. None può essere utilizzato per fare riferimento ad un oggetto qualsiasi, oppure quando si vuole indicare l’assenza di un oggetto.\nLe funzioni restituiscono None come risultato a meno che return non sia seguito da elenco di oggetti. None è hashable e può essere utilizzato come chiave di un dizionario. None è un oggetto della classe NoneType, che deriva da object ed è unico, cioè non esiste una seconda istanza di NoneType.\nEsempi di utilizzo di None:\n1x = None\n\ndef funzione():\n    pass\n\n2print(funzione())\n\n3d = {None: \"valore\"}\n\n4print(d)\n\n1\n\nAssegnazione di None a una variabile.\n\n2\n\nLe funzioni che non hanno un’istruzione di ritorno specifica restituiscono None. Output: None.\n\n3\n\nNone può essere utilizzato come chiave in un dizionario.\n\n4\n\nOutput: {None: 'valore'}.\n\n\n\n\n10.2.8 Ellissi\nL’ellissi, scritta come tre punti consecutivi senza spazi intermedi (...), è un oggetto speciale in Python utilizzato in applicazioni numeriche o come alternativa a None quando None è un valore valido.\nAd esempio, per inizializzare un dizionario che può accettare None come valore legittimo, si può inizializzare con ... come indicatore di “nessun valore fornito, neanche None”. Ellipsis è hashable e può essere utilizzato come chiave di un dizionario. Ellipsis è un oggetto della classe ellipsis, che deriva da object ed è unica come None.\nEsempi di utilizzo di Ellipsis:\n1e = ...\n\n2print(e)\n\n3d = {None: \"valore1\", ...: \"valore2\"}\n\n4print(d)\n\ndef funzione():\n    ...\n\n5print(funzione())\n\n1\n\nAssegnazione di Ellipsis a una variabile.\n\n2\n\nOutput: Ellipsis.\n\n3\n\nEllipsis può essere utilizzato come chiave in un dizionario.\n\n4\n\nOutput: {None: 'valore1', Ellipsis: 'valore2'}.\n\n5\n\nLe funzioni possono contenere Ellipsis come segnaposto per future implementazioni. Output: None.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Il modello dati</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html",
    "href": "seconda-parte-python-istruzioni.html",
    "title": "11  Istruzioni",
    "section": "",
    "text": "11.1 Istruzione di gestione identificatori",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html#istruzione-di-gestione-identificatori",
    "href": "seconda-parte-python-istruzioni.html#istruzione-di-gestione-identificatori",
    "title": "11  Istruzioni",
    "section": "",
    "text": "11.1.1 Assegnamenti\nGli assegnamenti in Python sono istruzioni semplici che collegano valori a variabili utilizzando l’operatore =. L’assegnamento in Python è una definizione e non può mai far parte di un’espressione. Per eseguire un’assegnamento come parte di un’espressione, è necessario utilizzare l’operatore := (noto come operatore “walrus”).\nEsempio di assegnamento semplice:\n1x = 10\n2y = 20\n3print(x + y)\n\n1\n\nAssegna il valore 10 alla variabile x.\n\n2\n\nAssegna il valore 20 alla variabile y.\n\n3\n\nOutput della somma di x e y: 30.\n\n\nEsempio di assegnamento con l’operatore walrus:\n1if (n := 10) &gt; 5:\n2    print(n)\n\n1\n\nAssegna il valore 10 a n e verifica se n è maggiore di 5.\n\n2\n\nOutput di n: 10.\n\n\n\n\n11.1.2 Importazione di moduli\nL’istruzione semplice import viene utilizzata per importare moduli in un programma Python, permettendo l’accesso alle funzioni, classi e variabili definite al loro interno.\nTutti gli identificatori definiti nel modulo nome_modulo si importano colla sintassi import nome_modulo e dal quel punto fino alla fine del modulo importatore, sono accessibili colla notazione data dal nome del modulo seguito dal punto e l’identificatore di interesse, cioè nome_modulo.nome_variabile dove nome_variabile è l’identificatore importato.\nUna sintassi alternativa è from nome_modulo import *, per cui gli identificatori sono utilizzabili senza preporre nome_modulo..\nInfine, si possono importare identificatori particolari usando from nome_modulo import seguito dall’elenco degli identificatori necessari, separati da virgole.\nEsempi:\n\nImportazione di tutti gli identificatori di un modulo:\n1import math\n\n2print(math.sqrt(4))\n\n1\n\nSi importa il modulo math.\n\n2\n\nOutput: 2.0.\n\n\nImportazione di identificatori particolari:\nfrom math import sqrt, pi\n\n1print(sqrt(4))\n\n2print(pi)\n\n1\n\nOutput: 2.0.\n\n2\n\nOutput: 3.141592653589793.\n\n\nImportazione di un modulo con un alias:\n1import numpy as np\n\narray = np.array([1, 2, 3])\n\n2print(array)\n\n1\n\nnumpy è una librarie non facente parte dello standard Python, importata solitamente con un identificatore abbreviato in np.\n\n2\n\nOutput: [1 2 3].\n\n\nImportazione di tutti gli identificatori di un modulo con accesso semplificato:\nfrom math import *\n\n1print(sqrt(4))\n\n2print(pi)\n\n1\n\nOutput: 2.0.\n\n2\n\nOutput: 3.141592653589793.\n\n\n\nÈ importante notare che l’istruzione import carica e inizializza il modulo solo una volta per sessione del programma. Se il modulo è già stato importato in precedenza, Python utilizza la versione già caricata, riducendo così il tempo di esecuzione e il consumo di memoria.\nQuando si importa un modulo, Python cerca il modulo nelle directory specificate nella variabile sys.path. Questa variabile include la directory corrente, le directory specificate nella variabile d’ambiente PYTHONPATH, e le directory di installazione predefinite.\nEsempio:\nimport sys\n\n1print(sys.path)\n\n1\n\nElenco delle directory del computer dove Python cerca i moduli.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html#istruzioni-di-controllo-di-flusso",
    "href": "seconda-parte-python-istruzioni.html#istruzioni-di-controllo-di-flusso",
    "title": "11  Istruzioni",
    "section": "11.2 Istruzioni di controllo di flusso",
    "text": "11.2 Istruzioni di controllo di flusso\nIl flusso di controllo di un programma regola l’ordine in cui le istruzioni vengno eseguite. Il flusso di controllo di un programma Python dipende principalmente da istruzioni condizionali, cicli e chiamate a funzioni.\nAnche il sollevamento e la gestione delle eccezioni influenzano il flusso di controllo (tramite le istruzioni try e with).\n\n11.2.1 Istruzione di esecuzione condizionale\nSpesso è necessario eseguire alcune istruzioni solo quando una certa condizione è vera o scegliere le istruzioni da eseguire a seconda di condizioni mutuamente esclusive. L’istruzione composta if, che comprende le clausole if, elif ed else, consente di eseguire condizionalmente blocchi di istruzioni.\nLa sintassi dell’istruzione if in pseudocodice è la seguente:\n1if espressione:\n2  istruzione(i)\n\n3elif espressione:\n4  istruzione(i)\n\n5elif espressione:\n6  istruzione(i)\n\n7else:\n8  istruzione(i)\n\n1\n\nClausola if con una condizione, cioè una espressione con valore interpretato come logico.\n\n2\n\nBlocco di codice eseguito se la condizione if è vera.\n\n3\n\nClausola elif con una condizione.\n\n4\n\nBlocco di codice eseguito se la condizione elif è vera.\n\n5\n\nClausola elif con una condizione.\n\n6\n\nBlocco di codice eseguito se la condizione elif è vera.\n\n7\n\nClausola else eseguita se tutte le condizioni precedenti sono false.\n\n8\n\nBlocco di codice eseguito dalla clausola else.\n\n\nLe clausole elif ed else sono opzionali. Ecco un tipico esempio di istruzione if con tutti e tre i tipi di clausole:\n1if x &lt; 0:\n2  print('x è negativo')\n\n3elif x % 2:\n4  print('x è positivo e dispari')\n\nelse:\n5  print('x è pari e non negativo')\n\n1\n\nControlla se x è negativo.\n\n2\n\nStampa \"x è negativo\" se la condizione è vera.\n\n3\n\nControlla se x è positivo e dispari.\n\n4\n\nStampa \"x è positivo e dispari\" se la condizione è vera.\n\n5\n\nStampa \"x è pari e non negativo\" se nessuna delle condizioni precedenti è vera.\n\n\nOgni clausola controlla una o più istruzioni raggruppate in un blocco di codice: si posizionano le istruzioni del blocco su righe logiche separate dopo la riga contenente la parola chiave della clausola (nota come riga intestazione della clausola), con un’indentazione tipicamente di quattro spazi oltre la riga intestazione. Il blocco termina quando l’indentazione torna al livello della riga intestazione della clausola o ulteriormente a sinistra (questo è lo stile imposto da PEP 8).\nÈ possibile utilizzare qualsiasi espressione Python come condizione in una clausola if o elif. Utilizzare un’espressione in questo modo è noto come usarla in un contesto booleano. In questo contesto, qualsiasi valore viene considerato vero o falso. Qualsiasi numero diverso da zero o contenitore non vuoto (stringa, tupla, lista, dizionario, set, ecc.) viene valutato come vero, mentre zero (0, di qualsiasi tipo numerico), None e contenitori vuoti vengono valutati come falsi.\nPer testare un valore x in un contesto booleano, utilizzare lo stile di codifica seguente:\nif x:\nQuesta è la forma più chiara e più “Pythonica”.\nNon utilizzare nessuna delle seguenti forme:\nif x is True:\n\nif x == True:\n\nif bool(x):\nC’è una differenza cruciale tra dire che un’espressione restituisce True (significa che l’espressione restituisce il valore 1 con il tipo bool) e dire che un’espressione viene valutata come vera (significa che l’espressione restituisce qualsiasi risultato che è vero in un contesto booleano). Quando si testa un’espressione, ad esempio in una clausola if, interessa solo come viene valutata, non cosa, precisamente, restituisce. Come menzionato in precedenza, “valutata come vera” è spesso espresso informalmente come “è veritiera”, e “valutata come falsa” come “è falsa”.\nQuando la condizione della clausola if viene valutata come vera, le istruzioni all’interno della clausola if vengono eseguite, quindi l’intera istruzione if termina. Altrimenti, Python valuta la condizione di ciascuna clausola elif, in ordine. Le istruzioni all’interno della prima clausola elif la cui condizione viene valutata come vera, se presente, vengono eseguite e l’intera istruzione if termina. Altrimenti, quando esiste una clausola else, essa viene eseguita. In ogni caso, le istruzioni successive all’intera costruzione if, allo stesso livello, vengono eseguite successivamente.\n\n\n11.2.2 Istruzione di pattern matching\nL’istruzione match introduce il pattern matching strutturale nel linguaggio Python. Questa funzionalità consente di testare facilmente la struttura e il contenuto degli oggetti Python.\nLa struttura sintattica generale dell’istruzione match è la seguente:\n1match espressione:\n2  case pattern1 [if guard1]:\n3    istruzione(i)\n\n  case pattern2 [if guard2]:\n4    istruzione(i)\n\n  ...\n\n5  case _:\n6    istruzione(i)\n\n1\n\nLa parola chiave match seguita da un’espressione il cui valore diventa il soggetto del matching.\n\n2\n\nClausole case indentate che controllano l’esecuzione del blocco di codice che contengono. Possono includere un’opzione if guard per ulteriori controlli.\n\n3\n\nBlocco di istruzioni da eseguire se pattern1 corrisponde.\n\n4\n\nBlocco di istruzioni da eseguire se pattern2 corrisponde.\n\n5\n\nPattern wildcard che corrisponde a qualsiasi valore.\n\n6\n\nBlocco di codice eseguito se nessun altro pattern corrisponde.\n\n\nDurante l’esecuzione, Python prima valuta l’espressione, quindi testa il valore risultante contro il pattern in ciascuna clausola case a turno, dall’inizio alla fine, fino a quando uno corrisponde. A quel punto, il blocco di codice indentato all’interno della clausola case corrispondente viene eseguito. Un pattern può fare due cose:\n\nVerificare che il soggetto sia un oggetto con una struttura particolare.\nAssociare componenti corrispondenti a nomi per un uso successivo (di solito all’interno della clausola case associata).\n\nQuando un pattern corrisponde al soggetto, il guard consente un controllo finale prima della selezione della clausola per l’esecuzione. Tutti i binding dei nomi del pattern sono già avvenuti, e si possono usare nel guard. Quando non c’è un guard, o quando il guard viene valutato come vero, il blocco di codice indentato della clausola case viene eseguito, dopo di che l’esecuzione dell’istruzione match è completa e non vengono controllate ulteriori clausole.\nL’istruzione match, di per sé, non prevede un’azione predefinita. Se ne serve una, l’ultima clausola case deve specificare un pattern wildcard, uno la cui sintassi garantisce che corrisponda a qualsiasi valore del soggetto. È un errore di sintassi seguire una clausola case con un pattern wildcard con ulteriori clausole case.\nGli elementi del pattern non possono essere creati in anticipo, associati a variabili e riutilizzati in più punti. La sintassi del pattern è valida solo immediatamente dopo la parola chiave case, quindi non c’è modo di eseguire tale assegnazione. Per ogni esecuzione di un’istruzione match, l’interprete è libero di memorizzare nella cache le espressioni del pattern che si ripetono all’interno delle clausole, ma la cache inizia vuota per ogni nuova esecuzione.\nEsempio di utilizzo dell’istruzione match:\n1def azione(comando, livello):\n2  match comando:\n3    case \"start\" if livello &gt; 1:\n4      print(\"Avvio con livello alto\")\n\n5    case \"start\":\n6      print(\"Avvio con livello basso\")\n\n7    case \"stop\" if livello &gt; 1:\n8      print(\"Arresto con livello alto\")\n\n9    case \"stop\":\n10      print(\"Arresto con livello basso\")\n\n11    case \"pause\":\n12      print(\"Pausa\")\n        \n13    case _:\n14      print(\"Comando sconosciuto\")\n\n15azione(\"start\", 2)\n16azione(\"start\", 1)\n17azione(\"pause\", 3)\n18azione(\"exit\", 0)\n\n1\n\nDefinizione della funzione azione con due parametri: comando e livello.\n\n2\n\nInizia il blocco match per il valore comando.\n\n3\n\nPattern \"start\" con guard che verifica se livello è maggiore di 1.\n\n4\n\nOutput se comando è \"start\" e livello è maggiore di 1.\n\n5\n\nPattern \"start\" senza guard.\n\n6\n\nOutput se comando è \"start\" e livello è minore o uguale a 1.\n\n7\n\nPattern \"stop\" con guard che verifica se livello è maggiore di 1.\n\n8\n\nOutput se comando è \"stop\" e livello è maggiore di 1.\n\n9\n\nPattern \"stop\" senza guard.\n\n10\n\nOutput se comando è \"stop\" e livello è minore o uguale a 1.\n\n11\n\nPattern \"pause\".\n\n12\n\nOutput se comando è \"pause\".\n\n13\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n14\n\nOutput se comando non corrisponde a nessun altro pattern.\n\n15\n\nChiamata a azione con \"start\" e livello 2. Output: Avvio con livello alto.\n\n16\n\nChiamata a azione con \"start\" e livello 1. Output: Avvio con livello basso.\n\n17\n\nChiamata a azione con \"pause\" e livello 3. Output: Pausa.\n\n18\n\nChiamata a azione con \"exit\" e livello 0. Output: Comando sconosciuto.\n\n\nIn questo esempio, la guardia if livello &gt; 1 aggiunge una condizione extra per i casi \"start\" e \"stop\", permettendo di distinguere tra diversi livelli di comando.\n\n11.2.2.1 Pattern letterali\nI pattern letterali corrispondono a valori letterali come interi, float, stringhe, ecc. La corrispondenza viene effettuata confrontando il valore del soggetto con il valore del pattern.\nEsempio:\n1def controlla_valore(valore):\n2  match valore:\n3    case 1:\n4      return \"Uno\"\n\n5    case \"ciao\":\n6      return \"Saluto\"\n\n7    case True:\n8      return \"Vero\"\n\n9    case None:\n10      return \"Nessuno\"\n\n11    case _:\n12      return \"Altro\"\n\n13print(controlla_valore(1))\n14print(controlla_valore(\"ciao\"))\n15print(controlla_valore(False))\n\n1\n\nDefinizione della funzione controlla_valore.\n\n2\n\nInizia il blocco match per il valore valore.\n\n3\n\nPattern letterale 1.\n\n4\n\nOutput se valore è 1.\n\n5\n\nPattern letterale \"ciao\".\n\n6\n\nOutput se valore è \"ciao\".\n\n7\n\nPattern letterale True.\n\n8\n\nOutput se valore è True.\n\n9\n\nPattern letterale None.\n\n10\n\nOutput se valore è None.\n\n11\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n12\n\nOutput se valore non corrisponde a nessun altro pattern.\n\n13\n\nChiamata a controlla_valore con 1. Output: Uno.\n\n14\n\nChiamata a controlla_valore con \"ciao\". Output: Saluto.\n\n15\n\nChiamata a controlla_valore con False. Output: Altro.\n\n\n\n\n11.2.2.2 Pattern di cattura\nI pattern di cattura utilizzano nomi non qualificati (nomi senza punti) per catturare valori all’interno di un pattern. Questi nomi sono wildcard che corrispondono a qualsiasi valore, ma con un effetto collaterale: il nome viene associato all’oggetto corrispondente nella corrispondente espressione di pattern matching. I binding creati dai pattern di cattura rimangono disponibili dopo l’esecuzione dell’istruzione match, permettendo alle istruzioni all’interno del blocco case e al codice successivo di processare i valori catturati.\nUn pattern di cattura semplice associa il nome della variabile al valore corrispondente. Se il pattern di cattura è combinato con altre forme di pattern, può catturare parti specifiche del soggetto.\nEsempio di utilizzo dei pattern di cattura:\n1def descrivi_valore(valore):\n2  match valore:\n3    case x if x &lt; 0:\n4      print(f\"{x} è un numero negativo\")\n\n5    case x if x == 0:\n6      print(f\"{x} è zero\")\n\n7    case x if x &gt; 0 and x % 2 == 0:\n8      print(f\"{x} è un numero positivo pari\")\n\n9    case x if x &gt; 0 and x % 2 != 0:\n10      print(f\"{x} è un numero positivo dispari\")\n\n11    case _ if isinstance(valore, str):\n12      print(f'\"{valore}\" è una stringa')\n\n13    case _ if isinstance(valore, list):\n14      print(f\"{valore} è una lista\")\n        \n15    case _:\n16      print(\"Tipo di valore non riconosciuto\")\n\n# Esempi di utilizzo della funzione\n17descrivi_valore(-5)\n18descrivi_valore(0)\n19descrivi_valore(4)\n20descrivi_valore(7)\n21descrivi_valore(\"ciao\")\n22descrivi_valore([1, 2, 3])\n23descrivi_valore({\"chiave\": \"valore\"})\n\n1\n\nDefinizione della funzione descrivi_valore.\n\n2\n\nInizio del blocco match per il valore valore.\n\n3\n\nPattern di cattura x con guard x &lt; 0.\n\n4\n\nOutput se valore è un numero negativo. Esempio di output: -5 è un numero negativo.\n\n5\n\nPattern di cattura x con guard x == 0.\n\n6\n\nOutput se valore è zero. Esempio di output: 0 è zero.\n\n7\n\nPattern di cattura x con guard x &gt; 0 and x % 2 == 0.\n\n8\n\nOutput se valore è un numero positivo pari. Esempio di output: 4 è un numero positivo pari.\n\n9\n\nPattern di cattura x con guard x &gt; 0 and x % 2 != 0.\n\n10\n\nOutput se valore è un numero positivo dispari. Esempio di output: 7 è un numero positivo dispari.\n\n11\n\nPattern di guard isinstance(valore, str).\n\n12\n\nOutput se valore è una stringa. Esempio di output: \"ciao\" è una stringa.\n\n13\n\nPattern di guard isinstance(valore, list).\n\n14\n\nOutput se valore è una lista. Esempio di output: [1, 2, 3] è una lista.\n\n15\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n16\n\nOutput se valore non corrisponde a nessun altro pattern. Esempio di output: Tipo di valore non riconosciuto.\n\n17\n\nChiamata a descrivi_valore con -5. Output: -5 è un numero negativo.\n\n18\n\nChiamata a descrivi_valore con 0. Output: 0 è zero.\n\n19\n\nChiamata a descrivi_valore con 4. Output: 4 è un numero positivo pari.\n\n20\n\nChiamata a descrivi_valore con 7. Output: 7 è un numero positivo dispari.\n\n21\n\nChiamata a descrivi_valore con \"ciao\". Output: \"ciao\" è una stringa.\n\n22\n\nChiamata a descrivi_valore con [1, 2, 3]. Output: [1, 2, 3] è una lista.\n\n23\n\nChiamata a descrivi_valore con {\"chiave\": \"valore\"}. Output: Tipo di valore non riconosciuto.\n\n\n\n\n11.2.2.3 Pattern a valore\nI pattern a valore utilizzano nomi qualificati per rappresentare valori piuttosto che catturarli. In questo modo, puoi fare riferimento a valori specifici all’interno di un pattern senza rischiare di sovrascrivere variabili esistenti. I nomi qualificati possono essere attributi di una classe o attributi di istanze di classe.\nPoiché i nomi semplici catturano i valori durante il pattern matching, è necessario utilizzare riferimenti agli attributi (nomi qualificati come nome.attr) per esprimere valori che possono cambiare tra le diverse esecuzioni dello stesso statement match.\nEsempio di utilizzo dei pattern a valore:\nclass Valori:\n  V1 = 42\n  V2 = \"ciao\"\n  V3 = [1, 2, 3]\n\nobj = Valori()\n1obj.V4 = 99\n\n2def controlla_valore(valore):\n3  match valore:\n4    case Valori.V1:\n5      print(\"Valore uguale a 42\")\n\n6    case Valori.V2:\n7      print('Valore uguale a \"ciao\"')\n\n8    case Valori.V3:\n9      print(\"Valore uguale a [1, 2, 3]\")\n\n10    case obj.V4:\n11      print(\"Valore uguale a 99\")\n\n12    case _:\n13      print(\"Valore non riconosciuto\")\n\n# Esempi di utilizzo della funzione\n14controlla_valore(42)\n15controlla_valore(\"ciao\")\n16controlla_valore([1, 2, 3])\n17controlla_valore(99)\n18controlla_valore(100)\n\n1\n\nAssegna un nuovo attributo V4 all’istanza obj della classe Valori.\n\n2\n\nDefinizione della funzione controlla_valore.\n\n3\n\nInizia il blocco match per il valore valore.\n\n4\n\nPattern a valore per Valori.V1.\n\n5\n\nOutput se valore è uguale a 42. Esempio di output: Valore uguale a 42.\n\n6\n\nPattern a valore per Valori.V2.\n\n7\n\nOutput se valore è uguale a \"ciao\". Esempio di output: Valore uguale a \"ciao\".\n\n8\n\nPattern a valore per Valori.V3.\n\n9\n\nOutput se valore è uguale a [1, 2, 3]. Esempio di output: Valore uguale a [1, 2, 3].\n\n10\n\nPattern a valore per obj.V4.\n\n11\n\nOutput se valore è uguale a 99. Esempio di output: Valore uguale a 99.\n\n12\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n13\n\nOutput se valore non corrisponde a nessun altro pattern. Esempio di output: Valore non riconosciuto.\n\n14\n\nChiamata a controlla_valore con 42. Output: Valore uguale a 42.\n\n15\n\nChiamata a controlla_valore con \"ciao\". Output: Valore uguale a \"ciao\".\n\n16\n\nChiamata a controlla_valore con [1, 2, 3]. Output: Valore uguale a [1, 2, 3].\n\n17\n\nChiamata a controlla_valore con 99. Output: Valore uguale a 99.\n\n18\n\nChiamata a controlla_valore con 100. Output: Valore non riconosciuto.\n\n\nIn questo esempio, Valori.V1, Valori.V2, e Valori.V3 sono attributi della classe Valori, mentre obj.V4 è un attributo dell’istanza obj della classe Valori.\n\n\n11.2.2.4 Pattern OR\nI pattern OR utilizzano l’operatore | per combinare più pattern. Il match ha successo se uno qualsiasi dei pattern combinati corrisponde al soggetto.\nEsempio di utilizzo dei pattern OR:\n1def descrivi_numero(numero):\n2  match numero:\n3    case 0 | 1:\n4      print(\"Numero è 0 o 1\")\n\n5    case 2 | 3:\n6      print(\"Numero è 2 o 3\")\n\n7    case _ if numero &gt; 3:\n8      print(\"Numero è maggiore di 3\")\n        \n9    case _:\n10      print(\"Numero non riconosciuto\")\n\n# Esempi di utilizzo della funzione\n11descrivi_numero(0)\n12descrivi_numero(2)\n13descrivi_numero(5)\n14descrivi_numero(-1)\n\n1\n\nDefinizione della funzione descrivi_numero.\n\n2\n\nInizia il blocco match per il valore numero.\n\n3\n\nPattern OR per 0 | 1.\n\n4\n\nOutput se numero è 0 o 1. Esempio di output: Numero è 0 o 1.\n\n5\n\nPattern OR per 2 | 3.\n\n6\n\nOutput se numero è 2 o 3. Esempio di output: Numero è 2 o 3.\n\n7\n\nPattern di guard per numero &gt; 3.\n\n8\n\nOutput se numero è maggiore di 3. Esempio di output: Numero è maggiore di 3.\n\n9\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n10\n\nOutput se numero non corrisponde a nessun altro pattern. Esempio di output: Numero non riconosciuto.\n\n11\n\nChiamata a descrivi_numero con 0. Output: Numero è 0 o 1.\n\n12\n\nChiamata a descrivi_numero con 2. Output: Numero è 2 o 3.\n\n13\n\nChiamata a descrivi_numero con 5. Output: Numero è maggiore di 3.\n\n14\n\nChiamata a descrivi_numero con -1. Output: Numero non riconosciuto.\n\n\n\n\n11.2.2.5 Pattern di gruppo\nI pattern di gruppo utilizzano parentesi per raggruppare parti di un pattern, consentendo la combinazione di pattern complessi. Questa funzionalità è utile quando si vuole applicare operazioni di pattern matching su componenti specifici di un soggetto.\nEsempio di utilizzo dei pattern di gruppo:\n1def analizza_tupla(tupla):\n2  match tupla:\n3    case (x, (y, z)):\n4      print(f\"Primo elemento: {x}, Secondo elemento: ({y}, {z})\")\n        \n5    case (x, y):\n6      print(f\"Primo elemento: {x}, Secondo elemento: {y}\")\n\n7    case _:\n8      print(\"Pattern non riconosciuto\")\n\n# Esempi di utilizzo della funzione\n9analizza_tupla((1, (2, 3)))\n10analizza_tupla((1, 4))\n11analizza_tupla((1, 2, 3))\n\n1\n\nDefinizione della funzione analizza_tupla.\n\n2\n\nInizia il blocco match per il valore tupla.\n\n3\n\nPattern di gruppo (x, (y, z)).\n\n4\n\nOutput se tupla corrisponde al pattern (x, (y, z)). Esempio di output: Primo elemento: 1, Secondo elemento: (2, 3).\n\n5\n\nPattern di gruppo (x, y).\n\n6\n\nOutput se tupla corrisponde al pattern (x, y). Esempio di output: Primo elemento: 1, Secondo elemento: 4.\n\n7\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n8\n\nOutput se tupla non corrisponde a nessun altro pattern. Esempio di output: Pattern non riconosciuto.\n\n9\n\nChiamata a analizza_tupla con (1, (2, 3)). Output: Primo elemento: 1, Secondo elemento: (2, 3).\n\n10\n\nChiamata a analizza_tupla con (1, 4). Output: Primo elemento: 1, Secondo elemento: 4.\n\n11\n\nChiamata a analizza_tupla con (1, 2, 3). Output: Pattern non riconosciuto.\n\n\nIn questo esempio, il pattern (x, (y, z)) confronta la tupla tupla per verificare se il secondo elemento è una tupla di due elementi, mentre il pattern (x, y) confronta la tupla tupla per verificare se ha esattamente due elementi. Questo esempio mostra come utilizzare i pattern di gruppo in Python per eseguire il pattern matching su tuple.\n\n\n11.2.2.6 Pattern di sequenza\nI pattern di sequenza corrispondono a sequenze come liste o tuple. Ogni elemento della sequenza viene confrontato con il pattern corrispondente. È possibile utilizzare l’asterisco (*) per catturare più elementi in una sottosequenza.\nEsempio:\n1def verifica_sequenza(sequenza):\n2  match sequenza:\n3    case [1, 2, 3]:\n4      return \"Sequenza 1, 2, 3\"\n\n5    case [x, y, z]:\n6      return f\"Sequenza generica: {x}, {y}, {z}\"\n\n7    case [x, *y, z]:\n8      return f\"Sequenza con primo e ultimo elemento: {x}, {z}, e mediano: {y}\"\n        \n9    case _:\n10      return \"Altro\"\n\n11print(verifica_sequenza([1, 2, 3]))\n12print(verifica_sequenza([4, 5, 6]))\n13print(verifica_sequenza([7, 8, 9, 10]))\n14print(verifica_sequenza([7, 8]))\n\n1\n\nDefinizione della funzione verifica_sequenza.\n\n2\n\nInizia il blocco match per il valore sequenza.\n\n3\n\nPattern di sequenza [1, 2, 3].\n\n4\n\nOutput se sequenza è [1, 2, 3].\n\n5\n\nPattern di sequenza generico [x, y, z] per una sequenza di esattamente tre elementi.\n\n6\n\nOutput con i valori catturati.\n\n7\n\nPattern di sequenza con l’uso dell’asterisco (*y) per catturare tutti gli elementi intermedi tra il primo (x) e l’ultimo (z).\n\n8\n\nOutput con il primo, l’ultimo e gli elementi intermedi della sequenza.\n\n9\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n10\n\nOutput se sequenza non corrisponde a nessun altro pattern.\n\n11\n\nChiamata a verifica_sequenza con [1, 2, 3]. Output: Sequenza 1, 2, 3.\n\n12\n\nChiamata a verifica_sequenza con [4, 5, 6]. Output: Sequenza generica: 4, 5, 6.\n\n13\n\nChiamata a verifica_sequenza con [7, 8, 9, 10]. Output: Sequenza con primo e ultimo elemento: 7, 10, e mediano: [8, 9].\n\n14\n\nChiamata a verifica_sequenza con [7, 8]. Output: Altro.\n\n\nIn questo esempio, l’uso dell’asterisco * nel pattern [x, *y, z] permette di catturare una sottosequenza di lunghezza arbitraria tra il primo e l’ultimo elemento della sequenza. Questo rende possibile gestire sequenze di lunghezza variabile, mentre il pattern [x, y, z] corrisponde solo a sequenze di esattamente tre elementi.\n\n\n11.2.2.7 Pattern as\nÈ possibile utilizzare i pattern as per catturare i valori abbinati da pattern più complessi o componenti di un pattern, che i semplici pattern di cattura non possono gestire. Quando P1 è un pattern, allora P1 as name è anche un pattern; quando P1 ha successo, Python associa il valore abbinato al nome name nel namespace locale.\nEsempio di utilizzo del pattern as:\ndef analizza_comando(comando):\n  match comando:\n    case (\"start\", param) as c:\n1      print(f\"Avvio con parametro {param}. Comando completo: {c}\")\n\n    case (\"stop\", param) as c:\n2      print(f\"Arresto con parametro {param}. Comando completo: {c}\")\n\n    case (\"pause\", param) as c:\n3      print(f\"Pausa con parametro {param}. Comando completo: {c}\")\n        \n    case _ as c:\n4      print(f\"Comando sconosciuto: {c}\")\n\n# Esempi di utilizzo\n5analizza_comando((\"start\", 5))\n6analizza_comando((\"stop\", 10))\n7analizza_comando((\"pause\", 15))\n8analizza_comando((\"exit\", 20))\n\n1\n\nCaso in cui il comando è un avvio con un parametro.\n\n2\n\nCaso in cui il comando è un arresto con un parametro.\n\n3\n\nCaso in cui il comando è una pausa con un parametro.\n\n4\n\nCaso wildcard che cattura qualsiasi altro comando.\n\n5\n\nChiamata a analizza_comando con (\"start\", 5). Output: Avvio con parametro 5. Comando completo: ('start', 5).\n\n6\n\nChiamata a analizza_comando con (\"stop\", 10). Output: Arresto con parametro 10. Comando completo: ('stop', 10).\n\n7\n\nChiamata a analizza_comando con (\"pause\", 15). Output: Pausa con parametro 15. Comando completo: ('pause', 15).\n\n8\n\nChiamata a analizza_comando con (\"exit\", 20). Output: Comando sconosciuto: ('exit', 20).\n\n\n\n\n11.2.2.8 Pattern di mappatura\nI pattern di mappatura corrispondono alle mappature definite nel linguaggio come i dizionari. Ogni coppia chiave-valore viene confrontata con il pattern corrispondente.\nEsempio:\n1def verifica_mappatura(mappatura):\n2  match mappatura:\n3    case {\"a\": 1, \"b\": 2}:\n4      return \"Mappatura a=1, b=2\"\n\n5    case {\"a\": x, \"b\": y}:\n6      return f\"Mappatura generica: a={x}, b={y}\"\n\n7    case _:\n8      return \"Altro\"\n\n9print(verifica_mappatura({\"a\": 1, \"b\": 2}))\n10print(verifica_mappatura({\"a\": 3, \"b\": 4}))\n11print(verifica_mappatura({\"c\": 5}))\n\n1\n\nDefinizione della funzione verifica_mappatura.\n\n2\n\nInizia il blocco match per il valore mappatura.\n\n3\n\nPattern di mappatura {\"a\": 1, \"b\": 2}.\n\n4\n\nOutput se mappatura è {\"a\": 1, \"b\": 2}.\n\n5\n\nPattern di mappatura generico {\"a\": x, \"b\": y}.\n\n6\n\nOutput con i valori catturati.\n\n7\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n8\n\nOutput se mappatura non corrisponde a nessun altro pattern.\n\n9\n\nChiamata a verifica_mappatura con {\"a\": 1, \"b\": 2}. Output: Mappatura a=1, b=2.\n\n10\n\nChiamata a verifica_mappatura con {\"a\": 3, \"b\": 4}. Output: Mappatura generica: a=3, b=4.\n\n11\n\nChiamata a verifica_mappatura con {\"c\": 5}. Output: Altro.\n\n\n\n\n11.2.2.9 Pattern di classe\nI pattern di classe permettono di verificare se un oggetto è un’istanza di una particolare classe e di accedere ai suoi attributi. Un pattern di classe ha la forma generale nome_o_attr(patterns), dove nome_o_attr è un nome semplice o qualificato legato a una classe, e patterns è una lista separata da virgole di specifiche di pattern.\nSe non ci sono specifiche di pattern, il pattern di classe corrisponde a qualsiasi istanza della classe data. Se ci sono specifiche di pattern posizionali, queste devono precedere qualsiasi specifica di pattern nominata.\nLe classi predefinite di Python come bool, bytearray, bytes, dict, float, frozenset, int, list, set, str e tuple sono tutte configurate per accettare un singolo pattern posizionale, che viene confrontato con il valore dell’istanza.\nEsempio:\nclass Punto:\n  def __init__(self, x, y):\n    self.x = x\n    self.y = y\n\ndef descrivi_punto(p):\n  match p:\n    case Punto(0, 0):\n1      return \"Punto all'origine\"\n\n    case Punto(x, 0):\n2      return f\"Punto sull'asse x a {x}\"\n\n    case Punto(0, y):\n3      return f\"Punto sull'asse y a {y}\"\n\n    case Punto(x, y) if x == y:\n4      return f\"Punto sulla bisettrice x=y a ({x}, {y})\"\n\n    case Punto(x, y):\n5      return f\"Punto a ({x}, {y})\"\n\n    case _:\n6      return \"Non è un punto\"\n\n# Esempi di utilizzo\np1 = Punto(0, 0)\np2 = Punto(3, 0)\np3 = Punto(0, 4)\np4 = Punto(2, 2)\np5 = Punto(1, 5)\n\n7print(descrivi_punto(p1))\n8print(descrivi_punto(p2))\n9print(descrivi_punto(p3))\n10print(descrivi_punto(p4))\n11print(descrivi_punto(p5))\n\n1\n\nPattern di classe che verifica se p è un’istanza di Punto con x e y uguali a 0.\n\n2\n\nPattern di classe che verifica se p è un’istanza di Punto con y uguale a 0.\n\n3\n\nPattern di classe che verifica se p è un’istanza di Punto con x uguale a 0.\n\n4\n\nPattern di classe con guard che verifica se p è un’istanza di Punto con x uguale a y.\n\n5\n\nPattern di classe generico che verifica se p è un’istanza di Punto e cattura i valori di x e y.\n\n6\n\nPattern wildcard che corrisponde a qualsiasi altro valore.\n\n7\n\nChiamata a descrivi_punto con Punto(0, 0). Output: Punto all'origine.\n\n8\n\nChiamata a descrivi_punto con Punto(3, 0). Output: Punto sull'asse x a 3.\n\n9\n\nChiamata a descrivi_punto con Punto(0, 4). Output: Punto sull'asse y a 4.\n\n10\n\nChiamata a descrivi_punto con Punto(2, 2). Output: Punto sulla bisettrice x=y a (2, 2).\n\n11\n\nChiamata a descrivi_punto con Punto(1, 5). Output: Punto a (1, 5).\n\n\nIn questo esempio, Punto è una classe con attributi x e y. I pattern di classe permettono di verificare se un oggetto è un’istanza di Punto e di accedere ai suoi attributi per ulteriori controlli.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html#cicli",
    "href": "seconda-parte-python-istruzioni.html#cicli",
    "title": "11  Istruzioni",
    "section": "11.3 Cicli",
    "text": "11.3 Cicli\n\n11.3.1 Istruzione while\nL’istruzione composta while ripete l’esecuzione di un blocco di istruzioni fintantoché un’espressione condizionale risulta vera. La clausola else viene eseguita quando il ciclo while termina naturalmente (cioè, la condizione del ciclo diventa falsa).\nEcco la sintassi completa dello pseudocodice per l’istruzione while con la clausola else:\n1while espressione:\n2  istruzione(i)\n\n3else:\n4  istruzione(i)\n\n1\n\nL’interprete valuta l’espressione condizionale.\n\n2\n\nSe l’espressione condizionale è vera, esegue il blocco di istruzioni all’interno del ciclo while. Al termine del blocco, torna a valutare l’espressione condizionale.\n\n3\n\nSe l’espressione condizionale è falsa, esegue il blocco di istruzioni all’interno della clausola else.\n\n4\n\nIl blocco di istruzioni all’interno della clausola else viene eseguito solo se il ciclo while termina naturalmente (cioè, la condizione del ciclo diventa falsa).\n\n\nEsempio pratico con while e else:\nx = 3\n\n1while x &gt; 0:\n2  print(x)\n\n  x -= 1\n\n3else:\n4  print(\"Ciclo terminato\")\n\n1\n\nInizia il ciclo while finché x è maggiore di 0.\n\n2\n\nStampa il valore corrente di x.\n\n3\n\nLa clausola else viene eseguita quando il ciclo while termina naturalmente.\n\n4\n\nStampa “Ciclo terminato”.\n\n\nL’istruzione while può anche includere una clausola else e le istruzioni break e continue. L’istruzione break interrompe il ciclo while, al pari di return se il ciclo si trova in una funzione. L’istruzione continue salta l’iterazione corrente e passa alla successiva.\nEsempio:\nx = 10\n\n1while x &gt; 0:\n  x -= 1\n\n  if x == 5:\n2    break\n\n  if x % 2 == 0:\n3    continue\n\n4  print(x)\n\n1\n\nInizia il ciclo while finché x è maggiore di 0.\n\n2\n\nInterrompe il ciclo quando x è uguale a 5.\n\n3\n\nSalta l’iterazione corrente se x è pari.\n\n4\n\nStampa il valore di x se non è stato saltato.\n\n\n\n\n11.3.2 Istruzione for\nL’istruzione for ripete l’esecuzione di un blocco di istruzioni controllata da un’espressione iterabile. La sintassi è:\n1for indice in iterabile:\n2    istruzione(i)\n\n1\n\nindice è normalmente un identificatore che funge da variabile di controllo del ciclo e viene associato a ciascun elemento dell’iterabile.\n\n2\n\nistruzione(i) rappresenta una o più istruzioni che vengono eseguite per ogni elemento dell’iterabile.\n\n\nEsempio tipico di for:\n1for lettera in 'ciao':\n2    print(f'Dammi una {lettera}...')\n\n1\n\nInizia il ciclo for su ogni carattere della stringa 'ciao'.\n\n2\n\nStampa \"Dammi una [lettera]...\" per ogni lettera della stringa.\n\n\nL’istruzione for può anche includere una clausola else che viene eseguita se il ciclo termina normalmente (cioè, non viene interrotto da un’istruzione break o return).\nnumeri = [1, 2, 3, 4, 5]\n\n1for numero in numeri:\n2  if numero == 3:\n    break\n    \n3  print(numero)\n\n4else:\n5    print(\"Ciclo completato\")\n\n1\n\nInizia il ciclo for sulla lista numeri.\n\n2\n\nSe il numero è 3, interrompe il ciclo con break.\n\n3\n\nStampa il numero corrente.\n\n4\n\nLa clausola else viene eseguita se il ciclo for termina naturalmente.\n\n5\n\nStampa “Ciclo completato”.\n\n\nL’iterabile può essere qualsiasi espressione iterabile in Python. In particolare, qualsiasi sequenza è iterabile. L’interprete chiama implicitamente la funzione built-in iter() sull’iterabile, producendo un iteratore.\n\n\n11.3.3 Iteratori e iterabili\nUn iteratore è un oggetto che permette di attraversare una collezione di elementi, uno alla volta. Gli iteratori sono utilizzati per rappresentare flussi di dati o collezioni di elementi che non sono necessariamente tutti disponibili in memoria contemporaneamente. Pertanto:\n\nUn oggetto è iterabile se può restituire un iteratore. Un oggetto iterabile implementa il metodo __iter__() che deve restituire un iteratore.\nUn oggetto è un iteratore se implementa i metodi __iter__() e __next__(). Il metodo __next__() restituisce il prossimo elemento della collezione e solleva l’eccezione StopIteration quando non ci sono più elementi.\n\nEsempio di iteratore:\n1numeri = [1, 2, 3]\n2iteratore = iter(numeri)\n\n3print(next(iteratore))\n4print(next(iteratore))\n5print(next(iteratore))\n6print(next(iteratore))\n\n1\n\nDefinizione di una lista di numeri.\n\n2\n\nCreazione di un iteratore dall’iterabile numeri.\n\n3\n\nOutput: 1.\n\n4\n\nOutput: 2.\n\n5\n\nOutput: 3.\n\n6\n\nSolleva l’eccezione StopIteration perché non ci sono più elementi.\n\n\nL’istruzione for chiama implicitamente iter sul suo iterabile per ottenere un iteratore. Lo pseudocodice seguente mostra cosa accade dietro le quinte:\n_iteratore_temporaneo = iter(contenitore)\n\nwhile True:\n    try:\n        x = next(_iteratore_temporaneo)\n\n    except StopIteration:\n        break\n\n    istruzione(i)\n\n\n11.3.4 La funzione range\nLa funzione range genera una sequenza di numeri interi. È comunemente usata nei cicli for.\n1for i in range(5):\n2  print(i)\n\n1\n\nInizia il ciclo for sui numeri da 0 a 4.\n\n2\n\nStampa il numero corrente.\n\n\nrange può accettare fino a tre argomenti: start, stop, e step.\n1for i in range(1, 10, 2):\n2  print(i)\n\n1\n\nInizia il ciclo for sui numeri da 1 a 9, con incremento di 2.\n\n2\n\nStampa il numero corrente.\n\n\nL’oggetto range è un iterabile ma non un iteratore. Tuttavia, è possibile ottenere un iteratore chiamando iter() su un oggetto range.\nr = range(5)\ni = iter(r)\n\n1print(next(i))\n2print(next(i))\n\n1\n\nStampa il primo numero dell’oggetto range: 0.\n\n2\n\nStampa il secondo numero dell’oggetto range: 1.\n\n\n\n\n11.3.5 Spacchettamento nei cicli for\nÈ possibile utilizzare un indice composto da più identificatori, come in un’assegnazione con spacchettamento. In questo caso, gli elementi dell’iteratore devono essere essi stessi iterabili, ciascuno con esattamente tanti elementi quanti sono gli identificatori nell’indice.\nEsempio di ciclo for su un dizionario:\nd = {'a': 1, 'b': 2, 'c': 3}\n\n1for chiave, valore in d.items():\n2  if chiave and valore:\n3    print(chiave, valore)\n\n1\n\nInizia il ciclo for sugli elementi del dizionario d.\n\n2\n\nVerifica se sia la chiave che il valore sono “truthy”.\n\n3\n\nStampa la coppia chiave-valore.\n\n\nÈ possibile usare un identificatore preceduto da un asterisco * nel target. Questo identificatore verrà associato a una lista di tutti gli elementi non assegnati ad altri target.\nlista = [1, 2, 3, 4, 5]\n\n1for primo, *centro, ultimo in [lista]:\n2  print(primo)\n3  print(centro)\n4  print(ultimo)\n\n1\n\nInizia il ciclo for sulla lista lista.\n\n2\n\nStampa il primo elemento della lista.\n\n3\n\nStampa tutti gli elementi centrali della lista.\n\n4\n\nStampa l’ultimo elemento della lista.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html#comprensioni",
    "href": "seconda-parte-python-istruzioni.html#comprensioni",
    "title": "11  Istruzioni",
    "section": "11.4 Comprensioni",
    "text": "11.4 Comprensioni\nLe comprensioni comprehension in Python sono un modo conciso e leggibile per creare nuove sequenze (liste, insiemi, dizionari) da iterabili esistenti. Sono un esempio di supporto alla programmazione funzionale in quanto permettono di creare nuove collezioni attraverso la trasformazione e il filtraggio di elementi, senza modificare l’iterabile originale. Questa capacità di trasformare dati in modo dichiarativo, senza effetti collaterali, è un principio fondamentale della programmazione funzionale.\n\n11.4.1 Liste\nLe comprensioni di liste sono uno degli utilizzi più comuni. Permettono di ispezionare ogni elemento di un iterabile e costruire una nuova lista aggiungendo i risultati di un’espressione calcolata su alcuni o tutti gli elementi. Una compresa di lista ha la seguente sintassi:\n[espressione for indice in iterabile clausole]\n\nindice e iterabile in ogni clausola for di una compresa di lista hanno la stessa sintassi e significato di quelli in una normale istruzione for.\nespressione può essere qualsiasi espressione Python valida e viene calcolata per ogni elemento della lista risultante.\nclausole è una serie di zero o più clausole, ciascuna con la forma for indice in iterabile o if espressione.\n\nEsempio semplice:\n1result = [x + 1 for x in range(5)]\n\n2print(result)\n\n1\n\nCrea una lista di numeri incrementati di 1 da 0 a 4.\n\n2\n\nOutput: [1, 2, 3, 4, 5].\n\n\nEsempio con condizione:\n1result = [x + 1 for x in range(5) if x &gt; 2]\n\n2print(result)\n\n1\n\nCrea una lista con i numeri da 1 a 5, ma solo per i numeri maggiori di 2.\n\n2\n\nOutput: [4, 5].\n\n\nEsempio con annidamento:\nlista_di_liste = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n1result = [x for sublist in lista_di_liste for x in sublist]\n2print(result)\n\n1\n\nAppiattisce una lista di liste in una singola lista.\n\n2\n\nOutput: [1, 2, 3, 4, 5, 6, 7, 8, 9].\n\n\n\n\n11.4.2 Insiemi\nLe comprensioni di insiemi hanno la stessa sintassi e semantica delle comprese di liste, ad eccezione che sono racchiuse tra parentesi graffe {} invece che tra parentesi quadre []. Il risultato è un insieme.\nEsempio:\n1s = {n // 2 for n in range(10)}\n\n2print(sorted(s))\n\n1\n\nCrea un insieme con i risultati della divisione intera di n per 2, da 0 a 9.\n\n2\n\nOutput: [0, 1, 2, 3, 4].\n\n\n\n\n11.4.3 Dizionari\nLe comprensioni di dizionari hanno la stessa sintassi delle comprese di insiemi, ma invece di una singola espressione prima della clausola for, si usano due espressioni separate da un due punti :: chiave:valore. Il risultato è un dizionario che mantiene l’ordine di inserimento.\nEsempio:\n1d = {s: i for i, s in enumerate(['zero', 'uno', 'due'])}\n\n2print(d)\n\n1\n\nCrea un dizionario associando ogni stringa al suo indice nella lista.\n\n2\n\nOutput: {'zero': 0, 'uno': 1, 'due': 2}.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html#gestione-anomalie",
    "href": "seconda-parte-python-istruzioni.html#gestione-anomalie",
    "title": "11  Istruzioni",
    "section": "11.5 Gestione anomalie",
    "text": "11.5 Gestione anomalie\n\n11.5.1 Istruzioni try e raise\nPython supporta la gestione delle eccezioni con l’istruzione composta try, che include le clausole try, except, finally ed else. Il codice può anche sollevare esplicitamente un’eccezione con l’istruzione raise. Quando il codice solleva un’eccezione, il normale flusso di controllo del programma si interrompe e Python cerca un gestore di eccezioni adatto.\nEsempio di utilizzo di try e raise:\n1def dividi(a, b):\n2  try:\n3    return a / b\n\n4  except ZeroDivisionError:\n5    raise ValueError(\"Divisione per zero non consentita\")\n\n6try:\n7  risultato = dividi(10, 0)\n\n8except ValueError as e:\n9  print(e)\n\n1\n\nDefinizione della funzione dividi.\n\n2\n\nInizia il blocco try.\n\n3\n\nTentativo di divisione.\n\n4\n\nGestione dell’eccezione ZeroDivisionError.\n\n5\n\nSollevamento di una nuova eccezione ValueError.\n\n6\n\nInizia un altro blocco try.\n\n7\n\nTentativo di chiamare dividi con un denominatore pari a zero.\n\n8\n\nGestione dell’eccezione ValueError.\n\n9\n\nOutput del messaggio di errore: Divisione per zero non consentita.\n\n\n\n\n11.5.2 Istruzione di controllo condizioni anomale\nL’istruzione assert condizione, messaggio viene utilizzata per eseguire controlli durante l’esecuzione del programma. Se la condizione è falsa, viene sollevata un’eccezione AssertionError che include il messaggio. Può essere usata per il debugging e per verificare condizioni che dovrebbero essere sempre vere in un punto specifico del codice.\nEsempi di utilizzo:\nx = 5\n\n1assert x &gt; 0, \"x deve essere maggiore di zero\"\n2assert x &lt; 0, \"x deve essere minore di zero\"\n\n1\n\nNon genera errore perché x &gt; 0 è vero.\n\n2\n\nGenera AssertionError con il messaggio \"x deve essere minore di zero\" perché x &lt; 0 è falso.\n\n\nÈ importante notare che le asserzioni possono essere disabilitate a livello di runtime utilizzando l’opzione -O (ottimizzazione) quando si esegue lo script Python. Questo rimuoverà tutte le istruzioni assert dal bytecode generato.\npython -O script.py",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-istruzioni.html#altre-istruzioni",
    "href": "seconda-parte-python-istruzioni.html#altre-istruzioni",
    "title": "11  Istruzioni",
    "section": "11.6 Altre istruzioni",
    "text": "11.6 Altre istruzioni\n\n11.6.1 Istruzione pass\nIl corpo di un’istruzione composta in Python non può essere vuoto; deve contenere almeno un’istruzione. Si può utilizzare l’istruzione pass, che non esegue alcuna azione, come segnaposto esplicito quando è richiesta un’istruzione sintatticamente ma non c’è nulla da fare.\nEsempio di utilizzo di pass:\n1if True:\n2  pass\n\n1\n\nCondizione sempre vera.\n\n2\n\nSegnaposto che non esegue alcuna azione.\n\n\n1def funzione_non_implementata():\n2  pass\n\n1\n\nDefinizione di una funzione.\n\n2\n\nSegnaposto per una funzione non ancora implementata.\n\n\n1class ClasseVuota:\n2  pass\n\n1\n\nDefinizione di una classe.\n\n2\n\nSegnaposto per una classe non ancora implementata.\n\n\n\n\n11.6.2 Istruzione with\nL’istruzione composta with può spesso essere un’alternativa più leggibile e utile all’istruzione try/finally. Essa consente di gestire risorse in modo efficiente e sicuro, assicurando che le risorse siano correttamente rilasciate dopo l’uso. Per essere gestita dall’istruzione with, una risorsa deve implementare il protocollo del context manager, che richiede i metodi speciali __enter__ e __exit__.\nUn esempio comune è l’uso di with per gestire i file:\n1with open('file.txt', 'r') as file:\n2  contenuto = file.read()\n  \n3  print(contenuto)\n\n1\n\nApre il file file.txt in modalità lettura.\n\n2\n\nLegge il contenuto del file.\n\n3\n\nOutput del contenuto del file.\n\n\nEsempio di un contesto personalizzato:\nclass GestoreRisorsa:\n1  def __enter__(self):\n2    print(\"Risorsa acquisita\")\n\n    return self\n    \n3  def __exit__(self, tipo, valore, traceback):\n4    print(\"Risorsa rilasciata\")\n      \n5with GestoreRisorsa() as risorsa:\n6  print(\"Usando la risorsa\")\n\n1\n\nMetodo __enter__ che viene chiamato all’inizio del blocco with.\n\n2\n\nOutput indicante che la risorsa è stata acquisita.\n\n3\n\nMetodo __exit__ che viene chiamato alla fine del blocco with, indipendentemente dal fatto che ci sia stata un’eccezione o meno.\n\n4\n\nOutput indicante che la risorsa è stata rilasciata.\n\n5\n\nInizia il blocco with usando il GestoreRisorsa.\n\n6\n\nOutput indicante l’uso della risorsa.\n\n\n\n\n11.6.3 Istruzioni di ritorno\nLe istruzioni di ritorno vengono utilizzate per restituire valori da una funzione. Esistono due tipi principali di istruzioni di ritorno: return e yield.\n\n11.6.3.1 return\nL’istruzione return viene utilizzata per restituire un valore da una funzione e terminare l’esecuzione della funzione.\n1def somma(a, b):\n2  return a + b\n\n3print(somma(3, 4))\n\n1\n\nDefinizione della funzione somma.\n\n2\n\nRestituisce la somma di a e b.\n\n3\n\nOutput della somma: 7.\n\n\n\n\n11.6.3.2 yield\nL’istruzione yield viene utilizzata per restituire un valore da una funzione generatore senza terminare l’esecuzione della funzione. La funzione può riprendere l’esecuzione dal punto in cui è stata interrotta al successivo ciclo di iterazione.\n1def generatore():\n2    yield 1\n3    yield 2\n4    yield 3\n\n5for valore in generatore():\n6    print(valore)\n\n1\n\nDefinizione della funzione generatore generatore.\n\n2\n\nRestituisce 1 e sospende l’esecuzione.\n\n3\n\nRestituisce 2 e sospende l’esecuzione.\n\n4\n\nRestituisce 3 e sospende l’esecuzione.\n\n5\n\nItera sui valori restituiti dal generatore.\n\n6\n\nOutput dei valori: 1, 2, 3.\n\n\n\n\n\n11.6.4 Modificatori di ambito\nLe istruzioni global e nonlocal sono utilizzate per modificare la visibilità delle variabili all’interno delle funzioni.\nL’istruzione global viene utilizzata per dichiarare che una variabile all’interno di una funzione fa riferimento a una variabile globale, cioè una variabile definita al di fuori di qualsiasi funzione. Senza global, tutte le assegnazioni di variabili all’interno di una funzione sono considerate locali alla funzione stessa.\nEsempio di utilizzo di global:\n1x = 10\n\ndef modifica_global():\n2  global x\n\n  x = 20\n\nmodifica_global()\n\n3print(x)\n\n1\n\nx è una variabile globale.\n\n2\n\nL’istruzione global dichiara che x fa riferimento alla variabile globale x, permettendo alla funzione di modificarla.\n\n3\n\nOutput: 20.\n\n\nL’istruzione nonlocal viene utilizzata per dichiarare che una variabile all’interno di una funzione fa riferimento a una variabile non locale, cioè una variabile definita in un contesto esterno ma non globale (ad esempio, all’interno di una funzione contenente). Senza nonlocal, tutte le assegnazioni di variabili all’interno di una funzione sono considerate locali alla funzione stessa.\nEsempio di utilizzo di nonlocal:\ndef esterna():\n1  x = 10\n\n  def interna():\n2    nonlocal x\n    \n    x = 20\n\n  interna()\n\n  print(x)\n\n3esterna()\n\n1\n\nx è una variabile locale alla funzione esterna.\n\n2\n\nL’istruzione nonlocal dichiara che x fa riferimento alla variabile non locale x, permettendo alla funzione interna di modificarla.\n\n3\n\nOutput: 20.\n\n\n\n\n11.6.5 Alias di tipo\nL’istruzione type viene utilizzata per creare alias di tipo. Questo consente di assegnare nomi significativi ai tipi di dati complessi, migliorando la leggibilità del codice. Si possono definire anche alias di tipi generici, cioè tipi parametrizzati da altri tipi.\nÈ importante sottolineare che gli alias non sono da intendere come utili al controllo statico dei tipi durante l’esecuzione, ma come annotazione utile per strumenti di analisi del codice e miglioramento della leggibilità.\nEsempi:\n\nDefinizione di alias di tipo:\n1type lista_coppie = list[tuple[str, int]]\n\n1\n\nlista_coppie è un alias di list[tuple[str, int]].\n\n\nDefinizione di alias di tipo generico:\n1type contenitore_ordinato[T] = list[t] | tuple[T, ...]\n\n1\n\ncontenitore_ordinato può essere o una lista o una tupla con zero o più elementi.\n\n\n\n\n\n11.6.6 Eliminazione di identificatori e elementi in contenitori\nL’istruzione del viene utilizzata per eliminare identificatori come variabili o di funzione e oggetti da contenitori, come elementi singoli o in sezioni (slice) di liste oppure chiavi di dizionari. del rimuovendo i riferimenti agli oggetti, segnala al garbage collector la possibilità di liberazione delle risorse associate.\nEsempi di utilizzo:\n\nEliminazione di una variabile:\nx = 10\n\n1del x\n\n2print(x)\n\n1\n\nElimina la variabile x.\n\n2\n\nDà errore perché x non esiste.\n\n\nEliminazione di un elemento da un contenitore di oggetti di tipo lista per indice:\nlista = [1, 2, 3, 4]\n\n1del lista[0]\n\n2print(lista)\n\n1\n\nElimina il primo elemento dalla lista.\n\n2\n\nOutput: [2, 3, 4].\n\n\nEliminare di elementi contigui da una lista:\nlista = [1, 2, 3, 4, 5, 6]\n\n1del lista[1:4]\n\n2print(lista)\n\n1\n\nElimina gli elementi dal secondo al quarto.\n\n2\n\nOutput: [1, 5, 6].\n\n\nEliminazione di una chiave da un dizionario:\ndizionario = {'a': 1, 'b': 2, 'c': 3}\n\n1del dizionario['a']\n\n2print(dizionario)\n\n1\n\nElimina la chiave 'a' dal dizionario.\n\n2\n\nOutput: {'b': 2, 'c': 3}.\n\n\nEliminazione di un attributo da un oggetto:\nclass ClasseSemplice:\n  def __init__(self):\n    self.attr = 42\n\noggetto_semplice = ClasseSemplice()\n\n1del oggetto_semplice.attr\n\n1\n\nElimina l’attributo 'attr' dall’oggetto 'oggetto_semplice'.\n\n\nEliminazione dell’identificatore di una funzione:\ndef somma_semplice(a, b):\n    return a + b\n\n1del somma_semplice\n\n2somma_semplice(a, b)\n\n1\n\nElimina il riferimento somma_semplice alla funzione.\n\n2\n\nErrore. Output: NameError: name 'somma_semplice' is not defined.\n\n\nEliminazione dell’identificatore di un modulo:\nimport math\n\n1print(math.sqrt(4))\n\ndel math\n\n2print(math)\n\n1\n\nOutput: 2.0.\n\n2\n\nErrore. Output: NameError: name 'math' is not defined. Did you forget to import 'math'?.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Istruzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html",
    "href": "seconda-parte-python-funzioni.html",
    "title": "12  Funzioni",
    "section": "",
    "text": "12.1 Definizione delle funzioni\nL’istruzione def è il modo usuale per creare una funzione. def è una dichiarazione composta a singola clausola con la seguente sintassi:\nQuando l’interprete incontra una definizione def, compila il corpo della funzione, creando un oggetto funzione, e associa nome_funzione all’oggetto funzione compilato nello spazio dei nomi contenitore (tipicamente lo spazio dei nomi del modulo, o uno spazio dei nomi di classe quando si definiscono metodi).\nEsempio di funzione senza parametri:\nEsempio di funzione con un parametro:",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#definizione-delle-funzioni",
    "href": "seconda-parte-python-funzioni.html#definizione-delle-funzioni",
    "title": "12  Funzioni",
    "section": "",
    "text": "1def nome_funzione(parametri):\n2  istruzione(i)\n\n1\n\nnome_funzione è un identificatore.\n\n2\n\nLe istruzioni indentate costituiscono il corpo della funzione.\n\n\n\n\n1def saluta():\n2  print(\"Ciao!\")\n\n3saluta()\n\n1\n\nDefinizione della funzione saluta.\n\n2\n\nStampa Ciao!.\n\n3\n\nChiamata alla funzione saluta.\n\n\n\n1def raddoppia(x):\n2  return x * 2\n\n3print(raddoppia(5))\n4print(raddoppia('ciao'))\n\n1\n\nDefinizione della funzione raddoppia con un parametro x.\n\n2\n\nRestituisce il valore di x moltiplicato per 2.\n\n3\n\nChiamata a raddoppia con l’argomento 5. Output: 10.\n\n4\n\nChiamata a raddoppia con l’argomento 'ciao'. Output: ciaociao.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#parametri",
    "href": "seconda-parte-python-funzioni.html#parametri",
    "title": "12  Funzioni",
    "section": "12.2 Parametri",
    "text": "12.2 Parametri\nI parametri (anche detti parametri formali) nominano i valori passati in una chiamata di funzione e possono specificare valori predefiniti. Ogni volta che chiamiamo una funzione, la chiamata associa ogni nome di parametro al valore corrispondente (argomento) in un nuovo spazio dei nomi locale. Questo spazio dei nomi locale esiste solo per la durata della funzione, e Python lo distrugge al termine dell’esecuzione della funzione. È importante notare che gli argomenti sono oggetti e che le modifiche a questi oggetti mutabili (come liste o dizionari) all’interno della funzione sono visibili anche al di fuori della funzione, nell’ambito del chiamante. Tuttavia, gli identificatori dei parametri non sono accessibili fuori dalla funzione.\nEcco un esempio illustrativo che mostra come i parametri di una funzione si comportano in Python, specialmente quando si tratta di oggetti mutabili:\n1def modifica_lista(lista):\n2  lista.append(4)\n\n3  lista = [1, 2, 3]\n  \n4  print(\"Dentro la funzione:\", lista)\n\n5mia_lista = [1, 2]\n\n6modifica_lista(mia_lista)\n\n7print(\"Fuori dalla funzione:\", mia_lista)\n\n1\n\nLa funzione prende un parametro lista, che è un riferimento a una lista passata come argomento.\n\n2\n\nLa funzione modifica la lista originale aggiungendo un nuovo elemento 4. Questa modifica sarà visibile anche al di fuori della funzione perché lista è un riferimento all’oggetto lista originale.\n\n3\n\nlista viene riassegnata a una nuova lista [1, 2, 3]. Questa riassegnazione non modifica l’oggetto originale passato come argomento, ma crea un nuovo oggetto locale a cui lista ora punta. Questa modifica non sarà visibile al di fuori della funzione.\n\n4\n\nStampa il contenuto dell’identificatore lista all’interno della funzione, che ora è [1, 2, 3] a causa della riassegnazione.\n\n5\n\nCreiamo una lista chiamata mia_lista con i valori [1, 2].\n\n6\n\nPassiamo mia_lista alla funzione modifica_lista.\n\n7\n\nStampa il contenuto di mia_lista dopo la chiamata alla funzione, mostrando che l’elemento 4 è stato aggiunto, ma la riassegnazione a [1, 2, 3] non ha avuto effetto:\n\n\nDentro la funzione: [1, 2, 3]\nFuori dalla funzione: [1, 2, 4]\nQuesto esempio mostra come l’oggetto mutabile (la lista) può essere modificato all’interno della funzione, e tali modifiche sono visibili al di fuori della funzione. Tuttavia, l’identificatore del parametro (in questo caso lista) viene distrutto dopo l’uscita dalla funzione e non è accessibile al di fuori della funzione.\n\n12.2.1 Parametri posizionali\nUn parametro posizionale è un identificatore, che nomina il parametro. Utilizziamo questi nomi all’interno del corpo della funzione per accedere ai valori degli argomenti della chiamata.\nEsempio di funzione con parametri posizionali:\n1def somma(a, b):\n2  return a + b\n\n3print(somma(3, 5))\n\n1\n\nDefinizione della funzione somma con i parametri a e b.\n\n2\n\nRestituisce la somma di a e b.\n\n3\n\nChiamata a somma con gli argomenti 3 e 5. Output: 8.\n\n\n\n\n12.2.2 Parametri nominati\nI parametri nominati normalmente assumono la forma nome=espressione. Questi parametri agiscono come valori predefiniti valutati una sola volta dall’interprete.\nEsempio di funzione con parametri nominati:\n1def saluta(nome=\"ospite\"):\n2  print(f\"Ciao, {nome}!\")\n\n3saluta()\n4saluta(\"Maria\")\n\n1\n\nDefinizione della funzione saluta con il parametro nominato nome e un valore predefinito.\n\n2\n\nStampa un messaggio di saluto.\n\n3\n\nChiamata a saluta senza argomenti. Output: Ciao, ospite!.\n\n4\n\nChiamata a saluta con l’argomento “Maria”. Output: Ciao, Maria!.\n\n\nEcco un esempio con un parametro che utilizza un’espressione come valore predefinito:\n1from datetime import datetime\n\n2def saluta(nome=\"ospite\", momento=datetime.now().strftime(\"%H:%M\")):\n3  print(f\"Ciao, {nome}! L'ora attuale è {momento}.\")\n\n4saluta()\n5saluta(\"Maria\")\n6saluta(\"Luigi\", \"14:30\")\n\n1\n\nImporta il modulo datetime che sarà usato per ottenere l’ora attuale.\n\n2\n\nDefinisce la funzione saluta con due parametri nominati: nome con un valore predefinito di ospite e momento con un valore predefinito che è l’ora corrente formattata come stringa HH:MM.\n\n3\n\nStampa un messaggio di saluto che include il nome e il momento specificato.\n\n4\n\nChiamata a saluta senza argomenti. Utilizza entrambi i valori predefiniti. Output: Ciao, ospite! L'ora attuale è &lt;ora_attuale&gt;..\n\n5\n\nChiamata a saluta con l’argomento Maria. Utilizza il valore predefinito per momento. Output: Ciao, Maria! L'ora attuale è &lt;ora_attuale&gt;..\n\n6\n\nChiamata a saluta con gli argomenti Luigi e 14:30. Non utilizza nessun valore predefinito. Output: Ciao, Luigi! L'ora attuale è 14:30..\n\n\nIn questo esempio, il parametro momento utilizza un’espressione come valore predefinito che viene valutata una volta sola al momento della definizione della funzione. Se viene chiamata senza argomenti, la funzione utilizza questi valori predefiniti.\n\n\n12.2.3 Marcatore di parametri posizionali\nLa firma di una funzione può contenere un marcatore di parametri posizionali / come parametro fittizio. I parametri che precedono il marcatore sono noti come parametri posizionali, e devono essere forniti come argomenti posizionali, non come argomenti nominati, quando si chiama la funzione; usare argomenti nominati per questi parametri genera un’eccezione TypeError.\nAd esempio, il tipo built-in int ha la seguente firma:\nint(x, /, base=10)\nQuando si chiama int, è necessario passare un valore per x e questo deve essere passato posizionalmente. base (usato quando x è una stringa da convertire in int) è opzionale e può essere passato sia posizionalmente che come argomento nominato. È un errore passare x come numero e anche passare base, ma la notazione non può catturare questa particolarità.\nEsempio di utilizzo del marcatore di parametri posizionali:\n1def funzione(x, /, base=10):\n2  return x + base\n\n3print(funzione(5))\n\n4print(funzione(5, base=2))\n\ntry:\n5  print(funzione(x=5))\n\nexcept TypeError as e:\n  print(e)\n\n1\n\nDefinizione della funzione funzione con un parametro posizionale x e un parametro nominato base con un valore predefinito.\n\n2\n\nLa funzione ritorna la somma di x e base.\n\n3\n\nChiamata a funzione con l’argomento posizionale 5. Utilizza il valore predefinito di base. Output: 15.\n\n4\n\nChiamata a funzione con l’argomento posizionale 5 e l’argomento nominato base=2. Output: 7.\n\n5\n\nChiamata a funzione con l’argomento nominato x=5. Genera un TypeError perché x deve essere fornito come argomento posizionale.\n\n\nSenza il marcatore posizionale /:\n1def funzione(x, base=10):\n2  return x + base\n\n3print(funzione(5))\n\n4print(funzione(5, 2))\n\n5print(funzione(5, base=2))\n\n6print(funzione(x=5))\n\n7print(funzione(x=5, base=2))\n\n1\n\nDefinizione della funzione funzione con x e base come argomenti.\n\n2\n\nLa funzione ritorna la somma di x e base.\n\n3\n\nChiamata a funzione con l’argomento posizionale 5. Utilizza il valore predefinito di base. Output: 15.\n\n4\n\nChiamata a funzione con gli argomenti posizionali 5 e 2. Output: 7.\n\n5\n\nChiamata a funzione con l’argomento posizionale 5 e l’argomento nominato base=2. Output: 7.\n\n6\n\nChiamata a funzione con l’argomento nominato x=5. Utilizza il valore predefinito di base. Output: 15.\n\n7\n\nChiamata a funzione con gli argomenti nominati x=5 e base=2. Output: 7.\n\n\n\n\n12.2.4 Collettori di argomenti\nPython consente di raccogliere argomenti che non corrispondono a parametri specifici utilizzando i collettori di argomenti posizionali (*nome) e nominati (**nome).\nUn collettore di argomenti posizionali crea una tupla, mentre un collettore di argomenti nominati crea un dizionario.\nEsempio di funzione con collettore di argomenti posizionali:\n1def somma_tutti(*numeri):\n2  print(type(numeri))\n\n3  return sum(numeri)\n\n4print(somma_tutti(1, 2, 3, 4))\n5print(somma_tutti())\n\n1\n\nDefinizione della funzione somma_tutti con il collettore di argomenti *numeri.\n\n2\n\nStampa il tipo di numeri.\n\n3\n\nRestituisce la somma di tutti i numeri.\n\n4\n\nChiamata a somma_tutti con gli argomenti 1, 2, 3, 4. Output: 10.\n\n5\n\nChiamata a somma_tutti senza argomenti. Output: 0.\n\n\nEsempio di funzione con collettore di argomenti nominati:\n1def stampa_dizionario(**diz):\n2  print(type(diz))\n\n3  for chiave, valore in diz.items():\n4    print(f\"{chiave}: {valore}\")\n\n5stampa_dizionario(nome=\"Mario\", eta=30)\n6stampa_dizionario(citta=\"Roma\", paese=\"Italia\")\n\n1\n\nDefinizione della funzione stampa_dizionario con il collettore di argomenti **diz.\n\n2\n\nStampa il tipo di diz.\n\n3\n\nItera sugli elementi del dizionario.\n\n4\n\nStampa ogni coppia chiave-valore.\n\n5\n\nChiamata a stampa_dizionario con argomenti nominati. Output: nome: Mario, eta: 30.\n\n6\n\nChiamata a stampa_dizionario con altri argomenti nominati. Output: citta: Roma, paese: Italia.\n\n\nEseguendo questi esempi, si può vedere che *numeri crea una tupla e **diz crea un dizionario.\nÈ anche possibile combinare i collettori di argomenti posizionali e nominati nella stessa funzione.\nEsempio di funzione con collettore di argomenti posizionali e nominati:\n1def mostra_tutti(*args, **kwargs):\n2  print(\"Argomenti posizionali:\", args)\n\n3  print(\"Argomenti nominati:\", kwargs)\n\n4mostra_tutti(1, 2, 3, nome=\"Alice\", eta=25)\n\n1\n\nDefinizione della funzione mostra_tutti con i collettori di argomenti *args e **kwargs.\n\n2\n\nStampa gli argomenti posizionali.\n\n3\n\nStampa gli argomenti nominati.\n\n4\n\nChiamata a mostra_tutti con argomenti posizionali e nominati. Output: Argomenti posizionali: (1, 2, 3), Argomenti nominati: {'nome': 'Alice', 'eta': 25}.\n\n\n\n\n12.2.5 Valori predefiniti mutabili\nQuando il valore predefinito di un parametro è un oggetto mutabile, e il corpo della funzione altera il parametro, le cose possono complicarsi. Questo perché il valore predefinito viene valutato una sola volta, quando la funzione è definita, non ogni volta che la funzione è chiamata. Di conseguenza, se il valore predefinito viene modificato (come nel caso di una lista alla quale vengono aggiunti elementi), la modifica persiste attraverso le chiamate successive alla funzione.\nEsempio di funzione con valore predefinito mutabile:\n1def aggiungi_elemento(elemento, lista=[]):\n2  lista.append(elemento)\n\n3  return lista\n\n4print(aggiungi_elemento(1))\n5print(aggiungi_elemento(2))\n\n1\n\nDefinizione della funzione aggiungi_elemento con il parametro lista avente un valore predefinito di lista vuota.\n\n2\n\nAggiunge l’elemento alla lista.\n\n3\n\nRestituisce la lista.\n\n4\n\nChiamata a aggiungi_elemento con l’argomento 1. Output: [1].\n\n5\n\nChiamata a aggiungi_elemento con l’argomento 2. Output: [1, 2].\n\n\nNel secondo caso, la lista restituita contiene [1, 2] anziché [2] perché il valore predefinito della lista è stato modificato dalla prima chiamata alla funzione e questa modifica persiste nella seconda chiamata. La lista usata come valore predefinito è la stessa in entrambe le chiamate.\nPer evitare questo comportamento, è meglio usare None come valore predefinito e creare una nuova lista all’interno della funzione se None è passato come argomento.\nEsempio di funzione con valore predefinito None:\n1def aggiungi_elemento(elemento, lista=None):\n2  if lista is None:\n3    lista = []\n\n4  lista.append(elemento)\n\n5  return lista\n\n6print(aggiungi_elemento(1))\n7print(aggiungi_elemento(2))\n\n1\n\nDefinizione della funzione aggiungi_elemento con il parametro lista avente un valore predefinito di None.\n\n2\n\nControlla se lista è None.\n\n3\n\nSe lista è None, crea una nuova lista vuota.\n\n4\n\nAggiunge l’elemento alla lista.\n\n5\n\nRestituisce la lista.\n\n6\n\nChiamata a aggiungi_elemento con l’argomento 1. Output: [1].\n\n7\n\nChiamata a aggiungi_elemento con l’argomento 2. Output: [2].\n\n\nIn questo caso, ogni chiamata alla funzione aggiungi_elemento crea una nuova lista se None è passato come valore predefinito, garantendo che ogni chiamata non influenzi le altre.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#attributi",
    "href": "seconda-parte-python-funzioni.html#attributi",
    "title": "12  Funzioni",
    "section": "12.3 Attributi",
    "text": "12.3 Attributi\nL’istruzione def imposta alcuni attributi di un oggetto funzione. Di seguito sono spiegati i principali attributi e come possono essere utilizzati.\n\n12.3.1 __name__\nQuesto attributo è l’identificatore che def utilizza come nome della funzione. Puoi riassegnare __name__ a qualsiasi valore stringa, ma se cerchi di dissociarlo, Python genererà un’eccezione TypeError.\nEsempio:\n1def saluta():\n2  print(\"Ciao!\")\n\n3print(saluta.__name__)\n\n4saluta.__name__ = \"greeting\"\n\n5print(saluta.__name__)\n\n1\n\nDefinizione della funzione saluta.\n\n2\n\nLa funzione stampa \"Ciao!\".\n\n3\n\nStampa il nome della funzione. Output: saluta.\n\n4\n\nCambia il nome della funzione in \"greeting\".\n\n5\n\nStampa il nuovo nome della funzione. Output: greeting.\n\n\nSe provi a dissociare __name__, otterrai un errore:\ndel saluta.__name__  # Questo genererà TypeError\n\n\n12.3.2 __defaults__\nQuesto attributo contiene una tupla dei valori predefiniti per i parametri nominati della funzione. Puoi riassegnare o dissociare liberamente questo attributo. Se la funzione non ha parametri nominati, __defaults__ sarà una tupla vuota.\nEsempio:\n1def saluta(nome=\"ospite\"):\n2  print(f\"Ciao, {nome}!\")\n\n3print(saluta.__defaults__)\n\n4saluta.__defaults__ = (\"amico\",)\n\n5saluta()\n\n1\n\nDefinizione della funzione saluta con un parametro nominato nome avente un valore predefinito.\n\n2\n\nLa funzione stampa un messaggio di saluto.\n\n3\n\nStampa i valori predefiniti dei parametri della funzione. Output: ('ospite',).\n\n4\n\nCambia il valore predefinito del parametro nome in \"amico\".\n\n5\n\nChiama la funzione senza argomenti. Output: Ciao, amico!.\n\n\nSe provi a dissociare __defaults__, l’attributo sarà semplicemente rimosso:\ndel saluta.__defaults__\n\n1print(saluta.__defaults__)\n\n1\n\nOutput: None.\n\n\nQuesti attributi permettono una flessibilità aggiuntiva nella manipolazione delle funzioni, offrendo modi per ispezionare e modificare il comportamento predefinito di una funzione.\n\n\n12.3.3 Docstring\nUn altro attributo della funzione è la stringa di documentazione, o docstring. Puoi utilizzare o riassegnare la docstring di una funzione come __doc__. Quando la prima istruzione nel corpo della funzione è un letterale stringa, il compilatore associa quella stringa come attributo docstring della funzione. Una regola simile si applica a classi e moduli. Le docstring possono estendersi su più righe fisiche, quindi è meglio specificarle in forma di stringa tra triple virgolette.\nLe docstring sono particolarmente utili perché vengono visualizzate dalla funzione built-in help() quando viene chiamata con il nome della funzione come argomento. Questo consente di fornire una descrizione dettagliata della funzione, delle sue aspettative di input e del suo comportamento, direttamente all’interno del codice.\nEsempio di docstring:\n1def somma_sequenza(*numeri):\n  \"\"\"Restituisce la somma di più argomenti numerici.\n  \n  Gli argomenti sono zero o più numeri.\n  Il risultato è la loro somma.\n2  \"\"\"\n3  return sum(numeri)\n\n4help(somma_sequenza)\n\n1\n\nDefinizione della funzione somma_sequenza con il collettore di argomenti *numeri.\n\n2\n\nDocstring della funzione che descrive il suo scopo e gli argomenti.\n\n3\n\nRestituisce la somma degli argomenti.\n\n4\n\nChiamata alla funzione help con l’argomento somma_sequenza, che visualizza la docstring della funzione.\n\n\nQuando si utilizza la funzione help(), la docstring viene visualizzata, offrendo informazioni utili sull’utilizzo della funzione:\nHelp on function somma_sequenza in module __main__:\n\nsomma_sequenza(*numeri)\n  Restituisce la somma di più argomenti numerici.\n\n  Gli argomenti sono zero o più numeri.\n  Il risultato è la loro somma.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#annotazioni",
    "href": "seconda-parte-python-funzioni.html#annotazioni",
    "title": "12  Funzioni",
    "section": "12.4 Annotazioni",
    "text": "12.4 Annotazioni\nOgni parametro in una clausola def può essere annotato con un’espressione arbitraria. Puoi anche annotare il valore di ritorno della funzione utilizzando la forma -&gt; espressione tra la parentesi ) della clausola def e i due punti : che terminano la clausola def. Queste annotazioni sono memorizzate nell’attributo __annotations__ della funzione e possono essere utilizzate per migliorare la leggibilità del codice e per il type hinting.\nEsempio di annotazioni delle funzioni:\n1def f(a: 'foo', b) -&gt; 'bar':\n2  pass\n\n3print(f.__annotations__)\n\n1\n\nDefinizione della funzione f con annotazioni per i parametri a e il valore di ritorno.\n\n2\n\nCorpo della funzione vuoto.\n\n3\n\nStampa le annotazioni della funzione f. Output: {'a': 'foo', 'return': 'bar'}.\n\n\nIl type hinting è una applicazione pratica delle annotazioni, che consente di specificare i tipi di variabili, parametri e valori di ritorno, fornendo informazioni utili per il controllo dei tipi a tempo di esecuzione o per strumenti di analisi statica del codice. Il type hinting può essere particolarmente utile per migliorare la leggibilità del codice e facilitare la rilevazione di errori.\nDi seguito, un esempio pratico che utilizza il type hinting:\n1def somma_numeri(numeri: list[int]) -&gt; int:\n2  \"\"\"Restituisce la somma di una lista di numeri interi.\"\"\"\n3  return sum(numeri)\n\n4print(somma_numeri([1, 2, 3, 4]))\n5print(somma_numeri.__annotations__)\n\n1\n\nDefinizione della funzione somma_numeri con annotazioni dei tipi per il parametro numeri e il valore di ritorno.\n\n2\n\nDocstring della funzione che descrive il suo scopo e gli argomenti.\n\n3\n\nRestituisce la somma degli elementi nella lista numeri.\n\n4\n\nChiamata alla funzione somma_numeri con una lista di numeri interi. Output: 10.\n\n5\n\nStampa le annotazioni della funzione somma_numeri. Output: {'numeri': list[int], 'return': &lt;class 'int'&gt;}.\n\n\nPossiamo utilizzare annotazioni per funzioni che accettano e restituiscono tipi più complessi, come dizionari o tuple.\nEsempio:\n1def processa_dati(dati: dict[str, tuple[int, int]]) -&gt; dict[str, int]:\n2  \"\"\"Elabora un dizionario di tuple e restituisce un dizionario di somme.\"\"\"\n3  risultato = {}\n\n4  for chiave, (val1, val2) in dati.items():\n5    risultato[chiave] = val1 + val2\n      \n6  return risultato\n\n7dati_input = {\"a\": (1, 2), \"b\": (3, 4)}\n\n8print(processa_dati(dati_input))\n\n9print(processa_dati.__annotations__)\n\n1\n\nDefinizione della funzione processa_dati con annotazioni dei tipi per il parametro dati e il valore di ritorno.\n\n2\n\nDocstring della funzione che descrive il suo scopo e gli argomenti.\n\n3\n\nInizializzazione del dizionario risultato.\n\n4\n\nIterazione sugli elementi del dizionario dati.\n\n5\n\nCalcola la somma dei valori nella tupla e la assegna al dizionario risultato.\n\n6\n\nRestituisce il dizionario risultato.\n\n7\n\nDefinizione di un dizionario di input dati_input.\n\n8\n\nChiamata alla funzione processa_dati con il dizionario di input. Output: {'a': 3, 'b': 7}.\n\n9\n\nStampa le annotazioni della funzione processa_dati. Output: {'dati': dict[str, tuple[int, int]], 'return': dict[str, int]}.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#listruzione-return",
    "href": "seconda-parte-python-funzioni.html#listruzione-return",
    "title": "12  Funzioni",
    "section": "12.5 L’Istruzione return",
    "text": "12.5 L’Istruzione return\nLa parola chiave return può essere utilizzata per terminare una funzione e opzionalmente restituire un valore. Quando una funzione non include una istruzione return, restituisce implicitamente None.\nEsempio di utilizzo di return:\n1def quadrato(x):\n2  return x * x\n\n3print(quadrato(5))\n\n1\n\nDefinizione della funzione quadrato con il parametro x.\n\n2\n\nRestituisce il quadrato di x.\n\n3\n\nChiamata alla funzione quadrato con l’argomento 5. Output: 25.\n\n\nEsempio di funzione che restituisce None:\n1def saluta():\n2  print(\"Ciao!\")\n\n3risultato = saluta()\n4print(risultato)\n\n1\n\nDefinizione della funzione saluta.\n\n2\n\nStampa \"Ciao!\".\n\n3\n\nChiamata alla funzione saluta e assegnazione del risultato a risultato.\n\n4\n\nStampa il valore di risultato. Output: Ciao! seguito da None.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#chiamate",
    "href": "seconda-parte-python-funzioni.html#chiamate",
    "title": "12  Funzioni",
    "section": "12.6 Chiamate",
    "text": "12.6 Chiamate\nUna chiamata di funzione è un’espressione con la seguente sintassi:\noggetto_funzione(argomenti)\noggetto_funzione può essere qualsiasi riferimento a un oggetto funzione (o altro oggetto chiamabile); più spesso, è solo il nome della funzione. Le parentesi denotano l’operazione di chiamata della funzione stessa. argomenti, nel caso più semplice, è una serie di zero o più espressioni separate da virgole ,, che forniscono i valori per i parametri corrispondenti della funzione.\nEsempio di chiamata di funzione:\n1def saluta(nome):\n2  print(f\"Ciao, {nome}!\")\n\n3saluta(\"Luigi\")\n\n1\n\nDefinizione della funzione saluta con il parametro nome.\n\n2\n\nStampa un messaggio di saluto con il nome.\n\n3\n\nChiamata a saluta con l’argomento “Luigi”. Output: Ciao, Luigi!.\n\n\n\n12.6.1 Argomenti\nGli argomenti possono essere di due tipi. Gli argomenti posizionali sono semplici espressioni; gli argomenti nominati assumono la forma:\nidentificatore=espressione  \nÈ un errore di sintassi che gli argomenti nominati precedano quelli posizionali in una chiamata di funzione. Zero o più argomenti posizionali possono essere seguiti da zero o più argomenti nominati. Ogni argomento posizionale fornisce il valore per il parametro che corrisponde a esso per posizione (ordine) nella definizione della funzione.\nEsempio di funzione con argomenti posizionali e nominati:\n1def f(a, b, c=23, d=42, *x):\n2  print(a, b, c, d, x)\n\n3f(1, 2, 3, 4, 5, 6)\n\n1\n\nDefinizione della funzione f con parametri posizionali, nominati e un collettore di argomenti.\n\n2\n\nStampa i valori dei parametri e degli argomenti.\n\n3\n\nChiamata a f con argomenti. Output: 1 2 3 4 (5, 6).\n\n\n\n\n12.6.2 Associazione degli argomenti ai parametri\nUna chiamata deve fornire un argomento per tutti i parametri posizionali obbligatori e può farlo per i parametri nominati che non sono esclusivamente nominati.\nLa corrispondenza avviene come segue:\n\nI parametri nella forma *espressione catturano tutti gli argomenti posizionali rimanenti come una tupla.\n1def f(a, b, *args):\n  print(a, b, args)\n\n2f(1, 2, 3, 4, 5)\n\n1\n\nFunzione con tre parametri posizionali di cui uno è il collettore.\n\n2\n\nChiamata con 5 argomenti posizionali.\n\n\nI parametri nella forma **espressione catturano tutti gli argomenti nominati rimanenti come un dizionario.\n1def f(a, b, **kwargs):\n  print(a, b, kwargs)\n\n2f(1, 2, c=3, d=4)\n\n1\n\nFunzione con due parametri posizionali e un collettore di argomenti nominati.\n\n2\n\nChiamata con due argomenti posizionali e due argomenti nominati.\n\n\nSupponiamo che la funzione abbia N parametri posizionali e la chiamata abbia M argomenti posizionali:\n\nQuando M &lt;= N, tutti gli argomenti posizionali vengono associati ai primi M parametri posizionali; i parametri posizionali rimanenti, se presenti, devono essere associati tramite argomenti nominati o avere valori predefiniti.\n1def f(a, b, c=3):\n  print(a, b, c)\n\n2f(1, 2)\n\n1\n\nFunzione con due parametri posizionali obbligatori e uno opzionale con valore predefinito.\n\n2\n\nChiamata con due argomenti posizionali.\n\n\nQuando M &gt; N, i rimanenti argomenti posizionali devono essere catturati da *espressione.\n1def f(a, b, *args):\n  print(a, b, args)\n\n2f(1, 2, 3, 4)\n\n1\n\nFunzione con due parametri posizionali obbligatori e un parametro *args per raccogliere argomenti posizionali rimanenti.\n\n2\n\nChiamata con quattro argomenti posizionali.\n\n\nQuando M &gt; N e non c’è un parametro *espressione, Python solleva un’eccezione TypeError.\n1def f(a, b):\n  print(a, b)\n\ntry:\n2  f(1, 2, 3)\n\nexcept TypeError as e:\n3  print(e)\n\n1\n\nFunzione con due parametri posizionali obbligatori.\n\n2\n\nChiamata con tre argomenti posizionali, che solleva un TypeError.\n\n3\n\nOutput dell’eccezione.\n\n\n\nGli argomenti nominati vengono quindi associati, nell’ordine delle occorrenze degli argomenti nella chiamata, ai parametri corrispondenti per nome. I tentativi di riassociare un nome di parametro già associato sollevano un’eccezione TypeError.\n1def f(a, b, c):\n  print(a, b, c)\n\n2f(a=1, b=2, c=3)\n\ntry:\n3  f(a=1, b=2, a=3)\n\nexcept TypeError as e:\n4  print(e)\n\n1\n\nFunzione con tre parametri posizionali obbligatori.\n\n2\n\nChiamata con tre argomenti nominati.\n\n3\n\nChiamata con un argomento nominato duplicato, che solleva un TypeError.\n\n4\n\nOutput dell’eccezione.\n\n\nSe a questo punto rimangono argomenti nominati non associati:\n\nQuando la firma della funzione include un parametro **nome, l’interprete crea un dizionario con coppie chiave/valore (nome_argomento, valore_argomento) e lo associa a nome nello spazio dei nomi della chiamata alla funzione.\n1def f(a, **kwargs):\n  print(a, kwargs)\n\n2f(1, b=2, c=3)\n\n1\n\nFunzione con un parametro posizionale obbligatorio e un parametro **kwargs per raccogliere argomenti nominati rimanenti.\n\n2\n\nChiamata con un argomento posizionale e due argomenti nominati.\n\n\nIn assenza di un tale parametro, Python solleva un’eccezione TypeError.\n1def f(a):\n    print(a)\n\ntry:\n2    f(a=1, b=2)\nexcept TypeError as e:\n3    print(e)\n\n1\n\nFunzione con un parametro posizionale obbligatorio.\n\n2\n\nChiamata con un argomento posizionale e uno nominato, che solleva un TypeError.\n\n3\n\nOutput dell’eccezione.\n\n\n\nI parametri nominati rimanenti non associati vengono associati ai loro valori predefiniti.\n1def f(a, b=2, c=3):\n    print(a, b, c)\n\n2f(1)\n3f(1, c=4)\n\n1\n\nFunzione con un parametro posizionale obbligatorio e due parametri con valori predefiniti.\n\n2\n\nChiamata con un argomento posizionale.\n\n3\n\nChiamata con un argomento posizionale e uno nominato.\n\n\n\nA questo punto, lo spazio dei nomi della chiamata alla funzione è completamente popolato e l’interprete esegue il corpo della funzione utilizzando quello spazio dei nomi come spazio dei nomi locale per la funzione.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#spazi-di-nomi",
    "href": "seconda-parte-python-funzioni.html#spazi-di-nomi",
    "title": "12  Funzioni",
    "section": "12.7 Spazi di nomi",
    "text": "12.7 Spazi di nomi\nI parametri di una funzione, insieme a qualsiasi nome che viene associato (attraverso un’assegnazione o altre istruzioni di binding, come def) nel corpo della funzione, costituiscono lo spazio dei nomi locale della funzione, noto anche come ambito locale. Ognuna di queste variabili è nota come variabile locale della funzione.\nLe variabili che non sono locali sono conosciute come variabili globali (in assenza di definizioni di funzioni annidate, di cui parleremo a breve). Le variabili globali sono attributi dell’oggetto modulo. Ogni volta che una variabile locale di una funzione ha lo stesso nome di una variabile globale, quel nome, all’interno del corpo della funzione, si riferisce alla variabile locale, non a quella globale. Esprimiamo questo dicendo che la variabile locale nasconde la variabile globale con lo stesso nome in tutto il corpo della funzione.\n\n12.7.1 L’istruzione global\nPer impostazione predefinita, qualsiasi variabile associata in un corpo di funzione è locale alla funzione. Se una funzione ha bisogno di associare o riassociare alcune variabili globali (pratica non consigliata!), la prima istruzione del corpo della funzione deve essere:\nglobal identificatori\ndove identificatori è uno o più identificatori separati da virgole ,. Gli identificatori elencati in un’istruzione global si riferiscono alle variabili globali (cioè attributi dell’oggetto modulo) che la funzione deve associare o riassociare.\nEsempio di utilizzo di global:\n1_count = 0\n\n2def contatore():\n3  global _count\n\n4  _count += 1\n\n5  return _count\n\n6print(contatore())\n7print(contatore())\n\n1\n\nVariabile globale _count inizializzata a 0.\n\n2\n\nDefinizione della funzione contatore.\n\n3\n\nDichiarazione di _count come variabile globale.\n\n4\n\nIncremento della variabile globale _count.\n\n5\n\nRestituzione del valore di _count.\n\n6\n\nChiamata a contatore. Output: 1.\n\n7\n\nChiamata a contatore nuovamente. Output: 2.\n\n\nSenza l’istruzione global, la funzione contatore solleverebbe un’eccezione UnboundLocalError quando viene chiamata, perché _count sarebbe una variabile locale non inizializzata (non associata). Sebbene l’istruzione global consenta questo tipo di programmazione, questo stile è inefficace e sconsigliato. Come menzionato in precedenza, quando si desidera raggruppare uno stato e un comportamento, i meccanismi orientati agli oggetti sono generalmente i migliori.\n\n\n12.7.2 Funzioni annidate e ambiti annidati\nUn’istruzione def all’interno del corpo di una funzione definisce una funzione annidata, e la funzione il cui corpo include la def è conosciuta come funzione esterna a quella annidata. Il codice nel corpo di una funzione annidata può accedere (ma non riassociare) variabili locali di una funzione esterna, note anche come variabili libere della funzione annidata.\nEsempio di funzione annidata che accede a variabili esterne:\n1def esterna(a, b, c):\n2  def annidata(x):\n3    return (x * 100.0) / (a + b + c)\n\n4  print('Percentuali:', annidata(a), annidata(b), annidata(c))\n\n5esterna(10, 20, 30)\n\n1\n\nDefinizione della funzione esterna esterna.\n\n2\n\nDefinizione della funzione annidata annidata.\n\n3\n\nLa funzione annidata accede alle variabili a, b e c della funzione esterna.\n\n4\n\nStampa le percentuali calcolate dalla funzione annidata.\n\n5\n\nChiamata alla funzione esterna con argomenti 10, 20, 30.\n\n\nUna funzione annidata che accede ai valori dalle variabili locali delle funzioni contenenti è anche nota come chiusura (closure).\nEsempio di chiusura:\n1def crea_sommatore(augendo):\n2  def somma(addendo):\n3    return addendo + augendo\n\n4  return somma\n\n5somma5 = crea_sommatore(5)\n6somma9 = crea_sommatore(9)\n\n7print(somma5(10))\n8print(somma9(10))\n\n1\n\nDefinizione della funzione esterna crea_sommatore.\n\n2\n\nDefinizione della funzione annidata somma.\n\n3\n\nLa funzione somma accede alla variabile augendo della funzione esterna.\n\n4\n\nLa funzione esterna crea_sommatore ritorna la funzione somma.\n\n5\n\nCreazione di una funzione che somma 5 a un numero.\n\n6\n\nCreazione di una funzione che somma 9 a un numero.\n\n7\n\nChiamata alla funzione somma5 con argomento 10. Output: 15.\n\n8\n\nChiamata alla funzione somma9 con argomento 10. Output: 19.\n\n\nLa parola chiave nonlocal funziona in modo simile a global, ma si riferisce a un nome nello spazio dei nomi di una funzione che circonda lessicamente.\nEsempio di nonlocal:\n1def crea_contatore():\n2  conteggio = 0\n  \n3  def contatore():\n4    nonlocal conteggio\n\n5    conteggio += 1\n    \n6    return conteggio\n  \n7  return contatore\n\n8c1 = crea_contatore()\n9c2 = crea_contatore()\n\n10print(c1(), c1(), c1())\n11print(c2(), c2())\n12print(c1(), c2(), c1())\n\n1\n\nDefinizione della funzione crea_contatore.\n\n2\n\nInizializzazione della variabile conteggio.\n\n3\n\nDefinizione della funzione annidata contatore.\n\n4\n\nDichiarazione di conteggio come nonlocal.\n\n5\n\nIncremento della variabile conteggio.\n\n6\n\nRestituzione del valore di conteggio.\n\n7\n\nRestituzione della funzione contatore.\n\n8\n\nCreazione di un contatore c1.\n\n9\n\nCreazione di un contatore c2.\n\n10\n\nChiamata a c1 tre volte. Output: 1 2 3.\n\n11\n\nChiamata a c2 due volte. Output: 1 2.\n\n12\n\nChiamata a c1 e c2 alternata. Output: 4 3 5.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-funzioni.html#espressioni-lambda",
    "href": "seconda-parte-python-funzioni.html#espressioni-lambda",
    "title": "12  Funzioni",
    "section": "12.8 Espressioni lambda",
    "text": "12.8 Espressioni lambda\nSe il corpo di una funzione è una singola espressione return, possiamo (opzionalmente) scegliere di sostituire la funzione con la speciale forma di espressione lambda:\nlambda parametri: espressione\nUn’espressione lambda è l’equivalente anonimo di una funzione normale il cui corpo è una singola istruzione return. La sintassi lambda non utilizza la parola chiave return. Possiamo usare un’espressione lambda ovunque potremmo usare un riferimento a una funzione.\nEsempio di utilizzo di una lambda:\n1numeri = [5, 2, 8, 3]\n\n2ordinati = sorted(numeri, key=lambda x: x)\n\n3print(ordinati)\n\n1\n\nLista di numeri.\n\n2\n\nUtilizzo di una lambda per ordinare la lista.\n\n3\n\nOutput: [2, 3, 5, 8].\n\n\nLe espressioni lambda possono essere utili quando desideriamo utilizzare una funzione estremamente semplice come argomento o valore di ritorno.\nAltro esempio:\n1calcola_area = lambda lunghezza, larghezza: lunghezza * larghezza\n\n2area1 = calcola_area(5, 10)\n3area2 = calcola_area(7, 3)\n\n4print(f\"L'area del rettangolo 1 è: {area1}\")\n5print(f\"L'area del rettangolo 2 è: {area2}\")\n\n1\n\nDefinisce una lambda che prende due parametri, lunghezza e larghezza, e ritorna il loro prodotto, che rappresenta l’area del rettangolo.\n\n2\n\nUtilizza la lambda per calcolare l’area di un rettangolo con lunghezza 5 e larghezza 10.\n\n3\n\nUtilizza la lambda per calcolare l’area di un rettangolo con lunghezza 7 e larghezza 3.\n\n4\n\nStampa l’area del primo rettangolo: \"L'area del rettangolo 1 è: 50\".\n\n5\n\nStampa l’area del secondo rettangolo: \"L'area del rettangolo 2 è: 21\".\n\n\nMentre lambda può essere utile, def è solitamente preferibile: è più generale e ti aiuta a rendere il codice più leggibile, poiché si può scegliere un nome chiaro per la funzione.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funzioni</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html",
    "href": "seconda-parte-python-esercizi.html",
    "title": "13  Esercizi",
    "section": "",
    "text": "13.1 ➀ Python come calcolatrice\nPrimi esperimenti con Python.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#python-come-calcolatrice",
    "href": "seconda-parte-python-esercizi.html#python-come-calcolatrice",
    "title": "13  Esercizi",
    "section": "",
    "text": "13.1.1 Numeri interi e in virgola mobile\n\nProblemaSoluzione\n\n\nUsare gli operatori matematici su costanti numeriche e osservare i risultati e gli errori nel REPL, perché è più immediato rispetto all’esecuzione completa del programma e permette di prendere dimistichezza velocemente con dei costrutti di base del linguaggio.\n\n\nIl codice seguente può essere eseguito sia nel REPL, riga per riga, sia come programma.\n\n\n\n\n\n\nSuggerimento\n\n\n\nUsando il REPL, basterà digitare l’espressione senza assegnamento per ottenere il risultato.\n\n\n# Moltiplicazione\nx = 5 * 2\nprint(x)\n\nx = 5 * 2.\nprint(x) # Cosa notiamo?\n\n# Divisione in virgola mobile\nx = 5 / 2\nprint(x)\n\nx = 4 / 2\nprint(x) # Cosa notiamo?\n\nx = 4 / 2.\nprint(x)\n\n# Confronto\nx = 5 &gt; 2\nprint(x)\n\nx = 5 &gt; 2.\nprint(x) # Cosa notiamo?\n\n# Diversità\nx = 4 != 4.\nprint(x) # Cosa notiamo?\n\nx = 0 != (1 - 1)\nprint(x) # Cosa notiamo?\n\n\n\n\n\n13.1.2 Stringhe\n\nProblemaSoluzione\n\n\nUsare gli operatori su stringhe, sempre nel REPL.\n\n\ns = \"Hello\" + ' ' + 'World!'\nprint(s)\n\nss = s\n\nss *= 2\nprint(ss)\nprint(s) # Cosa notiamo per s e ss?\n\n# Appartenenza\nb = 'el' in s\nprint(b) \n\nb = 'oo' not in s\nprint(b)\n\n# Confronto\nb = \"Ciao Mondo!\" &lt; s \nprint(b) # È rispettato l'ordine lessicografico?\n\nl_s= len(s)\nprint(l_s)\n\n# Slicing della stringa come contenitore di caratteri\ns_ = ss[:l_s] \nprint(s_) \n\nl_ss = len(ss) \nprint(l_ss)\n\n# Modo alternativo di ottenere la stringa originale solo usando ss\ns_ = ss[:int(l_ss / 2)] \nprint(s_) \n\n# Metodo per rendere la stringa in maiuscolo\nsu = s.upper()\nprint(su)\n\n# Uguaglianza\nb = s == su\nprint(b) # Cosa notiamo?\n\n\n\n\n\n13.1.3 Espressioni\n\nProblemaSoluzione\n\n\nCostruire delle espressioni per comprendere come mischiare numeri e stringhe, la precedenza degli operatori e le conversioni di tipo, sempre nel REPL.\n\n\nn = 42\ns = \"42\"\n\n# Congiunzione\nb = n and s\nprint(b) # Cosa notiamo?\n\n# Disgiunzione\nb = n or s\nprint(b) \n\n# Negazione e congiunzione\nb = n and not s\nprint(b) # Cosa notiamo?\n\n# Conversione di tipo in stringa e appartenenza\nb = str(2) in s\nprint(b)\n\n# Conversione di tipo in intero e divisione\nb = int(s) / 2\nprint(b)\n\n# Espressione con precedenza data dall'ordine degli operatori \ne = 2 + n * 3\nprint(e)\n\n# Espressione con precedenza modificata colle parentesi \ne = (2 + n) * 3\nprint(e) # Cosa notiamo?",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#numeri-pari-o-dispari",
    "href": "seconda-parte-python-esercizi.html#numeri-pari-o-dispari",
    "title": "13  Esercizi",
    "section": "13.2 ➁ Numeri pari o dispari",
    "text": "13.2 ➁ Numeri pari o dispari\nDefinire una funzione che prende in input un numero intero e restituisce una stringa di Pari o Dispari.\n\n13.2.1 Riscaldamento\n\nProblemaSoluzione\n\n\nSperimentiamo l’operatore modulo %, che restituisce il resto della divisione di due interi, con diversi input sia pari che dispari usando un test condizionale.\n\n\nn = 42\n\nif n % 2 == 0:\n  print(\"Pari\")\n\nelse:\n  print(\"Dispari\")\n\n\n\n\n\n13.2.2 Svolgimento\n\nProblemaSoluzione 1Soluzione 2Soluzione 3Soluzione 4\n\n\nInserire le istruzioni in una funzione che prende in input un parametro, il numero intero, e restituisce una stringa, Pari o Dispari. Sperimentare soluzioni diverse.\n\n\nUsiamo l’operatore modulo % che restituisce il resto della divisione di due interi all’interno di una funzione. Questa prende in input un numero intero e restituisce la stringa richiesta.\ndef pari_o_dispari(n):\n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)\n\n\nUsiamo l’operatore modulo % per il test di parità sul numero intero e la funzione isinstance per verificare il tipo in input.\ndef pari_o_dispari(n):\n  if not isinstance(n, int):\n    return \"Errore: l'input deve essere un numero intero!\"\n    \n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)\n\n\nUsiamo l’operatore modulo %, la funzione isinstance per verificare il tipo in input e assert in caso di input non corretto.\ndef pari_o_dispari(n):\n  assert isinstance(n, int), \\\n    \"Errore: l'input deve essere un numero intero!\"\n    \n  if n % 2 == 0:\n    return \"Pari\"\n\n  else:\n    return \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)\n\n'''\nrisultato = pari_o_dispari(\"42\")\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73.)\n\nprint(risultato)\n'''\n\n\nUsiamo la funzione divmod che restituisce il quoziente e il resto della divisione di due interi. Per ottenere documentazione su essa basterà digitare help(divmod) nel REPL.\ndef pari_o_dispari(n):\n  _, remainder = divmod(n, 2)\n\n  return \"Pari\" if remainder == 0 else \"Dispari\"\n\nrisultato = pari_o_dispari(42)\n\nprint(risultato)\n\nrisultato = pari_o_dispari(73)\n\nprint(risultato)",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#rimozione-di-duplicati-da-una-lista-preservando-lordinamento",
    "href": "seconda-parte-python-esercizi.html#rimozione-di-duplicati-da-una-lista-preservando-lordinamento",
    "title": "13  Esercizi",
    "section": "13.3 ➁ Rimozione di duplicati da una lista preservando l’ordinamento",
    "text": "13.3 ➁ Rimozione di duplicati da una lista preservando l’ordinamento\n\nProblemaSoluzione 1Soluzione 2Soluzione 3➂ Soluzione 4\n\n\nScrivere una funzione che prende in input una lista e ne rimuove i duplicati, preservando l’ordinamento.\n\n\nUsiamo un ciclo for per iterare attraverso la lista originale e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti in essa, preservando così l’ordine originale.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n\n  for elemento in lista:\n    if elemento not in lista_senza_duplicati:\n      lista_senza_duplicati.append(elemento)\n\n  return lista_senza_duplicati\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un ciclo while per iterare attraverso la lista originale. Un set viene utilizzato per memorizzare gli elementi già visti e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti nel set.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n\n  visti = set()\n\n  i = 0\n  while i &lt; len(lista):\n    if lista[i] not in visti:\n      lista_senza_duplicati.append(lista[i])\n\n      visti.add(lista[i])\n\n    i += 1\n\n  return lista_senza_duplicati\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un dizionario per memorizzare gli elementi unici, sfruttando il fatto che i dizionari preservano l’ordine di inserimento a partire da Python 3.7. Gli elementi vengono aggiunti al dizionario come chiavi, e infine si restituisce la lista delle chiavi del dizionario.\ndef rimuovi_duplicati(lista):\n  return list(dict.fromkeys(lista))\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUtilizziamo una list comprehension per creare una nuova lista. Un set viene usato per tenere traccia degli elementi già visti, e gli elementi vengono aggiunti alla lista finale solo se non sono già presenti nel set.\ndef rimuovi_duplicati(lista):\n    visti = set()\n    \n    lista_senza_duplicati = [elemento \n                             for elemento in lista \n                             if elemento not in visti and not visti.add(elemento)]\n    \n    return lista_senza_duplicati\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#rimozione-di-duplicati-da-una-lista-e-ordinamento",
    "href": "seconda-parte-python-esercizi.html#rimozione-di-duplicati-da-una-lista-e-ordinamento",
    "title": "13  Esercizi",
    "section": "13.4 ➁ Rimozione di duplicati da una lista e ordinamento",
    "text": "13.4 ➁ Rimozione di duplicati da una lista e ordinamento\n\nProblemaSoluzione 1Soluzione 2Soluzione 3➂ Soluzione 4\n\n\nScrivere una funzione che prende in input una lista e ne rimuove i duplicati, ordinando il risultato.\n\n\nUsiamo un ciclo for per iterare attraverso la lista originale e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti in essa. Dopo aver rimosso i duplicati, ordiniamo la lista risultante.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n\n  for elemento in lista:\n    if elemento not in lista_senza_duplicati:\n      lista_senza_duplicati.append(elemento)\n\n  return sorted(lista_senza_duplicati)\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un ciclo while per iterare attraverso la lista originale. Un set viene utilizzato per memorizzare gli elementi già visti e una lista di appoggio per memorizzare gli elementi unici. Gli elementi vengono aggiunti alla lista di appoggio solo se non sono già presenti nel set. Dopo aver rimosso i duplicati, ordiniamo la lista risultante.\ndef rimuovi_duplicati(lista):\n  lista_senza_duplicati = []\n  visti = set()\n\n  i = 0\n  while i &lt; len(lista):\n    if lista[i] not in visti:\n      lista_senza_duplicati.append(lista[i])\n\n      visti.add(lista[i])\n\n    i += 1\n\n  return sorted(lista_senza_duplicati)\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUsiamo un dizionario per memorizzare gli elementi unici, sfruttando il fatto che i dizionari preservano l’ordine di inserimento a partire da Python 3.7. Gli elementi vengono aggiunti al dizionario come chiavi. Dopo aver rimosso i duplicati, ordiniamo la lista delle chiavi del dizionario.\ndef rimuovi_duplicati(lista):\n  return sorted(dict.fromkeys(lista))\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista)) \n\n\nUtilizziamo una list comprehension per creare una nuova lista. Un set viene usato per tenere traccia degli elementi già visti, e gli elementi vengono aggiunti alla lista finale solo se non sono già presenti nel set. Dopo aver rimosso i duplicati, ordiniamo la lista risultante.\ndef rimuovi_duplicati(lista):\n  visti = set()\n\n  lista_senza_duplicati = [x for x in lista if not (x in visti or visti.add(x))]\n\n  return sorted(lista_senza_duplicati)\n\n# Esempio di utilizzo\nlista = [4, 2, 2, 3, 1, 4, 5]\n\nprint(rimuovi_duplicati(lista))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#calcolo-del-fattoriale-di-un-numero",
    "href": "seconda-parte-python-esercizi.html#calcolo-del-fattoriale-di-un-numero",
    "title": "13  Esercizi",
    "section": "13.5 ➁ Calcolo del fattoriale di un numero",
    "text": "13.5 ➁ Calcolo del fattoriale di un numero\n\nProblemaSoluzione 1Soluzione 2➂ Soluzione 3➃ Soluzione 4\n\n\nScrivere una funzione che prende in input un numero intero positivo e restituisce il suo fattoriale.\n\n\n\n\n\n\nSuggerimento\n\n\n\nIl fattoriale di un numero n è il prodotto di tutti i numeri interi positivi minori o uguali a n ed è denotato come n!.\n\n\n\n\nUsiamo un ciclo for per calcolare il fattoriale. Partiamo da 1 e moltiplichiamo progressivamente tutti i numeri fino a n.\ndef fattoriale(n):\n  risultato = 1\n\n  for i in range(1, n + 1):\n    risultato *= i\n\n  return risultato\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\nUsiamo un ciclo while per calcolare il fattoriale. Partiamo da 1 e moltiplichiamo progressivamente tutti i numeri fino a n, utilizzando una variabile di iterazione.\ndef fattoriale(n):\n  risultato = 1\n  i = 1\n\n  while i &lt;= n:\n    risultato *= i\n\n    i += 1\n\n  return risultato\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\nUtilizziamo la ricorsione per calcolare il fattoriale. La funzione richiama se stessa riducendo il problema fino a raggiungere il caso base n = 1.\ndef fattoriale(n):\n  if n == 0 or n == 1:\n    return 1\n\n  else:\n    return n * fattoriale(n - 1)\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.\n\n\n\n\nUsiamo la funzione reduce del modulo functools per calcolare il fattoriale. Questa soluzione utilizza un approccio funzionale per ridurre una sequenza di numeri a un singolo valore.\nfrom functools import reduce\n\ndef fattoriale(n):\n  return reduce(lambda x, y: x * y, range(1, n + 1), 1)\n\n# Esempio di utilizzo\nnumero = 5\n\n1print(fattoriale(numero))\n\n1\n\nOutput: 120.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#contare-le-parole-in-una-frase-in-modo-semplificato",
    "href": "seconda-parte-python-esercizi.html#contare-le-parole-in-una-frase-in-modo-semplificato",
    "title": "13  Esercizi",
    "section": "13.6 ➁ Contare le parole in una frase in modo semplificato",
    "text": "13.6 ➁ Contare le parole in una frase in modo semplificato\n\nProblemaSoluzione 1Soluzione 2➂ Soluzione 3➂ Soluzione 4\n\n\nScrivere una funzione che prende in input una stringa contenente una frase e restituisce un dizionario con il conteggio di ciascuna parola nella frase. Le frasi non devono contenere punteggiatura e il confronto tiene conto della differenza tra lettere maiuscole e minuscole.\n\n\nUsiamo un ciclo for per iterare attraverso le parole della frase, aggiornando il conteggio di ciascuna parola in un dizionario.\ndef conta_parole(frase):\n  parole = frase.split()\n  conteggio = {}\n  \n  for parola in parole:\n    if parola in conteggio:\n      conteggio[parola] += 1\n\n    else:\n      conteggio[parola] = 1\n\n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))  # &lt;1&gt; # \n\nOutput: {'ciao': 3, 'come': 1, 'stai': 1}.\n\n\n\nUsiamo il metodo get del dizionario per aggiornare il conteggio delle parole in un dizionario.\ndef conta_parole(frase):\n  parole = frase.split()\n  conteggio = {}\n  \n  for parola in parole:\n    conteggio[parola] = conteggio.get(parola, 0) + 1\n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))  \n\n\nUsiamo il modulo collections e il defaultdict per semplificare il conteggio delle parole.\nfrom collections import defaultdict\n\ndef conta_parole(frase):\n  parole = frase.split()\n  conteggio = defaultdict(int)\n\n  for parola in parole:\n    conteggio[parola] += 1\n      \n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))  \n\n\nUsiamo il modulo collections e Counter per contare le parole nella frase in modo conciso.\nfrom collections import Counter\n\ndef conta_parole(frase):\n  parole = frase.split()\n\n  conteggio = Counter(parole)\n\n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"ciao ciao come stai ciao\"\n\nprint(conta_parole(frase))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#contare-le-parole-in-una-frase-con-esattezza",
    "href": "seconda-parte-python-esercizi.html#contare-le-parole-in-una-frase-con-esattezza",
    "title": "13  Esercizi",
    "section": "13.7 ➂ Contare le parole in una frase con esattezza",
    "text": "13.7 ➂ Contare le parole in una frase con esattezza\n\nProblemaSoluzione 1Soluzione 2Soluzione 3Soluzione 4\n\n\nScrivere una funzione che prende in input una stringa contenente una frase e un flag maiuscolo_minuscolo che controlla se il conteggio delle parole debba tener conto del maiuscolo o minuscolo. Inoltre considera parole senza terner conto di eventuale punteggiatura nel calcolo. La funzione restituisce un dizionario con il conteggio di ciascuna parola nella frase.\n\n\n\n\n\n\nSuggerimento\n\n\n\nSi può usare string.punctuation del modulo string che contiene tutti i caratteri di punteggiatura disponibili in Python. Include caratteri come !\"#$%&'()*+,-./:;&lt;=&gt;?@[\\]^_``{|}~.\n\n\n\n\nUsiamo un ciclo for per iterare attraverso le parole della frase, aggiornando il conteggio di ciascuna parola in un dizionario. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = {}\n\n  for parola in parole:\n    if parola in conteggio:\n      conteggio[parola] += 1\n\n    else:\n      conteggio[parola] = 1\n\n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False)) \nprint(conta_parole(frase, maiuscolo_minuscolo=True))  \n\n\nUsiamo il metodo get del dizionario per aggiornare il conteggio delle parole in un dizionario. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = {}\n\n  for parola in parole:\n    conteggio[parola] = conteggio.get(parola, 0) + 1\n      \n  return conteggio\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False))  \nprint(conta_parole(frase, maiuscolo_minuscolo=True))  \n\n\nUsiamo il modulo collections e il defaultdict per semplificare il conteggio delle parole. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\nfrom collections import defaultdict\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = defaultdict(int)\n\n  for parola in parole:\n    conteggio[parola] += 1\n\n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False)) \nprint(conta_parole(frase, maiuscolo_minuscolo=True))  \n\n\nUsiamo il modulo collections e Counter per contare le parole nella frase in modo conciso. Il comportamento è determinato dal flag maiuscolo_minuscolo.\nimport string\nfrom collections import Counter\n\ndef conta_parole(frase, maiuscolo_minuscolo=False):\n  if not maiuscolo_minuscolo:\n    frase = frase.lower()\n\n  frase = ''.join(carattere for carattere in frase if carattere not in string.punctuation)\n\n  parole = frase.split()\n\n  conteggio = Counter(parole)\n\n  return dict(conteggio)\n\n# Esempio di utilizzo\nfrase = \"Ciao, ciao! Come stai? Ciao.\"\n\nprint(conta_parole(frase, maiuscolo_minuscolo=False)) \nprint(conta_parole(frase, maiuscolo_minuscolo=True))",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#creazione-e-gestione-di-file",
    "href": "seconda-parte-python-esercizi.html#creazione-e-gestione-di-file",
    "title": "13  Esercizi",
    "section": "13.8 ➃ Creazione e gestione di file",
    "text": "13.8 ➃ Creazione e gestione di file\n\n13.8.1 Creazione di file di testo\n\nProblemaSoluzione 1Soluzione 2\n\n\nScrivere una funzione che crea un file di testo, scrive diverse righe al suo interno includendo interi, float, stringhe, liste e dizionari, e salva il file.\n\n\ndef crea_file_di_testo(nome_file):\n1  with open(nome_file, 'w') as file:\n2    file.write(f\"Esempio di intero: {42}\\n\")\n\n3    file.write(f\"Esempio di float: {3.14}\\n\")\n\n4    file.write(f\"Esempio di stringa: {'Ciao, mondo!'}\\n\")\n    \n    lista = [1, 2, 3, 4]\n5    file.write(f\"Esempio di lista: {lista}\\n\")\n    \n    dizionario = {'chiave': 'valore', 'numero': 42}\n6    file.write(f\"Esempio di dizionario: {dizionario}\\n\")\n\n# Esempio di utilizzo\ncrea_file_di_testo(\"esempio.txt\")\n\n1\n\nApre un file in modalità scrittura.\n\n2\n\nScrive un esempio di intero nel file.\n\n3\n\nScrive un esempio di float nel file.\n\n4\n\nScrive un esempio di stringa nel file.\n\n5\n\nScrive un esempio di lista nel file.\n\n6\n\nScrive un esempio di dizionario nel file.\n\n\n\n\ndef crea_file_di_testo_writelines(nome_file):\n1  with open(nome_file, 'w') as file:\n    righe = [\n2      f\"Esempio di intero: {42}\\n\",\n\n3      f\"Esempio di float: {3.14}\\n\",\n\n      f\"Esempio di stringa: {'Ciao, mondo!'}\\n\",\n\n      f\"Esempio di lista: {[1, 2, 3, 4]}\\n\",\n\n      f\"Esempio di dizionario: {{'chiave': 'valore', 'numero': 42}}\\n\"\n    ]\n\n    file.writelines(righe)\n\n# Esempio di utilizzo\ncrea_file_di_testo_writelines(\"esempio_writelines.txt\")\n\n1\n\nApre un file in modalità scrittura.\n\n2\n\nDefinisce una lista di righe di testo, ognuna rappresentante un diverso tipo di dato.\n\n3\n\nScrive tutte le righe nel file utilizzando writelines.\n\n\n\n\n\n\n\n13.8.2 Creazione di file JSON\n\nProblemaSoluzione 1Soluzione 2\n\n\nScrivere una funzione che crea un file JSON, scrive alcuni dati al suo interno e salva il file.\n\n\n1import json\n\ndef crea_file_json(nome_file, dati):\n2  with open(nome_file, 'w') as file:\n3    json.dump(dati, file, indent=4)\n\n# Esempio di utilizzo\ndati = {\n  \"intero\": 42,\n  \"float\": 3.14,\n  \"stringa\": \"Ciao, mondo!\",\n  \"lista\": [1, 2, 3, 4],\n  \"dizionario\": {\"chiave\": \"valore\", \"numero\": 42}\n}\n\ncrea_file_json(\"esempio.json\", dati)\n\n1\n\nImporta il modulo json.\n\n2\n\nApre un file in modalità scrittura.\n\n3\n\nScrive i dati nel file JSON con indentazione.\n\n\n\n\n1import json\n\ndef crea_file_json_formattato(nome_file, dati):\n2  json_data = json.dumps(dati, indent=4)\n  \n3  with open(nome_file, 'w') as file:\n4    file.write(json_data)\n\n# Esempio di utilizzo\ndati = {\n  \"intero\": 42,\n  \"float\": 3.14,\n  \"stringa\": \"Ciao, mondo!\",\n  \"lista\": [1, 2, 3, 4],\n  \"dizionario\": {\"chiave\": \"valore\", \"numero\": 42}\n}\n\ncrea_file_json_formattato(\"esempio_formattato.json\", dati)\n\n1\n\nImporta il modulo json.\n\n2\n\nConverte i dati in una stringa JSON formattata con indentazione.\n\n3\n\nApre un file in modalità scrittura.\n\n4\n\nScrive la stringa JSON nel file.\n\n\n\n\n\n\n\n13.8.3 Lettura di file JSON\n\nProblemaSoluzione\n\n\nScrivere una funzione che legge un file JSON, riconosce i tipi di dato delle chiavi e dei valori e stampa i dati convertiti.\n\n\n1import json\n\ndef converti_valore(valore):\n  if isinstance(valore, str):\n    try:\n2      valore_convertito = int(valore)\n\n    except ValueError:\n      try:\n3        valore_convertito = float(valore)\n      except ValueError:\n4        valore_convertito = valore\n\n  else:\n    valore_convertito = valore\n\n  return valore_convertito\n\ndef leggi_file_json(nome_file):\n5  with open(nome_file, 'r') as file:\n6    dati = json.load(file)\n    \n    dati_convertiti = {}\n\n    for chiave, valore in dati.items():\n      chiave_convertita = converti_valore(chiave)\n\n      if isinstance(valore, list):\n        valore_convertito = [converti_valore(v) for v in valore]\n\n      else:\n        valore_convertito = converti_valore(valore)\n          \n      dati_convertiti[chiave_convertita] = valore_convertito\n  \n7    print(dati_convertiti)\n\ndef crea_file_json(nome_file):\n  dati = {\n    \"nome\": \"Mario\",\n    \"cognome\": \"Rossi\",\n    \"eta\": 30,  \n    \"altezza\": 1.75,  \n    \"hobby\": [\"lettura\", \"pittura\", \"ciclismo\"],  \n    \"punteggi\": [8, 90, 78],  \n    \"info\": {\"stato_civile\": \"sposato\", \"figli\": 2}  \n  }\n8  with open(nome_file, 'w') as file:\n9    json.dump(dati, file, indent=2)\n\ncrea_file_json(\"esempio.json\")\n\nleggi_file_json(\"esempio.json\")\n\n1\n\nImporta il modulo json.\n\n2\n\nProva a convertire in intero.\n\n3\n\nProva a convertire a valore in virgola mobile.\n\n4\n\nMantiene come stringa.\n\n5\n\nApre un file in modalità lettura.\n\n6\n\nLegge i dati dal file JSON.\n\n7\n\nStampa i dati letti dal file, con chiavi e valori convertiti ai rispettivi tipi.\n\n8\n\nApre un file in modalità scrittura.\n\n9\n\nScrive i dati nel file JSON con un’indentazione di 2 spazi.\n\n\n\n\n\n\n\n13.8.4 Creazione e gestione di cartelle e file\n\nProblemaSoluzione\n\n\nScrivere una funzione che crea una cartella e un file al suo interno, crea un’altra cartella e un file al suo interno, e poi esegue operazioni di cancellazione di cartelle e file, nonché spostamento di file tra le cartelle.\n\n\n1import os\n2import shutil\n\ndef crea_cartelle_e_file():\n3  os.makedirs(\"cartella1\", exist_ok=True)\n\n4  with open(os.path.join(\"cartella1\", \"file1.txt\"), 'w') as file:\n5    file.write(\"Questo è il file 1 nella cartella 1\")\n\n6  os.makedirs(\"cartella2\", exist_ok=True)\n\n7  with open(os.path.join(\"cartella2\", \"file2.txt\"), 'w') as file:\n8    file.write(\"Questo è il file 2 nella cartella 2\")\n\ndef elimina_file_e_cartelle():\n9  os.remove(os.path.join(\"cartella1\", \"file1.txt\"))\n\n10  os.rmdir(\"cartella1\")\n\n11  os.remove(os.path.join(\"cartella2\", \"file2.txt\"))\n\n12  os.rmdir(\"cartella2\")\n\ndef sposta_file():\n  crea_cartelle_e_file()\n\n13  shutil.move(os.path.join(\"cartella2\", \"file2.txt\"), os.path.join(\"cartella1\", \"file2.txt\"))\n\n  if os.path.exists(os.path.join(\"cartella1\", \"file2.txt\")):\n14    print(\"Spostamento riuscito!\")\n\n  else:\n15    print(\"Spostamento fallito.\")\n\n  elimina_file_e_cartelle()\n\n# Esempio di utilizzo\ncrea_cartelle_e_file()\nsposta_file()\n\n1\n\nImporta il modulo os.\n\n2\n\nImporta il modulo shutil.\n\n3\n\nCrea la prima cartella, se non esiste già.\n\n4\n\nCrea un file all’interno della prima cartella.\n\n5\n\nScrive del testo nel file della prima cartella.\n\n6\n\nCrea la seconda cartella, se non esiste già.\n\n7\n\nCrea un file all’interno della seconda cartella.\n\n8\n\nScrive del testo nel file della seconda cartella.\n\n9\n\nCancella il file nella prima cartella.\n\n10\n\nCancella la prima cartella.\n\n11\n\nCancella il file nella seconda cartella.\n\n12\n\nCancella la seconda cartella.\n\n13\n\nSposta il file dalla seconda cartella alla prima cartella.\n\n14\n\nVerifica se lo spostamento è riuscito.\n\n15\n\nStampa un messaggio di errore se lo spostamento fallisce.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#espressioni-regolari",
    "href": "seconda-parte-python-esercizi.html#espressioni-regolari",
    "title": "13  Esercizi",
    "section": "13.9 ➃ Espressioni regolari",
    "text": "13.9 ➃ Espressioni regolari\n\n13.9.1 Verifica di indirizzi email\n\nProblemaSoluzione\n\n\nScrivere una funzione che verifica se una stringa è un indirizzo email valido utilizzando le espressioni regolari.\n\n\n1import re\n\ndef verifica_email(email):\n2  pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\n\n3  if re.match(pattern, email):\n4    return True\n\n  else:\n5    return False\n\n# Esempio di utilizzo\nemail1 = \"esempio@test.com\"\nemail2 = \"invalid-email\"\n\nprint(verifica_email(email1))  # Output: True\nprint(verifica_email(email2))  # Output: False\n\n1\n\nImporta il modulo re.\n\n2\n\nDefinisce il pattern per un indirizzo email.\n\n3\n\nVerifica se la stringa email corrisponde al pattern.\n\n4\n\nRestituisce True se l’indirizzo email è valido.\n\n5\n\nRestituisce False se l’indirizzo email non è valido.\n\n\n\n\n\n\n\n13.9.2 Estrazione di numeri di telefono\n\nProblemaSoluzione\n\n\nScrivere una funzione che estrae tutti i numeri di telefono da una stringa utilizzando le espressioni regolari.\n\n\n1import re\n\ndef estrai_numeri_telefono(testo):\n2  pattern = r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b'\n\n3  numeri = re.findall(pattern, testo)\n\n4  return numeri\n\n# Esempio di utilizzo\ntesto = \"Contattaci al 123-456-7890 o 098.765.4321.\"\n\nprint(estrai_numeri_telefono(testo))  # Output: ['123-456-7890', '098.765.4321']\n\n1\n\nImporta il modulo re.\n\n2\n\nDefinisce il pattern per un numero di telefono.\n\n3\n\nTrova tutti i numeri di telefono nel testo.\n\n4\n\nRestituisce la lista dei numeri di telefono trovati.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercizi.html#interazione-con-sqlite3",
    "href": "seconda-parte-python-esercizi.html#interazione-con-sqlite3",
    "title": "13  Esercizi",
    "section": "13.10 ➃ Interazione con SQLite3",
    "text": "13.10 ➃ Interazione con SQLite3\n\n13.10.1 Creazione di un database e una tabella\n\nProblemaSoluzione\n\n\nScrivere una funzione che crea un database SQLite e una tabella chiamata utenti con tre colonne: id, nome e email.\n\n\n1import sqlite3\n\ndef crea_database(nome_db):\n2  conn = sqlite3.connect(nome_db)\n\n3  c = conn.cursor()\n\n4  c.execute('''CREATE TABLE utenti (id INTEGER PRIMARY KEY, nome TEXT, email TEXT)''')\n\n5  conn.commit()\n\n6  conn.close()\n\n# Esempio di utilizzo\ncrea_database(\"esempio.db\")\n\n1\n\nImporta il modulo sqlite3.\n\n2\n\nConnette al database (crea il database se non esiste).\n\n3\n\nCrea un cursore per eseguire comandi SQL.\n\n4\n\nEsegue il comando SQL per creare la tabella utenti.\n\n5\n\nSalva le modifiche.\n\n6\n\nChiude la connessione al database.\n\n\n\n\n\n\n\n13.10.2 Inserimento di dati nella tabella\n\nProblemaSoluzione\n\n\nScrivere una funzione che inserisce un nuovo utente nella tabella utenti.\n\n\n1import sqlite3\n\ndef inserisci_utente(nome_db, nome, email):\n2  conn = sqlite3.connect(nome_db)\n\n3  c = conn.cursor()\n\n4  c.execute('INSERT INTO utenti (nome, email) VALUES (?, ?)', (nome, email))\n\n5  conn.commit()\n\n6  conn.close()\n\n# Esempio di utilizzo\ninserisci_utente(\"esempio.db\", \"Mario Rossi\", \"mario.rossi@example.com\")\n\n1\n\nImporta il modulo sqlite3.\n\n2\n\nConnette al database.\n\n3\n\nCrea un cursore per eseguire comandi SQL.\n\n4\n\nEsegue il comando SQL per inserire un nuovo utente.\n\n5\n\nSalva le modifiche.\n\n6\n\nChiude la connessione al database.\n\n\n\n\n\n\n\n13.10.3 Lettura di dati dalla tabella\n\nProblemaSoluzione\n\n\nScrivere una funzione che legge tutti gli utenti dalla tabella utenti e li stampa.\n\n\n1import sqlite3\n\ndef leggi_utenti(nome_db):\n2  conn = sqlite3.connect(nome_db)\n\n3  c = conn.cursor()\n\n4  c.execute('SELECT * FROM utenti')\n\n5  utenti = c.fetchall()\n\n6  for utente in utenti:\n7    print(utente)\n\n8  conn.close()\n\n# Esempio di utilizzo\nleggi_utenti(\"esempio.db\")\n\n1\n\nImporta il modulo sqlite3.\n\n2\n\nConnette al database.\n\n3\n\nCrea un cursore per eseguire comandi SQL.\n\n4\n\nEsegue il comando SQL per selezionare tutti gli utenti.\n\n5\n\nRecupera tutti i risultati della query.\n\n6\n\nItera attraverso i risultati.\n\n7\n\nStampa ogni utente.\n\n8\n\nChiude la connessione al database.\n\n\n\n\n\n\n\n13.10.4 Aggiornamento di dati nella tabella\n\nProblemaSoluzione\n\n\nScrivere una funzione che aggiorna l’email di un utente nella tabella utenti.\n\n\n1import sqlite3\n\ndef aggiorna_email(nome_db, id_utente, nuova_email):\n2  conn = sqlite3.connect(nome_db)\n\n3  c = conn.cursor()\n\n4  c.execute('UPDATE utenti SET email = ? WHERE id = ?', (nuova_email, id_utente))\n\n5  conn.commit()\n\n6  conn.close()\n\n# Esempio di utilizzo\naggiorna_email(\"esempio.db\", 1, \"nuovo.email@example.com\")\n\n1\n\nImporta il modulo sqlite3.\n\n2\n\nConnette al database.\n\n3\n\nCrea un cursore per eseguire comandi SQL.\n\n4\n\nEsegue il comando SQL per aggiornare l’email dell’utente con l’ID specificato.\n\n5\n\nSalva le modifiche.\n\n6\n\nChiude la connessione al database.\n\n\n\n\n\n\n\n13.10.5 Eliminazione di dati dalla tabella\n\nProblemaSoluzione\n\n\nScrivere una funzione che elimina un utente dalla tabella utenti.\n\n\n1import sqlite3\n\ndef elimina_utente(nome_db, id_utente):\n2  conn = sqlite3.connect(nome_db)\n\n3  c = conn.cursor()\n\n4  c.execute('DELETE FROM utenti WHERE id = ?', (id_utente,))\n\n5  conn.commit()\n\n6  conn.close()\n\n# Esempio di utilizzo\nelimina_utente(\"esempio.db\", 1)\n\n1\n\nImporta il modulo sqlite3.\n\n2\n\nConnette al database.\n\n3\n\nCrea un cursore per eseguire comandi SQL.\n\n4\n\nEsegue il comando SQL per eliminare l’utente con l’ID specificato.\n\n5\n\nSalva le modifiche.\n\n6\n\nChiude la connessione al database.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Esercizi</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercitazione-uno.html",
    "href": "seconda-parte-python-esercitazione-uno.html",
    "title": "14  Esercitazione 1: analisi di un dataset di vendite",
    "section": "",
    "text": "14.1 Il problema\nIn questa esercitazione, analizzeremo i dati di vendita di un negozio utilizzando pandas per la manipolazione dei dati e Matplotlib per la visualizzazione. Impareremo a gestire i dati mancanti, filtrare e raggruppare i dati, e creare grafici significativi.\nObiettivo:\nDataset da salvare in un file di testo esercitazione-uno-vendite.csv:",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Esercitazione 1: analisi di un dataset di vendite</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercitazione-uno.html#il-problema",
    "href": "seconda-parte-python-esercitazione-uno.html#il-problema",
    "title": "14  Esercitazione 1: analisi di un dataset di vendite",
    "section": "",
    "text": "Caricare un dataset CSV in un DataFrame pandas.\nGestire i dati mancanti nel dataset.\nEffettuare operazioni di filtro e raggruppamento sui dati.\nCreare grafici per visualizzare i dati analizzati.\n\n\nid,prodotto,categoria,prezzo,quantità,data_vendita,venditore\n1,Notebook X200,Elettronica,1200.5,2,2023-01-15,Anna\n2,Smartphone Y7,Elettronica,700.0,1,2023-01-17,Marco\n3,Tablet Z10,Elettronica,300.0,3,2023-01-20,Sara\n4,Notebook X200,Elettronica,1200.5,1,2023-01-22,Anna\n5,Smartphone Y7,Elettronica,700.0,2,2023-01-25,Marco\n6,TV Ultra HD 55\",Elettrodomestici,800.0,1,2023-01-30,Anna\n7,Lavatrice 7kg,Elettrodomestici,500.0,1,2023-02-02,Sara\n8,Frigorifero 300L,Elettrodomestici,600.0,1,2023-02-10,Marco\n9,Notebook X200,Elettronica,1200.5,1,2023-02-12,Anna\n10,Smartphone Y7,Elettronica,700.0,1,2023-02-15,Marco\n11,Tablet Z10,Elettronica,300.0,2,2023-02-20,Sara\n12,TV Ultra HD 55\",Elettrodomestici,800.0,1,2023-02-25,Anna",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Esercitazione 1: analisi di un dataset di vendite</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercitazione-uno.html#introduzione-a-pandas",
    "href": "seconda-parte-python-esercitazione-uno.html#introduzione-a-pandas",
    "title": "14  Esercitazione 1: analisi di un dataset di vendite",
    "section": "14.2 Introduzione a pandas",
    "text": "14.2 Introduzione a pandas\nPandas è una libreria Python potente e flessibile per l’analisi e la manipolazione dei dati. Questa introduzione copre alcuni dei comandi principali che è utile conoscere, inclusa la manipolazione di file Excel.\n\n14.2.1 Installazione\nPrima di tutto, installiamo pandas (e numpy, che è una dipendenza):\npip install pandas numpy openpyxl\n\n\n14.2.2 Importazione della libreria\n1import pandas as pd\n2import numpy as np\n\n1\n\nImporta la libreria pandas.\n\n2\n\nImporta la libreria numpy, spesso utilizzata insieme a pandas.\n\n\n\n\n14.2.3 Il DataFrame\nUn DataFrame è una struttura dati bidimensionale con dati allineati in righe e colonne. Ogni colonna può contenere dati di tipo diverso (numeri, stringhe, ecc.).\nPuoi inizializzare un DataFrame utilizzando dizionari, liste di liste, liste di dizionari, array numpy, file CSV, file Excel, ecc.\nEsempio di inizializzazione da dizionario:\nimport pandas as pd\n\ndata = {'Nome': ['Alice', 'Bob', 'Charlie'], 'Età': [25, 30, 35]}\n\n1df = pd.DataFrame(data)\n\n2print(df)\n\n1\n\nCreazione di un DataFrame da un dizionario.\n\n2\n\nStampa del DataFrame:\n\n\n\n\n\n\nNome\nEtà\n\n\n\n\n0\nAlice\n25\n\n\n1\nBob\n30\n\n\n2\nCharlie\n35\n\n\n\nEsempio di inizializzazione da CSV:\n1df = pd.read_csv('data.csv')\n\n2print(df.head())\n\n1\n\nLettura di un file CSV.\n\n2\n\nVisualizza le prime 5 righe del DataFrame.\n\n\nEsempio di inizializzazione da Excel:\n1df_excel = pd.read_excel('data.xlsx')\n\n2print(df_excel.head())\n\n1\n\nLettura di un file Excel.\n\n2\n\nVisualizza le prime 5 righe del DataFrame.\n\n\n\n\n14.2.4 Ispezione\nPuoi ispezionare le righe e le colonne di un DataFrame utilizzando vari metodi come .head(), .tail(), .loc[], e .iloc[].\nEsempio:\n1print(df.head())\n\nprint(df['Nome'])\n\nprint(df.loc[0])\n\nprint(df.iloc[1])\n\n1\n\nStampa delle prime righe del DataFrame:\n\n\n\n\n\n\nNome\nEtà\n\n\n\n\n0\nAlice\n25\n\n\n1\nBob\n30\n\n\n2\nCharlie\n35\n\n\n\n\nStampa della colonna Nome:\n\n0      Alice\n1        Bob\n2    Charlie\nName: Nome, dtype: object\n\nStampa della prima riga utilizzando l’etichetta:\n\nNome    Alice\nEtà        25\nName: 0, dtype: object\n\nStampa della seconda riga utilizzando l’indice:\n\nNome    Bob\nEtà       30\nName: 1, dtype: object\n\n\n14.2.5 Filtri, raggruppamenti, pivot\nPuoi filtrare, raggruppare e pivotare i dati utilizzando metodi come .query(), .groupby(), e .pivot_table().\nEsempio:\n1df_filtrato = df[df['Età'] &gt; 25]\n2print(df_filtrato)\n\ndf_gruppato = df.groupby('Età').size()\nprint(df_gruppato)\n\npivot_data = {'A': ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'],\n              'B': ['one', 'one', 'two', 'two', 'one', 'one'],\n              'C': [1, 3, 2, 5, 4, 6]}\n\ndf_pivot = pd.DataFrame(pivot_data)\n\npivot_table = df_pivot.pivot_table(values='C', index='A', columns='B', aggfunc='sum')\nprint(pivot_table)\n\n1\n\nFiltro delle righe dove l’età è maggiore di 25.\n\n2\n\nStampa del DataFrame filtrato:\n\n\n\n\n\n\nNome\nEtà\n\n\n\n\n1\nBob\n30\n\n\n2\nCharlie\n35\n\n\n\n\nRaggruppamento per colonna Età.\nStampa del DataFrame raggruppato:\n\nEtà\n25    1\n30    1\n35    1\ndtype: int64\n\nCreazione di un DataFrame di esempio per il pivot.\nCreazione di una pivot table.\nStampa della pivot table:\n\n\n\n\nB\none\ntwo\n\n\n\n\nA\n\n\n\n\nbar\n10\n5\n\n\nfoo\n4\n2\n\n\n\n\n\n14.2.6 Modifica\nPuoi modificare i dati di un DataFrame assegnando nuovi valori agli elementi, alle colonne o utilizzando metodi di modifica in-place.\nEsempio:\n1df['Altezza'] = [165, 180, 175]\n2print(df)\n\ndf.loc[0, 'Età'] = 26\nprint(df)\n\n1\n\nAggiunta di una nuova colonna ‘Altezza’.\n\n2\n\nStampa del DataFrame modificato:\n\n\n\n\n\n\nNome\nEtà\nAltezza\n\n\n\n\n0\nAlice\n25\n165\n\n\n1\nBob\n30\n180\n\n\n2\nCharlie\n35\n175\n\n\n\n\nModifica del valore dell’età per la prima riga.\nStampa del DataFrame modificato:\n\n\n\n\n\nNome\nEtà\nAltezza\n\n\n\n\n0\nAlice\n26\n165\n\n\n1\nBob\n30\n180\n\n\n2\nCharlie\n35\n175\n\n\n\n\n\n14.2.7 Salvataggio\nPuoi salvare un DataFrame in vari formati di file, come CSV, Excel, JSON, ecc., utilizzando metodi come .to_csv(), .to_excel(), .to_json().\n1df.to_csv('data.csv', index=False)\n\n2df.to_excel('data.xlsx', index=False)\n\n3df.to_json('data.json')\n\n1\n\nSalvataggio del DataFrame in un file CSV senza includere gli indici.\n\n2\n\nSalvataggio del DataFrame in un file Excel senza includere gli indici.\n\n3\n\nSalvataggio del DataFrame in un file JSON.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Esercitazione 1: analisi di un dataset di vendite</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercitazione-uno.html#la-soluzione",
    "href": "seconda-parte-python-esercitazione-uno.html#la-soluzione",
    "title": "14  Esercitazione 1: analisi di un dataset di vendite",
    "section": "14.3 La soluzione",
    "text": "14.3 La soluzione\nPassaggi di soluzione:\n\nCreiamo il file CSV fornito e carichiamolo in un DataFrame pandas.\nControlliamo se ci sono valori mancanti nel dataset.\nFiltriamo le vendite del prodotto Notebook X200 e visualizziamo il risultato.\nRaggruppiamo le vendite per venditore e calcoliamo la somma totale delle quantità vendute per ciascun venditore.\nCreiamo una tabella pivot per vedere le vendite per data e prodotto.\nUtilizziamo Matplotlib per creare un grafico a linee delle vendite totali per ciascun mese.\n\n\n14.3.1 Passaggio 1: caricamento del dataset\nCarichiamo le librerie necessarie:\n1import pandas as pd\n2import matplotlib.pyplot as plt\n\n1\n\nImporta la libreria Pandas per la manipolazione dei dati.\n\n2\n\nImporta la libreria Matplotlib per la visualizzazione dei dati.\n\n\nCarichiamo il dataset:\n1df_vendite = pd.read_csv('esercitazione-uno-vendite.csv')\n\n1\n\nCarica il dataset dal file CSV esercitazione-uno-vendite.csv.\n\n\n\n\n14.3.2 Passaggio 2: gestione dei dati mancanti\nControlliamo se ci sono valori mancanti e rimuoviamo le righe con valori mancanti:\n1print(df_vendite.isnull().sum())\n\n2df_vendite_ripulito = df_vendite.dropna()\n\n1\n\nStampa il conteggio dei valori mancanti per ciascuna colonna.\n\n2\n\nRimuove le righe con valori mancanti dal DataFrame.\n\n\n\n\n14.3.3 Passaggio 3: operazioni di filtro\nFiltriamo le vendite del prodotto Notebook X200:\nvendite_notebook_x200 = df_vendite_ripulito[\n1  df_vendite_ripulito['prodotto'] == 'Notebook X200']\n\n2print(vendite_notebook_x200)\n\n1\n\nFiltra il DataFrame per il prodotto Notebook X200.\n\n2\n\nStampa le vendite del prodotto Notebook X200.\n\n\n\n\n14.3.4 Passaggio 4: operazioni di raggruppamento e somma\nL’operazione di group by in pandas permette di raggruppare i dati in base a una o più colonne, e quindi applicare una funzione di aggregazione su ciascun gruppo. Questo è utile quando si vuole calcolare statistiche aggregate, come somme, medie, conteggi, ecc., per ciascun gruppo di dati.\nAd esempio, se si dispone di un dataset delle vendite, è possibile raggruppare i dati per venditore e calcolare la somma delle quantità vendute da ciascun venditore. Questo può fornire una visione chiara delle prestazioni di ciascun venditore.\nRaggruppiamo per venditore e calcoliamo la somma delle quantità vendute:\n1vendite_per_venditore = df_vendite_ripulito.groupby('venditore')['quantità'].sum()\n\n2print(vendite_per_venditore)\n\n1\n\nRaggruppa i dati per venditore e calcola la somma delle quantità vendute.\n\n2\n\nStampa la somma delle quantità vendute per ciascun venditore.\n\n\n\n\n14.3.5 Passaggio 5: operazione di pivot\nL’operazione di pivot in pandas permette di trasformare i dati rendendoli più comprensibili e facili da analizzare. Una tabella pivot ruota i dati in modo da creare una nuova tabella in cui le righe e le colonne rappresentano diverse dimensioni dei dati. In particolare, è possibile specificare quali valori devono essere visualizzati come righe, quali come colonne, e quale funzione di aggregazione applicare ai dati.\nAd esempio, in un dataset delle vendite, è possibile creare una tabella pivot che mostra le quantità vendute per data_vendita e prodotto. Questo può aiutare a visualizzare come le vendite di ciascun prodotto cambiano nel tempo.\nCreiamo una tabella pivot per vedere le vendite per data e prodotto:\npivot_table_data_prodotto = df_vendite_ripulito.pivot_table(\n  values='quantità',\n  index='data_vendita',\n  columns='prodotto',\n  aggfunc='sum',\n1  fill_value=0)\n\n2print(pivot_table_data_prodotto)\n\n1\n\nCrea una tabella pivot per visualizzare le vendite per data e prodotto.\n\n2\n\nStampa la tabella pivot delle vendite per data e prodotto.\n\n\n\n\n14.3.6 Passaggio 6: visualizzazione con grafici\nCreiamo un grafico a barre delle vendite per venditore:\n1vendite_per_venditore.plot(kind='bar')\n\n2plt.title('Vendite per Venditore')\n3plt.xlabel('Venditore')\n4plt.ylabel('Quantità Venduta')\n5plt.show()\n\n1\n\nCrea un grafico a barre delle vendite per venditore.\n\n2\n\nImposta il titolo del grafico a barre.\n\n3\n\nImposta l’etichetta dell’asse x del grafico a barre.\n\n4\n\nImposta l’etichetta dell’asse y del grafico a barre.\n\n5\n\nMostra il grafico a barre.\n\n\nCreiamo un grafico a linee delle vendite totali per ciascun mese:\n1df_vendite_ripulito['data_vendita'] = pd.to_datetime(df_vendite_ripulito['data_vendita'])\n\n2df_vendite_ripulito.set_index('data_vendita', inplace=True)\n\n3vendite_mensili = df_vendite_ripulito.resample('M')['quantità'].sum()\n\n4vendite_mensili.plot(kind='line')\n\n5plt.title('Vendite Mensili Totali')\n6plt.xlabel('Mese')\n7plt.ylabel('Quantità Venduta')\n8plt.show()\n\n1\n\nConverte la colonna data_vendita in un oggetto datetime.\n\n2\n\nImposta data_vendita come indice del DataFrame.\n\n3\n\nRaggruppa i dati per mese e calcola la somma delle quantità vendute.\n\n4\n\nCrea un grafico a linee delle vendite mensili.\n\n5\n\nImposta il titolo del grafico a linee.\n\n6\n\nImposta l’etichetta dell’asse x del grafico a linee.\n\n7\n\nImposta l’etichetta dell’asse y del grafico a linee.\n\n8\n\nMostra il grafico a linee.",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Esercitazione 1: analisi di un dataset di vendite</span>"
    ]
  },
  {
    "objectID": "seconda-parte-python-esercitazione-uno.html#file",
    "href": "seconda-parte-python-esercitazione-uno.html#file",
    "title": "14  Esercitazione 1: analisi di un dataset di vendite",
    "section": "14.4 File",
    "text": "14.4 File\nCSV vendite: scarica\nFile Python completo: scarica\nMarino notebook completo: scarica",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Esercitazione 1: analisi di un dataset di vendite</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "",
    "text": "15.1 Classi e istanze\nUna classe è un tipo definibile dall’utente, che possiamo istanziare per costruire istanze, ovvero oggetti di quel tipo. Python supporta questo attraverso le sue classi e oggetti istanza.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#classi-e-istanze",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#classi-e-istanze",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "",
    "text": "15.1.1 L’istruzione class\nL’istruzione class è il modo più usuale per definire un oggetto classe. class è un’istruzione composta a singola clausola con la seguente sintassi:\n1class NomeClasse(classi-base, *, **kw):\n2  istruzione(i)\n\n1\n\nTestata della definizione di classe: NomeClasse è un identificatore, cioè una variabile che la definizione class, quando completata, associa (o riassocia) all’oggetto classe appena creato. Le convenzioni di denominazione Python consigliano di utilizzare la convenzione del cammello per i nomi delle classi, come Elemento, UtentePrivilegiato, StrutturaMultiUso, ecc. classi-base è una serie di espressioni delimitate da virgole i cui valori sono oggetti classe. Vari linguaggi di programmazione utilizzano nomi diversi per questi oggetti classe: possiamo chiamarli basi, superclasse o genitori della classe. Possiamo dire che la classe creata eredita da, deriva da, estende o sottoclasse le sue classi base; in questo capitolo, generalmente usiamo il termine estendere. Questa classe è una sottoclasse diretta o discendente delle sue classi base. **kw può includere un argomento denominato metaclass per stabilire la metaclasse della classe.\n\n2\n\nCorpo della definizione della classe composto di istruzioni di definizione di membri della classe. Queste possono includere la definizione di attributi, metodi e altre classi.\n\n\nLa definizione di una classe crea un oggetto classe, proprio come la definizione di una funzione crea un oggetto funzione. L’oggetto classe ha tipo type, da non confondere con la funzione predefinita type(). Quando si chiama una classe come se fosse una funzione, avviene l’istanziazione, che crea un nuovo oggetto istanza della classe con un tipo corrispondente alla classe stessa.\nEsempio di definizione di una classe:\n1class MiaClasse:\n2  def __init__(self, valore):\n3    self.valore = valore\n\n4istanza = MiaClasse(10)\n\n5print(type(MiaClasse))\n6print(type(istanza))\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n3\n\nAssocia un valore all’attributo valore dell’istanza.\n\n4\n\nCrea un’istanza della classe MiaClasse con valore 10.\n\n5\n\nStampa il tipo di MiaClasse, che sarà &lt;class 'type'&gt;.\n\n6\n\nStampa il tipo di istanza, che sarà &lt;class '__main__.MiaClasse'&gt;.\n\n\n\n\n15.1.2 Il parametro self\nIn Python, i metodi di istanza delle classi possono includere un parametro speciale self come primo parametro. Quando presente, self permette di passare al metodo l’istanza della classe, consentendo l’accesso agli attributi e ai metodi dell’istanza. La differenza fondamentale tra membri della classe e membri delle istanze è che i membri della classe sono condivisi tra tutte le istanze, mentre i membri delle istanze sono specifici per ciascuna istanza.\nEsempio di membri della classe e membri delle istanze:\n1class MiaClasse:\n2  attributo_classe = \"Valore di classe\"\n\n3  def __init__(self, valore):\n4    self.attributo_istanza = valore\n\n5  def mostra_attributi(self):\n6    return f\"Classe: {MiaClasse.attributo_classe}, Istanza: {self.attributo_istanza}\"\n\n# Creazione di due istanze della classe\n7istanza1 = MiaClasse(\"Valore 1\")\n8istanza2 = MiaClasse(\"Valore 2\")\n\n# Accesso agli attributi della classe e delle istanze\n9print(MiaClasse.attributo_classe)\n10print(istanza1.attributo_classe)\n11print(istanza1.attributo_istanza)\n12print(istanza2.attributo_istanza)\n\n# Chiamata ai metodi delle istanze\n13print(istanza1.mostra_attributi())\n14print(istanza2.mostra_attributi())\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce un attributo di classe attributo_classe con valore Valore di classe.\n\n3\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n4\n\nAssocia un valore all’attributo attributo_istanza dell’istanza.\n\n5\n\nDefinisce un metodo mostra_attributi per mostrare gli attributi.\n\n6\n\nIl metodo mostra_attributi restituisce una stringa con gli attributi di classe e di istanza.\n\n7\n\nCrea un’istanza della classe MiaClasse con valore Valore 1.\n\n8\n\nCrea un’istanza della classe MiaClasse con valore Valore 2.\n\n9\n\nStampa il valore dell’attributo di classe attributo_classe.\n\n10\n\nStampa il valore dell’attributo di classe attributo_classe dall’istanza istanza1.\n\n11\n\nStampa il valore dell’attributo di istanza attributo_istanza per istanza1.\n\n12\n\nStampa il valore dell’attributo di istanza attributo_istanza per istanza2.\n\n13\n\nChiama il metodo mostra_attributi sull’istanza istanza1.\n\n14\n\nChiama il metodo mostra_attributi sull’istanza istanza2.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#membri",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#membri",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.2 Membri",
    "text": "15.2 Membri\nUn riferimento a un membro è un’espressione della forma x.nome, dove x è qualsiasi espressione e nome è un identificatore chiamato nome del membro. Molti oggetti Python hanno membri, ma un riferimento a un membro ha una semantica speciale e ricca quando x si riferisce a una classe o a un’istanza. I metodi sono membri, quindi tutto ciò che diciamo sui membri in generale si applica anche a quelli chiamabili (cioè, metodi).\nQuando utilizziamo la sintassi x.nome per riferirci a un membro di un’istanza x di una classe C, la ricerca dell’attributo procede in tre passi:\n\nMembro nell’istanza: Se 'nome' è una chiave in x.__dict__, x.nome restituisce il valore associato a quella chiave. Questo è il caso più semplice e veloce.\nMembro nella classe o nelle sue basi: Se 'nome' non è una chiave in x.__dict__, la ricerca del membro procede nella classe di x (x.__class__) e nelle sue basi, seguendo l’ordine di risoluzione dei metodi (method resolution order, MRO).\nMetodo __getattr__: Se l’attributo non è trovato né nell’istanza né nella classe e nelle sue basi, viene chiamato il metodo speciale __getattr__, se definito. Questo metodo può fornire un valore di ritorno per l’attributo o sollevare un’eccezione AttributeError.\n\nEsempio di riferimento ai membri:\n1class Base:\n2  a = 23\n\n3class Derivata(Base):\n4  b = 45\n\n5d = Derivata()\n\n6d.c = 67\n\n7print(d.a)\n8print(d.b)\n9print(d.c)\n\n1\n\nDefinizione della classe Base.\n\n2\n\nL’attributo a della classe Base è associato al valore 23.\n\n3\n\nDefinizione della classe Derivata che eredita da Base.\n\n4\n\nL’attributo b della classe Derivata è associato al valore 45.\n\n5\n\nCreazione di un’istanza della classe Derivata.\n\n6\n\nAssociazione dell’attributo c dell’istanza d al valore 67.\n\n7\n\nStampa del valore dell’attributo a dell’istanza d, trovato nella classe base. Output: 23.\n\n8\n\nStampa del valore dell’attributo b dell’istanza d, trovato nella classe derivata. Output: 45.\n\n9\n\nStampa del valore dell’attributo c dell’istanza d, trovato nell’istanza stessa. Output: 67.\n\n\nIn Python, un attributo o un metodo può essere membro di una classe o di un’istanza. La differenza fondamentale tra membri di classe e membri di istanza è che i membri di classe sono condivisi tra tutte le istanze, mentre i membri di istanza sono specifici per ciascuna istanza.\nEsempio:\n1class Contatore:\n2  contatore_comune = 0\n\n3  def __init__(self, valore_iniziale=0):\n4    self.valore = valore_iniziale\n5    Contatore.contatore_comune += 1\n\n6  def incrementa(self):\n7    self.valore += 1\n\n# Membri di classe\n8print(Contatore.contatore_comune)\n\n# Creazione di due istanze\n9c1 = Contatore()\n10c2 = Contatore(10)\n\n# Membri di istanza\n11c1.incrementa()\n12c2.incrementa()\n\n13print(c1.valore)\n14print(c2.valore)\n\n# Membro di classe aggiornato\n15print(Contatore.contatore_comune)\n\n1\n\nDefinisce una classe Contatore.\n\n2\n\nDefinisce un attributo di classe contatore_comune inizializzato a 0.\n\n3\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n4\n\nAssocia un valore iniziale all’attributo valore dell’istanza.\n\n5\n\nIncrementa l’attributo di classe contatore_comune ogni volta che viene creata una nuova istanza.\n\n6\n\nDefinisce un metodo incrementa per incrementare l’attributo valore dell’istanza.\n\n7\n\nIncrementa l’attributo valore dell’istanza.\n\n8\n\nStampa il valore dell’attributo di classe contatore_comune.\n\n9\n\nCreazione di un’istanza della classe Contatore con valore iniziale di default.\n\n10\n\nCreazione di un’istanza della classe Contatore con valore iniziale 10.\n\n11\n\nIncrementa il valore dell’attributo valore dell’istanza c1.\n\n12\n\nIncrementa il valore dell’attributo valore dell’istanza c2.\n\n13\n\nStampa il valore dell’attributo valore dell’istanza c1. Output: 1.\n\n14\n\nStampa il valore dell’attributo valore dell’istanza c2. Output: 11.\n\n15\n\nStampa il valore dell’attributo di classe contatore_comune. Output: 2.\n\n\nQuesto esempio illustra come i membri di classe siano condivisi tra tutte le istanze, mentre i membri di istanza siano specifici per ciascuna istanza.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#oggetti",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#oggetti",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.3 Oggetti",
    "text": "15.3 Oggetti\nUna classe è un oggetto Python con le seguenti caratteristiche:\n\nLa definizione di una classe crea un oggetto classe, proprio come la definizione di una funzione crea un oggetto funzione. L’oggetto classe ha tipo type, da non confondere con la funzione predefinita type(). Quando si chiama una classe come se fosse una funzione, avviene l’istanziazione, che crea un nuovo oggetto istanza della classe con un tipo corrispondente alla classe stessa.\nEsempio:\n1class MiaClasse:\n2  def __init__(self, valore):\n3    self.valore = valore\n\n4istanza = MiaClasse(10)\n\n5print(type(MiaClasse))\n6print(type(istanza))\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n3\n\nAssocia un valore all’attributo valore dell’istanza.\n\n4\n\nCrea un’istanza della classe MiaClasse con valore 10.\n\n5\n\nStampa il tipo di MiaClasse, che sarà &lt;class 'type'&gt;.\n\n6\n\nStampa il tipo di istanza, che sarà &lt;class '__main__.MiaClasse'&gt;.\n\n\nUna classe ha membri con nomi arbitrari che possiamo associare e referenziare:\n1class MiaClasse:\n2  primo_attributo = \"esempio\"\n\n3print(MiaClasse.primo_attributo)\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nAssocia un attributo di classe primo_attributo con valore esempio.\n\n3\n\nStampa il valore dell’attributo di classe primo_attributo.\n\n\nI membri della classe possono essere metodi (funzioni) o dati ordinari (variabili):\n1class MiaClasse:\n2  primo_attributo = \"esempio\"\n\n3  def primo_metodo(self):\n4    return \"Ciao, mondo!\"\n\n5print(MiaClasse.primo_attributo)\n\n6mia_istanza = MiaClasse()\n\n7print(mia_istanza.primo_metodo())\n8print(MiaClasse.primo_metodo(mia_istanza))\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce un attributo di classe primo_attributo con valore esempio.\n\n3\n\nDefinisce un metodo primo_metodo con un parametro self.\n\n4\n\nIl metodo primo_metodo restituisce una stringa Ciao, mondo!.\n\n5\n\nStampa il valore dell’attributo di classe primo_attributo.\n\n6\n\nCrea un’istanza della classe MiaClasse e la associa a mia_istanza.\n\n7\n\nChiama il metodo primo_metodo sull’istanza mia_istanza. Python passa automaticamente mia_istanza come argomento per self.\n\n8\n\nChiama il metodo primo_metodo direttamente sulla classe MiaClasse, passando esplicitamente mia_istanza come argomento per self.\n\n\nGli attributi della classe associati a funzioni sono noti anche come metodi della classe:\n1class MiaClasse:\n2  def primo_metodo(self):\n3    return \"Questo è un metodo\"\n\n4istanza = MiaClasse()\n\n5print(istanza.primo_metodo())\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce un metodo primo_metodo.\n\n3\n\nIl metodo primo_metodo restituisce una stringa Questo è un metodo.\n\n4\n\nCrea un’istanza della classe MiaClasse.\n\n5\n\nChiama il metodo primo_metodo sull’istanza e stampa il risultato.\n\n\nUn metodo può avere uno dei tanti nomi definiti da Python con due trattini bassi all’inizio e alla fine (noti come nomi dunder, abbreviazione di “double-underscore names” - ad esempio, il nome __init__ è pronunciato “dunder init”). Python chiama implicitamente questi metodi speciali, quando una classe li fornisce, quando si verificano vari tipi di operazioni su quella classe o sulle sue istanze.\n1class MiaClasse:\n2  def __init__(self, valore):\n3    self.valore = valore\n\n4  def __str__(self):\n5    return f\"MiaClasse con valore {self.valore}\"\n\n6istanza = MiaClasse(10)\n\n7print(istanza)\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n3\n\nAssocia un valore all’attributo valore dell’istanza.\n\n4\n\nDefinisce il metodo speciale __str__ per la rappresentazione stringa.\n\n5\n\n__str__ restituisce una stringa rappresentativa dell’istanza.\n\n6\n\nCrea un’istanza della classe MiaClasse con valore 10.\n\n7\n\nStampa la rappresentazione stringa dell’istanza, chiamando implicitamente __str__.\n\n\nUna classe può ereditare da una o più classi, il che significa che delega ad altri oggetti classe la ricerca di alcuni attributi (inclusi metodi regolari e dunder) che non sono nella classe stessa.\n1class ClasseBase:\n2  def metodo_base(self):\n3    return \"Metodo base\"\n\n4class ClasseDerivata(ClasseBase):\n5  def metodo_derivato(self):\n6    return \"Metodo derivato\"\n\n7istanza = ClasseDerivata()\n\n8print(istanza.metodo_base())\n9print(istanza.metodo_derivato())\n\n1\n\nDefinisce una classe ClasseBase.\n\n2\n\nDefinisce un metodo metodo_base.\n\n3\n\nmetodo_base restituisce una stringa “Metodo base”.\n\n4\n\nDefinisce una classe ClasseDerivata che eredita da ClasseBase.\n\n5\n\nDefinisce un metodo metodo_derivato.\n\n6\n\nmetodo_derivato restituisce una stringa “Metodo derivato”.\n\n7\n\nCrea un’istanza della classe ClasseDerivata.\n\n8\n\nChiama il metodo metodo_base ereditato dall’istanza e stampa il risultato.\n\n9\n\nChiama il metodo metodo_derivato dell’istanza e stampa il risultato.\n\n\n\nUn’istanza di una classe è un oggetto Python con attributi con nomi arbitrari che possiamo associare e referenziare. Ogni oggetto istanza delega la ricerca degli attributi alla sua classe per qualsiasi attributo non trovato nell’istanza stessa. La classe, a sua volta, può delegare la ricerca alle classi da cui eredita, se presenti.\n1class MiaClasse:\n2  def __init__(self, valore):\n3    self.valore = valore\n\n4istanza = MiaClasse(10)\n\n5print(istanza.valore)\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n3\n\nAssocia un valore all’attributo valore dell’istanza.\n\n4\n\nCrea un’istanza della classe MiaClasse con valore 10.\n\n5\n\nStampa il valore dell’attributo valore dell’istanza.\n\n\nIn Python, le classi sono oggetti (valori), gestiti proprio come altri oggetti. Possiamo passare una classe come argomento in una chiamata a una funzione e una funzione può restituire una classe come risultato di una chiamata. Possiamo associare una classe a una variabile, a un elemento in un contenitore o a un attributo di un oggetto. Le classi possono anche essere chiavi in un dizionario. Poiché le classi sono oggetti perfettamente ordinari in Python, spesso diciamo che le classi sono oggetti di prima classe.\n1def crea_classe():\n2  class NuovaClasse:\n3    pass\n\n4  return NuovaClasse\n\n5MiaClasse = crea_classe()\n\n6istanza = MiaClasse()\n\n7print(type(istanza))\n\n1\n\nDefinisce una funzione crea_classe.\n\n2\n\nDefinisce una classe NuovaClasse all’interno della funzione.\n\n3\n\npass indica che il corpo della classe è vuoto.\n\n4\n\nRestituisce la classe NuovaClasse.\n\n5\n\nChiama la funzione crea_classe e associa la classe risultante a MiaClasse.\n\n6\n\nCrea un’istanza della classe MiaClasse.\n\n7\n\nStampa il tipo dell’istanza, che sarà &lt;class '__main__.crea_classe.&lt;locals&gt;.NuovaClasse'&gt;.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#il-corpo-della-classe",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#il-corpo-della-classe",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.4 Il corpo della classe",
    "text": "15.4 Il corpo della classe\nIl corpo di una classe è dove normalmente specifichiamo i membri della classe; questi membri possono essere funzioni o oggetti dati ordinari di qualsiasi tipo. Un membro di una classe può essere un’altra classe, quindi, ad esempio, possiamo avere una dichiarazione di classe annidata all’interno di un’altra definizione di classe.\n\n15.4.1 Attributi degli oggetti classe\nDi solito specifichiamo un membro di un oggetto classe associando un valore a un identificatore all’interno del corpo della classe. Per esempio:\n1class C1:\n2  x = 23\n\n3print(C1.x)\n\n1\n\nDefinizione della classe C1.\n\n2\n\nL’attributo x della classe C1 è associato al valore 23.\n\n3\n\nStampa del valore dell’attributo x della classe C1.\n\n\nPossiamo anche associare o disassociare membri della classe al di fuori del corpo della classe. Per esempio:\n1class C2:\n2  pass\n\n3C2.x = 23\n\n4print(C2.x)\n\n1\n\nDefinizione della classe C2.\n\n2\n\nCorpo della classe vuoto.\n\n3\n\nAssociazione dell’attributo x della classe C2 al valore 23.\n\n4\n\nStampa del valore dell’attributo x della classe C2.\n\n\nIl nostro programma è solitamente più leggibile se associamo attributi della classe solo con istruzioni all’interno del corpo della classe. Tuttavia, riassociarli altrove può essere necessario se vogliamo mantenere informazioni di stato a livello di classe, piuttosto che a livello di istanza; Python ci permette di farlo, se lo desideriamo. Non c’è differenza tra un attributo di classe associato nel corpo della classe e uno associato o riassociato al di fuori del corpo associando un attributo. Come discuteremo a breve, tutte le istanze della classe condividono tutti gli attributi della classe.\nL’istruzione della classe implicitamente imposta alcuni attributi della classe. L’attributo __name__ è la stringa dell’identificatore NomeClasse utilizzato nella dichiarazione della classe. L’attributo __bases__ è la tupla di oggetti classe forniti (o impliciti) come classi base nella dichiarazione della classe. Per esempio, utilizzando la classe C1 appena creata:\n1print(C1.__name__, C1.__bases__)\n\n1\n\nStampa del nome della classe e delle classi base.\n\n\nUna classe ha anche un attributo chiamato __dict__, che è la mappatura di sola lettura che la classe utilizza per mantenere altri attributi (noto anche, informalmente, come spazio dei nomi della classe).\nNelle istruzioni direttamente nel corpo di una classe, i riferimenti ai membri della classe devono utilizzare un nome semplice, non un nome completamente qualificato. Per esempio:\n1class C3:\n2  x = 23\n3  y = x + 22\n\n4print(C3.y)\n\n1\n\nDefinizione della classe C3.\n\n2\n\nL’attributo x della classe C3 è associato al valore 23.\n\n3\n\nL’attributo y della classe C3 è associato alla somma di x e 22.\n\n4\n\nStampa del valore dell’attributo y della classe C3.\n\n\nTuttavia, nelle istruzioni all’interno dei metodi definiti in un corpo di classe, i riferimenti agli attributi della classe devono utilizzare un nome completamente qualificato, non un nome semplice. Per esempio:\n1class C4:\n2  x = 23\n  \n3  def metodo(self):\n4    print(C4.x)\n\n5c = C4()\n\n6c.metodo()\n\n1\n\nDefinizione della classe C4.\n\n2\n\nL’attributo x della classe C4 è associato al valore 23.\n\n3\n\nDefinizione di un metodo della classe C4.\n\n4\n\nStampa del valore dell’attributo x della classe C4.\n\n5\n\nCreazione di un’istanza della classe C4.\n\n6\n\nChiamata del metodo dell’istanza c.\n\n\n\n\n15.4.2 Definizioni di funzioni nel corpo di una classe\nLa maggior parte dei corpi delle classi include alcune istruzioni def, poiché le funzioni (note come metodi in questo contesto) sono importanti membri per la maggior parte delle istanze delle classi. Un’istruzione def in un corpo di classe obbedisce alle regole viste per le funzioni ordinarie.\nEcco un esempio di una classe che include una definizione di metodo:\n1class C5:\n2  def ciao(self):\n3    print('Ciao')\n\n4c = C5()\n5c.ciao()\n\n1\n\nDefinizione della classe C5.\n\n2\n\nDefinizione di un metodo della classe C5.\n\n3\n\nStampa del messaggio Ciao.\n\n4\n\nCreazione di un’istanza della classe C5.\n\n5\n\nChiamata del metodo ciao() dell’istanza c.\n\n\n\n\n15.4.3 Variabili private della classe\nQuando un’istruzione in un corpo di classe (o in un metodo nel corpo) utilizza un identificatore che inizia (ma non termina) con due trattini bassi, come __ident, Python cambia implicitamente l’identificatore in _NomeClasse__ident, dove NomeClasse è il nome della classe. Questo cambiamento implicito consente a una classe di utilizzare nomi privati per attributi, metodi, variabili globali e altri scopi, riducendo il rischio di duplicare accidentalmente i nomi utilizzati altrove (particolarmente nelle sottoclassi).\nPer convenzione, gli identificatori che iniziano con un trattino basso sono considerati privati all’ambito che li associa, che tale ambito sia o meno una classe. Il compilatore Python non impone questa convenzione di privacy: è responsabilità dei programmatori rispettarla.\nEsempio:\n1class MiaClasse:\n2  def __init__(self, valore):\n3    self.__valore = valore\n\n4  def visualizza_valore(self):\n5    return self.__valore\n\n6  def __metodo_privato(self):\n7    return \"Questo è un metodo privato\"\n\n8istanza = MiaClasse(10)\n\n9print(istanza.visualizza_valore())\n\ntry:\n10  print(istanza.__valore)\n\nexcept Exception as e:\n  print(e)\n\n11print(istanza._MiaClasse__valore)\n\ntry:\n12  print(istanza.__metodo_privato())\n\nexcept Exception as e:\n  print(e)\n\n13print(istanza._MiaClasse__metodo_privato())\n\n1\n\nDefinisce una classe MiaClasse.\n\n2\n\nDefinisce il metodo speciale __init__ per l’inizializzazione.\n\n3\n\nUtilizza un attributo con due trattini bassi all’inizio, che verrà trasformato in _MiaClasse__valore.\n\n4\n\nDefinisce un metodo visualizza_valore.\n\n5\n\nIl metodo visualizza_valore restituisce l’attributo __valore.\n\n6\n\nDefinisce un metodo privato __metodo_privato.\n\n7\n\nIl metodo __metodo_privato restituisce una stringa.\n\n8\n\nCrea un’istanza della classe MiaClasse con valore 10.\n\n9\n\nChiama il metodo visualizza_valore sull’istanza e stampa il risultato. Output: 10.\n\n10\n\nIl tentativo di accedere direttamente all’attributo __valore genera un errore. Output: 'MiaClasse' object has no attribute '__valore'.\n\n11\n\nAccede all’attributo __valore utilizzando il nome modificato _MiaClasse__valore. Output: 10.\n\n12\n\nIl tentativo di chiamare direttamente il metodo __metodo_privato genera un errore. Output: 'MiaClasse' object has no attribute '__metodo_privato'.\n\n13\n\nChiama il metodo privato __metodo_privato utilizzando il nome modificato _MiaClasse__metodo_privato. Output: Questo è un metodo privato.\n\n\nIn questo esempio, l’attributo __valore e il metodo __metodo_privato sono “rinominati” da Python per evitare conflitti di nomi, rendendoli più difficili da accedere accidentalmente. Tuttavia, questo non rende gli attributi o i metodi veramente privati, poiché possono ancora essere accessibili utilizzando il nome modificato. Quindi, l’uso del doppio trattino basso è una convenzione per indicare che un attributo o metodo è destinato all’uso interno della classe, non un meccanismo di sicurezza.\n\n\n15.4.4 Stringhe di documentazione della classe\nSe la prima istruzione nel corpo della classe è un letterale stringa, il compilatore associa quella stringa come stringa di documentazione (o docstring) per la classe. La docstring per la classe è disponibile nell’attributo __doc__; se la prima istruzione nel corpo della classe non è un letterale stringa, il suo valore è None.\nEsempio di docstring di una classe:\n1class C6:\n2  \"\"\"Questa è una classe di esempio.\"\"\"\n  \n3  def metodo(self):\n4    pass\n\n5print(C6.__doc__)\n\n1\n\nDefinizione della classe C6.\n\n2\n\nStringa di documentazione della classe C6.\n\n3\n\nDefinizione di un metodo della classe C6.\n\n4\n\nCorpo del metodo vuoto.\n\n5\n\nStampa della docstring della classe C6.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#istanze",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#istanze",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.5 Istanze",
    "text": "15.5 Istanze\nPer creare un’istanza di una classe, chiamiamo l’oggetto classe come se fosse una funzione. Ogni chiamata restituisce una nuova istanza il cui tipo è quella classe:\n1un_istanza = C5()\n\n1\n\nCreazione di un’istanza della classe C5.\n\n\nLa funzione predefinita isinstance(i, C), con una classe come argomento C, restituisce True quando i è un’istanza della classe C o di qualsiasi sottoclasse di C. Altrimenti, isinstance restituisce False. Se C è una tupla di tipi (o più tipi uniti utilizzando l’operatore |), isinstance restituisce True se i è un’istanza o sottoclasse di uno dei tipi dati, e False altrimenti.\n\n15.5.1 __init__\nQuando una classe definisce o eredita un metodo chiamato __init__, chiamare l’oggetto classe esegue __init__ sulla nuova istanza per eseguire l’inizializzazione per istanza. Gli argomenti passati nella chiamata devono corrispondere ai parametri di __init__, eccetto per il parametro self. Per esempio, consideriamo la seguente definizione di classe:\n1class C6:\n2  def __init__(self, n):\n3    self.x = n\n\n4un_altra_istanza = C6(42)\n\n1\n\nDefinizione della classe C6.\n\n2\n\nDefinizione del metodo __init__ con il parametro n.\n\n3\n\nAssociazione dell’attributo x al valore del parametro n.\n\n4\n\nCreazione di un’istanza della classe C6 con il valore 42 per il parametro n.\n\n\nIl metodo __init__ di solito contiene istruzioni che associano attributi di istanza. Un metodo __init__ non deve restituire un valore diverso da None; se lo fa, Python solleva un’eccezione TypeError.\n\n\n15.5.2 Membri degli oggetti istanza\nUna volta creata un’istanza, possiamo accedere ai suoi membri (dati e metodi) utilizzando l’operatore punto ..\n1un_istanza.ciao()\n\n2print(un_altra_istanza.x)\n\n1\n\nChiamata del metodo ciao dell’istanza un_istanza.\n\n2\n\nStampa del valore dell’attributo x dell’istanza un_altra_istanza.\n\n\nPossiamo dare a un oggetto istanza un attributo associando un valore a un riferimento di attributo.\n1class C7:\n2  pass\n\n3z = C7()\n\n4z.x = 23\n\n5print(z.x)\n\n1\n\nDefinizione della classe C7.\n\n2\n\nCorpo della classe vuoto.\n\n3\n\nCreazione di un’istanza della classe C7.\n\n4\n\nAssociazione dell’attributo x dell’istanza z al valore 23.\n\n5\n\nStampa del valore dell’attributo x dell’istanza z.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#metodi-vincolati-e-non-vincolati",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#metodi-vincolati-e-non-vincolati",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.6 Metodi vincolati e non vincolati",
    "text": "15.6 Metodi vincolati e non vincolati\nIl metodo __get__ di un oggetto funzione può restituire l’oggetto funzione stesso o un oggetto metodo vincolato che avvolge la funzione; un metodo vincolato è associato all’istanza specifica da cui è ottenuto. Un metodo vincolato è un’istanza di un metodo che è legato a un oggetto particolare, il che significa che può essere chiamato senza dover passare l’oggetto come parametro. Al contrario, un metodo non vincolato non è legato a un’istanza e deve essere esplicitamente passato un oggetto come parametro.\nQuando un metodo è chiamato su un’istanza di una classe, Python crea un metodo vincolato, che ha un riferimento implicito all’istanza, passato come il primo argomento self. Questo permette al metodo di accedere agli attributi e ad altri metodi della classe tramite self.\nEsempio di metodo vincolato:\n1class C8:\n2  def saluta(self):\n3    print(\"Ciao!\")\n\nx = C8()\n\nmetodo_vincolato = x.saluta\n\nmetodo_vincolato()\n\n1\n\nDefinizione della classe C8.\n\n2\n\nDefinizione di un metodo della classe C8 chiamato saluta.\n\n3\n\nIl metodo saluta stampa il\n\n\nmessaggio \"Ciao!\". 4. Creazione di un’istanza della classe C8 e assegnazione a x. 5. Ottenimento di un metodo vincolato dall’istanza x e assegnazione a metodo_vincolato. Questo passo associa il metodo saluta all’istanza x, creando un metodo vincolato. 6. Chiamata del metodo vincolato. Questa chiamata è equivalente a x.saluta() e stampa \"Ciao!\".\nQuando metodo_vincolato è chiamato, non c’è bisogno di passare x come argomento perché x è già legato al metodo vincolato. Questo è ciò che rende i metodi vincolati potenti e comodi da usare.\nIn contrasto, un metodo non vincolato può essere ottenuto dalla classe stessa. In tal caso, è necessario passare esplicitamente l’istanza come primo argomento.\nEsempio di metodo non vincolato:\n1metodo_non_vincolato = C8.saluta\n\n2metodo_non_vincolato(x)\n\n1\n\nOttenimento di un metodo non vincolato dalla classe C8 e assegnazione a metodo_non_vincolato.\n\n2\n\nChiamata del metodo non vincolato, passando esplicitamente l’istanza x come argomento. Questo passo è necessario per fornire il contesto (self) per il metodo, poiché metodo_non_vincolato non è legato a nessuna istanza.\n\n\nIn sintesi, i metodi vincolati consentono di chiamare metodi di istanza senza dover passare esplicitamente l’istanza, rendendo il codice più pulito e intuitivo.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#ereditarietà",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#ereditarietà",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.7 Ereditarietà",
    "text": "15.7 Ereditarietà\nQuando utilizziamo un riferimento a un attributo C.nome su un oggetto classe C, e nome non è una chiave in C.__dict__, la ricerca procede implicitamente su ogni oggetto classe che è in C.__bases__ in un ordine specifico (noto storicamente come ordine di risoluzione dei metodi, o MRO, ma che in realtà si applica a tutti gli attributi, non solo ai metodi). Le classi base di C possono a loro volta avere le proprie basi. La ricerca controlla gli antenati diretti e indiretti, uno per uno, nell’MRO, fermandosi quando nome viene trovato.\nEsempio di ereditarietà:\n1class Base:\n2  a = 23\n\n3  def saluta(self):\n4    print(\"Ciao dal Base\")\n\n5class Derivata(Base):\n6  b = 45\n\n7d = Derivata()\n\n8print(d.a)\n\n9d.saluta()\n\n1\n\nDefinizione della classe Base.\n\n2\n\nL’attributo a della classe Base è associato al valore 23.\n\n3\n\nDefinizione di un metodo della classe Base.\n\n4\n\nStampa del messaggio Ciao dal Base.\n\n5\n\nDefinizione della classe Derivata che eredita da Base.\n\n6\n\nL’attributo b della classe Derivata è associato al valore 45.\n\n7\n\nCreazione di un’istanza della classe Derivata.\n\n8\n\nStampa del valore dell’attributo a dell’istanza d.\n\n9\n\nChiamata del metodo saluta dell’istanza d.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#metodi-speciali",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#metodi-speciali",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.8 Metodi speciali",
    "text": "15.8 Metodi speciali\nI metodi speciali in Python sono metodi con due trattini bassi all’inizio e alla fine del loro nome (dunder). Questi metodi vengono chiamati implicitamente in determinate situazioni. Ad esempio, il metodo __init__ viene chiamato quando viene creata una nuova istanza di una classe.\nEsempio di metodo speciale:\n1class C9:\n2  def __init__(self, valore):\n3    self.valore = valore\n\n4  def __str__(self):\n5    return f\"C9 con valore: {self.valore}\"\n\n6c = C9(10)\n\n7print(c)\n\n1\n\nDefinizione della classe C9.\n\n2\n\nDefinizione del metodo __init__ con il parametro valore.\n\n3\n\nAssociazione dell’attributo valore al valore del parametro valore.\n\n4\n\nDefinizione del metodo __str__.\n\n5\n\nRestituzione di una stringa rappresentativa dell’istanza.\n\n6\n\nCreazione di un’istanza della classe C9 con il valore 10.\n\n7\n\nStampa della rappresentazione dell’istanza c.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#metodi-di-classe-e-metodi-statici",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#metodi-di-classe-e-metodi-statici",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.9 Metodi di classe e metodi statici",
    "text": "15.9 Metodi di classe e metodi statici\nIn Python, i metodi possono essere definiti a livello di classe in due modi principali: come metodi statici e come metodi di classe. Entrambi offrono funzionalità diverse rispetto ai metodi di istanza.\n\n15.9.1 Metodi statici\nI metodi statici sono definiti utilizzando il decoratore @staticmethod. Questi metodi non ricevono automaticamente né il riferimento all’istanza (self) né alla classe (cls) come primo argomento. Sono simili alle funzioni normali, ma sono chiamati come membri della classe. Sono utili quando non è necessario accedere né alle variabili di istanza né alle variabili di classe all’interno del metodo.\nEsempio di metodo statico:\n1class Utilita:\n2  @staticmethod\n3  def somma(a, b):\n4    return a + b\n\n# Chiamata al metodo statico senza creare un'istanza\n5print(Utilita.somma(10, 5))\n\n1\n\nDefinizione della classe Utilita.\n\n2\n\nDecoratore @staticmethod per definire un metodo statico.\n\n3\n\nDefinizione del metodo statico somma.\n\n4\n\nIl metodo somma prende due argomenti e restituisce la loro somma.\n\n5\n\nChiamata al metodo statico somma senza creare un’istanza della classe.\n\n\n\n\n15.9.2 Metodi di classe\nI metodi di classe sono definiti utilizzando il decoratore @classmethod. Questi metodi ricevono automaticamente un riferimento alla classe (cls) come primo argomento. Sono utili quando si ha bisogno di accedere o modificare lo stato della classe piuttosto che quello dell’istanza.\nEsempio di metodo di classe:\n1class Contatore:\n2  contatore_comune = 0\n\n3  def __init__(self):\n4    Contatore.contatore_comune += 1\n\n5  @classmethod\n6  def ottieni_contatore(cls):\n7    return cls.contatore_comune\n\n# Creazione di istanze\n8c1 = Contatore()\n9c2 = Contatore()\n\n# Chiamata al metodo di classe\n10print(Contatore.ottieni_contatore())\n\n1\n\nDefinizione della classe Contatore.\n\n2\n\nAttributo di classe contatore_comune.\n\n3\n\nMetodo speciale __init__ per l’inizializzazione.\n\n4\n\nIncrementa l’attributo di classe contatore_comune ogni volta che viene creata una nuova istanza.\n\n5\n\nDecoratore @classmethod per definire un metodo di classe.\n\n6\n\nDefinizione del metodo di classe ottieni_contatore.\n\n7\n\nIl metodo ottieni_contatore restituisce il valore dell’attributo di classe contatore_comune.\n\n8\n\nCreazione di un’istanza della classe Contatore.\n\n9\n\nCreazione di un’altra istanza della classe Contatore.\n\n10\n\nChiamata al metodo di classe ottieni_contatore senza creare un’istanza della classe.\n\n\n\n\n15.9.3 Differenza tra metodi statici e metodi di classe\n\nMetodi statici:\n\nNon ricevono né l’istanza (self) né la classe (cls) come primo argomento.\nSono simili alle funzioni normali, ma possono essere chiamati attraverso il nome della classe.\nUtili per operazioni che non dipendono dallo stato della classe o dell’istanza.\n\nMetodi di classe:\n\nRicevono il riferimento alla classe (cls) come primo argomento.\nPossono accedere e modificare lo stato della classe.\nUtili per operazioni che riguardano lo stato globale della classe.\n\n\n\n\n15.9.4 Casi d’uso\n\nUtilizzare un metodo statico per una funzione di utilità che non necessita di accedere o modificare lo stato della classe o dell’istanza.\nclass Matematica:\n  @staticmethod\n  def moltiplica(a, b):\n    return a * b\n\n  @staticmethod\n  def dividi(a, b):\n    return a / b\n\nprint(Matematica.moltiplica(3, 4))\n\n\nOutput: 12.\n\n\nUtilizzare un metodo di classe per mantenere o ottenere lo stato della classe, come contare il numero di istanze create.\nclass Giocatore:\n  numero_giocatori = 0\n\n  def __init__(self, nome):\n    self.nome = nome\n    Giocatore.numero_giocatori += 1\n\n  @classmethod\n  def ottieni_numero_giocatori(cls):\n    return cls.numero_giocatori\n\ng1 = Giocatore(\"Mario\")\ng2 = Giocatore(\"Luigi\")\n\n1print(Giocatore.ottieni_numero_giocatori())\n\n1\n\nOutput: 2.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#descrittori",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#descrittori",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.10 Descrittori",
    "text": "15.10 Descrittori\nUn descrittore è un oggetto la cui classe fornisce uno o più metodi speciali chiamati __get__, __set__ o __delete__. I descrittori che sono attributi di classe controllano la semantica di accesso e impostazione degli attributi sulle istanze di quella classe.\nEsempio di un descrittore:\n1class Const:\n2  def __init__(self, value):\n3    self.__dict__['value'] = value\n\n4  def __set__(self, *_):\n5    pass\n\n6  def __get__(self, *_):\n7    return self.__dict__['value']\n\n8  def __delete__(self, *_):\n9    pass\n\n10class X:\n11  c = Const(23)\n\n12x = X()\n13print(x.c)\n\n14x.c = 42\n15print(x.c)\n\n16del x.c\n17print(x.c)\n\n1\n\nDefinizione della classe Const.\n\n2\n\nInizializzazione del descrittore con un valore.\n\n3\n\nMemorizzazione del valore nel dizionario dell’istanza.\n\n4\n\nMetodo __set__ del descrittore.\n\n5\n\nIgnora qualsiasi tentativo di impostazione del valore.\n\n6\n\nMetodo __get__ del descrittore.\n\n7\n\nRestituisce il valore memorizzato nel dizionario dell’istanza.\n\n8\n\nMetodo __delete__ del descrittore.\n\n9\n\nIgnora qualsiasi tentativo di eliminazione del valore.\n\n10\n\nDefinizione della classe X.\n\n11\n\nL’attributo c della classe X è un descrittore di tipo Const.\n\n12\n\nCreazione di un’istanza della classe X.\n\n13\n\nStampa del valore dell’attributo c dell’istanza x.\n\n14\n\nTentativo di impostazione del valore dell’attributo c dell’istanza x (ignorato).\n\n15\n\nStampa del valore dell’attributo c dell’istanza x.\n\n16\n\nTentativo di eliminazione dell’attributo c dell’istanza x (ignorato).\n\n17\n\nStampa del valore dell’attributo c dell’istanza x.\n\n\n\n15.10.1 Accesso\nNel caso di accesso ad un membro di una classe sia un descrittore, le regole viste in precedenza si qualificano come di seguito:\n\nSe il membro è un descrittore non sovrascrivente (ovvero, un descrittore che implementa solo il metodo __get__), viene restituito il risultato del metodo __get__ del descrittore. Esempio:\n\nclass DescrittoreNonSovrascrivente:\n  def __init__(self, valore):\n    self.valore = valore\n  \n  def __get__(self, istanza, proprietario):\n1    return self.valore\n\nclass MiaClasse:\n2  descrittore = DescrittoreNonSovrascrivente(\"valore descrittore\")\n\nistanza = MiaClasse()\n3print(istanza.descrittore)\n\n1\n\nIl metodo __get__ restituisce il valore del descrittore.\n\n2\n\nDefinisce un descrittore non sovrascrivente come attributo di classe.\n\n3\n\nTrova descrittore nella classe, chiama DescrittoreNonSovrascrivente.__get__ e restituisce \"valore descrittore\".\n\n\n\nSe il membro è un descrittore sovrascrivente (ovvero, un descrittore che implementa i metodi __get__ e __set__), viene chiamato il metodo __get__ del descrittore, che restituisce il valore dell’attributo. Esempio:\n\nclass DescrittoreSovrascrivente:\n  def __init__(self, valore):\n    self.valore = valore\n  \n  def __get__(self, istanza, proprietario):\n1    return self.valore\n  \n  def __set__(self, istanza, valore):\n2    self.valore = valore\n\nclass MiaClasse:\n3  descrittore = DescrittoreSovrascrivente(\"valore iniziale\")\n\nistanza = MiaClasse()\n4print(istanza.descrittore)\n\n5istanza.descrittore = \"nuovo valore\"\n6print(istanza.descrittore)\n\n1\n\nIl metodo __get__ restituisce il valore del descrittore.\n\n2\n\nIl metodo __set__ permette di modificare il valore del descrittore.\n\n3\n\nDefinisce un descrittore sovrascrivente come attributo di classe.\n\n4\n\nTrova descrittore nella classe, chiama DescrittoreSovrascrivente.__get__ e restituisce \"valore iniziale\".\n\n5\n\nChiama DescrittoreSovrascrivente.__set__ per modificare il valore.\n\n6\n\nTrova descrittore nella classe, chiama DescrittoreSovrascrivente.__get__ e restituisce \"nuovo valore\".\n\n\n\nSe il membro non è un descrittore, viene restituito il valore associato al membro. Esempio:\n\nclass ClasseBase:\n1  attributo_base = \"valore base\"\n\nclass MiaClasse(ClasseBase):\n  pass\n\nistanza = MiaClasse()\n2print(istanza.attributo_base)\n\n1\n\nDefinisce un attributo di classe non descrittore.\n\n2\n\nTrova attributo_base nella classe base e restituisce \"valore base\".\n\n\n\n\n15.10.2 Usi comuni\nUn uso comune dei descrittori è la validazione degli attributi. Ad esempio, possiamo creare un descrittore per assicurare che un attributo sia sempre un numero positivo.\n1class PositiveNumber:\n2  def __init__(self):\n3    self.value = None\n      \n4  def __get__(self, instance, owner):\n5    return self.value\n  \n6  def __set__(self, instance, value):\n7    if value &lt; 0:\n8      raise ValueError(\"Il valore deve essere positivo\")\n\n9    self.value = value\n\n10class Prodotto:\n11  prezzo = PositiveNumber()\n\n12p = Prodotto()\n13p.prezzo = 10\n14print(p.prezzo)\n\n15p.prezzo = -5\n\n1\n\nDefinisce un descrittore PositiveNumber.\n\n2\n\nInizializzazione del descrittore.\n\n3\n\nMemorizzazione del valore.\n\n4\n\nMetodo __get__ del descrittore per ottenere il valore.\n\n5\n\nRestituisce il valore memorizzato.\n\n6\n\nMetodo __set__ del descrittore per impostare il valore.\n\n7\n\nControlla se il valore è negativo.\n\n8\n\nSolleva un’eccezione se il valore è negativo.\n\n9\n\nImposta il valore se è positivo.\n\n10\n\nDefinisce una classe Prodotto.\n\n11\n\nL’attributo prezzo della classe Prodotto è un descrittore di tipo PositiveNumber.\n\n12\n\nCreazione di un’istanza della classe Prodotto.\n\n13\n\nImposta il valore dell’attributo prezzo dell’istanza p.\n\n14\n\nStampa il valore dell’attributo prezzo dell’istanza p.\n\n15\n\nTentativo di impostazione di un valore negativo per l’attributo prezzo (solleva un’eccezione).\n\n\nUn altro uso comune dei descrittori è la memorizzazione nella cache dei risultati di calcoli costosi.\n1class CachedProperty:\n2  def __init__(self, func):\n3    self.func = func\n4    self.value = None\n5    self.is_cached = False\n\n6  def __get__(self, instance, owner):\n7    if not self.is_cached:\n8      self.value = self.func(instance)\n9      self.is_cached = True\n\n10    return self.value\n\n11class DatiComplessi:\n12  @CachedProperty\n13  def calcolo_costoso(self):\n14    print(\"Calcolo in corso...\")\n\n15    return 42\n\n16d = DatiComplessi()\n17print(d.calcolo_costoso)\n18print(d.calcolo_costoso)\n\n1\n\nDefinisce un descrittore CachedProperty.\n\n2\n\nInizializzazione del descrittore con una funzione.\n\n3\n\nMemorizza la funzione.\n\n4\n\nMemorizza il valore.\n\n5\n\nFlag per indicare se il valore è memorizzato nella cache.\n\n6\n\nMetodo __get__ del descrittore per ottenere il valore.\n\n7\n\nControlla se il valore è memorizzato nella cache.\n\n8\n\nCalcola il valore e lo memorizza nella cache se non è presente.\n\n9\n\nImposta il flag di cache.\n\n10\n\nRestituisce il valore memorizzato nella cache.\n\n11\n\nDefinisce una classe DatiComplessi.\n\n12\n\nUtilizza CachedProperty per decorare un metodo.\n\n13\n\nDefinisce un metodo calcolo_costoso.\n\n14\n\nStampa un messaggio durante il calcolo.\n\n15\n\nRestituisce un valore.\n\n16\n\nCreazione di un’istanza della classe DatiComplessi.\n\n17\n\nChiama calcolo_costoso e stampa il risultato (calcola e memorizza nella cache).\n\n18\n\nChiama calcolo_costoso e stampa il risultato (usa il valore memorizzato nella cache).",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-programmazione-orientata-agli-oggetti.html#decoratori",
    "href": "terza-parte-python-programmazione-orientata-agli-oggetti.html#decoratori",
    "title": "15  Programmazione orientata agli oggetti",
    "section": "15.11 Decoratori",
    "text": "15.11 Decoratori\nI decoratori in Python sono funzioni che modificano il comportamento di altre funzioni o metodi. Sono utili per estendere la funzionalità di funzioni o metodi senza modificarne il codice.\nEsempio di decoratore:\n1def mio_decoratore(f):\n2  def wrapper():\n3    print(\"Qualcosa prima della funzione\")\n\n4    f()\n\n5    print(\"Qualcosa dopo la funzione\")\n\n6  return wrapper\n\n7@mio_decoratore\n8def di_ciao():\n9  print(\"Ciao!\")\n\n10di_ciao()\n\n1\n\nDefinizione del decoratore mio_decoratore.\n\n2\n\nDefinizione della funzione wrapper interna.\n\n3\n\nStampa di un messaggio prima della chiamata della funzione decorata.\n\n4\n\nChiamata della funzione decorata.\n\n5\n\nStampa di un messaggio dopo la chiamata della funzione decorata.\n\n6\n\nRestituzione della funzione wrapper.\n\n7\n\nApplicazione del decoratore mio_decoratore alla funzione di_ciao.\n\n8\n\nDefinizione della funzione di_ciao.\n\n9\n\nStampa del messaggio Ciao!.\n\n10\n\nChiamata della funzione di_ciao decorata. Output:\n\n\nQualcosa prima della funzione\nCiao!\nQualcosa dopo la funzione\nL’analogo del codice precedente senza l’uso della sintassi di decorazione @, esplicita ciò che avviene dietro le quinte:\n1def mio_decoratore(f):\n2  def wrapper():\n3    print(\"Qualcosa prima della funzione\")\n\n4    f()\n\n5    print(\"Qualcosa dopo la funzione\")\n\n6  return wrapper\n\n7def di_ciao():\n8  print(\"Ciao!\")\n\n9di_ciao = mio_decoratore(di_ciao)\n\ndi_ciao()\n\n1\n\nDefinizione del decoratore mio_decoratore.\n\n2\n\nDefinizione della funzione wrapper interna.\n\n3\n\nStampa di un messaggio prima della chiamata della funzione decorata.\n\n4\n\nChiamata della funzione decorata.\n\n5\n\nStampa di un messaggio dopo la chiamata della funzione decorata.\n\n6\n\nRestituzione della funzione wrapper.\n\n7\n\nDefinizione della funzione di_ciao.\n\n8\n\nStampa del messaggio Ciao!.\n\n9\n\nApplicazione\n\n\ndel decoratore mio_decoratore alla funzione di_ciao assegnando di_ciao alla funzione wrapper restituita. 10. Chiamata della funzione di_ciao decorata. Output: python   Qualcosa prima della funzione   Ciao!   Qualcosa dopo la funzione\nNel primo esempio, la sintassi @mio_decoratore applica il decoratore alla funzione di_ciao direttamente sopra la definizione della funzione. Nel secondo esempio, il decoratore mio_decoratore viene applicato esplicitamente assegnando di_ciao alla funzione wrapper restituita dal decoratore. Entrambi gli approcci producono lo stesso risultato, ma il secondo esempio mostra chiaramente come tutte le volte che chiamo la funzione devo modificare la sintassi mentre usando il decoratore nella definizione della funzione, ho una sola variazione che non impatta i codici che utilizzano la di_ciao().",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Programmazione orientata agli oggetti</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html",
    "href": "terza-parte-python-moduli.html",
    "title": "16  Moduli",
    "section": "",
    "text": "16.1 Oggetti Modulo\nI moduli in Python sono gestiti come altri oggetti. Pertanto, puoi passare un modulo come argomento in una chiamata a una funzione. Allo stesso modo, una funzione può restituire un modulo come risultato di una chiamata. Un modulo, proprio come qualsiasi altro oggetto, può essere referenziato da una variabile, un elemento in un contenitore o un attributo di un oggetto. I moduli possono essere chiavi o valori in un dizionario e possono essere membri di un insieme. Ad esempio, il dizionario sys.modules contiene oggetti modulo come valori. Il fatto che i moduli possano essere trattati come altri valori in Python è spesso espresso dicendo che i moduli sono oggetti di prima classe.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html#listruzione-import",
    "href": "terza-parte-python-moduli.html#listruzione-import",
    "title": "16  Moduli",
    "section": "16.2 L’istruzione import",
    "text": "16.2 L’istruzione import\nIl codice Python per un modulo chiamato aname vive solitamente in un file chiamato aname.py. Puoi usare qualsiasi file sorgente Python come modulo eseguendo un’istruzione import in un altro file sorgente Python. import ha la seguente sintassi:\nimport modname [as varname][,...]\nDopo la parola chiave import vengono uno o più specificatori di modulo separati da virgole. Nel caso più semplice e comune, un specificatore di modulo è solo modname, un identificatore che Python vincola all’oggetto modulo quando l’istruzione import termina. In questo caso, Python cerca il modulo con lo stesso nome per soddisfare la richiesta di importazione. Ad esempio, questa istruzione:\n1import mymodule\n\n1\n\nCerca il modulo chiamato mymodule e vincola la variabile chiamata mymodule nell’ambito corrente all’oggetto modulo.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html#il-corpo-del-modulo",
    "href": "terza-parte-python-moduli.html#il-corpo-del-modulo",
    "title": "16  Moduli",
    "section": "16.3 Il corpo del modulo",
    "text": "16.3 Il corpo del modulo\nIl corpo di un modulo è la sequenza di istruzioni nel file sorgente del modulo. Non c’è una sintassi speciale richiesta per indicare che un file sorgente è un modulo; puoi usare qualsiasi file sorgente Python valido come modulo. Il corpo di un modulo viene eseguito immediatamente la prima volta che un programma importa il modulo. Quando il corpo inizia a essere eseguito, l’oggetto modulo è già stato creato, con una voce in sys.modules già vincolata all’oggetto modulo. Il namespace (spazio dei nomi) globale del modulo viene gradualmente popolato man mano che il corpo del modulo viene eseguito.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html#attributi-degli-oggetti-modulo",
    "href": "terza-parte-python-moduli.html#attributi-degli-oggetti-modulo",
    "title": "16  Moduli",
    "section": "16.4 Attributi degli oggetti modulo",
    "text": "16.4 Attributi degli oggetti modulo\nUn’istruzione import crea un nuovo spazio di nomi contenente tutti gli attributi del modulo. Per accedere a un attributo in questo spazio di nomi, utilizza il nome o l’alias del modulo come prefisso:\n1import mymodule\n2a = mymodule.f()\n\n1\n\nImporta il modulo mymodule.\n\n2\n\nAccede all’attributo f() del modulo mymodule.\n\n\nNormalmente, sono le istruzioni nel corpo del modulo a vincolare gli attributi di un oggetto modulo. Quando un’istruzione nel corpo del modulo vincola una variabile globale, ciò che viene vincolato è un attributo dell’oggetto modulo.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html#la-funzione-__getattr__",
    "href": "terza-parte-python-moduli.html#la-funzione-__getattr__",
    "title": "16  Moduli",
    "section": "16.5 La funzione __getattr__",
    "text": "16.5 La funzione __getattr__\nUna funzione __getattr__ definita a livello di modulo può creare dinamicamente nuovi attributi del modulo. Un possibile motivo per farlo sarebbe definire attributi che richiedono molto tempo per essere creati; definirli in una funzione __getattr__ a livello di modulo rinvia la creazione degli attributi fino a quando non vengono effettivamente referenziati, se mai lo saranno.\nEcco un esempio di codice che potrebbe essere aggiunto a mymodule.py per rinviare la creazione di un elenco contenente i primi milioni di numeri primi:\n1def __getattr__(name):\n2  if name == 'first_million_primes':\n3    def generate_n_primes(n):\n      # ... codice per generare 'n' numeri primi ...\n      pass\n\n4    import sys\n\n5    this_module = sys.modules[__name__]\n\n6    this_module.first_million_primes = generate_n_primes(1_000_000)\n\n7    return this_module.first_million_primes\n      \n8  raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\n\n1\n\nDefinisce la funzione __getattr__ a livello di modulo.\n\n2\n\nControlla se l’attributo richiesto è first_million_primes.\n\n3\n\nDefinisce una funzione interna per generare ‘n’ numeri primi.\n\n4\n\nImporta il modulo sys.\n\n5\n\nOttiene il modulo corrente da sys.modules.\n\n6\n\nCrea l’attributo first_million_primes nel modulo corrente.\n\n7\n\nRestituisce l’attributo first_million_primes.\n\n8\n\nSolleva un’eccezione AttributeError se l’attributo non è trovato.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html#la-dichiarazione-from",
    "href": "terza-parte-python-moduli.html#la-dichiarazione-from",
    "title": "16  Moduli",
    "section": "16.6 La dichiarazione from",
    "text": "16.6 La dichiarazione from\nL’istruzione from di Python consente di importare attributi specifici da un modulo nello spazio dei nomi corrente. from ha due varianti di sintassi:\nfrom modname import attrname [as varname][,...]\nfrom modname import *\nUn’istruzione from specifica un nome di modulo, seguito da uno o più specificatori di attributo separati da virgole. Nel caso più semplice e comune, uno specificatore di attributo è solo un identificatore attrname, che è una variabile che Python vincola all’attributo con lo stesso nome nel modulo chiamato modname. Ad esempio:\n1from mymodule import f\n\n1\n\nImporta l’attributo f dal modulo mymodule.\n\n\nQuando as varname è parte di uno specificatore di attributo, Python ottiene il valore dell’attributo attrname dal modulo e lo vincola alla variabile varname. Ad esempio:\n1from mymodule import f as foo\n\n1\n\nImporta l’attributo f dal modulo mymodule e lo vincola alla variabile foo.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-moduli.html#gestione-dei-fallimenti-di-importazione",
    "href": "terza-parte-python-moduli.html#gestione-dei-fallimenti-di-importazione",
    "title": "16  Moduli",
    "section": "16.7 Gestione dei fallimenti di importazione",
    "text": "16.7 Gestione dei fallimenti di importazione\nSe stai importando un modulo che non fa parte di Python standard e desideri gestire i fallimenti di importazione, puoi farlo catturando l’eccezione ImportError. Ad esempio, se il tuo codice utilizza il modulo di terze parti rich per formattare l’output in modo opzionale, ma ricade su un output normale se quel modulo non è stato installato, importeresti il modulo utilizzando:\ntry:\n1  import rich\n  \n2except ImportError:\n3  rich = None\n\n1\n\nProva a importare il modulo rich.\n\n2\n\nCattura l’eccezione ImportError se il modulo non è trovato.\n\n3\n\nImposta rich su None se il modulo non è disponibile.\n\n\nPoi, nella parte di output del tuo programma, scriveresti:\n1if rich is not None:\n    # ... output utilizzando le funzionalità del modulo rich ...\n\n2else:\n    # ... output utilizzando le normali istruzioni print() ...\n\n1\n\nControlla se il modulo rich è disponibile.\n\n2\n\nEsegue l’output normale se rich non è disponibile.\n\n\nCon questi esempi, hai una panoramica dettagliata su come creare, importare e gestire moduli in Python, inclusi la gestione degli attributi dinamici e la gestione dei fallimenti di importazione.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Moduli</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-esercitazione-uno.html",
    "href": "terza-parte-python-esercitazione-uno.html",
    "title": "17  Esercitazione 1: web app con Flask",
    "section": "",
    "text": "17.1 Il problema\nIn questa esercitazione, svilupperemo una semplice web app utilizzando Flask. L’applicazione accetterà in input un indirizzo dall’utente e mostrerà la mappa corrispondente utilizzando Google Maps, consentendo all’utente di scegliere il tipo di visualizzazione della mappa (mappa normale, satellite, terreno). Inoltre, permetteremo all’utente di visualizzare punti di interesse (POI) come ristoranti e ospedali e di tracciare un percorso tra due indirizzi.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Esercitazione 1: web app con Flask</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-esercitazione-uno.html#flask",
    "href": "terza-parte-python-esercitazione-uno.html#flask",
    "title": "17  Esercitazione 1: web app con Flask",
    "section": "17.2 Flask",
    "text": "17.2 Flask\nFlask è un micro-framework per il web sviluppato in Python. È semplice da usare e molto flessibile, rendendolo ideale per piccoli progetti web e prototipi. Flask utilizza Jinja2 per il rendering dei template HTML e supporta vari metodi HTTP per la gestione delle richieste web.\n\n17.2.1 Installazione\nPer installare Flask, è possibile utilizzare pip:\npip install Flask\n\n\n17.2.2 Creazione di una semplice web app\nIniziamo creando una semplice applicazione Flask che visualizza Hello, World! quando si accede alla homepage.\nCrea un file chiamato app.py e aggiungi il seguente codice:\n1from flask import Flask\n\n2app = Flask(__name__)\n\n3@app.route('/')\n4def hello_world():\n5  return 'Hello, World!'\n\n6if __name__ == '__main__':\n7  app.run(debug=True)\n\n1\n\nImportiamo la classe Flask dal modulo flask. Questa classe viene utilizzata per creare un’applicazione Flask.\n\n2\n\nCreiamo un’istanza dell’applicazione Flask. __name__ è una variabile speciale che indica il nome del modulo corrente. Flask usa questa variabile per sapere dove trovare risorse come i file di template e di configurazione.\n\n3\n\nUtilizziamo il decoratore @app.route('/') per definire una “route” per la nostra applicazione. Una route è un URL specifico che l’utente può visitare nel browser. In questo caso, la route è la homepage, rappresentata da /.\n\n4\n\nDefiniamo una funzione chiamata hello_world che viene eseguita quando un utente visita la route /.\n\n5\n\nLa funzione hello_world restituisce una stringa 'Hello, World!'. Questo è il contenuto che verrà visualizzato nel browser dell’utente quando visiterà la homepage dell’applicazione.\n\n6\n\nControlliamo se lo script è eseguito direttamente (non importato come modulo in un altro script). Se è così, eseguiamo il codice nel blocco.\n\n7\n\nAvviamo l’applicazione Flask. app.run(debug=True) avvia un server web integrato che esegue l’applicazione. L’opzione debug=True abilita la modalità di debug, che fornisce informazioni dettagliate sugli errori e ricarica automaticamente l’applicazione quando i file di codice vengono modificati.\n\n\n\n\n17.2.3 Esecuzione della web app\nPer eseguire l’applicazione, utilizza il comando:\npython app.py\nNaviga verso http://127.0.0.1:5000/ nel browser per vedere il risultato.\n\n\n17.2.4 Template\nFlask utilizza Jinja2 come motore di template. I template permettono di separare la logica dell’applicazione dalla presentazione. Possiamo creare file HTML che contengono variabili e istruzioni di controllo che vengono sostituite con i dati reali al momento del rendering.\nPer utilizzare i template, crea una cartella chiamata templates nella directory del tuo progetto. All’interno di templates, crea un file chiamato index.html:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n1  &lt;title&gt;Home&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n2  &lt;h1&gt;{{ title }}&lt;/h1&gt;\n3  &lt;p&gt;{{ message }}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n1\n\nTitolo della pagina: Il titolo della pagina HTML, visualizzato nella barra del titolo del browser.\n\n2\n\nVariabile Jinja2 per il titolo: Variabile Jinja2 title che sarà sostituita con il valore passato dal codice Python.\n\n3\n\nVariabile Jinja2 per il messaggio: Variabile Jinja2 message che sarà sostituita con il valore passato dal codice Python.\n\n\nAggiorniamo app.py per utilizzare il template index.html:\n1from flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n2  return render_template('index.html',\n                         title='Hello, World!', \n                         message='Welcome to my Flask app')\n\nif __name__ == '__main__':\n  app.run(debug=True)\n\n1\n\nImportiamo la funzione render_template da Flask.\n\n2\n\nUtilizziamo render_template nella funzione home per renderizzare il template index.html e passare i valori per title e message.\n\n\n\n\n17.2.5 Jinja2\nJinja2 è il motore di template utilizzato da Flask. Permette di inserire variabili, eseguire cicli e condizioni, e molto altro nei file HTML.\nSintassi di base di Jinja2:\n\nVariabili { variabile }.\nCondizioni {% if condizione %} ... {% endif %}.\nCicli {% for item in lista %} ... {% endfor %}.\n\nEsempio con ciclo e condizione:\nAggiorniamo index.html per includere un ciclo e una condizione:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Home&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;{{ title }}&lt;/h1&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;ul&gt;\n  {% for item in items %}\n    &lt;li&gt;{% if item == 'Special' %}&lt;strong&gt;{{ item }}&lt;/strong&gt;{% else %}{{ item }}{% endif %}&lt;/li&gt;\n  {% endfor %}\n  &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nAggiorniamo app.py per passare una lista di elementi al template:\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n  items = ['Item 1', 'Item 2', 'Special', 'Item 3']\n\n  return render_template('index.html', \n                          title='Hello, World!', \n                          message='Welcome to my Flask app', \n                          items=items)\n\nif __name__ == '__main__':\n  app.run(debug=True)\n\n\n17.2.6 Metodi HTTP\nFlask supporta vari metodi HTTP, inclusi GET e POST, che sono i più comunemente utilizzati. I metodi HTTP sono modi standard per inviare e ricevere dati tra il client (come il browser web) e il server. In Flask, dobbiamo considerare questi metodi perché determinano come i dati vengono inviati e ricevuti dall’applicazione. Ad esempio, il metodo GET viene utilizzato per richiedere dati dal server (come caricare una pagina web), mentre il metodo POST viene utilizzato per inviare dati al server (come inviare un modulo).\nCreiamo un semplice modulo di contatto che utilizza sia GET che POST.\nForm HTML, da salvare in templates/contact.html:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Contattaci&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Contattaci&lt;/h1&gt;\n  &lt;form method=\"post\"&gt;\n    &lt;label for=\"nome\"&gt;Nome:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"nome\" name=\"nome\" required&gt;\n    &lt;label for=\"messaggio\"&gt;Messaggio:&lt;/label&gt;\n    &lt;textarea id=\"messaggio\" name=\"messaggio\" required&gt;&lt;/textarea&gt;\n    &lt;input type=\"submit\" value=\"Invia\"&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nAggiornamento di app.py:\n1from flask import Flask, render_template, request\n\n2app = Flask(__name__)\n\n3@app.route('/')\n4def home():\n5  items = ['Item 1', 'Item 2', 'Special', 'Item 3']\n\n  return render_template('index.html', \n                         title='Hello, World!', \n                         message='Welcome to my Flask app', \n6                         items=items)\n\n7@app.route('/contact', methods=['GET', 'POST'])\n8def contact():\n9  if request.method == 'POST':\n10    nome = request.form['nome']\n\n11    messaggio = request.form['messaggio']\n\n12\n\n13    return f'Thank you {nome}, your message has been received.'\n\n14  return render_template('contact.html')\n\n15if __name__ == '__main__':\n16  app.run(debug=True)\n\n1\n\nImportiamo Flask, render_template e request da Flask per gestire i dati dei moduli.\n\n2\n\nCreiamo un’applicazione Flask.\n\n3\n\nDefiniamo la route per la homepage con il decoratore @app.route('/').\n\n4\n\nDefiniamo la funzione home che viene chiamata quando la homepage viene richiesta.\n\n5\n\nCreiamo una lista di oggetti da passare al template.\n\n6\n\nUtilizziamo render_template per rendere il template index.html con variabili title, message e items.\n\n7\n\nDefiniamo la route /contact che gestisce sia le richieste GET che POST.\n\n8\n\nDefiniamo la funzione contact che gestisce la logica per la route /contact.\n\n9\n\nSe il metodo della richiesta è POST, elaboriamo i dati del modulo.\n\n10\n\nOtteniamo il valore del campo nome dal modulo.\n\n11\n\nOtteniamo il valore del campo messaggio dal modulo.\n\n12\n\nQui, è possibile aggiungere codice per elaborare i dati del modulo, come inviarli via email.\n\n13\n\nRestituiamo un messaggio di ringraziamento con il nome dell’utente.\n\n14\n\nSe il metodo è GET, visualizziamo il modulo di contatto.\n\n15\n\nEseguiamo l’applicazione Flask in modalità di debug.\n\n16\n\nAvviamo il server Flask.\n\n\n\n\n17.2.7 Per continuare\nQuesta introduzione copre le basi di Flask, inclusi template, Jinja2 e metodi HTTP. Flask è un framework potente e flessibile che rende lo sviluppo web con Python semplice ed efficace. Per ulteriori approfondimenti, è possibile consultare la documentazione ufficiale di Flask.\n\n\n17.2.8 Esercitazione 1: web app con Flask",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Esercitazione 1: web app con Flask</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-esercitazione-uno.html#il-problema-1",
    "href": "terza-parte-python-esercitazione-uno.html#il-problema-1",
    "title": "17  Esercitazione 1: web app con Flask",
    "section": "17.3 Il problema",
    "text": "17.3 Il problema\nIn questa esercitazione, svilupperemo una semplice web app utilizzando Flask. L’applicazione accetterà in input un indirizzo dall’utente e mostrerà la mappa corrispondente utilizzando Google Maps, consentendo all’utente di scegliere il tipo di visualizzazione della mappa (mappa normale, satellite, terreno) e visualizzare i dettagli dell’indirizzo. Inoltre, sarà possibile tracciare un percorso tra due indirizzi.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Esercitazione 1: web app con Flask</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-esercitazione-uno.html#flask-1",
    "href": "terza-parte-python-esercitazione-uno.html#flask-1",
    "title": "17  Esercitazione 1: web app con Flask",
    "section": "17.4 Flask",
    "text": "17.4 Flask\nFlask è un micro-framework per il web sviluppato in Python. È semplice da usare e molto flessibile, rendendolo ideale per piccoli progetti web e prototipi. Flask utilizza Jinja2 per il rendering dei template HTML e supporta vari metodi HTTP per la gestione delle richieste web.\n\n17.4.1 Installazione\nPer installare Flask, è possibile utilizzare pip:\npip install Flask\n\n\n17.4.2 Creazione di una semplice web app\nIniziamo creando una semplice applicazione Flask che visualizza Hello, World! quando si accede alla homepage.\nCrea un file chiamato app.py e aggiungi il seguente codice:\n1from flask import Flask\n\n2app = Flask(__name__)\n\n3@app.route('/')\n4def hello_world():\n5    return 'Hello, World!'\n\n6if __name__ == '__main__':\n7    app.run(debug=True)\n\n1\n\nImportiamo la classe Flask dal modulo flask.\n\n2\n\nCreiamo un’istanza dell’applicazione Flask.\n\n3\n\nUtilizziamo il decoratore @app.route('/') per definire una route per la nostra applicazione.\n\n4\n\nDefiniamo una funzione chiamata hello_world che viene eseguita quando un utente visita la route /.\n\n5\n\nLa funzione hello_world restituisce una stringa 'Hello, World!'.\n\n6\n\nControlliamo se lo script è eseguito direttamente.\n\n7\n\nAvviamo l’applicazione Flask in modalità debug.\n\n\n\n\n17.4.3 Esecuzione della web app\nPer eseguire l’applicazione, utilizza il comando:\npython app.py\nNaviga verso http://127.0.0.1:5000/ nel browser per vedere il risultato.\n\n\n17.4.4 Template\nFlask utilizza Jinja2 come motore di template. I template permettono di separare la logica dell’applicazione dalla presentazione. Possiamo creare file HTML che contengono variabili e istruzioni di controllo che vengono sostituite con i dati reali al momento del rendering.\nPer utilizzare i template, crea una cartella chiamata templates nella directory del tuo progetto. All’interno di templates, crea un file chiamato index.html:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n1  &lt;title&gt;Home&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n2  &lt;h1&gt;{{ title }}&lt;/h1&gt;\n3  &lt;p&gt;{{ message }}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n1\n\nTitolo della pagina.\n\n2\n\nVariabile Jinja2 per il titolo.\n\n3\n\nVariabile Jinja2 per il messaggio.\n\n\nAggiorniamo app.py per utilizzare il template index.html:\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return render_template('index.html', \n                           title='Hello, World!', \n                           message='Welcome to my Flask app')\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\nImportiamo la funzione render_template da Flask.\nUtilizziamo render_template nella funzione home per rendere il template index.html e passare i valori per title e message.\n\n\n\n17.4.5 Jinja2\nJinja2 è il motore di template utilizzato da Flask. Permette di inserire variabili, eseguire cicli e condizioni, e molto altro nei file HTML.\nSintassi di base di Jinja2:\n\nVariabili { variabile }.\nCondizioni {% if condizione %} ... {% endif %}.\nCicli {% for item in lista %} ... {% endfor %}.\n\nAggiorniamo index.html per includere un ciclo e una condizione:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Home&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;{{ title }}&lt;/h1&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;ul&gt;\n  {% for item in items %}\n    &lt;li&gt;{% if item == 'Special' %}&lt;strong&gt;{{ item }}&lt;/strong&gt;{% else %}{{ item }}{% endif %}&lt;/li&gt;\n  {% endfor %}\n  &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nAggiorniamo app.py per passare una lista di elementi al template:\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    items = ['Item 1', 'Item 2', 'Special', 'Item 3']\n    return render_template('index.html', \n                           title='Hello, World!', \n                           message='Welcome to my Flask app', \n                           items=items)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\nDefiniamo una lista di oggetti da passare al template.\nPassiamo la lista di oggetti items al template.\n\n\n\n17.4.6 Metodi HTTP\nFlask supporta vari metodi HTTP, inclusi GET e POST, che sono i più comunemente utilizzati. I metodi HTTP sono modi standard per inviare e ricevere dati tra il client (come il browser web) e il server. In Flask, dobbiamo considerare questi metodi perché determinano come i dati vengono inviati e ricevuti dall’applicazione. Ad esempio, il metodo GET viene utilizzato per richiedere dati dal server (come caricare una pagina web), mentre il metodo POST viene utilizzato per inviare dati al server (come inviare un modulo).\nCreiamo un semplice modulo di contatto che utilizza sia GET che POST.\nForm HTML (templates/contact.html):\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Contattaci&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Contattaci&lt;/h1&gt;\n  &lt;form method=\"post\"&gt;\n    &lt;label for=\"nome\"&gt;Nome:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"nome\" name=\"nome\" required&gt;\n    &lt;label for=\"messaggio\"&gt;Messaggio:&lt;/label&gt;\n    &lt;textarea id=\"messaggio\" name=\"messaggio\" required&gt;&lt;/textarea&gt;\n    &lt;input type=\"submit\" value=\"Invia\"&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nAggiornamento di app.py:\n1from flask import Flask, render_template, request\n\n2app = Flask(__name__)\n\n3@app.route('/')\n4def home():\n5    items = ['Item 1', 'Item 2', 'Special', 'Item 3']\n    return render_template('index.html', \n                           title='Hello, World!', \n                           message='Welcome to my Flask app', \n6                           items=items)\n\n7@app.route('/contact', methods=['GET', 'POST'])\n8def contact():\n9    if request.method == 'POST':\n10        nome = request.form['nome']\n11        messaggio = request.form['messaggio']\n\n12\n13        return f'Thank you {nome}, your message has been received.'\n14    return render_template('contact.html')\n\n15if __name__ == '__main__':\n16    app.run(debug=True)\n\n1\n\nImportiamo Flask, render_template e request da Flask per gestire i dati dei moduli.\n\n2\n\nCreiamo un’applicazione Flask.\n\n3\n\nDefiniamo la route per la homepage con il decoratore @app.route('/').\n\n4\n\nDefiniamo la funzione home che viene chiamata quando la homepage viene richiesta.\n\n5\n\nCreiamo una lista di oggetti da passare al template.\n\n6\n\nUtilizziamo render_template per rendere il template index.html con variabili title, message e items.\n\n7\n\nDefiniamo la route /contact che gestisce sia le richieste GET che POST.\n\n8\n\nDefiniamo la funzione contact che gestisce la logica per la route /contact.\n\n9\n\nSe il metodo della richiesta è POST, elaboriamo i dati del modulo.\n\n10\n\nOtteniamo il valore del campo nome dal modulo.\n\n11\n\nOtteniamo il valore del campo messaggio dal modulo.\n\n12\n\nQui, è possibile aggiungere codice per elaborare i dati del modulo, come inviarli via email.\n\n13\n\nRestituiamo un messaggio di ringraziamento con il nome dell’utente.\n\n14\n\nSe il metodo è GET, visualizziamo il modulo di contatto.\n\n15\n\nEseguiamo l’applicazione Flask in modalità di debug.\n\n16\n\nAvviamo il server Flask.\n\n\n\n\n17.4.7 Per continuare\nQuesta introduzione copre le basi di Flask, inclusi template, Jinja2 e metodi HTTP. Flask è un framework potente e flessibile che rende lo sviluppo web con Python semplice ed efficace. Per ulteriori approfondimenti, è possibile consultare la documentazione ufficiale di Flask.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Esercitazione 1: web app con Flask</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-esercitazione-uno.html#passaggi-dellesercitazione",
    "href": "terza-parte-python-esercitazione-uno.html#passaggi-dellesercitazione",
    "title": "17  Esercitazione 1: web app con Flask",
    "section": "17.5 Passaggi dell’esercitazione",
    "text": "17.5 Passaggi dell’esercitazione\n\nCreare un’applicazione Flask.\nImplementare della pagina web per l’inserimento dell’indirizzo.\nIntegrare Google Maps per visualizzare la mappa basata sull’indirizzo inserito.\nConsentire la selezione del tipo di visualizzazione della mappa.\nVisualizzare una tabella con i dettagli dell’indirizzo.\nPermettere di tracciare un percorso tra due indirizzi.\n\n\n17.5.1 Passaggio 1: creazione di un’applicazione Flask\nIl primo passo è creare una semplice applicazione Flask. Creiamo un file chiamato app.py che analizza due template cioè due file HTML delle variabili i cui valori saranno definiti al tempo di esecuzione.\nLa struttura dei file su disco prevede una cartella radice dove posizioniamo app.py, VisualizzaMappa e la sottocartella templates dove andranno i template delle pagine HTML:\nVisualizzaMappa/\n├── app.py\n├── templates/\n│   ├── index.html\n│   └── mappa.html\n│   └── route.html\n└── static/\napp.py:\n1from flask import Flask, render_template, request\n2import requests\n\n3app = Flask(__name__)\n\nGOOGLE_API_KEY = \"INSERIRE CHIAVE API GOOGLE MAPS\"\n\n\n4@app.route('/', methods=['GET', 'POST'])\ndef home():\n5  if request.method == 'POST':\n6    indirizzo = request.form['indirizzo']\n7    visualizzazione = request.form['visualizzazione']\n\n    geocode_url = f\"https://maps.googleapis.com/maps/api/geocode/json?\" + \\\n8                  f\"address={indirizzo}&key={GOOGLE_API_KEY}\"\n\n9    response = requests.get(geocode_url)\n10    data = response.json()\n\n11    if data['status'] == 'OK':\n12      result = data['results'][0]\n13      dettagli = {\n        'Indirizzo Formattato': result['formatted_address'],\n        'Latitudine': result['geometry']['location']['lat'],\n        'Longitudine': result['geometry']['location']['lng'],\n        'Tipo di Luogo': result['types']\n      }\n    else:\n14      dettagli = None\n\n    return render_template('mappa.html',\n                           indirizzo=indirizzo,\n                           visualizzazione=visualizzazione,\n                           dettagli=dettagli,\n15                           api_key=GOOGLE_API_KEY)\n\n16  return render_template('index.html')\n\n\n17@app.route('/route', methods=['GET', 'POST'])\ndef route():\n18  if request.method == 'POST':\n19    start = request.form['start']\n20    end = request.form['end']\n\n    return render_template('route.html',\n                           start=start,\n                           end=end,\n21                           api_key=GOOGLE_API_KEY)\n\n22  return render_template('route_form.html')\n\n\nif __name__ == '__main__':\n23  app.run(debug=True)\n\n1\n\nImporta Flask e i moduli necessari per gestire le richieste e i template.\n\n2\n\nImporta il modulo requests per effettuare richieste HTTP.\n\n3\n\nCrea l’istanza dell’applicazione Flask.\n\n4\n\nDefinisce una route per la homepage, che accetta sia richieste GET che POST.\n\n5\n\nControlla se la richiesta è di tipo POST.\n\n6\n\nOttiene l’indirizzo inserito dall’utente nel modulo HTML.\n\n7\n\nOttiene il tipo di visualizzazione selezionato dall’utente nel modulo HTML.\n\n8\n\nCostruisce l’URL per l’API di Google Maps per ottenere i dettagli dell’indirizzo.\n\n9\n\nEffettua una richiesta HTTP all’API di Google Maps.\n\n10\n\nConverte la risposta JSON in un dizionario Python.\n\n11\n\nControlla se la richiesta all’API di Google Maps è andata a buon fine.\n\n12\n\nOttiene il primo risultato dalla risposta dell’API.\n\n13\n\nEstrae i dettagli dell’indirizzo dalla risposta dell’API.\n\n14\n\nSe la richiesta all’API di Google Maps non è andata a buon fine, imposta dettagli a None.\n\n15\n\nRenderizza il template mappa.html, passando l’indirizzo, il tipo di visualizzazione e i dettagli come variabili.\n\n16\n\nRenderizza il template index.html per le richieste GET.\n\n17\n\nDefinisce una route per il percorso, che accetta sia richieste GET che POST.\n\n18\n\nControlla se la richiesta è di tipo POST.\n\n19\n\nOttiene l’indirizzo di partenza inserito dall’utente nel modulo HTML.\n\n20\n\nOttiene l’indirizzo di arrivo inserito dall’utente nel modulo HTML.\n\n21\n\nRenderizza il template route.html, passando gli indirizzi di partenza e arrivo come variabili.\n\n22\n\nRenderizza il template route_form.html per le richieste GET.\n\n23\n\nAvvia l’applicazione Flask in modalità debug.\n\n\n\n\n17.5.2 Passaggio 2: implementazione della pagina web per inserimento indirizzo\nCreiamo una pagina web che permetta agli utenti di inserire un indirizzo e selezionare il tipo di visualizzazione della mappa. Creiamo un file chiamato templates/index.html.\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Inserisci Indirizzo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Inserisci un indirizzo&lt;/h1&gt;\n  &lt;form method=\"post\"&gt;\n    &lt;label for=\"indirizzo\"&gt;Indirizzo:&lt;/label&gt;\n1    &lt;input type=\"text\" id=\"indirizzo\" name=\"indirizzo\" required&gt;\n    &lt;label for=\"visualizzazione\"&gt;Visualizzazione:&lt;/label&gt;\n2    &lt;select id=\"visualizzazione\" name=\"visualizzazione\"&gt;\n      &lt;option value=\"roadmap\"&gt;Mappa&lt;/option&gt;\n      &lt;option value=\"satellite\"&gt;Satellite&lt;/option&gt;\n      &lt;option value=\"terrain\"&gt;Terreno&lt;/option&gt;\n    &lt;/select&gt;\n3    &lt;input type=\"submit\" value=\"Mostra Mappa\"&gt;\n  &lt;/form&gt;\n  &lt;h1&gt;Traccia un percorso&lt;/h1&gt;\n  &lt;form method=\"post\" action=\"/route\"&gt;\n    &lt;label for=\"start\"&gt;Partenza:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"start\" name=\"start\" required&gt;\n    &lt;label for=\"end\"&gt;Arrivo:&lt;/label&gt;\n    &lt;input type=\"text\" id=\"end\" name=\"end\" required&gt;\n    &lt;input type=\"submit\" value=\"Traccia Percorso\"&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n1\n\nCampo di input per l’indirizzo.\n\n2\n\nDropdown per selezionare il tipo di visualizzazione della mappa.\n\n3\n\nPulsante di invio per il modulo.\n\n\n\n\n17.5.3 Passaggio 3: integrazione di Google Maps\nCreiamo un template per visualizzare la mappa di Google. Creiamo un file chiamato templates/mappa.html.\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Mappa&lt;/title&gt;\n1  &lt;script src=\"https://maps.googleapis.com/maps/api/js?key={{ api_key }}&libraries=places\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    function initMap() {\n      var geocoder = new google.maps.Geocoder();\n2      var indirizzo = \"{{ indirizzo }}\";\n3      var visualizzazione = \"{{ visualizzazione }}\";\n      geocoder.geocode({'address': indirizzo}, function(results, status) {\n        if (status === 'OK') {\n          var mapOptions = {\n            zoom: 15,\n            center: results[0].geometry.location,\n4            mapTypeId: visualizzazione,\n5            tilt: 45\n          };\n          var map = new google.maps.Map(document.getElementById('map'), mapOptions);\n\n          var service = new google.maps.places.PlacesService(map);\n          service.nearbySearch({\n            location: results[0].geometry.location,\n            radius: 1000,\n            type: ['restaurant']\n          }, function(results, status) {\n            if (status === google.maps.places.PlacesServiceStatus.OK) {\n              for (var i = 0; i &lt; results.length; i++) {\n                var place = results[i];\n                new google.maps.Marker({\n                  position: place.geometry.location,\n                  map: map,\n                  title: place.name\n                });\n              }\n            }\n          });\n\n          var panorama = new google.maps.StreetViewPanorama(\n            document.getElementById('street-view'), {\n              position: results[0].geometry.location,\n              pov: {\n                heading: 34,\n                pitch: 10\n              }\n            });\n6          map.setStreetView(panorama);\n        } else {\n          alert('Geocode non riuscito per il seguente motivo: ' + status);\n        }\n      });\n    }\n  &lt;/script&gt;\n&lt;/head&gt;\n7&lt;body onload=\"initMap()\"&gt;\n  &lt;h1&gt;Mappa di {{ indirizzo }}&lt;/h1&gt;\n8  &lt;div id=\"map\" style=\"height: 500px; width: 100%;\"&gt;&lt;/div&gt;\n9  &lt;div id=\"street-view\" style=\"height: 500px; width: 100%; margin-top: 20px;\"&gt;&lt;/div&gt;\n10  {% if dettagli %}\n  &lt;h2&gt;Dettagli Indirizzo&lt;/h2&gt;\n  &lt;table&gt;\n    &lt;tr&gt;&lt;th&gt;Chiave&lt;/th&gt;&lt;th&gt;Valore&lt;/th&gt;&lt;/tr&gt;\n    {% for chiave, valore in dettagli.items() %}\n    &lt;tr&gt;&lt;td&gt;{{ chiave }}&lt;/td&gt;&lt;td&gt;{{ valore }}&lt;/td&gt;&lt;/tr&gt;\n    {% endfor %}\n  &lt;/table&gt;\n11  {% else %}\n  &lt;p&gt;Dettagli non disponibili.&lt;/p&gt;\n  {% endif %}\n&lt;/body&gt;\n&lt;/html&gt;\n\n1\n\nCarica l’API di Google Maps con la chiave API.\n\n2\n\nInserisce l’indirizzo passato dal backend.\n\n3\n\nInserisce il tipo di visualizzazione passato dal backend.\n\n4\n\nImposta il tipo di visualizzazione della mappa.\n\n5\n\nAggiunge l’inclinazione per la visualizzazione 3D.\n\n6\n\nUtilizza l’API di Street View per creare una vista 3D interattiva.\n\n7\n\nChiama la funzione initMap quando la pagina è caricata.\n\n8\n\ndiv per visualizzare la mappa.\n\n9\n\ndiv per visualizzare la Street View sotto la mappa principale.\n\n10\n\nControlla se i dettagli dell’indirizzo sono disponibili.\n\n11\n\nMessaggio di fallback se i dettagli non sono disponibili.\n\n\nCreiamo un template per tracciare il percorso. Creiamo un file chiamato templates/route.html.\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Percorso&lt;/title&gt;\n1  &lt;script src=\"https://maps.googleapis.com/maps/api/js?key={{ api_key }}\"&gt;&lt;/script&gt;\n  &lt;script&gt;\n    function initMap() {\n      var directionsService = new google.maps.DirectionsService();\n      var directionsRenderer = new google.maps.DirectionsRenderer();\n2      var start = \"{{ start }}\";\n3      var end = \"{{ end }}\";\n      var map = new google.maps.Map(document.getElementById('map'), {\n        zoom: 7,\n        center: {lat: 41.85, lng: -87.65}\n      });\n      directionsRenderer.setMap(map);\n      var request = {\n        origin: start,\n        destination: end,\n        travelMode: 'DRIVING'\n      };\n      directionsService.route(request, function(result, status) {\n        if (status === 'OK') {\n          directionsRenderer.setDirections(result);\n        } else {\n          alert('Directions request failed due to ' + status);\n        }\n      });\n    }\n  &lt;/script&gt;\n&lt;/head&gt;\n4&lt;body onload=\"initMap()\"&gt;\n  &lt;h1&gt;Percorso da {{ start }} a {{ end }}&lt;/h1&gt;\n5  &lt;div id=\"map\" style=\"height: 500px; width: 100%;\"&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n1\n\nCarica l’API di Google Maps con la chiave API.\n\n2\n\nInserisce l’indirizzo di partenza passato dal backend.\n\n3\n\nInserisce l’indirizzo di arrivo passato dal backend.\n\n4\n\nChiama la funzione initMap quando la pagina è caricata.\n\n5\n\ndiv per visualizzare il percorso sulla mappa.\n\n\n\n\n17.5.4 Passaggio 4: test dell’applicazione\nEseguiamo l’applicazione Flask:\npython app.py\nApriamo il browser e navighiamo all’indirizzo http://127.0.0.1:5000/. Inseriamo un indirizzo, selezioniamo il tipo di visualizzazione e clicchiamo su Mostra Mappa. La mappa di Google dovrebbe essere visualizzata con l’indirizzo inserito e il tipo di visualizzazione selezionato. Inoltre, possiamo inserire gli indirizzi di partenza e arrivo per tracciare un percorso sulla mappa. I dettagli dell’indirizzo verranno mostrati in una tabella sotto la mappa.",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Esercitazione 1: web app con Flask</span>"
    ]
  },
  {
    "objectID": "terza-parte-python-esercitazione-uno.html#file",
    "href": "terza-parte-python-esercitazione-uno.html#file",
    "title": "17  Esercitazione 1: web app con Flask",
    "section": "17.6 File",
    "text": "17.6 File\napp.py\nindex.html\nmappa.html\nroute.html",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Esercitazione 1: web app con Flask</span>"
    ]
  },
  {
    "objectID": "appendice-riferimenti.html#footnotes",
    "href": "appendice-riferimenti.html#footnotes",
    "title": "Riferimenti",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione",
      "Appendici",
      "Riferimenti"
    ]
  },
  {
    "objectID": "antonio.html#footnotes",
    "href": "antonio.html#footnotes",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎"
  },
  {
    "objectID": "come-collaborare.html#footnotes",
    "href": "come-collaborare.html#footnotes",
    "title": "Da neofita di Python a campione",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎"
  },
  {
    "objectID": "prima-parte.html#footnotes",
    "href": "prima-parte.html#footnotes",
    "title": "Prima parte: I fondamenti della programmazione",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione",
      "Prima parte: I fondamenti della programmazione"
    ]
  },
  {
    "objectID": "seconda-parte.html#footnotes",
    "href": "seconda-parte.html#footnotes",
    "title": "Seconda parte: Le basi di Python",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione",
      "Seconda parte: Le basi di Python"
    ]
  },
  {
    "objectID": "terza-parte.html#footnotes",
    "href": "terza-parte.html#footnotes",
    "title": "Terza parte: Python orientato agli oggetti",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione",
      "Terza parte: Python orientato agli oggetti"
    ]
  },
  {
    "objectID": "quarta-parte.html#footnotes",
    "href": "quarta-parte.html#footnotes",
    "title": "Quarta parte: Python avanzato",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione",
      "Quarta parte: Python avanzato"
    ]
  },
  {
    "objectID": "quinta-parte.html#footnotes",
    "href": "quinta-parte.html#footnotes",
    "title": "Quinta parte: strumenti",
    "section": "",
    "text": "Antomon?↩︎\nAntomon?↩︎",
    "crumbs": [
      "Prefazione",
      "Quinta parte: strumenti"
    ]
  }
]