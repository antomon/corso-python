---
reference-location: margin
citation-location: margin
---

# La semantica dei linguaggi di programmazione

Dopo aver esaminato la sintassi dei linguaggi di programmazione, ci concentriamo ora sulla **semantica**, l'altra componente fondamentale di un linguaggio di programmazione. Mentre la sintassi si occupa della forma e della struttura del codice, la semantica riguarda il significato delle istruzioni e come queste vengono interpretate ed eseguite dal computer.

La semantica di un linguaggio di programmazione definisce come le istruzioni sintatticamente corrette devono essere interpretate e quale effetto producono quando vengono eseguite. È il ponte tra la struttura formale del codice e il suo comportamento effettivo durante l'esecuzione.

L'importanza della comprensione della semantica è simile alla comprensione del significato delle parole e delle frasi in un linguaggio naturale:

1. Correttezza del programma: Una buona comprensione della semantica permette di scrivere programmi che non solo sono sintatticamente corretti, ma che producono anche i risultati desiderati.

2. Debugging efficace: Conoscere la semantica aiuta a identificare e correggere errori logici nel codice, che possono essere più sottili e difficili da individuare rispetto agli errori sintattici.

3. Ottimizzazione del codice: Una comprensione approfondita della semantica consente di scrivere codice più efficiente, sfruttando al meglio le caratteristiche del linguaggio.

4. Portabilità del codice: Conoscere le sfumature semantiche di diversi linguaggi aiuta a scrivere codice che si comporta in modo coerente su piattaforme diverse.

5. Comunicazione tra programmatori: Una chiara comprensione della semantica facilita la collaborazione tra sviluppatori, permettendo di discutere e ragionare sul comportamento del codice in modo preciso.

## Tipi di semantica

Esistono diversi tipi di semantica nel contesto dei linguaggi di programmazione. Ciascun tipo di semantica ha un ruolo specifico e può essere particolarmente rilevante a seconda del linguaggio di programmazione o del paradigma di programmazione adottato.

### Semantica statica

La **semantica statica** riguarda le regole che possono essere verificate durante la compilazione, senza eseguire il programma. Include il controllo dei tipi, la verifica della dichiarazione delle variabili prima del loro uso e altre regole che non dipendono dall'esecuzione del programma.

Esempio in Java:

```java
int x = 10;
String y = "Hello";

y = x;  // <1>
```
1. Il compilatore segnala un errore su questa riga perché non è possibile assegnare un valore intero a una variabile di tipo stringa.

### Semantica dinamica

La **semantica dinamica** si riferisce al comportamento del programma durante l'esecuzione. Descrive come le istruzioni vengono eseguite e come il programma si evolve nel tempo.

Esempio in Python:

```python
def divide(a, b):  # <1>
  return a / b  # <2>

print(divide(10, 2))  # <3>
print(divide(10, 0))  # <4>
```
1. Definizione della funzione `divide` che accetta due parametri `a` e `b`.
2. La funzione `divide` ritorna il risultato della divisione di `a` per `b`.
3. `print(divide(10, 2))` stampa `5.0`.
4. `print(divide(10, 0))` causa un errore a runtime per la divisione per zero.

### Semantica operazionale

La **semantica operazionale** spiega come un programma esegue le sue istruzioni passo dopo passo. Immaginiamo di seguire una ricetta di cucina: la semantica operazionale ci direbbe esattamente cosa fare in ogni passo, come prendere un ingrediente, mescolarlo, cuocerlo, ecc.

In termini di programmazione, la semantica operazionale descrive come ogni istruzione del programma modifica lo stato del computer, come i valori delle variabili o il flusso di esecuzione. Questo tipo di semantica è spesso utilizzato per definire formalmente come dovrebbe comportarsi un linguaggio di programmazione, fornendo una guida precisa su come il codice dovrebbe essere eseguito dal computer.

Esempio in C++:

```cpp
for (int i = 0; i < 5; i++) {  /* <1> */
  if (i % 2 == 0) {  /* <2> */
    continue;  /* <3> */
  }

  std::cout << i << std::endl;  /* <4> */
}
```
1. Ciclo `for` che itera da `0` a `4`.
2. Controllo condizionale per verificare se `i` è pari.
3. `continue` salta le iterazioni pari.
4. Stampa solo i valori dispari di `i`.

### Semantica denotazionale

La **semantica denotazionale** è un approccio formale per definire il significato di un programma associando ogni costrutto del linguaggio a una denotazione matematica, tipicamente una funzione. Questo metodo consente di ragionare in modo rigoroso e preciso sul comportamento dei programmi.

In altre parole, ogni parte di un programma è mappata a un valore o a una funzione matematica. Questa mappatura permette di comprendere e prevedere il comportamento del programma in termini matematici, indipendentemente dall'implementazione concreta.

Consideriamo un esempio di codice in Python che filtra, ordina e somma elementi di una lista:

```python
def filtra_pari(lista):  # <1>
  return [x for x in lista if x % 2 == 0]  # <2>

def ordina(lista):  # <3>
  return sorted(lista)  # <4>

def somma_primi_tre(lista):  # <5>
  return sum(lista[:3])  # <6>

lista = [5, 3, 8, 6, 2, 9, 1, 4, 7]  # <7>

lista_pari = filtra_pari(lista)  # <8>

lista_ordinata = ordina(lista_pari)  # <9>

risultato = somma_primi_tre(lista_ordinata)  # <10>

print(risultato)  # <11>
```
1. Definizione della funzione `filtra_pari` che accetta una lista.
2. La funzione `filtra_pari` restituisce una nuova lista contenente solo i numeri pari.
3. Definizione della funzione `ordina` che accetta una lista.
4. La funzione `ordina` restituisce la lista ordinata.
5. Definizione della funzione `somma_primi_tre` che accetta una lista.
6. La funzione `somma_primi_tre` restituisce la somma dei primi tre elementi della lista.
7. Definizione della lista `lista` contenente numeri interi.
8. Applicazione della funzione `filtra_pari` alla lista `lista`, memorizzando il risultato in `lista_pari`.
9. Applicazione della funzione `ordina` alla lista `lista_pari`, memorizzando il risultato in `lista_ordinata`.
10. Applicazione della funzione `somma_primi_tre` alla lista `lista_ordinata`, memorizzando il risultato in `risultato`.
11. Stampa del valore di `risultato`.

La relativa mappatura denotazionale diviene:

- `filtra_pari(lista)` corrisponde a una funzione $F$ che mappa una lista $L$ a una lista contenente solo gli elementi pari di $L$.

- `ordina(lista)` corrisponde a una funzione $S$ che mappa una lista $L$ alla lista ordinata.

- `somma_primi_tre(lista)` corrisponde a una funzione $T$ che mappa una lista $L$ alla somma dei suoi primi tre elementi.

Quindi, il programma può essere rappresentato come la composizione delle funzioni matematiche:

$$
T(S(F(L)))
$$

dove $L$ è la lista iniziale, $F$ è `filtra_pari`, $S$ è `ordina`, e $T$ è `somma_primi_tre`.

La semantica denotazionale è utilizzata per garantire la correttezza dei programmi e per la verifica formale del loro comportamento. È un approccio potente per verificare che un programma rispetti specifiche formali e per dimostrare proprietà dei programmi in modo matematico. Operativamente, lo sviluppatore definisce le mappature denotazionali per i costrutti del programma, esprimendoli come funzioni matematiche. Strumenti come Coq e Isabelle/HOL aiutano a verificare formalmente queste mappature, dimostrando che il programma soddisfa specifiche precise e comportandosi come atteso in ogni possibile scenario.

### Semantica assiomatica

La **semantica assiomatica** è un approccio formale per definire il significato dei programmi basato su precondizioni e postcondizioni logiche. Questo metodo, sviluppato da Tony Hoare [@hoare1969], utilizza asserzioni logiche per descrivere lo stato del programma prima e dopo l'esecuzione delle istruzioni, permettendo di dimostrare formalmente la correttezza dei programmi.

In altre parole, la semantica assiomatica stabilisce regole per verificare che un programma rispetti determinate specifiche formali. Questo è particolarmente utile per garantire che il programma funzioni correttamente in tutte le condizioni previste.

Consideriamo un semplice esempio in Python che calcola la somma di due numeri:

```python
def somma(a, b):  # <1>
  return a + b  # <2>

print(somma(3, 4))  # <3>
```
1. Definizione della funzione `somma` che accetta due parametri `a` e `b`.
2. La funzione `somma` restituisce la somma di `a` e `b`.
3. Chiamata della funzione `somma` con argomenti `3` e `4`, stampa `7`.

Per verificare formalmente questo codice in Coq[^1-prima-parte-semantica]: 

[^1-prima-parte-semantica]: Coq è scaricabile da [Coq Official Website](https://coq.inria.fr/).

```coq
(* Importazione della libreria standard di Coq *)
Require Import Coq.Arith.Arith.
Require Import Coq.Init.Nat.

(* Definizione della funzione somma in Coq *)
Definition somma (a b : nat) : nat := a + b.

(* Affermazione del teorema che verifica la correttezza della funzione somma *)
Theorem somma_corretto : forall a b : nat,
    somma a b = a + b.
Proof.
  intros a b.
  unfold somma.
  reflexivity.
Qed.

(* Verifica di un caso specifico: somma 3 4 = 7 *)
Example test_somma : somma 3 4 = 7.
Proof.
  simpl.
  reflexivity.
Qed.
```
In questo codice:

- Abbiamo definito la funzione `somma` in Coq per replicare il comportamento della funzione Python.

- Abbiamo affermato e dimostrato formalmente che `somma a b` è uguale a `a + b` per tutti i numeri naturali `a` e `b`.

- Abbiamo verificato un caso specifico (`somma 3 4 = 7`) per dimostrare che il nostro teorema e la nostra funzione sono corretti.

Salviamo il codice in un file `somma.v` e, in un terminale, navighiamo nella sua directory contenente. Quindi, eseguiamo il comando:

```sh
coqc somma.v
```

Questo comando compila il file `somma.v` e verifica i teoremi e gli esempi al suo interno. Se tutto è corretto, non verrà restituito alcun errore.

In contesti dove la correttezza del software è critica, come nei sistemi avionici, nei dispositivi medici e nei sistemi finanziari, la verifica formale basata sulla semantica assiomatica è fondamentale. Utilizzando strumenti come Coq, Isabelle/HOL, SPARK e altri prover interattivi, gli ingegneri del software possono formalizzare le specifiche del sistema e dimostrare che il codice implementato le soddisfa.[^2-prima-parte-semantica]

[^2-prima-parte-semantica]: Per approfondire: [@chlipala2022].

## Elementi semantici fondamentali

Dopo aver esplorato i vari tipi di semantica nei linguaggi di programmazione, è importante comprendere i componenti fondamentali che questi tipi di semantica descrivono e regolano. Gli elementi semantici fondamentali sono i mattoni con cui costruiamo e comprendiamo il comportamento dei programmi. Tra questi, alcuni concetti come variabili, tipi di dati, espressioni, controllo del flusso, gestione della memoria, funzioni e sistemi di tipi sono cruciali per ogni linguaggio di programmazione moderno, altri sono particolari di linguaggi specifici come la concorrenza e il supporto alla programmazione ad aspetti. 

Vediamo in dettaglio ciascuno di questi elementi:

- Variabili: Una variabile in un linguaggio di programmazione è un nome simbolico associato a una locazione di memoria in cui è memorizzato un dato. Le variabili sono utilizzate all'interno di espressioni e istruzioni, per referenziare e manipolare dati durante l'esecuzione di un programma. Il valore associato alla variabile è memorizzato nella locazione di memoria a cui la variabile fa riferimento e il tipo di dato della variabile determina come quel valore viene interpretato e quali operazioni possono essere eseguite su di esso. 

  - Dichiarazione: Introduce una variabile nel programma, specificando il suo nome e, in molti linguaggi, il suo tipo di dato.

  - Definizione: Oltre a dichiarare la variabile, le assegna anche uno spazio di memoria.

  - Inizializzazione: L'assegnazione del primo valore a una variabile.

  - Ambito (inglese: _scope_): Definisce la visibilità e l'accessibilità di una variabile all'interno del codice.

  - Durata: Il periodo durante il quale una variabile mantiene valido il legame con un dato presente in memoria.

- Tipi di dati: Il tipo di dato definisce l'insieme di valori che una variabile può assumere e le operazioni che possono essere eseguite su di essa. I tipi di dato sono alla base di molte operazioni semantiche nei linguaggi di programmazione.

- Tipi primitivi: Numeri interi, numeri a virgola mobile, caratteri, booleani.
- Tipi composti: Array, strutture, classi, tuple.
- Tipi di riferimento: Puntatori, riferimenti.
- Tipi astratti: Definiti dall'utente per rappresentare concetti complessi.
- Tipi generici: Permettono di scrivere codice che può lavorare con diversi tipi di dati mantenendo la sicurezza dei tipi.

### 3. Espressioni e operatori

Le espressioni sono combinazioni di valori, variabili e operatori che producono un risultato. Gli operatori sono simboli che rappresentano operazioni sui dati.

- Operatori aritmetici: +, -, *, /, %
- Operatori di confronto: ==, !=, <, >, <=, >=
- Operatori logici: AND, OR, NOT
- Operatori di assegnazione: =, +=, -=, *=, /=
- Operatori bit a bit: &, |, ^, ~, <<, >>
- Precedenza e associatività degli operatori: Determinano l'ordine in cui le operazioni vengono eseguite.

### 4. Controllo del flusso

La semantica del controllo del flusso definisce come l'esecuzione del programma procede attraverso le istruzioni. Include vari costrutti che permettono di dirigere il flusso di esecuzione.

- Strutture condizionali: if, else, switch, ternary operator
- Cicli: for, while, do-while, foreach
- Istruzioni di salto: break, continue, return, goto
- Gestione delle eccezioni: try, catch, finally, throw

### 5. Funzioni e procedure

Le funzioni sono blocchi di codice riutilizzabili che eseguono specifiche operazioni. Le procedure sono simili alle funzioni ma non restituiscono un valore.

- Definizione e dichiarazione: Sintassi per creare funzioni
- Parametri: Formali vs. attuali, passaggio per valore vs. riferimento
- Valori di ritorno: Tipi di ritorno, multiple return values
- Ricorsione: Funzioni che chiamano se stesse
- Overloading: Definizione di più funzioni con lo stesso nome ma parametri diversi
- Lambda e funzioni anonime: Funzioni senza nome, spesso usate come argomenti
- Funzioni in prima classe: Le funzioni possono essere trattate come dati, passate come argomenti e restituite come valori.

### 6. Gestione della memoria

La gestione della memoria definisce come il programma alloca, utilizza e libera la memoria. Questo include il ciclo di vita delle variabili e la gestione della memoria dinamica.

- Allocazione statica: Memoria allocata al momento della compilazione
- Allocazione dinamica: Memoria allocata durante l'esecuzione
- Garbage collection: Meccanismo automatico di liberazione della memoria
- Gestione manuale della memoria: Allocazione e deallocazione esplicita (es. in C)
- Memory leaks: Problemi dovuti a memoria non correttamente deallocata

### 7. Sistemi di tipi

Il sistema di tipi di un linguaggio definisce come i tipi vengono assegnati e controllati.

- Tipizzazione statica vs dinamica: Quando avviene il controllo dei tipi
- Tipizzazione forte vs debole: Rigidità nel controllo dei tipi
- Inferenza di tipo: Il compilatore deduce automaticamente il tipo di una variabile (es. TypeScript, Haskell)
- Polimorfismo: Capacità di un'entità di assumere più forme
- Coercizione di tipo: Conversione automatica tra tipi diversi

### 8. Programmazione orientata agli oggetti

Paradigma di programmazione basato sul concetto di "oggetti" che contengono dati e codice.

- Classi e oggetti: Modelli e istanze
- Incapsulamento: Nascondere i dettagli implementativi
- Ereditarietà: Meccanismo per creare nuove classi basate su classi esistenti
- Polimorfismo: Capacità di oggetti di classi diverse di rispondere allo stesso messaggio
- Interfacce e classi astratte: Definizione di contratti per le classi

### 9. Programmazione asincrona

Permette l'esecuzione di operazioni non bloccanti, migliorando l'efficienza e la reattività dei programmi.

- Promise/Future: Rappresentano il risultato di un'operazione asincrona
- async/await: Sintassi che semplifica la scrittura di codice asincrono
- Callback: Funzioni chiamate al completamento di un'operazione asincrona
- Event loop: Meccanismo per gestire operazioni asincrone

### 10. Modularità e organizzazione del codice

La suddivisione del codice in moduli migliora la manutenibilità, la riusabilità e l'incapsulamento.

- Namespace: Meccanismo per evitare conflitti di nomi
- Moduli e pacchetti: Organizzazione del codice in unità logiche
- Import/Export: Meccanismi per condividere codice tra moduli
- Visibilità e accesso: public, private, protected

### 11. Metaprogrammazione

Tecniche per scrivere programmi che manipolano o generano altri programmi.

- Reflection: Capacità di un programma di esaminare, introspezione e modificare la propria struttura e comportamento
- Generazione di codice: Creazione automatica di codice sorgente
- Macro: Istruzioni che vengono espanse in tempo di compilazione

### 12. Concorrenza e parallelismo

Meccanismi per eseguire più task simultaneamente o apparentemente simultaneamente.

- Thread e processi: Unità di esecuzione concorrente
- Sincronizzazione: Meccanismi per coordinare l'esecuzione di thread (mutex, semafori)
- Parallellismo: Esecuzione simultanea su hardware multi-core

### 13. Programmazione orientata agli aspetti

Un paradigma di programmazione che permette di separare le preoccupazioni trasversali dal codice principale.

- Aspetti: Moduli che incapsulano comportamenti trasversali
- Pointcut: Punti nel programma dove viene applicato un aspetto
- Advice: Codice che viene eseguito quando viene raggiunto un pointcut
- Weaving: Processo di applicazione degli aspetti al codice principale

Questa panoramica estesa fornisce una base solida per comprendere gli elementi semantici fondamentali dei linguaggi di programmazione moderni. Ogni concetto merita un approfondimento dettagliato, che verrà fornito nei capitoli successivi, offrendo una comprensione più approfondita e pratica di come questi elementi interagiscono per creare sistemi software complessi e potenti.

