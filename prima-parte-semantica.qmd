---
reference-location: margin
citation-location: margin
---

# Semantica dei linguaggi di programmazione

La **semantica** di un linguaggio di programmazione definisce il significato delle istruzioni sintatticamente corrette. In altre parole, la semantica specifica cosa fa un programma quando viene eseguito, descrivendo l'effetto delle istruzioni sullo stato del sistema. Gli elementi semantici sono numerosi, possono essere anche complessi e non tutti presenti in uno specifico linguaggio. 

Di seguito ne sono riportati alcuni tra i principali elementi semantici.

## Modello dati

Un **modello dati** è una rappresentazione formale dei tipi di dati e delle operazioni che possono essere eseguite su di essi. Esso definisce le strutture fondamentali attraverso le quali i dati vengono organizzati, memorizzati, manipolati e interagiscono all'interno del programma. 

Le componenti il modello dati sono:

1. Tipi di dati:

    - Tipi primitivi: Questi sono i tipi di dati fondamentali che il linguaggio supporta nativamente, come numeri interi, numeri in virgola mobile, caratteri e booleani.

    - Tipi compositi: Questi sono tipi di dati costruiti combinando tipi primitivi. Esempi comuni includono array, liste, tuple, set e dizionari.

    - Tipi di dati definiti dall'utente: Questi sono tipi di dati che possono essere definiti dagli utenti del linguaggio, come le `struct` in C oppure le classi in Python o C++, che permettono di creare tipi di dati personalizzati. 

2. Operazioni:

    - Operazioni aritmetiche: Operazioni che possono essere eseguite sui tipi di dati, come addizione, sottrazione, moltiplicazione e divisione per i numeri.

    - Operazioni logiche: Operazioni che coinvolgono valori booleani, come AND, OR e NOT.

    - Operazioni di sequenza: Operazioni che si possono eseguire su sequenze di dati, come l'indicizzazione, la _slicing_ e l'iterazione.

    - Altre operazioni ad hoc per il tipo di dato.

3. Regole di comportamento:

    - Mutabilità: Determina se un oggetto può essere modificato dopo la sua creazione. Oggetti mutabili, come liste e dizionari in Python, possono essere cambiati. Oggetti immutabili, come tuple e stringhe, non possono essere modificati dopo la loro creazione.

    - Copia e clonazione: Regole che determinano come i dati vengono copiati. Per esempio, in Python, la copia di una lista crea una nuova lista con gli stessi elementi, mentre la copia di un intero crea solo un riferimento allo stesso valore.

### Linguaggi procedurali

Nei linguaggi di programmazione procedurali, il modello dati è incentrato su tipi di dati semplici e compositi che supportano lo stile di programmazione orientato alle funzioni e procedure. Alcune caratteristiche tipiche includono:

- Tipi primitivi: Numeri interi, numeri a virgola mobile, caratteri e booleani.

- Strutture composite: Array, strutture (`struct`) e unioni (`union`). Gli array permettono di gestire collezioni di elementi dello stesso tipo, mentre le strutture permettono di combinare vari tipi di dati sotto un unico nome. Le unioni consentono di memorizzare diversi tipi di dati nello stesso spazio di memoria, ma solo uno di essi può essere attivo alla volta.

- Operazioni basate su funzioni: Le operazioni sui dati vengono eseguite attraverso funzioni che manipolano i valori passati come argomenti.

Esempio in C:

```c
#include <stdio.h>
#include <string.h>

#define MAX_DATI 100

union Valore { /* <1> */
  int intero;
  float decimale;
  char carattere;
};

struct Dato {  /* <2> */
  char tipo;  
  // 'i' per int, 'f' per float, 'c' per char
  union Valore valore;
};

void stampa_dato(struct Dato d) { /* <3> */
  switch (d.tipo) {
    case 'i':
      printf("Intero: %d\n", d.valore.intero);
      break;

    case 'f':
      printf("Float: %f\n", d.valore.decimale);
      break;

    case 'c':
      printf("Carattere: %c\n", d.valore.carattere);
      break;

    default:
      printf("Tipo sconosciuto\n");
      break;
  }
}

int confronta_dato(struct Dato d1, struct Dato d2) {
  if (d1.tipo != d2.tipo) return 0;

  switch (d1.tipo) {
    case 'i': return d1.valore.intero == d2.valore.intero;

    case 'f': return d1.valore.decimale == d2.valore.decimale;

    case 'c': return d1.valore.carattere == d2.valore.carattere;

    default: return 0;
  }
}

void inserisci_dato(struct Dato dati[], int *count, struct Dato nuovo_dato) { /* <4> */
  if (*count < MAX_DATI) {
    dati[*count] = nuovo_dato;

    (*count)++;

  } else {
    printf("Array pieno, impossibile inserire nuovo dato.\n");
  }
}

void cancella_dato(struct Dato dati[], int *count, struct Dato dato_da_cancellare) { /* <5> */
  for (int i = 0; i < *count; i++) {
    if (confronta_dato(dati[i], dato_da_cancellare)) {
      for (int j = i; j < *count - 1; j++) {
        dati[j] = dati[j + 1];
      }

      (*count)--;

      i--; 
    }
  }
}

int main() {
  struct Dato dati[MAX_DATI]; /* <6> */
  int count = 0;

  struct Dato dato1 = {'i', .valore.intero = 42};
  struct Dato dato2 = {'f', .valore.decimale = 3.14};
  struct Dato dato3 = {'c', .valore.carattere = 'A'};
  
  inserisci_dato(dati, &count, dato1); /* <7> */
  inserisci_dato(dati, &count, dato2);
  inserisci_dato(dati, &count, dato3);

  for (int i = 0; i < count; i++) { /* <8> */
    stampa_dato(dati[i]);
  }

  cancella_dato(dati, &count, dato1); /* <9> */

  printf("Dopo cancellazione:\n");

  for (int i = 0; i < count; i++) {
    stampa_dato(dati[i]);
  }

  return 0;
}
```
1. Definizione di una `union`.
2. Definizione di una `struct` che include la `union`.
3. Funzione per stampare i valori in base al tipo.
4. Funzione per inserire un nuovo dato alla fine dell'array.
5. Funzione per cancellare tutte le occorrenze di un dato dall'array.
6. Definizione di un array di `struct` Dato.
7. Inserimento di dati nell'array.
8. Stampa dei dati nell'array.
9. Cancellazione di un dato specifico e ristampa dell'array.

L'esempio mostra come nel modello dati del linguaggio C possono essere definiti dei tipi compositi (`Dato`, `Valore`) e delle operazioni su quelli (`stampa_dato`, `confronta_dato`, `inserisci_dato`, `cancella_dato`). Il codice, pur realizzante una semplice libreria, appare _slegato_, cioè con funzioni che si applicano a tipi di dati specifici solo dall'interpretazione degli identificatori della funzione stessa e dei suoi parametri, cioè senza un legame esplicito e non ambiguo, tra tipo e funzione.

### Linguaggi orientati agli oggetti

La programmazione orientata agli oggetti è un paradigma che utilizza **oggetti** per rappresentare concetti ed entità del mondo reale o astratto. Questo approccio si basa su un processo mentale fondamentale per risolvere problemi complessi: la decomposizione. Un problema complesso è più facilmente risolvibile se diviso in parti più piccole, ciascuna delle quali possiede uno stato e la possibilità di interagire con le altre parti. Questa divisione può essere effettuata per gradi, come se si osservasse sempre più da vicino il problema, effettivamente continunandone la specificazione, fino a raggiungere un livello sufficientemente di dettaglio da poter essere realizzato come istruzioni, codificate in costrutti permessi dalla sintassi del linguaggio, dell'oggetto.

#### Oggetti

Lo stato di un oggetto è definito dai suoi attributi, i cui valori possono essere altri oggetti già disponibili, sia definiti dall'utente che dal linguaggio. L'interazione tra diversi oggetti avviene attraverso i metodi, che sono funzioni associate agli oggetti che possono modificare lo stato dell'oggetto o invocare metodi su altri oggetti.

I membri di un oggetto (attributi e metodi) possono avere diverse limitazioni di accesso, definite dal concetto di visibilità:

- Pubblica: Gli attributi e i metodi pubblici sono accessibili da qualsiasi parte del programma. Questa visibilità permette a qualsiasi altro oggetto o funzione di interagire con questi membri.
  
- Privata: Gli attributi e i metodi privati sono accessibili solo da altri membri dell'oggetto e rispondono alla esigenza di separare il codice di interfaccia da quello utile al funzionamento interno.
  
- Protetta: Gli attributi e i metodi protetti sono accessibili da tutti i membri del medesimo oggetto ma, a differenza dei privati, anche da quelli degli oggetti derivati. Questo fornisce un livello intermedio di accesso, utile per la gestione dell'ereditarietà.

L'**incapsulamento** è il principio su cui si basa la gestione della visibilità e guida la separazione del codice realizzante le specificità di un oggetto, da come è fruito dagli altri oggetti. Questo protegge l'integrità del suo stato e ne facilita la manutenzione del codice stesso, permettendo modifiche di implementazione, senza impatti sul codice esterno fintantoché non si cambiano i membri pubblici. Inoltre, se ben sfruttata nella progettazione, rende il codice più comprensibile e riduce la superficie d'attacco.

#### Classi

Un oggetto può essere generato da una struttura statica che ne definisce tutte le caratteristiche, la **classe**, oppure può essere creato a partire da un altro oggetto esistente, noto come **prototipo**.

Nella programmazione ad oggetti basata su classi, ogni oggetto è un'istanza _vivente_ di una classe predefinita, che ne rappresenta il progetto o l'archetipo. La classe definisce i membri e la visibilità, quindi, in definitiva tutte le proprietà comuni agli oggetti dello stesso tipo o matrice. Gli oggetti vengono creati chiamando un metodo speciale della classe, noto come costruttore e, all'atto della loro vita, un secondo metodo, il distruttore, che si occupa di effettuare le azioni di terminazione. 

La classe può inoltre definire metodi e attributi particolari, che possono essere ereditati da altre classi, cioè possono essere utilizzati da quest'ultime al pari dei propri membri. In tal modo, il linguaggio permette la costruzioni di gerarchie di classi che modellano relazioni di specializzazione, dalla più generale alla più particolare.

Ciò, oltre ad essere uno strumento di progettazione utile di per sé, facilita il riuso del codice per mezzo dell'estensione, al posto della modifica, di funzionalità. La classe che eredita da un'altra classe si definisce _derivata_ dalla classe che, a sua volta, è detta _base_.

#### Prototipi

Alternativamente, alcuni linguaggi usano il concetto di prototipo, in cui gli oggetti sono le entità principali e non esiste una matrice separata come la classe. In questo paradigma, ogni oggetto può servire da prototipo per altri e ciò significa che, invece di creare nuove istanze di una classe, si creano nuovi oggetti clonando o estendendo quelli esistenti. È possibile aggiungere o modificare proprietà e metodi di un oggetto prototipo e, in tal caso, queste modifiche si propagheranno in tutti gli oggetti che derivano da esso.

Il paradigma basato su prototipi offre maggiore flessibilità e dinamismo rispetto a quello basato su classi, poiché la struttura degli oggetti può essere modificata in modo dinamico. D'altronde, questo approccio può anche introdurre complessità e rendere più difficile la gestione delle gerarchie di oggetti e la comprensione del codice, poiché non esistono strutture fisse come le classi.

#### Esempi di gerarchie di classi e prototipi

Vediamo le differenze tra classi e prototipi, riprendendo l'esempio in Java nella versione semplificata (senza astrazione):

```java
class Animale { 
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    void faiVerso() {
        System.out.println("L'animale fa un verso");
    }
}

class Cane extends Animale { 

    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }
}

public class Main {
    public static void main(String[] args) {
        Animale mioCane = new Cane("Fido");

        mioCane.faiVerso(); 
    }
}
```

Implementiamo il medesimo programma in Javascript[^2-prima-parte-sintassi-semantica], linguaggio che usa il concetto di prototipo: 

```javascript
let Animale = { // <1>
    nome: "Generic",

    init: function(nome) {
        this.nome = nome;
    },

    faiVerso: function() {
        console.log("L'animale fa un verso");
    }
};

let Cane = Object.create(Animale); // <2>

Cane.faiVerso = function() { // <3>
    console.log("Il cane abbaia");
};

let mioCane = Object.create(Cane); // <4>
mioCane.init("Fido"); // <5>

mioCane.faiVerso(); // <6>
```
1. Definizione dell'oggetto prototipo `Animale`.
2. Creazione di un nuovo oggetto basato sul prototipo `Animale`. 
3. Viene creato un nuovo oggetto `Cane` basato sul prototipo `Animale`, usando `Object.create(Animale)`. Questo permette a `Cane` di ereditare proprietà e metodi da `Animale`. Il metodo `faiVerso` viene sovrascritto nell'oggetto `Cane` per specificare il comportamento da cane.
4. Un nuovo oggetto `mioCane` viene creato basandosi sul prototipo `Cane` usando `Object.create(Cane)`.
5. Il metodo `init` viene chiamato per inizializzare il nome dell'oggetto `mioCane`.
6. Quando viene chiamato `mioCane.faiVerso()`, il metodo sovrascritto nell'oggetto `Cane` viene eseguito, mostrando `Il cane abbaia`.

[^2-prima-parte-sintassi-semantica]: In JavaScript, le classi come sintassi sono state introdotte in ECMAScript 6 (ES6), per semplificare la creazione di oggetti e la gestione dell'ereditarietà prototipale. Tuttavia, è importante capire che sotto il cofano, JavaScript non utilizza classi nel senso tradizionale come in linguaggi come Java o C++ e non esiste un meccanismo nativo per creare classi astratte, anche se è possibile simulare il comportamento delle classi astratte utilizzando varie tecniche. Una comune è quella di lanciare un'eccezione se un metodo funzionalmente astratto non viene sovrascritto nella classe derivata.

#### Ereditarietà

Come abbiamo visto, l'ereditarietà è un meccanismo che permette a una classe di ereditare membri da un'altra classe. Essa si può presentare singola o **multipla**, ove la prima consente a una classe derivata di estendere solo una classe base. Questo è il modello di ereditarietà più comune e supportato da molti linguaggi di programmazione orientati agli oggetti, come Java e C#.

L'ereditarietà multipla è tale da permettere a una classe di ricevere attributi e metodi contemporaneamente da più classi base. Questo meccanismo risponde all'esigenza di specializzare più concetti allo stesso tempo. Va sottolineato che è uno strumento potente prono, però, ad abusi, perché può introdurre complessità nella gestione delle gerarchie di classi e causare conflitti quando lo stesso metodo è ereditato da più classi, situazione nota come _problema del diamante_. Pertanto, alcuni linguaggi ne limitano l'applicazione, come Java che consente solo l'ereditarietà multipla di interfacce, ma non di classi. Altri, come Go, non supportano l'ereditarietà per scelta di progettazione. Go enfatizza la composizione rispetto all'ereditarietà per promuovere uno stile di programmazione più essenziale e flessibile. La composizione consente di costruire comportamenti complessi aggregando oggetti più semplici, evitando le complicazioni delle gerarchie di classi multilivello. Il C++, invece, supporta completamente l'ereditarietà multipla.

#### Interfacce e classi astratte

Le **interfacce** e le **classi astratte** sono due concetti fondamentali nella programmazione orientata agli oggetti, che consentono di definire contratti che le classi concrete devono rispettare.

Un'**interfaccia** è un contratto che specifica un insieme di metodi che una classe deve implementare, senza fornire l'implementazione effettiva di questi metodi. Le interfacce sono utilizzate per definire comportamenti comuni che possono essere condivisi da classi diverse, indipendentemente dalla loro posizione nella gerarchia delle classi. Le classi che implementano un'interfaccia devono fornire una definizione concreta per tutti i metodi dichiarati nell'interfaccia. In Java, ad esempio, le interfacce sono definite con la parola chiave `interface`.

Esempio di interfaccia e ereditarietà multipla in Java:

```java
interface Domestico {
    void addomestica(); // Metodo per addomesticare
}

class Animale {
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    void faiVerso() {
        System.out.println("L'animale fa un verso");
    }
}

class Cane extends Animale implements Domestico {
    private boolean addomesticato; // Variabile per indicare se è addomesticato

    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }

    @Override
    public void addomestica() {
        this.addomesticato = true; // Imposta la variabile a true
        System.out.println("Il cane è stato addomesticato");
    }

    public boolean isAddomesticato() {
        return addomesticato;
    }
}

public class Main {
    public static void main(String[] args) {
        Cane mioCane = new Cane("Fido"); // Creazione di un oggetto Cane

        mioCane.faiVerso(); // Stampa: Il cane abbaia
        mioCane.addomestica(); // Stampa: Il cane è stato addomesticato
        System.out.println("Cane addomesticato: " + mioCane.isAddomesticato()); // Stampa: Cane addomesticato: true
    }
}
```



Una **classe astratta**, invece, è una classe che non può essere istanziata direttamente. Può contenere sia metodi astratti (senza corpo, che devono essere implementati dalle classi derivate) sia metodi concreti (con corpo, che possono essere utilizzati dalle classi derivate). Le classi astratte sono utilizzate per fornire una base comune con alcune implementazioni di default e lasciare ad altre classi il compito di completare l'implementazione. In Java, le classi astratte sono definite con la parola chiave `abstract`.

Esempio di classe astratta in Java:

```java
abstract class Animale {
    String nome;

    Animale(String nome) {
        this.nome = nome;
    }

    abstract void faiVerso();

    String descrizione() {
        return "L'animale si chiama " + nome;
    }
}

class Cane extends Animale {
    Cane(String nome) {
        super(nome);
    }

    @Override
    void faiVerso() {
        System.out.println("Il cane abbaia");
    }
}
```

In questo esempio, la classe `Animale` è astratta e contiene il metodo astratto `faiVerso` e il metodo concreto `descrizione`. La classe `Cane` estende `Animale` e fornisce un'implementazione concreta per il metodo `faiVerso`.

Le interfacce e le classi astratte sono strumenti potenti per promuovere la riusabilità del codice e l'estensibilità dei sistemi software, poiché permettono di definire contratti chiari e di implementare diverse versioni di una funzionalità senza modificare il codice esistente.













- Variabile: È un nome simbolico associato a locazione di memoria che può contenere uno o più valori. È fondamentale per la manipolazione di dati perché sono un mezzo per astrarre dalla costante memorizzata. Le variabili possono essere associate a diversi tipi di dati e durate di vita. La semantica delle variabili include la loro dichiarazione, inizializzazione, uso e visibilità:

  - Dichiarazione: La dichiarazione di una variabile è il processo mediante il quale si introduce una variabile nel programma, specificandone il nome e, in molti casi, il tipo di dato che essa può contenere. La dichiarazione informa il compilatore o l'interprete che una certa variabile esiste e può essere utilizzata nel codice.

  - Inizializzazione: L'inizializzazione di una variabile è il processo di assegnare un valore iniziale alla variabile. L'inizializzazione può avvenire contestualmente alla dichiarazione o in un'istruzione separata successiva.

  - Visibilità: Indica dove la variabile può essere utilizzata all'interno del codice (ad esempio, variabili locali o globali).

  - Durata di Vita: Descrive per quanto tempo la variabile rimane in memoria durante l'esecuzione del programma (ad esempio, automatica, statica, dinamica).

- Tipo di dati: I tipi di dati definiscono il dominio dei valori che una variabile può assumere e le operazioni che possono essere eseguite su quei valori. Un tipo di dato determina la natura del valore (ad esempio, numero intero, carattere, booleano) e le operazioni che possono essere effettuate su di esso. Generalmente si distinguono in:

  - Tipo primitivo: I tipi di dati fondamentali forniti da un linguaggio, come integer, float, boolean e character.

  - Tipo complesso: Tipo di dati costituiti da più tipi primitivi, come array, struct e oggetti.

  - Tipo di dati utente: Tipo definito dall'utente, come classi e tipi personalizzati, che permette di creare strutture dati più complesse e specifiche per il problema da risolvere.

- Ambito (in inglese, _scope_): L'ambito rappresenta la porzione del codice in cui un identificatore (come una variabile o una funzione) è definito e, quindi, esiste. L'ambito determina dove un identificatore può essere dichiarato e utilizzato. Tipicamente gli ambiti sono:

  - Globale: Identificatori dichiarati a livello globale, accessibili ovunque nel programma.

  - Locale: Identificatori dichiarati all'interno di un blocco, come una funzione o un loop, e accessibili solo all'interno di quel blocco.

  - Statico e dinamico: L'ambito statico è determinato a tempo di compilazione, mentre l'ambito dinamico è determinato a runtime, influenzando come e dove gli identificatori possono essere utilizzati.

- Visibilità: La visibilità si riferisce a dove nel codice un identificatore può essere visto e utilizzato. Anche se correlata all'ambito, la visibilità può essere influenzata da altri fattori come la modularità e i namespace, che organizzano e separano gli identificatori per evitare conflitti di nome. La visibilità è generalmente:

  - Globale: Un identificatore dichiarato con visibilità globale può essere utilizzato in qualsiasi parte del programma.

  - Locale: Un identificatore dichiarato con visibilità locale è visibile solo all'interno del blocco di codice in cui è stato dichiarato.

- Funzioni e metodi: Le funzioni e i metodi sono blocchi di codice riutilizzabili che eseguono una serie di istruzioni. Alcuni concetti collegati sono:

  - Parametri e argomenti: Valori passati alle funzioni per influenzarne il comportamento. I parametri sono definiti nella dichiarazione della funzione, mentre gli argomenti sono i valori effettivi passati quando la funzione è chiamata.

  - Valore di ritorno: Il risultato prodotto da una funzione, che può essere utilizzato nell'istruzione chiamante.

  - Overloading: Definizione di più funzioni con lo stesso nome ma diversi parametri, consentendo diverse implementazioni basate sui tipi e il numero di argomenti.

  - Ricorsione: Capacità di una funzione di chiamare se stessa, utile per risolvere problemi che possono essere suddivisi in sottoproblemi simili.

  - Funzioni di prima classe: Le funzioni possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.

  - Funzioni di ordine superiore: Funzioni che accettano altre funzioni come argomenti e/o ritornano funzioni come risultati.

- Durata di vita delle variabili: La durata di vita delle variabili si riferisce a quanto tempo una variabile rimane in memoria durante l'esecuzione del programma. Alcune tipologie di durata:

  - Automatica: Variabili che esistono solo durante l'esecuzione del blocco in cui sono dichiarate.

  - Statica: Variabili che esistono per tutta la durata del programma e mantengono il loro valore tra diverse chiamate di funzione.

  - Dinamica: Variabili allocate dinamicamente durante l'esecuzione del programma, solitamente gestite manualmente dall'utente (ad esempio, usando `malloc`/`free` in C) o automaticamente tramite garbage collection.

- Durata di vita di altri identificatori: 

  - Funzioni: Le funzioni stesse generalmente hanno una durata di vita che coincide con la durata del programma. Tuttavia, i puntatori a funzione e le chiusure (in inglese, closures) possono avere durate di vita diverse in alcuni linguaggi.

  - Classi e oggetti: Le classi hanno una durata di vita che coincide con la durata del programma, mentre gli oggetti (istanze di classi) hanno durate di vita dinamiche, determinate dalla loro allocazione e deallocazione.

  - Moduli: In linguaggi come Python, i moduli hanno una durata di vita che coincide con la durata del programma o del processo di importazione.

- Controllo di flusso: Determina l'ordine in cui le istruzioni vengono eseguite e alcuni esempi sono:

  - Condizionali: Strutture che permettono al programma di prendere decisioni (`if`, `else`, `switch`/`case`).

  - Cicli: Strutture che ripetono un blocco di codice (`for`, `while`, `do`-`while`).

  - Eccezioni: Meccanismi per gestire errori e condizioni anomale (`try`, `catch`, `throw`), permettendo al programma di continuare l'esecuzione in modo controllato.



- Gestione della memoria utilizzata dal programma: La gestione della memoria è fondamentale per il funzionamento efficiente di un programma. Ne esistono diverse modalità: 

  - Allocazione dinamica: La memoria è allocata e deallocata a runtime, permettendo una gestione flessibile delle risorse.

  - Garbage collection: Automatizza la deallocazione della memoria non utilizzata, riducendo il rischio di sfruttamento non ottimale (memory leak) e semplificando la gestione della memoria.

- Spazio di nomi (in inglese namespace): I namespace organizzano variabili, funzioni e altri identificatori per evitare conflitti di nome.

- Moduli e librerie: I moduli e le librerie suddividono il codice in unità riutilizzabili e organizzate, da importare in programmi. I moduli possono definire degli spazi di nomi. 

- Concorrenza: La concorrenza permette l'esecuzione parallela di più sequenze di istruzioni, migliorando le prestazioni e la reattività. Alcuni concetti relativi sono:

  - Thread: Un thread è la più piccola unità di elaborazione che può essere eseguita in modo indipendente. I thread consentono l'esecuzione parallela di codice all'interno di un programma.

  - Sincronizzazione: Meccanismi per gestire l'accesso concorrente alle risorse condivise, prevenendo condizioni di gara e garantendo la consistenza dei dati.

  - Lock e mutex: Meccanismi per prevenire condizioni di corsa (in inglese race condition), cioè un fenomeno che si presenta nei sistemi concorrenti quando, in presenza di una sequenza di processi multipli, il risultato finale dell'esecuzione dei processi dipende dalla temporizzazione o dalla sequenza con cui vengono eseguiti. Garantiscono, pertanto, l'accesso sicuro alle risorse condivise.

  - Async/await: Gestione di operazioni asincrone, migliorando l'efficienza e la reattività delle applicazioni.

- Input/output (I/O): L'input/output gestisce la comunicazione tra il programma e l'ambiente esterno.

  - File I/O: Lettura e scrittura su file per memorizzare e recuperare dati persistenti.

  - Network I/O: Comunicazione attraverso reti per inviare e ricevere dati tra sistemi diversi.

  - Standard I/O: Interazione con l'utente tramite input da tastiera e output su schermo.

- Annotazioni e metadati: Le annotazioni e i metadati forniscono informazioni aggiuntive al compilatore o al runtime, influenzando il comportamento del programma o fornendo dettagli utili per la documentazione e l'analisi del codice.

  - Annotazioni: Informazioni extra utilizzate per specificare comportamenti speciali o configurazioni. Ad esempio, in Java, le annotazioni possono essere utilizzate per indicare che un metodo è obsoleto (`@Deprecated`), per sovrascrivere un metodo della superclasse (`@Override`), o per specificare la relazione tra entità nel contesto di framework come JPA (Jakarta Persistence; `@Entity`, `@Table`). In Python, le annotazioni sono utilizzate principalmente per indicare i tipi di variabili, parametri di funzione e valori di ritorno (type hint). Non influenzano direttamente il comportamento del programma, ma sono utili per la documentazione e il type checking anche automatico.

  - Docstring: Commenti strutturati che documentano il codice, spesso utilizzati per generare documentazione automatica. In Python, ad esempio, le docstring possono essere utilizzate per descrivere il funzionamento di moduli, classi, metodi e funzioni, rendendo il codice più leggibile e comprensibile.

- Macro e metaprogrammazione: Le macro e la metaprogrammazione permettono di scrivere codice che manipola altre porzioni di codice.

  - Macro: Sequenze di istruzioni predefinite che possono essere inserite nel codice durante la fase di precompilazione. In C, sono utilizzate con il preprocessore per definire costanti, funzioni inline e codice condizionale.

  - Metaprogrammazione: Tecniche per scrivere codice che genera o modifica altre parti del codice a runtime o a compile-time, migliorando la flessibilità e il riutilizzo del codice. In Python include l'uso di decoratori, metaclassi e introspezione.

Questi elementi semantici combinati determinano il comportamento e la logica di un programma, influenzando il modo in cui il codice viene scritto, eseguito e mantenuto. 

## Applicazione dei concetti di sintassi e semantica

Dissezioniamo un algoritmo molto semplice per illustrare come sintassi e semantica di un linguaggio abbiano ruoli distinti e complementari in un programma. È importante comprendere che un buon programmatore deve avere tutte e tre le competenze, cioè conoscere le specificità formali del linguaggio (o di più linguaggi), quindi, la sua sintassi e semantica e saper comporre algoritmi, che potrà realizzare grazie proprio a quelle.

Consideriamo un esempio semplice di algoritmo per calcolare la somma dei numeri da 1 a n. In input si avrà un numero intero `n` e in output il risultato. In pseudocodice (cioè mimiamo il rigore sintattico di un linguaggio di programmazione, ma utilizziamo la lingua italiana) si può rappresentare così:

```bash
Inizializza somma a 0
Per ogni numero i da 1 a n:
  Aggiungi i a somma
Restituisci somma
```

O, in alternativa, possiamo definire una funzione che implementa l'algoritmo: 

```bash
funzione calcola_somma(n):
  somma = 0
  per i da 1 a n:
    somma = somma + i
  ritorna somma
```

Effettuiamo una analisi dettagliata della funzione per indicare quali elementi sintattici e semantici sono presenti. Partiamo dalla prima riga:

```bash
funzione calcola_somma(n):
```

- Sintassi:

  - `funzione`: Parola chiave che introduce la definizione di una funzione.
  - `calcola_somma`: Identificatore della funzione.
  - `(n)`: Delimitatori che contengono un identificatore.

- Semantica: Definisce una funzione chiamata `calcola_somma` che accetta un parametro `n`.

La seconda riga ha l'inizializzazione della variabile che conterrà il risultato: 

```bash
somma = 0
```

- Sintassi:
  - `somma`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `0`: Letterale numero intero.

- Semantica:
  - Inizializza la variabile `somma` a `0`.

A seguire la definizione di un ciclo: 

```bash
per i da 1 a n:
```

- Sintassi:

  - `per`: Parola chiave che introduce il ciclo.
  - `i`: Identificatore della variabile di controllo del ciclo.
  - `da 1 a n`: Espressione di controllo del ciclo che indica l'intervallo.

- Semantica: Itera la variabile `i` da `1` a `n`.

Un assegnamento per accumulare i valori nella variabile di ritorno:

```bash
somma = somma + i
```

- Sintassi:

  - `somma`: Identificatore della variabile.
  - `=`: Operatore di assegnazione.
  - `somma + i`: Espressione aritmetica composta da: `somma` identificatore di variabile, `+` operatore aritmetico e `i` identificatore di variabile.

- Semantica: Aggiunge il valore di `i` alla variabile `somma` e assegna il risultato a `somma`.

E finalmente il risultato del calcolo viene restituito al chiamante: 

```bash
ritorna somma
```

- Sintassi:
  - `ritorna`: Parola chiave che indica la restituzione di un valore.
  - `somma`: Identificatore della variabile.

- Semantica:
  - Restituisce il valore della variabile `somma` come risultato della funzione.

